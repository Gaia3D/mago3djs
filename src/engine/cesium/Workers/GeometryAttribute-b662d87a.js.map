{"version":3,"file":"GeometryAttribute-b662d87a.js","sources":["../../../../Source/Core/GeometryType.js","../../../../Source/Core/PrimitiveType.js","../../../../Source/Core/Geometry.js","../../../../Source/Core/GeometryAttribute.js"],"sourcesContent":["/**\r\n * @private\r\n */\r\nvar GeometryType = {\r\n  NONE: 0,\r\n  TRIANGLES: 1,\r\n  LINES: 2,\r\n  POLYLINES: 3,\r\n};\r\nexport default Object.freeze(GeometryType);\r\n","import WebGLConstants from \"./WebGLConstants.js\";\r\n\r\n/**\r\n * The type of a geometric primitive, i.e., points, lines, and triangles.\r\n *\r\n * @enum {Number}\r\n */\r\nvar PrimitiveType = {\r\n  /**\r\n   * Points primitive where each vertex (or index) is a separate point.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  POINTS: WebGLConstants.POINTS,\r\n\r\n  /**\r\n   * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  LINES: WebGLConstants.LINES,\r\n\r\n  /**\r\n   * Line loop primitive where each vertex (or index) after the first connects a line to\r\n   * the previous vertex, and the last vertex implicitly connects to the first.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  LINE_LOOP: WebGLConstants.LINE_LOOP,\r\n\r\n  /**\r\n   * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  LINE_STRIP: WebGLConstants.LINE_STRIP,\r\n\r\n  /**\r\n   * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  TRIANGLES: WebGLConstants.TRIANGLES,\r\n\r\n  /**\r\n   * Triangle strip primitive where each vertex (or index) after the first two connect to\r\n   * the previous two vertices forming a triangle.  For example, this can be used to model a wall.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  TRIANGLE_STRIP: WebGLConstants.TRIANGLE_STRIP,\r\n\r\n  /**\r\n   * Triangle fan primitive where each vertex (or index) after the first two connect to\r\n   * the previous vertex and the first vertex forming a triangle.  For example, this can be used\r\n   * to model a cone or circle.\r\n   *\r\n   * @type {Number}\r\n   * @constant\r\n   */\r\n  TRIANGLE_FAN: WebGLConstants.TRIANGLE_FAN,\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPrimitiveType.validate = function (primitiveType) {\r\n  return (\r\n    primitiveType === PrimitiveType.POINTS ||\r\n    primitiveType === PrimitiveType.LINES ||\r\n    primitiveType === PrimitiveType.LINE_LOOP ||\r\n    primitiveType === PrimitiveType.LINE_STRIP ||\r\n    primitiveType === PrimitiveType.TRIANGLES ||\r\n    primitiveType === PrimitiveType.TRIANGLE_STRIP ||\r\n    primitiveType === PrimitiveType.TRIANGLE_FAN\r\n  );\r\n};\r\n\r\nexport default Object.freeze(PrimitiveType);\r\n","import Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport GeometryType from \"./GeometryType.js\";\r\nimport Matrix2 from \"./Matrix2.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport Transforms from \"./Transforms.js\";\r\n\r\n/**\r\n * A geometry representation with attributes forming vertices and optional index data\r\n * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,\r\n * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can\r\n * be created from many heterogeneous - in many cases - geometries for performance.\r\n * <p>\r\n * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.\r\n * </p>\r\n *\r\n * @alias Geometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.\r\n * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.\r\n * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.\r\n * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.\r\n *\r\n * @see PolygonGeometry\r\n * @see RectangleGeometry\r\n * @see EllipseGeometry\r\n * @see CircleGeometry\r\n * @see WallGeometry\r\n * @see SimplePolylineGeometry\r\n * @see BoxGeometry\r\n * @see EllipsoidGeometry\r\n *\r\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\r\n *\r\n * @example\r\n * // Create geometry with a position attribute and indexed lines.\r\n * var positions = new Float64Array([\r\n *   0.0, 0.0, 0.0,\r\n *   7500000.0, 0.0, 0.0,\r\n *   0.0, 7500000.0, 0.0\r\n * ]);\r\n *\r\n * var geometry = new Cesium.Geometry({\r\n *   attributes : {\r\n *     position : new Cesium.GeometryAttribute({\r\n *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\r\n *       componentsPerAttribute : 3,\r\n *       values : positions\r\n *     })\r\n *   },\r\n *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\r\n *   primitiveType : Cesium.PrimitiveType.LINES,\r\n *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\r\n * });\r\n */\r\nfunction Geometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options.attributes\", options.attributes);\r\n  //>>includeEnd('debug');\r\n\r\n  /**\r\n   * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a\r\n   * {@link GeometryAttribute} containing the attribute's data.\r\n   * <p>\r\n   * Attributes are always stored non-interleaved in a Geometry.\r\n   * </p>\r\n   * <p>\r\n   * There are reserved attribute names with well-known semantics.  The following attributes\r\n   * are created by a Geometry (depending on the provided {@link VertexFormat}.\r\n   * <ul>\r\n   *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>\r\n   *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>\r\n   *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>\r\n   *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>\r\n   *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>\r\n   * </ul>\r\n   * </p>\r\n   * <p>\r\n   * The following attribute names are generally not created by a Geometry, but are added\r\n   * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare\r\n   * the geometry for rendering.\r\n   * <ul>\r\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\r\n   *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\r\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\r\n   *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\r\n   *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>\r\n   *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>\r\n   * </ul>\r\n   * </p>\r\n   *\r\n   * @type GeometryAttributes\r\n   *\r\n   * @default undefined\r\n   *\r\n   *\r\n   * @example\r\n   * geometry.attributes.position = new Cesium.GeometryAttribute({\r\n   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\r\n   *   componentsPerAttribute : 3,\r\n   *   values : new Float32Array(0)\r\n   * });\r\n   *\r\n   * @see GeometryAttribute\r\n   * @see VertexFormat\r\n   */\r\n  this.attributes = options.attributes;\r\n\r\n  /**\r\n   * Optional index data that - along with {@link Geometry#primitiveType} -\r\n   * determines the primitives in the geometry.\r\n   *\r\n   * @type Array\r\n   *\r\n   * @default undefined\r\n   */\r\n  this.indices = options.indices;\r\n\r\n  /**\r\n   * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},\r\n   * but can varying based on the specific geometry.\r\n   *\r\n   * @type PrimitiveType\r\n   *\r\n   * @default undefined\r\n   */\r\n  this.primitiveType = defaultValue(\r\n    options.primitiveType,\r\n    PrimitiveType.TRIANGLES\r\n  );\r\n\r\n  /**\r\n   * An optional bounding sphere that fully encloses the geometry.  This is\r\n   * commonly used for culling.\r\n   *\r\n   * @type BoundingSphere\r\n   *\r\n   * @default undefined\r\n   */\r\n  this.boundingSphere = options.boundingSphere;\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  this.geometryType = defaultValue(options.geometryType, GeometryType.NONE);\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  this.boundingSphereCV = options.boundingSphereCV;\r\n\r\n  /**\r\n   * Used for computing the bounding sphere for geometry using the applyOffset vertex attribute\r\n   * @private\r\n   */\r\n  this.offsetAttribute = options.offsetAttribute;\r\n}\r\n\r\n/**\r\n * Computes the number of vertices in a geometry.  The runtime is linear with\r\n * respect to the number of attributes in a vertex, not the number of vertices.\r\n *\r\n * @param {Geometry} geometry The geometry.\r\n * @returns {Number} The number of vertices in the geometry.\r\n *\r\n * @example\r\n * var numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);\r\n */\r\nGeometry.computeNumberOfVertices = function (geometry) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"geometry\", geometry);\r\n  //>>includeEnd('debug');\r\n\r\n  var numberOfVertices = -1;\r\n  for (var property in geometry.attributes) {\r\n    if (\r\n      geometry.attributes.hasOwnProperty(property) &&\r\n      defined(geometry.attributes[property]) &&\r\n      defined(geometry.attributes[property].values)\r\n    ) {\r\n      var attribute = geometry.attributes[property];\r\n      var num = attribute.values.length / attribute.componentsPerAttribute;\r\n      //>>includeStart('debug', pragmas.debug);\r\n      if (numberOfVertices !== num && numberOfVertices !== -1) {\r\n        throw new DeveloperError(\r\n          \"All attribute lists must have the same number of attributes.\"\r\n        );\r\n      }\r\n      //>>includeEnd('debug');\r\n      numberOfVertices = num;\r\n    }\r\n  }\r\n\r\n  return numberOfVertices;\r\n};\r\n\r\nvar rectangleCenterScratch = new Cartographic();\r\nvar enuCenterScratch = new Cartesian3();\r\nvar fixedFrameToEnuScratch = new Matrix4();\r\nvar boundingRectanglePointsCartographicScratch = [\r\n  new Cartographic(),\r\n  new Cartographic(),\r\n  new Cartographic(),\r\n];\r\nvar boundingRectanglePointsEnuScratch = [\r\n  new Cartesian2(),\r\n  new Cartesian2(),\r\n  new Cartesian2(),\r\n];\r\nvar points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\r\nvar pointEnuScratch = new Cartesian3();\r\nvar enuRotationScratch = new Quaternion();\r\nvar enuRotationMatrixScratch = new Matrix4();\r\nvar rotation2DScratch = new Matrix2();\r\n\r\n/**\r\n * For remapping texture coordinates when rendering GroundPrimitives with materials.\r\n * GroundPrimitive texture coordinates are computed to align with the cartographic coordinate system on the globe.\r\n * However, EllipseGeometry, RectangleGeometry, and PolygonGeometry all bake rotations to per-vertex texture coordinates\r\n * using different strategies.\r\n *\r\n * This method is used by EllipseGeometry and PolygonGeometry to approximate the same visual effect.\r\n * We encapsulate rotation and scale by computing a \"transformed\" texture coordinate system and computing\r\n * a set of reference points from which \"cartographic\" texture coordinates can be remapped to the \"transformed\"\r\n * system using distances to lines in 2D.\r\n *\r\n * This approximation becomes less accurate as the covered area increases, especially for GroundPrimitives near the poles,\r\n * but is generally reasonable for polygons and ellipses around the size of USA states.\r\n *\r\n * RectangleGeometry has its own version of this method that computes remapping coordinates using cartographic space\r\n * as an intermediary instead of local ENU, which is more accurate for large-area rectangles.\r\n *\r\n * @param {Cartesian3[]} positions Array of positions outlining the geometry\r\n * @param {Number} stRotation Texture coordinate rotation.\r\n * @param {Ellipsoid} ellipsoid Ellipsoid for projecting and generating local vectors.\r\n * @param {Rectangle} boundingRectangle Bounding rectangle around the positions.\r\n * @returns {Number[]} An array of 6 numbers specifying [minimum point, u extent, v extent] as points in the \"cartographic\" system.\r\n * @private\r\n */\r\nGeometry._textureCoordinateRotationPoints = function (\r\n  positions,\r\n  stRotation,\r\n  ellipsoid,\r\n  boundingRectangle\r\n) {\r\n  var i;\r\n\r\n  // Create a local east-north-up coordinate system centered on the polygon's bounding rectangle.\r\n  // Project the southwest, northwest, and southeast corners of the bounding rectangle into the plane of ENU as 2D points.\r\n  // These are the equivalents of (0,0), (0,1), and (1,0) in the texture coordiante system computed in ShadowVolumeAppearanceFS,\r\n  // aka \"ENU texture space.\"\r\n  var rectangleCenter = Rectangle.center(\r\n    boundingRectangle,\r\n    rectangleCenterScratch\r\n  );\r\n  var enuCenter = Cartographic.toCartesian(\r\n    rectangleCenter,\r\n    ellipsoid,\r\n    enuCenterScratch\r\n  );\r\n  var enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(\r\n    enuCenter,\r\n    ellipsoid,\r\n    fixedFrameToEnuScratch\r\n  );\r\n  var fixedFrameToEnu = Matrix4.inverse(\r\n    enuToFixedFrame,\r\n    fixedFrameToEnuScratch\r\n  );\r\n\r\n  var boundingPointsEnu = boundingRectanglePointsEnuScratch;\r\n  var boundingPointsCarto = boundingRectanglePointsCartographicScratch;\r\n\r\n  boundingPointsCarto[0].longitude = boundingRectangle.west;\r\n  boundingPointsCarto[0].latitude = boundingRectangle.south;\r\n\r\n  boundingPointsCarto[1].longitude = boundingRectangle.west;\r\n  boundingPointsCarto[1].latitude = boundingRectangle.north;\r\n\r\n  boundingPointsCarto[2].longitude = boundingRectangle.east;\r\n  boundingPointsCarto[2].latitude = boundingRectangle.south;\r\n\r\n  var posEnu = pointEnuScratch;\r\n\r\n  for (i = 0; i < 3; i++) {\r\n    Cartographic.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);\r\n    posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);\r\n    boundingPointsEnu[i].x = posEnu.x;\r\n    boundingPointsEnu[i].y = posEnu.y;\r\n  }\r\n\r\n  // Rotate each point in the polygon around the up vector in the ENU by -stRotation and project into ENU as 2D.\r\n  // Compute the bounding box of these rotated points in the 2D ENU plane.\r\n  // Rotate the corners back by stRotation, then compute their equivalents in the ENU texture space using the corners computed earlier.\r\n  var rotation = Quaternion.fromAxisAngle(\r\n    Cartesian3.UNIT_Z,\r\n    -stRotation,\r\n    enuRotationScratch\r\n  );\r\n  var textureMatrix = Matrix3.fromQuaternion(\r\n    rotation,\r\n    enuRotationMatrixScratch\r\n  );\r\n\r\n  var positionsLength = positions.length;\r\n  var enuMinX = Number.POSITIVE_INFINITY;\r\n  var enuMinY = Number.POSITIVE_INFINITY;\r\n  var enuMaxX = Number.NEGATIVE_INFINITY;\r\n  var enuMaxY = Number.NEGATIVE_INFINITY;\r\n  for (i = 0; i < positionsLength; i++) {\r\n    posEnu = Matrix4.multiplyByPointAsVector(\r\n      fixedFrameToEnu,\r\n      positions[i],\r\n      posEnu\r\n    );\r\n    posEnu = Matrix3.multiplyByVector(textureMatrix, posEnu, posEnu);\r\n\r\n    enuMinX = Math.min(enuMinX, posEnu.x);\r\n    enuMinY = Math.min(enuMinY, posEnu.y);\r\n    enuMaxX = Math.max(enuMaxX, posEnu.x);\r\n    enuMaxY = Math.max(enuMaxY, posEnu.y);\r\n  }\r\n\r\n  var toDesiredInComputed = Matrix2.fromRotation(stRotation, rotation2DScratch);\r\n\r\n  var points2D = points2DScratch;\r\n  points2D[0].x = enuMinX;\r\n  points2D[0].y = enuMinY;\r\n\r\n  points2D[1].x = enuMinX;\r\n  points2D[1].y = enuMaxY;\r\n\r\n  points2D[2].x = enuMaxX;\r\n  points2D[2].y = enuMinY;\r\n\r\n  var boundingEnuMin = boundingPointsEnu[0];\r\n  var boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;\r\n  var boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;\r\n\r\n  for (i = 0; i < 3; i++) {\r\n    var point2D = points2D[i];\r\n    // rotate back\r\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\r\n\r\n    // Convert point into east-north texture coordinate space\r\n    point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;\r\n    point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;\r\n  }\r\n\r\n  var minXYCorner = points2D[0];\r\n  var maxYCorner = points2D[1];\r\n  var maxXCorner = points2D[2];\r\n  var result = new Array(6);\r\n  Cartesian2.pack(minXYCorner, result);\r\n  Cartesian2.pack(maxYCorner, result, 2);\r\n  Cartesian2.pack(maxXCorner, result, 4);\r\n\r\n  return result;\r\n};\r\nexport default Geometry;\r\n","import defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\n\r\n/**\r\n * Values and type information for geometry attributes.  A {@link Geometry}\r\n * generally contains one or more attributes.  All attributes together form\r\n * the geometry's vertices.\r\n *\r\n * @alias GeometryAttribute\r\n * @constructor\r\n *\r\n * @param {Object} [options] Object with the following properties:\r\n * @param {ComponentDatatype} [options.componentDatatype] The datatype of each component in the attribute, e.g., individual elements in values.\r\n * @param {Number} [options.componentsPerAttribute] A number between 1 and 4 that defines the number of components in an attributes.\r\n * @param {Boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.\r\n * @param {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} [options.values] The values for the attributes stored in a typed array.\r\n *\r\n * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.\r\n *\r\n *\r\n * @example\r\n * var geometry = new Cesium.Geometry({\r\n *   attributes : {\r\n *     position : new Cesium.GeometryAttribute({\r\n *       componentDatatype : Cesium.ComponentDatatype.FLOAT,\r\n *       componentsPerAttribute : 3,\r\n *       values : new Float32Array([\r\n *         0.0, 0.0, 0.0,\r\n *         7500000.0, 0.0, 0.0,\r\n *         0.0, 7500000.0, 0.0\r\n *       ])\r\n *     })\r\n *   },\r\n *   primitiveType : Cesium.PrimitiveType.LINE_LOOP\r\n * });\r\n *\r\n * @see Geometry\r\n */\r\nfunction GeometryAttribute(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(options.componentDatatype)) {\r\n    throw new DeveloperError(\"options.componentDatatype is required.\");\r\n  }\r\n  if (!defined(options.componentsPerAttribute)) {\r\n    throw new DeveloperError(\"options.componentsPerAttribute is required.\");\r\n  }\r\n  if (\r\n    options.componentsPerAttribute < 1 ||\r\n    options.componentsPerAttribute > 4\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"options.componentsPerAttribute must be between 1 and 4.\"\r\n    );\r\n  }\r\n  if (!defined(options.values)) {\r\n    throw new DeveloperError(\"options.values is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  /**\r\n   * The datatype of each component in the attribute, e.g., individual elements in\r\n   * {@link GeometryAttribute#values}.\r\n   *\r\n   * @type ComponentDatatype\r\n   *\r\n   * @default undefined\r\n   */\r\n  this.componentDatatype = options.componentDatatype;\r\n\r\n  /**\r\n   * A number between 1 and 4 that defines the number of components in an attributes.\r\n   * For example, a position attribute with x, y, and z components would have 3 as\r\n   * shown in the code example.\r\n   *\r\n   * @type Number\r\n   *\r\n   * @default undefined\r\n   *\r\n   * @example\r\n   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\r\n   * attribute.componentsPerAttribute = 3;\r\n   * attribute.values = new Float32Array([\r\n   *   0.0, 0.0, 0.0,\r\n   *   7500000.0, 0.0, 0.0,\r\n   *   0.0, 7500000.0, 0.0\r\n   * ]);\r\n   */\r\n  this.componentsPerAttribute = options.componentsPerAttribute;\r\n\r\n  /**\r\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\r\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\r\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\r\n   * <p>\r\n   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.\r\n   * </p>\r\n   *\r\n   * @type Boolean\r\n   *\r\n   * @default false\r\n   *\r\n   * @example\r\n   * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\r\n   * attribute.componentsPerAttribute = 4;\r\n   * attribute.normalize = true;\r\n   * attribute.values = new Uint8Array([\r\n   *   Cesium.Color.floatToByte(color.red),\r\n   *   Cesium.Color.floatToByte(color.green),\r\n   *   Cesium.Color.floatToByte(color.blue),\r\n   *   Cesium.Color.floatToByte(color.alpha)\r\n   * ]);\r\n   */\r\n  this.normalize = defaultValue(options.normalize, false);\r\n\r\n  /**\r\n   * The values for the attributes stored in a typed array.  In the code example,\r\n   * every three elements in <code>values</code> defines one attributes since\r\n   * <code>componentsPerAttribute</code> is 3.\r\n   *\r\n   * @type {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array}\r\n   *\r\n   * @default undefined\r\n   *\r\n   * @example\r\n   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\r\n   * attribute.componentsPerAttribute = 3;\r\n   * attribute.values = new Float32Array([\r\n   *   0.0, 0.0, 0.0,\r\n   *   7500000.0, 0.0, 0.0,\r\n   *   0.0, 7500000.0, 0.0\r\n   * ]);\r\n   */\r\n  this.values = options.values;\r\n}\r\nexport default GeometryAttribute;\r\n"],"names":["Object","freeze","NONE","TRIANGLES","LINES","POLYLINES","PrimitiveType","POINTS","WebGLConstants","LINE_LOOP","LINE_STRIP","TRIANGLE_STRIP","TRIANGLE_FAN","primitiveType","Geometry","options","defaultValue","EMPTY_OBJECT","Check","typeOf","object","attributes","this","indices","boundingSphere","geometryType","GeometryType","boundingSphereCV","offsetAttribute","computeNumberOfVertices","geometry","numberOfVertices","property","hasOwnProperty","defined","values","attribute","num","length","componentsPerAttribute","DeveloperError","rectangleCenterScratch","Cartographic","enuCenterScratch","Cartesian3","fixedFrameToEnuScratch","Matrix4","boundingRectanglePointsCartographicScratch","boundingRectanglePointsEnuScratch","Cartesian2","points2DScratch","pointEnuScratch","enuRotationScratch","Quaternion","enuRotationMatrixScratch","rotation2DScratch","Matrix2","_textureCoordinateRotationPoints","positions","stRotation","ellipsoid","boundingRectangle","i","rectangleCenter","Rectangle","center","enuCenter","toCartesian","enuToFixedFrame","Transforms","eastNorthUpToFixedFrame","fixedFrameToEnu","inverse","boundingPointsEnu","boundingPointsCarto","longitude","west","latitude","south","north","east","posEnu","multiplyByPointAsVector","x","y","rotation","fromAxisAngle","UNIT_Z","textureMatrix","Matrix3","fromQuaternion","positionsLength","enuMinX","Number","POSITIVE_INFINITY","enuMinY","enuMaxX","NEGATIVE_INFINITY","enuMaxY","multiplyByVector","Math","min","max","toDesiredInComputed","fromRotation","points2D","boundingEnuMin","boundingPointsWidth","boundingPointsHeight","point2D","minXYCorner","maxYCorner","maxXCorner","result","Array","pack","componentDatatype","normalize"],"mappings":"4KAGA,MAMeA,OAAOC,OANH,CACjBC,KAAM,EACNC,UAAW,EACXC,MAAO,EACPC,UAAW,ICATC,EAAgB,CAOlBC,OAAQC,iBAAeD,OAQvBH,MAAOI,iBAAeJ,MAStBK,UAAWD,iBAAeC,UAQ1BC,WAAYF,iBAAeE,WAQ3BP,UAAWK,iBAAeL,UAS1BQ,eAAgBH,iBAAeG,eAU/BC,aAAcJ,iBAAeI,aAM/BN,SAAyB,SAAUO,GACjC,OACEA,IAAkBP,EAAcC,QAChCM,IAAkBP,EAAcF,OAChCS,IAAkBP,EAAcG,WAChCI,IAAkBP,EAAcI,YAChCG,IAAkBP,EAAcH,WAChCU,IAAkBP,EAAcK,gBAChCE,IAAkBP,EAAcM,iBAIrBZ,OAAOC,OAAOK,GClB7B,SAASQ,EAASC,GAChBA,EAAUC,eAAaD,EAASC,eAAaC,cAG7CC,QAAMC,OAAOC,OAAO,qBAAsBL,EAAQM,YAiDlDC,KAAKD,WAAaN,EAAQM,WAU1BC,KAAKC,QAAUR,EAAQQ,QAUvBD,KAAKT,cAAgBG,eACnBD,EAAQF,cACRP,EAAcH,WAWhBmB,KAAKE,eAAiBT,EAAQS,eAK9BF,KAAKG,aAAeT,eAAaD,EAAQU,aAAcC,EAAaxB,MAKpEoB,KAAKK,iBAAmBZ,EAAQY,iBAMhCL,KAAKM,gBAAkBb,EAAQa,gBAajCd,EAASe,wBAA0B,SAAUC,GAE3CZ,QAAMC,OAAOC,OAAO,WAAYU,GAGhC,IAAIC,GAAoB,EACxB,IAAK,IAAIC,KAAYF,EAAST,WAC5B,GACES,EAAST,WAAWY,eAAeD,IACnCE,UAAQJ,EAAST,WAAWW,KAC5BE,UAAQJ,EAAST,WAAWW,GAAUG,QACtC,CACA,IAAIC,EAAYN,EAAST,WAAWW,GAChCK,EAAMD,EAAUD,OAAOG,OAASF,EAAUG,uBAE9C,GAAIR,IAAqBM,IAA6B,IAAtBN,EAC9B,MAAM,IAAIS,iBACR,gEAIJT,EAAmBM,EAIvB,OAAON,GAGT,IAAIU,EAAyB,IAAIC,eAC7BC,EAAmB,IAAIC,aACvBC,EAAyB,IAAIC,UAC7BC,EAA6C,CAC/C,IAAIL,eACJ,IAAIA,eACJ,IAAIA,gBAEFM,EAAoC,CACtC,IAAIC,aACJ,IAAIA,aACJ,IAAIA,cAEFC,EAAkB,CAAC,IAAID,aAAc,IAAIA,aAAc,IAAIA,cAC3DE,EAAkB,IAAIP,aACtBQ,EAAqB,IAAIC,aACzBC,EAA2B,IAAIR,UAC/BS,EAAoB,IAAIC,UA0B5B1C,EAAS2C,iCAAmC,SAC1CC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAMAC,EAAkBC,YAAUC,OAC9BJ,EACApB,GAEEyB,EAAYxB,eAAayB,YAC3BJ,EACAH,EACAjB,GAEEyB,EAAkBC,aAAWC,wBAC/BJ,EACAN,EACAf,GAEE0B,EAAkBzB,UAAQ0B,QAC5BJ,EACAvB,GAGE4B,EAAoBzB,EACpB0B,EAAsB3B,EAE1B2B,EAAoB,GAAGC,UAAYd,EAAkBe,KACrDF,EAAoB,GAAGG,SAAWhB,EAAkBiB,MAEpDJ,EAAoB,GAAGC,UAAYd,EAAkBe,KACrDF,EAAoB,GAAGG,SAAWhB,EAAkBkB,MAEpDL,EAAoB,GAAGC,UAAYd,EAAkBmB,KACrDN,EAAoB,GAAGG,SAAWhB,EAAkBiB,MAEpD,IAAIG,EAAS9B,EAEb,IAAKW,EAAI,EAAGA,EAAI,EAAGA,IACjBpB,eAAayB,YAAYO,EAAoBZ,GAAIF,EAAWqB,GAC5DA,EAASnC,UAAQoC,wBAAwBX,EAAiBU,EAAQA,GAClER,EAAkBX,GAAGqB,EAAIF,EAAOE,EAChCV,EAAkBX,GAAGsB,EAAIH,EAAOG,EAMlC,IAAIC,EAAWhC,aAAWiC,cACxB1C,aAAW2C,QACV5B,EACDP,GAEEoC,EAAgBC,UAAQC,eAC1BL,EACA/B,GAGEqC,EAAkBjC,EAAUpB,OAC5BsD,EAAUC,OAAOC,kBACjBC,EAAUF,OAAOC,kBACjBE,EAAUH,OAAOI,kBACjBC,EAAUL,OAAOI,kBACrB,IAAKnC,EAAI,EAAGA,EAAI6B,EAAiB7B,IAC/BmB,EAASnC,UAAQoC,wBACfX,EACAb,EAAUI,GACVmB,GAEFA,EAASQ,UAAQU,iBAAiBX,EAAeP,EAAQA,GAEzDW,EAAUQ,KAAKC,IAAIT,EAASX,EAAOE,GACnCY,EAAUK,KAAKC,IAAIN,EAASd,EAAOG,GACnCY,EAAUI,KAAKE,IAAIN,EAASf,EAAOE,GACnCe,EAAUE,KAAKE,IAAIJ,EAASjB,EAAOG,GAGrC,IAAImB,EAAsB/C,UAAQgD,aAAa7C,EAAYJ,GAEvDkD,EAAWvD,EACfuD,EAAS,GAAGtB,EAAIS,EAChBa,EAAS,GAAGrB,EAAIW,EAEhBU,EAAS,GAAGtB,EAAIS,EAChBa,EAAS,GAAGrB,EAAIc,EAEhBO,EAAS,GAAGtB,EAAIa,EAChBS,EAAS,GAAGrB,EAAIW,EAEhB,IAAIW,EAAiBjC,EAAkB,GACnCkC,EAAsBlC,EAAkB,GAAGU,EAAIuB,EAAevB,EAC9DyB,EAAuBnC,EAAkB,GAAGW,EAAIsB,EAAetB,EAEnE,IAAKtB,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACtB,IAAI+C,EAAUJ,EAAS3C,GAEvBN,UAAQ2C,iBAAiBI,EAAqBM,EAASA,GAGvDA,EAAQ1B,GAAK0B,EAAQ1B,EAAIuB,EAAevB,GAAKwB,EAC7CE,EAAQzB,GAAKyB,EAAQzB,EAAIsB,EAAetB,GAAKwB,EAG/C,IAAIE,EAAcL,EAAS,GACvBM,EAAaN,EAAS,GACtBO,EAAaP,EAAS,GACtBQ,EAAS,IAAIC,MAAM,GAKvB,OAJAjE,aAAWkE,KAAKL,EAAaG,GAC7BhE,aAAWkE,KAAKJ,EAAYE,EAAQ,GACpChE,aAAWkE,KAAKH,EAAYC,EAAQ,GAE7BA,oCC3UT,SAA2BlG,GAIzB,GAHAA,EAAUC,eAAaD,EAASC,eAAaC,eAGxCiB,UAAQnB,EAAQqG,mBACnB,MAAM,IAAI5E,iBAAe,0CAE3B,IAAKN,UAAQnB,EAAQwB,wBACnB,MAAM,IAAIC,iBAAe,+CAE3B,GACEzB,EAAQwB,uBAAyB,GACjCxB,EAAQwB,uBAAyB,EAEjC,MAAM,IAAIC,iBACR,2DAGJ,IAAKN,UAAQnB,EAAQoB,QACnB,MAAM,IAAIK,iBAAe,+BAY3BlB,KAAK8F,kBAAoBrG,EAAQqG,kBAoBjC9F,KAAKiB,uBAAyBxB,EAAQwB,uBAyBtCjB,KAAK+F,UAAYrG,eAAaD,EAAQsG,WAAW,GAoBjD/F,KAAKa,OAASpB,EAAQoB"}