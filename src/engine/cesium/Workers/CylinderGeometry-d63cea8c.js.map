{"version":3,"file":"CylinderGeometry-d63cea8c.js","sources":["../../../../Source/Core/CylinderGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport VertexFormat from \"./VertexFormat.js\";\r\n\r\nvar radiusScratch = new Cartesian2();\r\nvar normalScratch = new Cartesian3();\r\nvar bitangentScratch = new Cartesian3();\r\nvar tangentScratch = new Cartesian3();\r\nvar positionScratch = new Cartesian3();\r\n\r\n/**\r\n * A description of a cylinder.\r\n *\r\n * @alias CylinderGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Number} options.length The length of the cylinder.\r\n * @param {Number} options.topRadius The radius of the top of the cylinder.\r\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\r\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n *\r\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\r\n *\r\n * @see CylinderGeometry.createGeometry\r\n *\r\n * @example\r\n * // create cylinder geometry\r\n * var cylinder = new Cesium.CylinderGeometry({\r\n *     length: 200000,\r\n *     topRadius: 80000,\r\n *     bottomRadius: 200000,\r\n * });\r\n * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\r\n */\r\nfunction CylinderGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  var length = options.length;\r\n  var topRadius = options.topRadius;\r\n  var bottomRadius = options.bottomRadius;\r\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n  var slices = defaultValue(options.slices, 128);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(length)) {\r\n    throw new DeveloperError(\"options.length must be defined.\");\r\n  }\r\n  if (!defined(topRadius)) {\r\n    throw new DeveloperError(\"options.topRadius must be defined.\");\r\n  }\r\n  if (!defined(bottomRadius)) {\r\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\r\n  }\r\n  if (slices < 3) {\r\n    throw new DeveloperError(\r\n      \"options.slices must be greater than or equal to 3.\"\r\n    );\r\n  }\r\n  if (\r\n    defined(options.offsetAttribute) &&\r\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  this._length = length;\r\n  this._topRadius = topRadius;\r\n  this._bottomRadius = bottomRadius;\r\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n  this._slices = slices;\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._workerName = \"createCylinderGeometry\";\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {CylinderGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nCylinderGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(value)) {\r\n    throw new DeveloperError(\"value is required\");\r\n  }\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  array[startingIndex++] = value._length;\r\n  array[startingIndex++] = value._topRadius;\r\n  array[startingIndex++] = value._bottomRadius;\r\n  array[startingIndex++] = value._slices;\r\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n  return array;\r\n};\r\n\r\nvar scratchVertexFormat = new VertexFormat();\r\nvar scratchOptions = {\r\n  vertexFormat: scratchVertexFormat,\r\n  length: undefined,\r\n  topRadius: undefined,\r\n  bottomRadius: undefined,\r\n  slices: undefined,\r\n  offsetAttribute: undefined,\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {CylinderGeometry} [result] The object into which to store the result.\r\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\r\n */\r\nCylinderGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  var vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  var length = array[startingIndex++];\r\n  var topRadius = array[startingIndex++];\r\n  var bottomRadius = array[startingIndex++];\r\n  var slices = array[startingIndex++];\r\n  var offsetAttribute = array[startingIndex];\r\n\r\n  if (!defined(result)) {\r\n    scratchOptions.length = length;\r\n    scratchOptions.topRadius = topRadius;\r\n    scratchOptions.bottomRadius = bottomRadius;\r\n    scratchOptions.slices = slices;\r\n    scratchOptions.offsetAttribute =\r\n      offsetAttribute === -1 ? undefined : offsetAttribute;\r\n    return new CylinderGeometry(scratchOptions);\r\n  }\r\n\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._length = length;\r\n  result._topRadius = topRadius;\r\n  result._bottomRadius = bottomRadius;\r\n  result._slices = slices;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\r\n  var length = cylinderGeometry._length;\r\n  var topRadius = cylinderGeometry._topRadius;\r\n  var bottomRadius = cylinderGeometry._bottomRadius;\r\n  var vertexFormat = cylinderGeometry._vertexFormat;\r\n  var slices = cylinderGeometry._slices;\r\n\r\n  if (\r\n    length <= 0 ||\r\n    topRadius < 0 ||\r\n    bottomRadius < 0 ||\r\n    (topRadius === 0 && bottomRadius === 0)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  var twoSlices = slices + slices;\r\n  var threeSlices = slices + twoSlices;\r\n  var numVertices = twoSlices + twoSlices;\r\n\r\n  var positions = CylinderGeometryLibrary.computePositions(\r\n    length,\r\n    topRadius,\r\n    bottomRadius,\r\n    slices,\r\n    true\r\n  );\r\n\r\n  var st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\r\n  var normals = vertexFormat.normal\r\n    ? new Float32Array(numVertices * 3)\r\n    : undefined;\r\n  var tangents = vertexFormat.tangent\r\n    ? new Float32Array(numVertices * 3)\r\n    : undefined;\r\n  var bitangents = vertexFormat.bitangent\r\n    ? new Float32Array(numVertices * 3)\r\n    : undefined;\r\n\r\n  var i;\r\n  var computeNormal =\r\n    vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\r\n\r\n  if (computeNormal) {\r\n    var computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\r\n\r\n    var normalIndex = 0;\r\n    var tangentIndex = 0;\r\n    var bitangentIndex = 0;\r\n\r\n    var theta = Math.atan2(bottomRadius - topRadius, length);\r\n    var normal = normalScratch;\r\n    normal.z = Math.sin(theta);\r\n    var normalScale = Math.cos(theta);\r\n    var tangent = tangentScratch;\r\n    var bitangent = bitangentScratch;\r\n\r\n    for (i = 0; i < slices; i++) {\r\n      var angle = (i / slices) * CesiumMath.TWO_PI;\r\n      var x = normalScale * Math.cos(angle);\r\n      var y = normalScale * Math.sin(angle);\r\n      if (computeNormal) {\r\n        normal.x = x;\r\n        normal.y = y;\r\n\r\n        if (computeTangent) {\r\n          tangent = Cartesian3.normalize(\r\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\r\n            tangent\r\n          );\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n          normals[normalIndex++] = normal.x;\r\n          normals[normalIndex++] = normal.y;\r\n          normals[normalIndex++] = normal.z;\r\n          normals[normalIndex++] = normal.x;\r\n          normals[normalIndex++] = normal.y;\r\n          normals[normalIndex++] = normal.z;\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n          tangents[tangentIndex++] = tangent.x;\r\n          tangents[tangentIndex++] = tangent.y;\r\n          tangents[tangentIndex++] = tangent.z;\r\n          tangents[tangentIndex++] = tangent.x;\r\n          tangents[tangentIndex++] = tangent.y;\r\n          tangents[tangentIndex++] = tangent.z;\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n          bitangent = Cartesian3.normalize(\r\n            Cartesian3.cross(normal, tangent, bitangent),\r\n            bitangent\r\n          );\r\n          bitangents[bitangentIndex++] = bitangent.x;\r\n          bitangents[bitangentIndex++] = bitangent.y;\r\n          bitangents[bitangentIndex++] = bitangent.z;\r\n          bitangents[bitangentIndex++] = bitangent.x;\r\n          bitangents[bitangentIndex++] = bitangent.y;\r\n          bitangents[bitangentIndex++] = bitangent.z;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < slices; i++) {\r\n      if (vertexFormat.normal) {\r\n        normals[normalIndex++] = 0;\r\n        normals[normalIndex++] = 0;\r\n        normals[normalIndex++] = -1;\r\n      }\r\n      if (vertexFormat.tangent) {\r\n        tangents[tangentIndex++] = 1;\r\n        tangents[tangentIndex++] = 0;\r\n        tangents[tangentIndex++] = 0;\r\n      }\r\n      if (vertexFormat.bitangent) {\r\n        bitangents[bitangentIndex++] = 0;\r\n        bitangents[bitangentIndex++] = -1;\r\n        bitangents[bitangentIndex++] = 0;\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < slices; i++) {\r\n      if (vertexFormat.normal) {\r\n        normals[normalIndex++] = 0;\r\n        normals[normalIndex++] = 0;\r\n        normals[normalIndex++] = 1;\r\n      }\r\n      if (vertexFormat.tangent) {\r\n        tangents[tangentIndex++] = 1;\r\n        tangents[tangentIndex++] = 0;\r\n        tangents[tangentIndex++] = 0;\r\n      }\r\n      if (vertexFormat.bitangent) {\r\n        bitangents[bitangentIndex++] = 0;\r\n        bitangents[bitangentIndex++] = 1;\r\n        bitangents[bitangentIndex++] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  var numIndices = 12 * slices - 12;\r\n  var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\r\n  var index = 0;\r\n  var j = 0;\r\n  for (i = 0; i < slices - 1; i++) {\r\n    indices[index++] = j;\r\n    indices[index++] = j + 2;\r\n    indices[index++] = j + 3;\r\n\r\n    indices[index++] = j;\r\n    indices[index++] = j + 3;\r\n    indices[index++] = j + 1;\r\n\r\n    j += 2;\r\n  }\r\n\r\n  indices[index++] = twoSlices - 2;\r\n  indices[index++] = 0;\r\n  indices[index++] = 1;\r\n  indices[index++] = twoSlices - 2;\r\n  indices[index++] = 1;\r\n  indices[index++] = twoSlices - 1;\r\n\r\n  for (i = 1; i < slices - 1; i++) {\r\n    indices[index++] = twoSlices + i + 1;\r\n    indices[index++] = twoSlices + i;\r\n    indices[index++] = twoSlices;\r\n  }\r\n\r\n  for (i = 1; i < slices - 1; i++) {\r\n    indices[index++] = threeSlices;\r\n    indices[index++] = threeSlices + i;\r\n    indices[index++] = threeSlices + i + 1;\r\n  }\r\n\r\n  var textureCoordIndex = 0;\r\n  if (vertexFormat.st) {\r\n    var rad = Math.max(topRadius, bottomRadius);\r\n    for (i = 0; i < numVertices; i++) {\r\n      var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\r\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\r\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\r\n    }\r\n  }\r\n\r\n  var attributes = new GeometryAttributes();\r\n  if (vertexFormat.position) {\r\n    attributes.position = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.DOUBLE,\r\n      componentsPerAttribute: 3,\r\n      values: positions,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.normal) {\r\n    attributes.normal = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: normals,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.tangent) {\r\n    attributes.tangent = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: tangents,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.bitangent) {\r\n    attributes.bitangent = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 3,\r\n      values: bitangents,\r\n    });\r\n  }\r\n\r\n  if (vertexFormat.st) {\r\n    attributes.st = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      values: st,\r\n    });\r\n  }\r\n\r\n  radiusScratch.x = length * 0.5;\r\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\r\n\r\n  var boundingSphere = new BoundingSphere(\r\n    Cartesian3.ZERO,\r\n    Cartesian2.magnitude(radiusScratch)\r\n  );\r\n\r\n  if (defined(cylinderGeometry._offsetAttribute)) {\r\n    length = positions.length;\r\n    var applyOffset = new Uint8Array(length / 3);\r\n    var offsetValue =\r\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n        ? 0\r\n        : 1;\r\n    arrayFill(applyOffset, offsetValue);\r\n    attributes.applyOffset = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 1,\r\n      values: applyOffset,\r\n    });\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: indices,\r\n    primitiveType: PrimitiveType.TRIANGLES,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: cylinderGeometry._offsetAttribute,\r\n  });\r\n};\r\n\r\nvar unitCylinderGeometry;\r\n\r\n/**\r\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\r\n * @returns {Geometry} The computed vertices and indices.\r\n *\r\n * @private\r\n */\r\nCylinderGeometry.getUnitCylinder = function () {\r\n  if (!defined(unitCylinderGeometry)) {\r\n    unitCylinderGeometry = CylinderGeometry.createGeometry(\r\n      new CylinderGeometry({\r\n        topRadius: 1.0,\r\n        bottomRadius: 1.0,\r\n        length: 1.0,\r\n        vertexFormat: VertexFormat.POSITION_ONLY,\r\n      })\r\n    );\r\n  }\r\n  return unitCylinderGeometry;\r\n};\r\nexport default CylinderGeometry;\r\n"],"names":["radiusScratch","Cartesian2","normalScratch","Cartesian3","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","options","length","defaultValue","EMPTY_OBJECT","topRadius","bottomRadius","vertexFormat","VertexFormat","DEFAULT","slices","defined","DeveloperError","offsetAttribute","GeometryOffsetAttribute","TOP","this","_length","_topRadius","_bottomRadius","_vertexFormat","clone","_slices","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","unitCylinderGeometry","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","i","twoSlices","threeSlices","numVertices","positions","CylinderGeometryLibrary","computePositions","st","Float32Array","normals","normal","tangents","tangent","bitangents","bitangent","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","theta","Math","atan2","z","sin","normalScale","cos","angle","CesiumMath","TWO_PI","x","y","normalize","cross","UNIT_Z","numIndices","indices","IndexDatatype","createTypedArray","index","j","textureCoordIndex","rad","max","position","fromArray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","boundingSphere","BoundingSphere","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","arrayFill","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","TRIANGLES","getUnitCylinder","POSITION_ONLY"],"mappings":"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"}