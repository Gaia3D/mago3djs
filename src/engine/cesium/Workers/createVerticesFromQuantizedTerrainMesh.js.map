{"version":3,"file":"createVerticesFromQuantizedTerrainMesh.js","sources":["../../../../Source/Core/TerrainProvider.js","../../../../Source/WorkersES6/createVerticesFromQuantizedTerrainMesh.js"],"sourcesContent":["import defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\n\r\n/**\r\n * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\r\n * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\r\n * interface and is not intended to be instantiated directly.\r\n *\r\n * @alias TerrainProvider\r\n * @constructor\r\n *\r\n * @see EllipsoidTerrainProvider\r\n * @see CesiumTerrainProvider\r\n * @see VRTheWorldTerrainProvider\r\n * @see GoogleEarthEnterpriseTerrainProvider\r\n */\r\nfunction TerrainProvider() {\r\n  DeveloperError.throwInstantiationError();\r\n}\r\n\r\nObject.defineProperties(TerrainProvider.prototype, {\r\n  /**\r\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing\r\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\r\n   * are passed an instance of {@link TileProviderError}.\r\n   * @memberof TerrainProvider.prototype\r\n   * @type {Event}\r\n   * @readonly\r\n   */\r\n  errorEvent: {\r\n    get: DeveloperError.throwInstantiationError,\r\n  },\r\n\r\n  /**\r\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\r\n   * the source of the terrain. This function should\r\n   * not be called before {@link TerrainProvider#ready} returns true.\r\n   * @memberof TerrainProvider.prototype\r\n   * @type {Credit}\r\n   * @readonly\r\n   */\r\n  credit: {\r\n    get: DeveloperError.throwInstantiationError,\r\n  },\r\n\r\n  /**\r\n   * Gets the tiling scheme used by the provider.  This function should\r\n   * not be called before {@link TerrainProvider#ready} returns true.\r\n   * @memberof TerrainProvider.prototype\r\n   * @type {TilingScheme}\r\n   * @readonly\r\n   */\r\n  tilingScheme: {\r\n    get: DeveloperError.throwInstantiationError,\r\n  },\r\n\r\n  /**\r\n   * Gets a value indicating whether or not the provider is ready for use.\r\n   * @memberof TerrainProvider.prototype\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  ready: {\r\n    get: DeveloperError.throwInstantiationError,\r\n  },\r\n\r\n  /**\r\n   * Gets a promise that resolves to true when the provider is ready for use.\r\n   * @memberof TerrainProvider.prototype\r\n   * @type {Promise.<Boolean>}\r\n   * @readonly\r\n   */\r\n  readyPromise: {\r\n    get: DeveloperError.throwInstantiationError,\r\n  },\r\n\r\n  /**\r\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\r\n   * indicates which areas of the globe are water rather than land, so they can be rendered\r\n   * as a reflective surface with animated waves.  This function should not be\r\n   * called before {@link TerrainProvider#ready} returns true.\r\n   * @memberof TerrainProvider.prototype\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  hasWaterMask: {\r\n    get: DeveloperError.throwInstantiationError,\r\n  },\r\n\r\n  /**\r\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\r\n   * This function should not be called before {@link TerrainProvider#ready} returns true.\r\n   * @memberof TerrainProvider.prototype\r\n   * @type {Boolean}\r\n   * @readonly\r\n   */\r\n  hasVertexNormals: {\r\n    get: DeveloperError.throwInstantiationError,\r\n  },\r\n\r\n  /**\r\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\r\n   * at points and in rectangles.  This function should not be called before\r\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\r\n   * information is not available.\r\n   * @memberof TerrainProvider.prototype\r\n   * @type {TileAvailability}\r\n   * @readonly\r\n   */\r\n  availability: {\r\n    get: DeveloperError.throwInstantiationError,\r\n  },\r\n});\r\n\r\nvar regularGridIndicesCache = [];\r\n\r\n/**\r\n * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\r\n * this function multiple times with the same grid width and height returns the\r\n * same list of indices.  The total number of vertices must be less than or equal\r\n * to 65536.\r\n *\r\n * @param {Number} width The number of vertices in the regular grid in the horizontal direction.\r\n * @param {Number} height The number of vertices in the regular grid in the vertical direction.\r\n * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\r\n */\r\nTerrainProvider.getRegularGridIndices = function (width, height) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\r\n    throw new DeveloperError(\r\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var byWidth = regularGridIndicesCache[width];\r\n  if (!defined(byWidth)) {\r\n    regularGridIndicesCache[width] = byWidth = [];\r\n  }\r\n\r\n  var indices = byWidth[height];\r\n  if (!defined(indices)) {\r\n    if (width * height < CesiumMath.SIXTY_FOUR_KILOBYTES) {\r\n      indices = byWidth[height] = new Uint16Array(\r\n        (width - 1) * (height - 1) * 6\r\n      );\r\n    } else {\r\n      indices = byWidth[height] = new Uint32Array(\r\n        (width - 1) * (height - 1) * 6\r\n      );\r\n    }\r\n    addRegularGridIndices(width, height, indices, 0);\r\n  }\r\n\r\n  return indices;\r\n};\r\n\r\nvar regularGridAndEdgeIndicesCache = [];\r\n\r\n/**\r\n * @private\r\n */\r\nTerrainProvider.getRegularGridIndicesAndEdgeIndices = function (width, height) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\r\n    throw new DeveloperError(\r\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var byWidth = regularGridAndEdgeIndicesCache[width];\r\n  if (!defined(byWidth)) {\r\n    regularGridAndEdgeIndicesCache[width] = byWidth = [];\r\n  }\r\n\r\n  var indicesAndEdges = byWidth[height];\r\n  if (!defined(indicesAndEdges)) {\r\n    var indices = TerrainProvider.getRegularGridIndices(width, height);\r\n\r\n    var edgeIndices = getEdgeIndices(width, height);\r\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\r\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\r\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\r\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\r\n\r\n    indicesAndEdges = byWidth[height] = {\r\n      indices: indices,\r\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\r\n      southIndicesEastToWest: southIndicesEastToWest,\r\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\r\n      northIndicesWestToEast: northIndicesWestToEast,\r\n    };\r\n  }\r\n\r\n  return indicesAndEdges;\r\n};\r\n\r\nvar regularGridAndSkirtAndEdgeIndicesCache = [];\r\n\r\n/**\r\n * @private\r\n */\r\nTerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function (\r\n  width,\r\n  height\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\r\n    throw new DeveloperError(\r\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\r\n  if (!defined(byWidth)) {\r\n    regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\r\n  }\r\n\r\n  var indicesAndEdges = byWidth[height];\r\n  if (!defined(indicesAndEdges)) {\r\n    var gridVertexCount = width * height;\r\n    var gridIndexCount = (width - 1) * (height - 1) * 6;\r\n    var edgeVertexCount = width * 2 + height * 2;\r\n    var edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\r\n    var vertexCount = gridVertexCount + edgeVertexCount;\r\n    var indexCount = gridIndexCount + edgeIndexCount;\r\n\r\n    var edgeIndices = getEdgeIndices(width, height);\r\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\r\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\r\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\r\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\r\n\r\n    var indices = IndexDatatype.createTypedArray(vertexCount, indexCount);\r\n    addRegularGridIndices(width, height, indices, 0);\r\n    TerrainProvider.addSkirtIndices(\r\n      westIndicesSouthToNorth,\r\n      southIndicesEastToWest,\r\n      eastIndicesNorthToSouth,\r\n      northIndicesWestToEast,\r\n      gridVertexCount,\r\n      indices,\r\n      gridIndexCount\r\n    );\r\n\r\n    indicesAndEdges = byWidth[height] = {\r\n      indices: indices,\r\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\r\n      southIndicesEastToWest: southIndicesEastToWest,\r\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\r\n      northIndicesWestToEast: northIndicesWestToEast,\r\n      indexCountWithoutSkirts: gridIndexCount,\r\n    };\r\n  }\r\n\r\n  return indicesAndEdges;\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nTerrainProvider.addSkirtIndices = function (\r\n  westIndicesSouthToNorth,\r\n  southIndicesEastToWest,\r\n  eastIndicesNorthToSouth,\r\n  northIndicesWestToEast,\r\n  vertexCount,\r\n  indices,\r\n  offset\r\n) {\r\n  var vertexIndex = vertexCount;\r\n  offset = addSkirtIndices(\r\n    westIndicesSouthToNorth,\r\n    vertexIndex,\r\n    indices,\r\n    offset\r\n  );\r\n  vertexIndex += westIndicesSouthToNorth.length;\r\n  offset = addSkirtIndices(\r\n    southIndicesEastToWest,\r\n    vertexIndex,\r\n    indices,\r\n    offset\r\n  );\r\n  vertexIndex += southIndicesEastToWest.length;\r\n  offset = addSkirtIndices(\r\n    eastIndicesNorthToSouth,\r\n    vertexIndex,\r\n    indices,\r\n    offset\r\n  );\r\n  vertexIndex += eastIndicesNorthToSouth.length;\r\n  addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\r\n};\r\n\r\nfunction getEdgeIndices(width, height) {\r\n  var westIndicesSouthToNorth = new Array(height);\r\n  var southIndicesEastToWest = new Array(width);\r\n  var eastIndicesNorthToSouth = new Array(height);\r\n  var northIndicesWestToEast = new Array(width);\r\n\r\n  var i;\r\n  for (i = 0; i < width; ++i) {\r\n    northIndicesWestToEast[i] = i;\r\n    southIndicesEastToWest[i] = width * height - 1 - i;\r\n  }\r\n\r\n  for (i = 0; i < height; ++i) {\r\n    eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\r\n    westIndicesSouthToNorth[i] = (height - i - 1) * width;\r\n  }\r\n\r\n  return {\r\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\r\n    southIndicesEastToWest: southIndicesEastToWest,\r\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\r\n    northIndicesWestToEast: northIndicesWestToEast,\r\n  };\r\n}\r\n\r\nfunction addRegularGridIndices(width, height, indices, offset) {\r\n  var index = 0;\r\n  for (var j = 0; j < height - 1; ++j) {\r\n    for (var i = 0; i < width - 1; ++i) {\r\n      var upperLeft = index;\r\n      var lowerLeft = upperLeft + width;\r\n      var lowerRight = lowerLeft + 1;\r\n      var upperRight = upperLeft + 1;\r\n\r\n      indices[offset++] = upperLeft;\r\n      indices[offset++] = lowerLeft;\r\n      indices[offset++] = upperRight;\r\n      indices[offset++] = upperRight;\r\n      indices[offset++] = lowerLeft;\r\n      indices[offset++] = lowerRight;\r\n\r\n      ++index;\r\n    }\r\n    ++index;\r\n  }\r\n}\r\n\r\nfunction addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\r\n  var previousIndex = edgeIndices[0];\r\n\r\n  var length = edgeIndices.length;\r\n  for (var i = 1; i < length; ++i) {\r\n    var index = edgeIndices[i];\r\n\r\n    indices[offset++] = previousIndex;\r\n    indices[offset++] = index;\r\n    indices[offset++] = vertexIndex;\r\n\r\n    indices[offset++] = vertexIndex;\r\n    indices[offset++] = index;\r\n    indices[offset++] = vertexIndex + 1;\r\n\r\n    previousIndex = index;\r\n    ++vertexIndex;\r\n  }\r\n\r\n  return offset;\r\n}\r\n\r\n/**\r\n * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\r\n * ensure that adjacent heightmap vertices are separated by no more than\r\n * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\r\n * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\r\n * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\r\n * @type {Number}\r\n */\r\nTerrainProvider.heightmapTerrainQuality = 0.25;\r\n\r\n/**\r\n * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\r\n *\r\n * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\r\n * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\r\n * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\r\n * @returns {Number} An estimated geometric error.\r\n */\r\nTerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (\r\n  ellipsoid,\r\n  tileImageWidth,\r\n  numberOfTilesAtLevelZero\r\n) {\r\n  return (\r\n    (ellipsoid.maximumRadius *\r\n      2 *\r\n      Math.PI *\r\n      TerrainProvider.heightmapTerrainQuality) /\r\n    (tileImageWidth * numberOfTilesAtLevelZero)\r\n  );\r\n};\r\n\r\n/**\r\n * Requests the geometry for a given tile.  This function should not be called before\r\n * {@link TerrainProvider#ready} returns true.  The result must include terrain data and\r\n * may optionally include a water mask and an indication of which child tiles are available.\r\n * @function\r\n *\r\n * @param {Number} x The X coordinate of the tile for which to request geometry.\r\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\r\n * @param {Number} level The level of the tile for which to request geometry.\r\n * @param {Request} [request] The request object. Intended for internal use only.\r\n *\r\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\r\n *          returns undefined instead of a promise, it is an indication that too many requests are already\r\n *          pending and the request will be retried later.\r\n */\r\nTerrainProvider.prototype.requestTileGeometry =\r\n  DeveloperError.throwInstantiationError;\r\n\r\n/**\r\n * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be\r\n * called before {@link TerrainProvider#ready} returns true.\r\n * @function\r\n *\r\n * @param {Number} level The tile level for which to get the maximum geometric error.\r\n * @returns {Number} The maximum geometric error.\r\n */\r\nTerrainProvider.prototype.getLevelMaximumGeometricError =\r\n  DeveloperError.throwInstantiationError;\r\n\r\n/**\r\n * Determines whether data for a tile is available to be loaded.\r\n * @function\r\n *\r\n * @param {Number} x The X coordinate of the tile for which to request geometry.\r\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\r\n * @param {Number} level The level of the tile for which to request geometry.\r\n * @returns {Boolean|undefined} Undefined if not supported by the terrain provider, otherwise true or false.\r\n */\r\nTerrainProvider.prototype.getTileDataAvailable =\r\n  DeveloperError.throwInstantiationError;\r\n\r\n/**\r\n * Makes sure we load availability data for a tile\r\n * @function\r\n *\r\n * @param {Number} x The X coordinate of the tile for which to request geometry.\r\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\r\n * @param {Number} level The level of the tile for which to request geometry.\r\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\r\n */\r\nTerrainProvider.prototype.loadTileDataAvailability =\r\n  DeveloperError.throwInstantiationError;\r\nexport default TerrainProvider;\r\n","import AxisAlignedBoundingBox from \"../Core/AxisAlignedBoundingBox.js\";\r\nimport Cartesian2 from \"../Core/Cartesian2.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Cartographic from \"../Core/Cartographic.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport CesiumMath from \"../Core/Math.js\";\r\nimport Matrix4 from \"../Core/Matrix4.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\r\nimport TerrainProvider from \"../Core/TerrainProvider.js\";\r\nimport Transforms from \"../Core/Transforms.js\";\r\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nvar maxShort = 32767;\r\n\r\nvar cartesian3Scratch = new Cartesian3();\r\nvar scratchMinimum = new Cartesian3();\r\nvar scratchMaximum = new Cartesian3();\r\nvar cartographicScratch = new Cartographic();\r\nvar toPack = new Cartesian2();\r\n\r\nfunction createVerticesFromQuantizedTerrainMesh(\r\n  parameters,\r\n  transferableObjects\r\n) {\r\n  var quantizedVertices = parameters.quantizedVertices;\r\n  var quantizedVertexCount = quantizedVertices.length / 3;\r\n  var octEncodedNormals = parameters.octEncodedNormals;\r\n  var edgeVertexCount =\r\n    parameters.westIndices.length +\r\n    parameters.eastIndices.length +\r\n    parameters.southIndices.length +\r\n    parameters.northIndices.length;\r\n  var includeWebMercatorT = parameters.includeWebMercatorT;\r\n\r\n  var exaggeration = parameters.exaggeration;\r\n  var exaggerationRelativeHeight = parameters.exaggerationRelativeHeight;\r\n  var hasExaggeration = exaggeration !== 1.0;\r\n  var includeGeodeticSurfaceNormals = hasExaggeration;\r\n\r\n  var rectangle = Rectangle.clone(parameters.rectangle);\r\n  var west = rectangle.west;\r\n  var south = rectangle.south;\r\n  var east = rectangle.east;\r\n  var north = rectangle.north;\r\n\r\n  var ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\r\n\r\n  var minimumHeight = parameters.minimumHeight;\r\n  var maximumHeight = parameters.maximumHeight;\r\n\r\n  var center = parameters.relativeToCenter;\r\n  var fromENU = Transforms.eastNorthUpToFixedFrame(center, ellipsoid);\r\n  var toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\r\n\r\n  var southMercatorY;\r\n  var oneOverMercatorHeight;\r\n  if (includeWebMercatorT) {\r\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\r\n      south\r\n    );\r\n    oneOverMercatorHeight =\r\n      1.0 /\r\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(north) -\r\n        southMercatorY);\r\n  }\r\n\r\n  var uBuffer = quantizedVertices.subarray(0, quantizedVertexCount);\r\n  var vBuffer = quantizedVertices.subarray(\r\n    quantizedVertexCount,\r\n    2 * quantizedVertexCount\r\n  );\r\n  var heightBuffer = quantizedVertices.subarray(\r\n    quantizedVertexCount * 2,\r\n    3 * quantizedVertexCount\r\n  );\r\n  var hasVertexNormals = defined(octEncodedNormals);\r\n\r\n  var uvs = new Array(quantizedVertexCount);\r\n  var heights = new Array(quantizedVertexCount);\r\n  var positions = new Array(quantizedVertexCount);\r\n  var webMercatorTs = includeWebMercatorT\r\n    ? new Array(quantizedVertexCount)\r\n    : [];\r\n  var geodeticSurfaceNormals = includeGeodeticSurfaceNormals\r\n    ? new Array(quantizedVertexCount)\r\n    : [];\r\n\r\n  var minimum = scratchMinimum;\r\n  minimum.x = Number.POSITIVE_INFINITY;\r\n  minimum.y = Number.POSITIVE_INFINITY;\r\n  minimum.z = Number.POSITIVE_INFINITY;\r\n\r\n  var maximum = scratchMaximum;\r\n  maximum.x = Number.NEGATIVE_INFINITY;\r\n  maximum.y = Number.NEGATIVE_INFINITY;\r\n  maximum.z = Number.NEGATIVE_INFINITY;\r\n\r\n  var minLongitude = Number.POSITIVE_INFINITY;\r\n  var maxLongitude = Number.NEGATIVE_INFINITY;\r\n  var minLatitude = Number.POSITIVE_INFINITY;\r\n  var maxLatitude = Number.NEGATIVE_INFINITY;\r\n\r\n  for (var i = 0; i < quantizedVertexCount; ++i) {\r\n    var rawU = uBuffer[i];\r\n    var rawV = vBuffer[i];\r\n\r\n    var u = rawU / maxShort;\r\n    var v = rawV / maxShort;\r\n    var height = CesiumMath.lerp(\r\n      minimumHeight,\r\n      maximumHeight,\r\n      heightBuffer[i] / maxShort\r\n    );\r\n\r\n    cartographicScratch.longitude = CesiumMath.lerp(west, east, u);\r\n    cartographicScratch.latitude = CesiumMath.lerp(south, north, v);\r\n    cartographicScratch.height = height;\r\n\r\n    minLongitude = Math.min(cartographicScratch.longitude, minLongitude);\r\n    maxLongitude = Math.max(cartographicScratch.longitude, maxLongitude);\r\n    minLatitude = Math.min(cartographicScratch.latitude, minLatitude);\r\n    maxLatitude = Math.max(cartographicScratch.latitude, maxLatitude);\r\n\r\n    var position = ellipsoid.cartographicToCartesian(cartographicScratch);\r\n\r\n    uvs[i] = new Cartesian2(u, v);\r\n    heights[i] = height;\r\n    positions[i] = position;\r\n\r\n    if (includeWebMercatorT) {\r\n      webMercatorTs[i] =\r\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\r\n          cartographicScratch.latitude\r\n        ) -\r\n          southMercatorY) *\r\n        oneOverMercatorHeight;\r\n    }\r\n\r\n    if (includeGeodeticSurfaceNormals) {\r\n      geodeticSurfaceNormals[i] = ellipsoid.geodeticSurfaceNormal(position);\r\n    }\r\n\r\n    Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\r\n\r\n    Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\r\n    Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\r\n  }\r\n\r\n  var westIndicesSouthToNorth = copyAndSort(parameters.westIndices, function (\r\n    a,\r\n    b\r\n  ) {\r\n    return uvs[a].y - uvs[b].y;\r\n  });\r\n  var eastIndicesNorthToSouth = copyAndSort(parameters.eastIndices, function (\r\n    a,\r\n    b\r\n  ) {\r\n    return uvs[b].y - uvs[a].y;\r\n  });\r\n  var southIndicesEastToWest = copyAndSort(parameters.southIndices, function (\r\n    a,\r\n    b\r\n  ) {\r\n    return uvs[b].x - uvs[a].x;\r\n  });\r\n  var northIndicesWestToEast = copyAndSort(parameters.northIndices, function (\r\n    a,\r\n    b\r\n  ) {\r\n    return uvs[a].x - uvs[b].x;\r\n  });\r\n\r\n  var occludeePointInScaledSpace;\r\n  if (minimumHeight < 0.0) {\r\n    // Horizon culling point needs to be recomputed since the tile is at least partly under the ellipsoid.\r\n    var occluder = new EllipsoidalOccluder(ellipsoid);\r\n    occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\r\n      center,\r\n      positions,\r\n      minimumHeight\r\n    );\r\n  }\r\n\r\n  var hMin = minimumHeight;\r\n  hMin = Math.min(\r\n    hMin,\r\n    findMinMaxSkirts(\r\n      parameters.westIndices,\r\n      parameters.westSkirtHeight,\r\n      heights,\r\n      uvs,\r\n      rectangle,\r\n      ellipsoid,\r\n      toENU,\r\n      minimum,\r\n      maximum\r\n    )\r\n  );\r\n  hMin = Math.min(\r\n    hMin,\r\n    findMinMaxSkirts(\r\n      parameters.southIndices,\r\n      parameters.southSkirtHeight,\r\n      heights,\r\n      uvs,\r\n      rectangle,\r\n      ellipsoid,\r\n      toENU,\r\n      minimum,\r\n      maximum\r\n    )\r\n  );\r\n  hMin = Math.min(\r\n    hMin,\r\n    findMinMaxSkirts(\r\n      parameters.eastIndices,\r\n      parameters.eastSkirtHeight,\r\n      heights,\r\n      uvs,\r\n      rectangle,\r\n      ellipsoid,\r\n      toENU,\r\n      minimum,\r\n      maximum\r\n    )\r\n  );\r\n  hMin = Math.min(\r\n    hMin,\r\n    findMinMaxSkirts(\r\n      parameters.northIndices,\r\n      parameters.northSkirtHeight,\r\n      heights,\r\n      uvs,\r\n      rectangle,\r\n      ellipsoid,\r\n      toENU,\r\n      minimum,\r\n      maximum\r\n    )\r\n  );\r\n\r\n  var aaBox = new AxisAlignedBoundingBox(minimum, maximum, center);\r\n  var encoding = new TerrainEncoding(\r\n    center,\r\n    aaBox,\r\n    hMin,\r\n    maximumHeight,\r\n    fromENU,\r\n    hasVertexNormals,\r\n    includeWebMercatorT,\r\n    includeGeodeticSurfaceNormals,\r\n    exaggeration,\r\n    exaggerationRelativeHeight\r\n  );\r\n  var vertexStride = encoding.stride;\r\n  var size =\r\n    quantizedVertexCount * vertexStride + edgeVertexCount * vertexStride;\r\n  var vertexBuffer = new Float32Array(size);\r\n\r\n  var bufferIndex = 0;\r\n  for (var j = 0; j < quantizedVertexCount; ++j) {\r\n    if (hasVertexNormals) {\r\n      var n = j * 2.0;\r\n      toPack.x = octEncodedNormals[n];\r\n      toPack.y = octEncodedNormals[n + 1];\r\n    }\r\n\r\n    bufferIndex = encoding.encode(\r\n      vertexBuffer,\r\n      bufferIndex,\r\n      positions[j],\r\n      uvs[j],\r\n      heights[j],\r\n      toPack,\r\n      webMercatorTs[j],\r\n      geodeticSurfaceNormals[j]\r\n    );\r\n  }\r\n\r\n  var edgeTriangleCount = Math.max(0, (edgeVertexCount - 4) * 2);\r\n  var indexBufferLength = parameters.indices.length + edgeTriangleCount * 3;\r\n  var indexBuffer = IndexDatatype.createTypedArray(\r\n    quantizedVertexCount + edgeVertexCount,\r\n    indexBufferLength\r\n  );\r\n  indexBuffer.set(parameters.indices, 0);\r\n\r\n  var percentage = 0.0001;\r\n  var lonOffset = (maxLongitude - minLongitude) * percentage;\r\n  var latOffset = (maxLatitude - minLatitude) * percentage;\r\n  var westLongitudeOffset = -lonOffset;\r\n  var westLatitudeOffset = 0.0;\r\n  var eastLongitudeOffset = lonOffset;\r\n  var eastLatitudeOffset = 0.0;\r\n  var northLongitudeOffset = 0.0;\r\n  var northLatitudeOffset = latOffset;\r\n  var southLongitudeOffset = 0.0;\r\n  var southLatitudeOffset = -latOffset;\r\n\r\n  // Add skirts.\r\n  var vertexBufferIndex = quantizedVertexCount * vertexStride;\r\n  addSkirt(\r\n    vertexBuffer,\r\n    vertexBufferIndex,\r\n    westIndicesSouthToNorth,\r\n    encoding,\r\n    heights,\r\n    uvs,\r\n    octEncodedNormals,\r\n    ellipsoid,\r\n    rectangle,\r\n    parameters.westSkirtHeight,\r\n    southMercatorY,\r\n    oneOverMercatorHeight,\r\n    westLongitudeOffset,\r\n    westLatitudeOffset\r\n  );\r\n  vertexBufferIndex += parameters.westIndices.length * vertexStride;\r\n  addSkirt(\r\n    vertexBuffer,\r\n    vertexBufferIndex,\r\n    southIndicesEastToWest,\r\n    encoding,\r\n    heights,\r\n    uvs,\r\n    octEncodedNormals,\r\n    ellipsoid,\r\n    rectangle,\r\n    parameters.southSkirtHeight,\r\n    southMercatorY,\r\n    oneOverMercatorHeight,\r\n    southLongitudeOffset,\r\n    southLatitudeOffset\r\n  );\r\n  vertexBufferIndex += parameters.southIndices.length * vertexStride;\r\n  addSkirt(\r\n    vertexBuffer,\r\n    vertexBufferIndex,\r\n    eastIndicesNorthToSouth,\r\n    encoding,\r\n    heights,\r\n    uvs,\r\n    octEncodedNormals,\r\n    ellipsoid,\r\n    rectangle,\r\n    parameters.eastSkirtHeight,\r\n    southMercatorY,\r\n    oneOverMercatorHeight,\r\n    eastLongitudeOffset,\r\n    eastLatitudeOffset\r\n  );\r\n  vertexBufferIndex += parameters.eastIndices.length * vertexStride;\r\n  addSkirt(\r\n    vertexBuffer,\r\n    vertexBufferIndex,\r\n    northIndicesWestToEast,\r\n    encoding,\r\n    heights,\r\n    uvs,\r\n    octEncodedNormals,\r\n    ellipsoid,\r\n    rectangle,\r\n    parameters.northSkirtHeight,\r\n    southMercatorY,\r\n    oneOverMercatorHeight,\r\n    northLongitudeOffset,\r\n    northLatitudeOffset\r\n  );\r\n\r\n  TerrainProvider.addSkirtIndices(\r\n    westIndicesSouthToNorth,\r\n    southIndicesEastToWest,\r\n    eastIndicesNorthToSouth,\r\n    northIndicesWestToEast,\r\n    quantizedVertexCount,\r\n    indexBuffer,\r\n    parameters.indices.length\r\n  );\r\n\r\n  transferableObjects.push(vertexBuffer.buffer, indexBuffer.buffer);\r\n\r\n  return {\r\n    vertices: vertexBuffer.buffer,\r\n    indices: indexBuffer.buffer,\r\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\r\n    southIndicesEastToWest: southIndicesEastToWest,\r\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\r\n    northIndicesWestToEast: northIndicesWestToEast,\r\n    vertexStride: vertexStride,\r\n    center: center,\r\n    minimumHeight: minimumHeight,\r\n    maximumHeight: maximumHeight,\r\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\r\n    encoding: encoding,\r\n    indexCountWithoutSkirts: parameters.indices.length,\r\n  };\r\n}\r\n\r\nfunction findMinMaxSkirts(\r\n  edgeIndices,\r\n  edgeHeight,\r\n  heights,\r\n  uvs,\r\n  rectangle,\r\n  ellipsoid,\r\n  toENU,\r\n  minimum,\r\n  maximum\r\n) {\r\n  var hMin = Number.POSITIVE_INFINITY;\r\n\r\n  var north = rectangle.north;\r\n  var south = rectangle.south;\r\n  var east = rectangle.east;\r\n  var west = rectangle.west;\r\n\r\n  if (east < west) {\r\n    east += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  var length = edgeIndices.length;\r\n  for (var i = 0; i < length; ++i) {\r\n    var index = edgeIndices[i];\r\n    var h = heights[index];\r\n    var uv = uvs[index];\r\n\r\n    cartographicScratch.longitude = CesiumMath.lerp(west, east, uv.x);\r\n    cartographicScratch.latitude = CesiumMath.lerp(south, north, uv.y);\r\n    cartographicScratch.height = h - edgeHeight;\r\n\r\n    var position = ellipsoid.cartographicToCartesian(\r\n      cartographicScratch,\r\n      cartesian3Scratch\r\n    );\r\n    Matrix4.multiplyByPoint(toENU, position, position);\r\n\r\n    Cartesian3.minimumByComponent(position, minimum, minimum);\r\n    Cartesian3.maximumByComponent(position, maximum, maximum);\r\n\r\n    hMin = Math.min(hMin, cartographicScratch.height);\r\n  }\r\n  return hMin;\r\n}\r\n\r\nfunction addSkirt(\r\n  vertexBuffer,\r\n  vertexBufferIndex,\r\n  edgeVertices,\r\n  encoding,\r\n  heights,\r\n  uvs,\r\n  octEncodedNormals,\r\n  ellipsoid,\r\n  rectangle,\r\n  skirtLength,\r\n  southMercatorY,\r\n  oneOverMercatorHeight,\r\n  longitudeOffset,\r\n  latitudeOffset\r\n) {\r\n  var hasVertexNormals = defined(octEncodedNormals);\r\n\r\n  var north = rectangle.north;\r\n  var south = rectangle.south;\r\n  var east = rectangle.east;\r\n  var west = rectangle.west;\r\n\r\n  if (east < west) {\r\n    east += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  var length = edgeVertices.length;\r\n  for (var i = 0; i < length; ++i) {\r\n    var index = edgeVertices[i];\r\n    var h = heights[index];\r\n    var uv = uvs[index];\r\n\r\n    cartographicScratch.longitude =\r\n      CesiumMath.lerp(west, east, uv.x) + longitudeOffset;\r\n    cartographicScratch.latitude =\r\n      CesiumMath.lerp(south, north, uv.y) + latitudeOffset;\r\n    cartographicScratch.height = h - skirtLength;\r\n\r\n    var position = ellipsoid.cartographicToCartesian(\r\n      cartographicScratch,\r\n      cartesian3Scratch\r\n    );\r\n\r\n    if (hasVertexNormals) {\r\n      var n = index * 2.0;\r\n      toPack.x = octEncodedNormals[n];\r\n      toPack.y = octEncodedNormals[n + 1];\r\n    }\r\n\r\n    var webMercatorT;\r\n    if (encoding.hasWebMercatorT) {\r\n      webMercatorT =\r\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\r\n          cartographicScratch.latitude\r\n        ) -\r\n          southMercatorY) *\r\n        oneOverMercatorHeight;\r\n    }\r\n\r\n    var geodeticSurfaceNormal;\r\n    if (encoding.hasGeodeticSurfaceNormals) {\r\n      geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(position);\r\n    }\r\n\r\n    vertexBufferIndex = encoding.encode(\r\n      vertexBuffer,\r\n      vertexBufferIndex,\r\n      position,\r\n      uv,\r\n      cartographicScratch.height,\r\n      toPack,\r\n      webMercatorT,\r\n      geodeticSurfaceNormal\r\n    );\r\n  }\r\n}\r\n\r\nfunction copyAndSort(typedArray, comparator) {\r\n  var copy;\r\n  if (typeof typedArray.slice === \"function\") {\r\n    copy = typedArray.slice();\r\n    if (typeof copy.sort !== \"function\") {\r\n      // Sliced typed array isn't sortable, so we can't use it.\r\n      copy = undefined;\r\n    }\r\n  }\r\n\r\n  if (!defined(copy)) {\r\n    copy = Array.prototype.slice.call(typedArray);\r\n  }\r\n\r\n  copy.sort(comparator);\r\n\r\n  return copy;\r\n}\r\nexport default createTaskProcessorWorker(\r\n  createVerticesFromQuantizedTerrainMesh\r\n);\r\n"],"names":["TerrainProvider","DeveloperError","throwInstantiationError","Object","defineProperties","prototype","errorEvent","get","credit","tilingScheme","ready","readyPromise","hasWaterMask","hasVertexNormals","availability","regularGridIndicesCache","getRegularGridIndices","width","height","CesiumMath","FOUR_GIGABYTES","byWidth","defined","indices","addRegularGridIndices","SIXTY_FOUR_KILOBYTES","Uint16Array","Uint32Array","regularGridAndEdgeIndicesCache","getRegularGridIndicesAndEdgeIndices","indicesAndEdges","edgeIndices","getEdgeIndices","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","regularGridAndSkirtAndEdgeIndicesCache","i","Array","offset","index","j","upperLeft","lowerLeft","lowerRight","upperRight","addSkirtIndices","vertexIndex","previousIndex","length","getRegularGridAndSkirtIndicesAndEdgeIndices","gridVertexCount","gridIndexCount","edgeVertexCount","vertexCount","indexCount","Math","max","IndexDatatype","createTypedArray","indexCountWithoutSkirts","heightmapTerrainQuality","getEstimatedLevelZeroGeometricErrorForAHeightmap","ellipsoid","tileImageWidth","numberOfTilesAtLevelZero","maximumRadius","PI","requestTileGeometry","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability","maxShort","cartesian3Scratch","Cartesian3","scratchMinimum","scratchMaximum","cartographicScratch","Cartographic","toPack","Cartesian2","findMinMaxSkirts","edgeHeight","heights","uvs","rectangle","toENU","minimum","maximum","hMin","Number","POSITIVE_INFINITY","north","south","east","west","TWO_PI","h","uv","longitude","lerp","x","latitude","y","position","cartographicToCartesian","Matrix4","multiplyByPoint","minimumByComponent","maximumByComponent","min","addSkirt","vertexBuffer","vertexBufferIndex","edgeVertices","encoding","octEncodedNormals","skirtLength","southMercatorY","oneOverMercatorHeight","longitudeOffset","latitudeOffset","webMercatorT","geodeticSurfaceNormal","n","hasWebMercatorT","WebMercatorProjection","geodeticLatitudeToMercatorAngle","hasGeodeticSurfaceNormals","encode","copyAndSort","typedArray","comparator","copy","slice","sort","undefined","call","createTaskProcessorWorker","parameters","transferableObjects","quantizedVertices","quantizedVertexCount","westIndices","eastIndices","southIndices","northIndices","includeWebMercatorT","exaggeration","exaggerationRelativeHeight","includeGeodeticSurfaceNormals","Rectangle","clone","Ellipsoid","minimumHeight","maximumHeight","center","relativeToCenter","fromENU","Transforms","eastNorthUpToFixedFrame","inverseTransformation","uBuffer","subarray","vBuffer","heightBuffer","positions","webMercatorTs","geodeticSurfaceNormals","z","NEGATIVE_INFINITY","minLongitude","maxLongitude","minLatitude","maxLatitude","rawU","rawV","u","v","occludeePointInScaledSpace","a","b","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","aaBox","AxisAlignedBoundingBox","TerrainEncoding","vertexStride","stride","Float32Array","bufferIndex","edgeTriangleCount","indexBufferLength","indexBuffer","set","percentage","lonOffset","latOffset","westLongitudeOffset","eastLongitudeOffset","northLatitudeOffset","southLatitudeOffset","push","buffer","vertices"],"mappings":"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"}