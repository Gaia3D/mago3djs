{"version":3,"file":"createVectorTileClampedPolylines.js","sources":["../../../../Source/WorkersES6/createVectorTileClampedPolylines.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Cartographic from \"../Core/Cartographic.js\";\r\nimport combine from \"../Core/combine.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport CesiumMath from \"../Core/Math.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nvar MAX_SHORT = 32767;\r\nvar MITER_BREAK = Math.cos(CesiumMath.toRadians(150.0));\r\n\r\nvar scratchBVCartographic = new Cartographic();\r\nvar scratchEncodedPosition = new Cartesian3();\r\n\r\nfunction decodePositions(\r\n  uBuffer,\r\n  vBuffer,\r\n  heightBuffer,\r\n  rectangle,\r\n  minimumHeight,\r\n  maximumHeight,\r\n  ellipsoid\r\n) {\r\n  var positionsLength = uBuffer.length;\r\n  var decodedPositions = new Float64Array(positionsLength * 3);\r\n  for (var i = 0; i < positionsLength; ++i) {\r\n    var u = uBuffer[i];\r\n    var v = vBuffer[i];\r\n    var h = heightBuffer[i];\r\n\r\n    var lon = CesiumMath.lerp(rectangle.west, rectangle.east, u / MAX_SHORT);\r\n    var lat = CesiumMath.lerp(rectangle.south, rectangle.north, v / MAX_SHORT);\r\n    var alt = CesiumMath.lerp(minimumHeight, maximumHeight, h / MAX_SHORT);\r\n\r\n    var cartographic = Cartographic.fromRadians(\r\n      lon,\r\n      lat,\r\n      alt,\r\n      scratchBVCartographic\r\n    );\r\n    var decodedPosition = ellipsoid.cartographicToCartesian(\r\n      cartographic,\r\n      scratchEncodedPosition\r\n    );\r\n    Cartesian3.pack(decodedPosition, decodedPositions, i * 3);\r\n  }\r\n  return decodedPositions;\r\n}\r\n\r\nfunction getPositionOffsets(counts) {\r\n  var countsLength = counts.length;\r\n  var positionOffsets = new Uint32Array(countsLength + 1);\r\n  var offset = 0;\r\n  for (var i = 0; i < countsLength; ++i) {\r\n    positionOffsets[i] = offset;\r\n    offset += counts[i];\r\n  }\r\n  positionOffsets[countsLength] = offset;\r\n  return positionOffsets;\r\n}\r\n\r\nvar previousCompressedCartographicScratch = new Cartographic();\r\nvar currentCompressedCartographicScratch = new Cartographic();\r\nfunction removeDuplicates(uBuffer, vBuffer, heightBuffer, counts) {\r\n  var countsLength = counts.length;\r\n  var positionsLength = uBuffer.length;\r\n  var markRemoval = new Uint8Array(positionsLength);\r\n  var previous = previousCompressedCartographicScratch;\r\n  var current = currentCompressedCartographicScratch;\r\n  var offset = 0;\r\n  for (var i = 0; i < countsLength; i++) {\r\n    var count = counts[i];\r\n    var updatedCount = count;\r\n    for (var j = 1; j < count; j++) {\r\n      var index = offset + j;\r\n      var previousIndex = index - 1;\r\n      current.longitude = uBuffer[index];\r\n      current.latitude = vBuffer[index];\r\n      previous.longitude = uBuffer[previousIndex];\r\n      previous.latitude = vBuffer[previousIndex];\r\n\r\n      if (Cartographic.equals(current, previous)) {\r\n        updatedCount--;\r\n        markRemoval[previousIndex] = 1;\r\n      }\r\n    }\r\n    counts[i] = updatedCount;\r\n    offset += count;\r\n  }\r\n\r\n  var nextAvailableIndex = 0;\r\n  for (var k = 0; k < positionsLength; k++) {\r\n    if (markRemoval[k] !== 1) {\r\n      uBuffer[nextAvailableIndex] = uBuffer[k];\r\n      vBuffer[nextAvailableIndex] = vBuffer[k];\r\n      heightBuffer[nextAvailableIndex] = heightBuffer[k];\r\n      nextAvailableIndex++;\r\n    }\r\n  }\r\n}\r\n\r\nfunction VertexAttributesAndIndices(volumesCount) {\r\n  var vertexCount = volumesCount * 8;\r\n  var vec3Floats = vertexCount * 3;\r\n  var vec4Floats = vertexCount * 4;\r\n  this.startEllipsoidNormals = new Float32Array(vec3Floats);\r\n  this.endEllipsoidNormals = new Float32Array(vec3Floats);\r\n  this.startPositionAndHeights = new Float32Array(vec4Floats);\r\n  this.startFaceNormalAndVertexCornerIds = new Float32Array(vec4Floats);\r\n  this.endPositionAndHeights = new Float32Array(vec4Floats);\r\n  this.endFaceNormalAndHalfWidths = new Float32Array(vec4Floats);\r\n  this.vertexBatchIds = new Uint16Array(vertexCount);\r\n\r\n  this.indices = IndexDatatype.createTypedArray(vertexCount, 36 * volumesCount);\r\n\r\n  this.vec3Offset = 0;\r\n  this.vec4Offset = 0;\r\n  this.batchIdOffset = 0;\r\n  this.indexOffset = 0;\r\n\r\n  this.volumeStartIndex = 0;\r\n}\r\n\r\nvar towardCurrScratch = new Cartesian3();\r\nvar towardNextScratch = new Cartesian3();\r\nfunction computeMiteredNormal(\r\n  previousPosition,\r\n  position,\r\n  nextPosition,\r\n  ellipsoidSurfaceNormal,\r\n  result\r\n) {\r\n  var towardNext = Cartesian3.subtract(\r\n    nextPosition,\r\n    position,\r\n    towardNextScratch\r\n  );\r\n  var towardCurr = Cartesian3.subtract(\r\n    position,\r\n    previousPosition,\r\n    towardCurrScratch\r\n  );\r\n  Cartesian3.normalize(towardNext, towardNext);\r\n  Cartesian3.normalize(towardCurr, towardCurr);\r\n\r\n  if (Cartesian3.dot(towardNext, towardCurr) < MITER_BREAK) {\r\n    towardCurr = Cartesian3.multiplyByScalar(\r\n      towardCurr,\r\n      -1.0,\r\n      towardCurrScratch\r\n    );\r\n  }\r\n\r\n  Cartesian3.add(towardNext, towardCurr, result);\r\n  if (Cartesian3.equals(result, Cartesian3.ZERO)) {\r\n    result = Cartesian3.subtract(previousPosition, position);\r\n  }\r\n\r\n  // Make sure the normal is orthogonal to the ellipsoid surface normal\r\n  Cartesian3.cross(result, ellipsoidSurfaceNormal, result);\r\n  Cartesian3.cross(ellipsoidSurfaceNormal, result, result);\r\n  Cartesian3.normalize(result, result);\r\n  return result;\r\n}\r\n\r\n// Winding order is reversed so each segment's volume is inside-out\r\n//          3-----------7\r\n//         /|   left   /|\r\n//        / | 1       / |\r\n//       2-----------6  5  end\r\n//       | /         | /\r\n// start |/  right   |/\r\n//       0-----------4\r\n//\r\nvar REFERENCE_INDICES = [\r\n  0,\r\n  2,\r\n  6,\r\n  0,\r\n  6,\r\n  4, // right\r\n  0,\r\n  1,\r\n  3,\r\n  0,\r\n  3,\r\n  2, // start face\r\n  0,\r\n  4,\r\n  5,\r\n  0,\r\n  5,\r\n  1, // bottom\r\n  5,\r\n  3,\r\n  1,\r\n  5,\r\n  7,\r\n  3, // left\r\n  7,\r\n  5,\r\n  4,\r\n  7,\r\n  4,\r\n  6, // end face\r\n  7,\r\n  6,\r\n  2,\r\n  7,\r\n  2,\r\n  3, // top\r\n];\r\nvar REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\r\n\r\nvar positionScratch = new Cartesian3();\r\nvar scratchStartEllipsoidNormal = new Cartesian3();\r\nvar scratchStartFaceNormal = new Cartesian3();\r\nvar scratchEndEllipsoidNormal = new Cartesian3();\r\nvar scratchEndFaceNormal = new Cartesian3();\r\nVertexAttributesAndIndices.prototype.addVolume = function (\r\n  preStartRTC,\r\n  startRTC,\r\n  endRTC,\r\n  postEndRTC,\r\n  startHeight,\r\n  endHeight,\r\n  halfWidth,\r\n  batchId,\r\n  center,\r\n  ellipsoid\r\n) {\r\n  var position = Cartesian3.add(startRTC, center, positionScratch);\r\n  var startEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\r\n    position,\r\n    scratchStartEllipsoidNormal\r\n  );\r\n  position = Cartesian3.add(endRTC, center, positionScratch);\r\n  var endEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\r\n    position,\r\n    scratchEndEllipsoidNormal\r\n  );\r\n\r\n  var startFaceNormal = computeMiteredNormal(\r\n    preStartRTC,\r\n    startRTC,\r\n    endRTC,\r\n    startEllipsoidNormal,\r\n    scratchStartFaceNormal\r\n  );\r\n  var endFaceNormal = computeMiteredNormal(\r\n    postEndRTC,\r\n    endRTC,\r\n    startRTC,\r\n    endEllipsoidNormal,\r\n    scratchEndFaceNormal\r\n  );\r\n\r\n  var startEllipsoidNormals = this.startEllipsoidNormals;\r\n  var endEllipsoidNormals = this.endEllipsoidNormals;\r\n  var startPositionAndHeights = this.startPositionAndHeights;\r\n  var startFaceNormalAndVertexCornerIds = this\r\n    .startFaceNormalAndVertexCornerIds;\r\n  var endPositionAndHeights = this.endPositionAndHeights;\r\n  var endFaceNormalAndHalfWidths = this.endFaceNormalAndHalfWidths;\r\n  var vertexBatchIds = this.vertexBatchIds;\r\n\r\n  var batchIdOffset = this.batchIdOffset;\r\n  var vec3Offset = this.vec3Offset;\r\n  var vec4Offset = this.vec4Offset;\r\n\r\n  var i;\r\n  for (i = 0; i < 8; i++) {\r\n    Cartesian3.pack(startEllipsoidNormal, startEllipsoidNormals, vec3Offset);\r\n    Cartesian3.pack(endEllipsoidNormal, endEllipsoidNormals, vec3Offset);\r\n\r\n    Cartesian3.pack(startRTC, startPositionAndHeights, vec4Offset);\r\n    startPositionAndHeights[vec4Offset + 3] = startHeight;\r\n\r\n    Cartesian3.pack(endRTC, endPositionAndHeights, vec4Offset);\r\n    endPositionAndHeights[vec4Offset + 3] = endHeight;\r\n\r\n    Cartesian3.pack(\r\n      startFaceNormal,\r\n      startFaceNormalAndVertexCornerIds,\r\n      vec4Offset\r\n    );\r\n    startFaceNormalAndVertexCornerIds[vec4Offset + 3] = i;\r\n\r\n    Cartesian3.pack(endFaceNormal, endFaceNormalAndHalfWidths, vec4Offset);\r\n    endFaceNormalAndHalfWidths[vec4Offset + 3] = halfWidth;\r\n\r\n    vertexBatchIds[batchIdOffset++] = batchId;\r\n\r\n    vec3Offset += 3;\r\n    vec4Offset += 4;\r\n  }\r\n\r\n  this.batchIdOffset = batchIdOffset;\r\n  this.vec3Offset = vec3Offset;\r\n  this.vec4Offset = vec4Offset;\r\n  var indices = this.indices;\r\n  var volumeStartIndex = this.volumeStartIndex;\r\n\r\n  var indexOffset = this.indexOffset;\r\n  for (i = 0; i < REFERENCE_INDICES_LENGTH; i++) {\r\n    indices[indexOffset + i] = REFERENCE_INDICES[i] + volumeStartIndex;\r\n  }\r\n\r\n  this.volumeStartIndex += 8;\r\n  this.indexOffset += REFERENCE_INDICES_LENGTH;\r\n};\r\n\r\nvar scratchRectangle = new Rectangle();\r\nvar scratchEllipsoid = new Ellipsoid();\r\nvar scratchCenter = new Cartesian3();\r\n\r\nvar scratchPrev = new Cartesian3();\r\nvar scratchP0 = new Cartesian3();\r\nvar scratchP1 = new Cartesian3();\r\nvar scratchNext = new Cartesian3();\r\nfunction createVectorTileClampedPolylines(parameters, transferableObjects) {\r\n  var encodedPositions = new Uint16Array(parameters.positions);\r\n  var widths = new Uint16Array(parameters.widths);\r\n  var counts = new Uint32Array(parameters.counts);\r\n  var batchIds = new Uint16Array(parameters.batchIds);\r\n\r\n  // Unpack tile decoding parameters\r\n  var rectangle = scratchRectangle;\r\n  var ellipsoid = scratchEllipsoid;\r\n  var center = scratchCenter;\r\n  var packedBuffer = new Float64Array(parameters.packedBuffer);\r\n\r\n  var offset = 0;\r\n  var minimumHeight = packedBuffer[offset++];\r\n  var maximumHeight = packedBuffer[offset++];\r\n\r\n  Rectangle.unpack(packedBuffer, offset, rectangle);\r\n  offset += Rectangle.packedLength;\r\n\r\n  Ellipsoid.unpack(packedBuffer, offset, ellipsoid);\r\n  offset += Ellipsoid.packedLength;\r\n\r\n  Cartesian3.unpack(packedBuffer, offset, center);\r\n\r\n  var i;\r\n\r\n  // Unpack positions and generate volumes\r\n  var positionsLength = encodedPositions.length / 3;\r\n  var uBuffer = encodedPositions.subarray(0, positionsLength);\r\n  var vBuffer = encodedPositions.subarray(positionsLength, 2 * positionsLength);\r\n  var heightBuffer = encodedPositions.subarray(\r\n    2 * positionsLength,\r\n    3 * positionsLength\r\n  );\r\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\r\n\r\n  removeDuplicates(uBuffer, vBuffer, heightBuffer, counts);\r\n\r\n  // Figure out how many volumes and how many vertices there will be.\r\n  var countsLength = counts.length;\r\n  var volumesCount = 0;\r\n  for (i = 0; i < countsLength; i++) {\r\n    var polylinePositionCount = counts[i];\r\n    volumesCount += polylinePositionCount - 1;\r\n  }\r\n\r\n  var attribsAndIndices = new VertexAttributesAndIndices(volumesCount);\r\n\r\n  var positions = decodePositions(\r\n    uBuffer,\r\n    vBuffer,\r\n    heightBuffer,\r\n    rectangle,\r\n    minimumHeight,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    center\r\n  );\r\n\r\n  positionsLength = uBuffer.length;\r\n  var positionsRTC = new Float32Array(positionsLength * 3);\r\n  for (i = 0; i < positionsLength; ++i) {\r\n    positionsRTC[i * 3] = positions[i * 3] - center.x;\r\n    positionsRTC[i * 3 + 1] = positions[i * 3 + 1] - center.y;\r\n    positionsRTC[i * 3 + 2] = positions[i * 3 + 2] - center.z;\r\n  }\r\n\r\n  var currentPositionIndex = 0;\r\n  var currentHeightIndex = 0;\r\n  for (i = 0; i < countsLength; i++) {\r\n    var polylineVolumeCount = counts[i] - 1;\r\n    var halfWidth = widths[i] * 0.5;\r\n    var batchId = batchIds[i];\r\n    var volumeFirstPositionIndex = currentPositionIndex;\r\n    for (var j = 0; j < polylineVolumeCount; j++) {\r\n      var volumeStart = Cartesian3.unpack(\r\n        positionsRTC,\r\n        currentPositionIndex,\r\n        scratchP0\r\n      );\r\n      var volumeEnd = Cartesian3.unpack(\r\n        positionsRTC,\r\n        currentPositionIndex + 3,\r\n        scratchP1\r\n      );\r\n\r\n      var startHeight = heightBuffer[currentHeightIndex];\r\n      var endHeight = heightBuffer[currentHeightIndex + 1];\r\n      startHeight = CesiumMath.lerp(\r\n        minimumHeight,\r\n        maximumHeight,\r\n        startHeight / MAX_SHORT\r\n      );\r\n      endHeight = CesiumMath.lerp(\r\n        minimumHeight,\r\n        maximumHeight,\r\n        endHeight / MAX_SHORT\r\n      );\r\n\r\n      currentHeightIndex++;\r\n\r\n      var preStart = scratchPrev;\r\n      var postEnd = scratchNext;\r\n      if (j === 0) {\r\n        // Check if this volume is like a loop\r\n        var finalPositionIndex =\r\n          volumeFirstPositionIndex + polylineVolumeCount * 3;\r\n        var finalPosition = Cartesian3.unpack(\r\n          positionsRTC,\r\n          finalPositionIndex,\r\n          scratchPrev\r\n        );\r\n        if (Cartesian3.equals(finalPosition, volumeStart)) {\r\n          Cartesian3.unpack(positionsRTC, finalPositionIndex - 3, preStart);\r\n        } else {\r\n          var offsetPastStart = Cartesian3.subtract(\r\n            volumeStart,\r\n            volumeEnd,\r\n            scratchPrev\r\n          );\r\n          preStart = Cartesian3.add(offsetPastStart, volumeStart, scratchPrev);\r\n        }\r\n      } else {\r\n        Cartesian3.unpack(positionsRTC, currentPositionIndex - 3, preStart);\r\n      }\r\n\r\n      if (j === polylineVolumeCount - 1) {\r\n        // Check if this volume is like a loop\r\n        var firstPosition = Cartesian3.unpack(\r\n          positionsRTC,\r\n          volumeFirstPositionIndex,\r\n          scratchNext\r\n        );\r\n        if (Cartesian3.equals(firstPosition, volumeEnd)) {\r\n          Cartesian3.unpack(\r\n            positionsRTC,\r\n            volumeFirstPositionIndex + 3,\r\n            postEnd\r\n          );\r\n        } else {\r\n          var offsetPastEnd = Cartesian3.subtract(\r\n            volumeEnd,\r\n            volumeStart,\r\n            scratchNext\r\n          );\r\n          postEnd = Cartesian3.add(offsetPastEnd, volumeEnd, scratchNext);\r\n        }\r\n      } else {\r\n        Cartesian3.unpack(positionsRTC, currentPositionIndex + 6, postEnd);\r\n      }\r\n\r\n      attribsAndIndices.addVolume(\r\n        preStart,\r\n        volumeStart,\r\n        volumeEnd,\r\n        postEnd,\r\n        startHeight,\r\n        endHeight,\r\n        halfWidth,\r\n        batchId,\r\n        center,\r\n        ellipsoid\r\n      );\r\n\r\n      currentPositionIndex += 3;\r\n    }\r\n    currentPositionIndex += 3;\r\n    currentHeightIndex++;\r\n  }\r\n\r\n  var indices = attribsAndIndices.indices;\r\n\r\n  transferableObjects.push(attribsAndIndices.startEllipsoidNormals.buffer);\r\n  transferableObjects.push(attribsAndIndices.endEllipsoidNormals.buffer);\r\n  transferableObjects.push(attribsAndIndices.startPositionAndHeights.buffer);\r\n  transferableObjects.push(\r\n    attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer\r\n  );\r\n  transferableObjects.push(attribsAndIndices.endPositionAndHeights.buffer);\r\n  transferableObjects.push(attribsAndIndices.endFaceNormalAndHalfWidths.buffer);\r\n  transferableObjects.push(attribsAndIndices.vertexBatchIds.buffer);\r\n  transferableObjects.push(indices.buffer);\r\n\r\n  var results = {\r\n    indexDatatype:\r\n      indices.BYTES_PER_ELEMENT === 2\r\n        ? IndexDatatype.UNSIGNED_SHORT\r\n        : IndexDatatype.UNSIGNED_INT,\r\n    startEllipsoidNormals: attribsAndIndices.startEllipsoidNormals.buffer,\r\n    endEllipsoidNormals: attribsAndIndices.endEllipsoidNormals.buffer,\r\n    startPositionAndHeights: attribsAndIndices.startPositionAndHeights.buffer,\r\n    startFaceNormalAndVertexCornerIds:\r\n      attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer,\r\n    endPositionAndHeights: attribsAndIndices.endPositionAndHeights.buffer,\r\n    endFaceNormalAndHalfWidths:\r\n      attribsAndIndices.endFaceNormalAndHalfWidths.buffer,\r\n    vertexBatchIds: attribsAndIndices.vertexBatchIds.buffer,\r\n    indices: indices.buffer,\r\n  };\r\n\r\n  if (parameters.keepDecodedPositions) {\r\n    var positionOffsets = getPositionOffsets(counts);\r\n    transferableObjects.push(positions.buffer, positionOffsets.buffer);\r\n    results = combine(results, {\r\n      decodedPositions: positions.buffer,\r\n      decodedPositionOffsets: positionOffsets.buffer,\r\n    });\r\n  }\r\n\r\n  return results;\r\n}\r\nexport default createTaskProcessorWorker(createVectorTileClampedPolylines);\r\n"],"names":["MAX_SHORT","MITER_BREAK","Math","cos","CesiumMath","toRadians","scratchBVCartographic","Cartographic","scratchEncodedPosition","Cartesian3","previousCompressedCartographicScratch","currentCompressedCartographicScratch","VertexAttributesAndIndices","volumesCount","vertexCount","vec3Floats","vec4Floats","this","startEllipsoidNormals","Float32Array","endEllipsoidNormals","startPositionAndHeights","startFaceNormalAndVertexCornerIds","endPositionAndHeights","endFaceNormalAndHalfWidths","vertexBatchIds","Uint16Array","indices","IndexDatatype","createTypedArray","vec3Offset","vec4Offset","batchIdOffset","indexOffset","volumeStartIndex","towardCurrScratch","towardNextScratch","computeMiteredNormal","previousPosition","position","nextPosition","ellipsoidSurfaceNormal","result","towardNext","subtract","towardCurr","normalize","dot","multiplyByScalar","add","equals","ZERO","cross","REFERENCE_INDICES","REFERENCE_INDICES_LENGTH","length","positionScratch","scratchStartEllipsoidNormal","scratchStartFaceNormal","scratchEndEllipsoidNormal","scratchEndFaceNormal","prototype","addVolume","preStartRTC","startRTC","endRTC","postEndRTC","startHeight","endHeight","halfWidth","batchId","center","ellipsoid","startEllipsoidNormal","geodeticSurfaceNormal","i","endEllipsoidNormal","startFaceNormal","endFaceNormal","pack","scratchRectangle","Rectangle","scratchEllipsoid","Ellipsoid","scratchCenter","scratchPrev","scratchP0","scratchP1","scratchNext","createTaskProcessorWorker","parameters","transferableObjects","encodedPositions","positions","widths","counts","Uint32Array","batchIds","rectangle","packedBuffer","Float64Array","offset","minimumHeight","maximumHeight","unpack","packedLength","positionsLength","uBuffer","subarray","vBuffer","heightBuffer","AttributeCompression","zigZagDeltaDecode","countsLength","markRemoval","Uint8Array","previous","current","count","updatedCount","j","index","previousIndex","longitude","latitude","nextAvailableIndex","k","removeDuplicates","attribsAndIndices","decodedPositions","u","v","h","lon","lerp","west","east","lat","south","north","alt","cartographic","fromRadians","decodedPosition","cartographicToCartesian","decodePositions","positionsRTC","x","y","z","currentPositionIndex","currentHeightIndex","polylineVolumeCount","volumeFirstPositionIndex","volumeStart","volumeEnd","preStart","postEnd","finalPositionIndex","finalPosition","offsetPastStart","firstPosition","offsetPastEnd","push","buffer","results","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","keepDecodedPositions","positionOffsets","getPositionOffsets","combine","decodedPositionOffsets"],"mappings":"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"}