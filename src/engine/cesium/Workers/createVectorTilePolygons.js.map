{"version":3,"file":"createVectorTilePolygons.js","sources":["../../../../Source/WorkersES6/createVectorTilePolygons.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Cartographic from \"../Core/Cartographic.js\";\r\nimport Color from \"../Core/Color.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport CesiumMath from \"../Core/Math.js\";\r\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nvar scratchCenter = new Cartesian3();\r\nvar scratchEllipsoid = new Ellipsoid();\r\nvar scratchRectangle = new Rectangle();\r\nvar scratchScalars = {\r\n  min: undefined,\r\n  max: undefined,\r\n  indexBytesPerElement: undefined,\r\n};\r\n\r\nfunction unpackBuffer(buffer) {\r\n  var packedBuffer = new Float64Array(buffer);\r\n\r\n  var offset = 0;\r\n  scratchScalars.indexBytesPerElement = packedBuffer[offset++];\r\n\r\n  scratchScalars.min = packedBuffer[offset++];\r\n  scratchScalars.max = packedBuffer[offset++];\r\n\r\n  Cartesian3.unpack(packedBuffer, offset, scratchCenter);\r\n  offset += Cartesian3.packedLength;\r\n\r\n  Ellipsoid.unpack(packedBuffer, offset, scratchEllipsoid);\r\n  offset += Ellipsoid.packedLength;\r\n\r\n  Rectangle.unpack(packedBuffer, offset, scratchRectangle);\r\n}\r\n\r\nfunction packedBatchedIndicesLength(batchedIndices) {\r\n  var length = batchedIndices.length;\r\n  var count = 0;\r\n  for (var i = 0; i < length; ++i) {\r\n    count += Color.packedLength + 3 + batchedIndices[i].batchIds.length;\r\n  }\r\n  return count;\r\n}\r\n\r\nfunction packBuffer(indexDatatype, boundingVolumes, batchedIndices) {\r\n  var numBVs = boundingVolumes.length;\r\n  var length =\r\n    1 +\r\n    1 +\r\n    numBVs * OrientedBoundingBox.packedLength +\r\n    1 +\r\n    packedBatchedIndicesLength(batchedIndices);\r\n\r\n  var packedBuffer = new Float64Array(length);\r\n\r\n  var offset = 0;\r\n  packedBuffer[offset++] = indexDatatype;\r\n  packedBuffer[offset++] = numBVs;\r\n\r\n  for (var i = 0; i < numBVs; ++i) {\r\n    OrientedBoundingBox.pack(boundingVolumes[i], packedBuffer, offset);\r\n    offset += OrientedBoundingBox.packedLength;\r\n  }\r\n\r\n  var indicesLength = batchedIndices.length;\r\n  packedBuffer[offset++] = indicesLength;\r\n\r\n  for (var j = 0; j < indicesLength; ++j) {\r\n    var batchedIndex = batchedIndices[j];\r\n\r\n    Color.pack(batchedIndex.color, packedBuffer, offset);\r\n    offset += Color.packedLength;\r\n\r\n    packedBuffer[offset++] = batchedIndex.offset;\r\n    packedBuffer[offset++] = batchedIndex.count;\r\n\r\n    var batchIds = batchedIndex.batchIds;\r\n    var batchIdsLength = batchIds.length;\r\n    packedBuffer[offset++] = batchIdsLength;\r\n\r\n    for (var k = 0; k < batchIdsLength; ++k) {\r\n      packedBuffer[offset++] = batchIds[k];\r\n    }\r\n  }\r\n\r\n  return packedBuffer;\r\n}\r\n\r\nvar maxShort = 32767;\r\n\r\nvar scratchEncodedPosition = new Cartesian3();\r\nvar scratchNormal = new Cartesian3();\r\nvar scratchScaledNormal = new Cartesian3();\r\nvar scratchMinHeightPosition = new Cartesian3();\r\nvar scratchMaxHeightPosition = new Cartesian3();\r\nvar scratchBVCartographic = new Cartographic();\r\nvar scratchBVRectangle = new Rectangle();\r\n\r\nfunction createVectorTilePolygons(parameters, transferableObjects) {\r\n  unpackBuffer(parameters.packedBuffer);\r\n\r\n  var indices;\r\n  var indexBytesPerElement = scratchScalars.indexBytesPerElement;\r\n  if (indexBytesPerElement === 2) {\r\n    indices = new Uint16Array(parameters.indices);\r\n  } else {\r\n    indices = new Uint32Array(parameters.indices);\r\n  }\r\n\r\n  var positions = new Uint16Array(parameters.positions);\r\n  var counts = new Uint32Array(parameters.counts);\r\n  var indexCounts = new Uint32Array(parameters.indexCounts);\r\n  var batchIds = new Uint32Array(parameters.batchIds);\r\n  var batchTableColors = new Uint32Array(parameters.batchTableColors);\r\n\r\n  var boundingVolumes = new Array(counts.length);\r\n\r\n  var center = scratchCenter;\r\n  var ellipsoid = scratchEllipsoid;\r\n  var rectangle = scratchRectangle;\r\n  var minHeight = scratchScalars.min;\r\n  var maxHeight = scratchScalars.max;\r\n\r\n  var minimumHeights = parameters.minimumHeights;\r\n  var maximumHeights = parameters.maximumHeights;\r\n  if (defined(minimumHeights) && defined(maximumHeights)) {\r\n    minimumHeights = new Float32Array(minimumHeights);\r\n    maximumHeights = new Float32Array(maximumHeights);\r\n  }\r\n\r\n  var i;\r\n  var j;\r\n  var rgba;\r\n\r\n  var positionsLength = positions.length / 2;\r\n  var uBuffer = positions.subarray(0, positionsLength);\r\n  var vBuffer = positions.subarray(positionsLength, 2 * positionsLength);\r\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer);\r\n\r\n  var decodedPositions = new Float64Array(positionsLength * 3);\r\n  for (i = 0; i < positionsLength; ++i) {\r\n    var u = uBuffer[i];\r\n    var v = vBuffer[i];\r\n\r\n    var x = CesiumMath.lerp(rectangle.west, rectangle.east, u / maxShort);\r\n    var y = CesiumMath.lerp(rectangle.south, rectangle.north, v / maxShort);\r\n\r\n    var cart = Cartographic.fromRadians(x, y, 0.0, scratchBVCartographic);\r\n    var decodedPosition = ellipsoid.cartographicToCartesian(\r\n      cart,\r\n      scratchEncodedPosition\r\n    );\r\n    Cartesian3.pack(decodedPosition, decodedPositions, i * 3);\r\n  }\r\n\r\n  var countsLength = counts.length;\r\n  var offsets = new Array(countsLength);\r\n  var indexOffsets = new Array(countsLength);\r\n  var currentOffset = 0;\r\n  var currentIndexOffset = 0;\r\n  for (i = 0; i < countsLength; ++i) {\r\n    offsets[i] = currentOffset;\r\n    indexOffsets[i] = currentIndexOffset;\r\n\r\n    currentOffset += counts[i];\r\n    currentIndexOffset += indexCounts[i];\r\n  }\r\n\r\n  var batchedPositions = new Float32Array(positionsLength * 3 * 2);\r\n  var batchedIds = new Uint16Array(positionsLength * 2);\r\n  var batchedIndexOffsets = new Uint32Array(indexOffsets.length);\r\n  var batchedIndexCounts = new Uint32Array(indexCounts.length);\r\n  var batchedIndices = [];\r\n\r\n  var colorToBuffers = {};\r\n  for (i = 0; i < countsLength; ++i) {\r\n    rgba = batchTableColors[i];\r\n    if (!defined(colorToBuffers[rgba])) {\r\n      colorToBuffers[rgba] = {\r\n        positionLength: counts[i],\r\n        indexLength: indexCounts[i],\r\n        offset: 0,\r\n        indexOffset: 0,\r\n        batchIds: [i],\r\n      };\r\n    } else {\r\n      colorToBuffers[rgba].positionLength += counts[i];\r\n      colorToBuffers[rgba].indexLength += indexCounts[i];\r\n      colorToBuffers[rgba].batchIds.push(i);\r\n    }\r\n  }\r\n\r\n  // get the offsets and counts for the positions and indices of each primitive\r\n  var buffer;\r\n  var byColorPositionOffset = 0;\r\n  var byColorIndexOffset = 0;\r\n  for (rgba in colorToBuffers) {\r\n    if (colorToBuffers.hasOwnProperty(rgba)) {\r\n      buffer = colorToBuffers[rgba];\r\n      buffer.offset = byColorPositionOffset;\r\n      buffer.indexOffset = byColorIndexOffset;\r\n\r\n      var positionLength = buffer.positionLength * 2;\r\n      var indexLength = buffer.indexLength * 2 + buffer.positionLength * 6;\r\n\r\n      byColorPositionOffset += positionLength;\r\n      byColorIndexOffset += indexLength;\r\n\r\n      buffer.indexLength = indexLength;\r\n    }\r\n  }\r\n\r\n  var batchedDrawCalls = [];\r\n\r\n  for (rgba in colorToBuffers) {\r\n    if (colorToBuffers.hasOwnProperty(rgba)) {\r\n      buffer = colorToBuffers[rgba];\r\n\r\n      batchedDrawCalls.push({\r\n        color: Color.fromRgba(parseInt(rgba)),\r\n        offset: buffer.indexOffset,\r\n        count: buffer.indexLength,\r\n        batchIds: buffer.batchIds,\r\n      });\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < countsLength; ++i) {\r\n    rgba = batchTableColors[i];\r\n\r\n    buffer = colorToBuffers[rgba];\r\n    var positionOffset = buffer.offset;\r\n    var positionIndex = positionOffset * 3;\r\n    var batchIdIndex = positionOffset;\r\n\r\n    var polygonOffset = offsets[i];\r\n    var polygonCount = counts[i];\r\n    var batchId = batchIds[i];\r\n\r\n    var polygonMinimumHeight = minHeight;\r\n    var polygonMaximumHeight = maxHeight;\r\n    if (defined(minimumHeights) && defined(maximumHeights)) {\r\n      polygonMinimumHeight = minimumHeights[i];\r\n      polygonMaximumHeight = maximumHeights[i];\r\n    }\r\n\r\n    var minLat = Number.POSITIVE_INFINITY;\r\n    var maxLat = Number.NEGATIVE_INFINITY;\r\n    var minLon = Number.POSITIVE_INFINITY;\r\n    var maxLon = Number.NEGATIVE_INFINITY;\r\n\r\n    for (j = 0; j < polygonCount; ++j) {\r\n      var position = Cartesian3.unpack(\r\n        decodedPositions,\r\n        polygonOffset * 3 + j * 3,\r\n        scratchEncodedPosition\r\n      );\r\n      ellipsoid.scaleToGeodeticSurface(position, position);\r\n\r\n      var carto = ellipsoid.cartesianToCartographic(\r\n        position,\r\n        scratchBVCartographic\r\n      );\r\n      var lat = carto.latitude;\r\n      var lon = carto.longitude;\r\n\r\n      minLat = Math.min(lat, minLat);\r\n      maxLat = Math.max(lat, maxLat);\r\n      minLon = Math.min(lon, minLon);\r\n      maxLon = Math.max(lon, maxLon);\r\n\r\n      var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\r\n      var scaledNormal = Cartesian3.multiplyByScalar(\r\n        normal,\r\n        polygonMinimumHeight,\r\n        scratchScaledNormal\r\n      );\r\n      var minHeightPosition = Cartesian3.add(\r\n        position,\r\n        scaledNormal,\r\n        scratchMinHeightPosition\r\n      );\r\n\r\n      scaledNormal = Cartesian3.multiplyByScalar(\r\n        normal,\r\n        polygonMaximumHeight,\r\n        scaledNormal\r\n      );\r\n      var maxHeightPosition = Cartesian3.add(\r\n        position,\r\n        scaledNormal,\r\n        scratchMaxHeightPosition\r\n      );\r\n\r\n      Cartesian3.subtract(maxHeightPosition, center, maxHeightPosition);\r\n      Cartesian3.subtract(minHeightPosition, center, minHeightPosition);\r\n\r\n      Cartesian3.pack(maxHeightPosition, batchedPositions, positionIndex);\r\n      Cartesian3.pack(minHeightPosition, batchedPositions, positionIndex + 3);\r\n\r\n      batchedIds[batchIdIndex] = batchId;\r\n      batchedIds[batchIdIndex + 1] = batchId;\r\n\r\n      positionIndex += 6;\r\n      batchIdIndex += 2;\r\n    }\r\n\r\n    rectangle = scratchBVRectangle;\r\n    rectangle.west = minLon;\r\n    rectangle.east = maxLon;\r\n    rectangle.south = minLat;\r\n    rectangle.north = maxLat;\r\n\r\n    boundingVolumes[i] = OrientedBoundingBox.fromRectangle(\r\n      rectangle,\r\n      minHeight,\r\n      maxHeight,\r\n      ellipsoid\r\n    );\r\n\r\n    var indicesIndex = buffer.indexOffset;\r\n\r\n    var indexOffset = indexOffsets[i];\r\n    var indexCount = indexCounts[i];\r\n\r\n    batchedIndexOffsets[i] = indicesIndex;\r\n\r\n    for (j = 0; j < indexCount; j += 3) {\r\n      var i0 = indices[indexOffset + j] - polygonOffset;\r\n      var i1 = indices[indexOffset + j + 1] - polygonOffset;\r\n      var i2 = indices[indexOffset + j + 2] - polygonOffset;\r\n\r\n      // triangle on the top of the extruded polygon\r\n      batchedIndices[indicesIndex++] = i0 * 2 + positionOffset;\r\n      batchedIndices[indicesIndex++] = i1 * 2 + positionOffset;\r\n      batchedIndices[indicesIndex++] = i2 * 2 + positionOffset;\r\n\r\n      // triangle on the bottom of the extruded polygon\r\n      batchedIndices[indicesIndex++] = i2 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = i1 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = i0 * 2 + 1 + positionOffset;\r\n    }\r\n\r\n    // indices for the walls of the extruded polygon\r\n    for (j = 0; j < polygonCount; ++j) {\r\n      var v0 = j;\r\n      var v1 = (j + 1) % polygonCount;\r\n\r\n      batchedIndices[indicesIndex++] = v0 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = v1 * 2 + positionOffset;\r\n      batchedIndices[indicesIndex++] = v0 * 2 + positionOffset;\r\n\r\n      batchedIndices[indicesIndex++] = v0 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = v1 * 2 + 1 + positionOffset;\r\n      batchedIndices[indicesIndex++] = v1 * 2 + positionOffset;\r\n    }\r\n\r\n    buffer.offset += polygonCount * 2;\r\n    buffer.indexOffset = indicesIndex;\r\n\r\n    batchedIndexCounts[i] = indicesIndex - batchedIndexOffsets[i];\r\n  }\r\n\r\n  batchedIndices = IndexDatatype.createTypedArray(\r\n    batchedPositions.length / 3,\r\n    batchedIndices\r\n  );\r\n\r\n  var batchedIndicesLength = batchedDrawCalls.length;\r\n  for (var m = 0; m < batchedIndicesLength; ++m) {\r\n    var tempIds = batchedDrawCalls[m].batchIds;\r\n    var count = 0;\r\n    var tempIdsLength = tempIds.length;\r\n    for (var n = 0; n < tempIdsLength; ++n) {\r\n      count += batchedIndexCounts[tempIds[n]];\r\n    }\r\n    batchedDrawCalls[m].count = count;\r\n  }\r\n\r\n  var indexDatatype =\r\n    batchedIndices.BYTES_PER_ELEMENT === 2\r\n      ? IndexDatatype.UNSIGNED_SHORT\r\n      : IndexDatatype.UNSIGNED_INT;\r\n  var packedBuffer = packBuffer(\r\n    indexDatatype,\r\n    boundingVolumes,\r\n    batchedDrawCalls\r\n  );\r\n\r\n  transferableObjects.push(\r\n    batchedPositions.buffer,\r\n    batchedIndices.buffer,\r\n    batchedIndexOffsets.buffer,\r\n    batchedIndexCounts.buffer,\r\n    batchedIds.buffer,\r\n    packedBuffer.buffer\r\n  );\r\n\r\n  return {\r\n    positions: batchedPositions.buffer,\r\n    indices: batchedIndices.buffer,\r\n    indexOffsets: batchedIndexOffsets.buffer,\r\n    indexCounts: batchedIndexCounts.buffer,\r\n    batchIds: batchedIds.buffer,\r\n    packedBuffer: packedBuffer.buffer,\r\n  };\r\n}\r\nexport default createTaskProcessorWorker(createVectorTilePolygons);\r\n"],"names":["scratchCenter","Cartesian3","scratchEllipsoid","Ellipsoid","scratchRectangle","Rectangle","scratchScalars","min","undefined","max","indexBytesPerElement","packBuffer","indexDatatype","boundingVolumes","batchedIndices","numBVs","length","OrientedBoundingBox","packedLength","count","i","Color","batchIds","packedBatchedIndicesLength","packedBuffer","Float64Array","offset","pack","indicesLength","j","batchedIndex","color","batchIdsLength","k","scratchEncodedPosition","scratchNormal","scratchScaledNormal","scratchMinHeightPosition","scratchMaxHeightPosition","scratchBVCartographic","Cartographic","scratchBVRectangle","createTaskProcessorWorker","parameters","transferableObjects","indices","buffer","unpack","unpackBuffer","Uint16Array","Uint32Array","rgba","positions","counts","indexCounts","batchTableColors","Array","center","ellipsoid","rectangle","minHeight","maxHeight","minimumHeights","maximumHeights","defined","Float32Array","positionsLength","uBuffer","subarray","vBuffer","AttributeCompression","zigZagDeltaDecode","decodedPositions","u","v","x","CesiumMath","lerp","west","east","y","south","north","cart","fromRadians","decodedPosition","cartographicToCartesian","countsLength","offsets","indexOffsets","currentOffset","currentIndexOffset","batchedPositions","batchedIds","batchedIndexOffsets","batchedIndexCounts","colorToBuffers","positionLength","indexLength","push","indexOffset","byColorPositionOffset","byColorIndexOffset","hasOwnProperty","batchedDrawCalls","fromRgba","parseInt","positionOffset","positionIndex","batchIdIndex","polygonOffset","polygonCount","batchId","polygonMinimumHeight","polygonMaximumHeight","minLat","Number","POSITIVE_INFINITY","maxLat","NEGATIVE_INFINITY","minLon","maxLon","position","scaleToGeodeticSurface","carto","cartesianToCartographic","lat","latitude","lon","longitude","Math","normal","geodeticSurfaceNormal","scaledNormal","multiplyByScalar","minHeightPosition","add","maxHeightPosition","subtract","fromRectangle","indicesIndex","indexCount","i0","i1","i2","v0","v1","IndexDatatype","createTypedArray","batchedIndicesLength","m","tempIds","tempIdsLength","n","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT"],"mappings":"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"}