{"version":3,"file":"FrustumGeometry-95793a9f.js","sources":["../../../../Source/Core/CullingVolume.js","../../../../Source/Core/OrthographicOffCenterFrustum.js","../../../../Source/Core/OrthographicFrustum.js","../../../../Source/Core/PerspectiveOffCenterFrustum.js","../../../../Source/Core/PerspectiveFrustum.js","../../../../Source/Core/FrustumGeometry.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Intersect from \"./Intersect.js\";\r\nimport Plane from \"./Plane.js\";\r\n\r\n/**\r\n * The culling volume defined by planes.\r\n *\r\n * @alias CullingVolume\r\n * @constructor\r\n *\r\n * @param {Cartesian4[]} [planes] An array of clipping planes.\r\n */\r\nfunction CullingVolume(planes) {\r\n  /**\r\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\r\n   * define the unit vector normal to the plane, and the w component is the distance of the\r\n   * plane from the origin.\r\n   * @type {Cartesian4[]}\r\n   * @default []\r\n   */\r\n  this.planes = defaultValue(planes, []);\r\n}\r\n\r\nvar faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\r\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\r\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\r\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\r\n\r\nvar scratchPlaneCenter = new Cartesian3();\r\nvar scratchPlaneNormal = new Cartesian3();\r\nvar scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\r\n\r\n/**\r\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\r\n * The planes are aligned to the x, y, and z axes in world coordinates.\r\n *\r\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\r\n * @param {CullingVolume} [result] The object onto which to store the result.\r\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\r\n */\r\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(boundingSphere)) {\r\n    throw new DeveloperError(\"boundingSphere is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new CullingVolume();\r\n  }\r\n\r\n  var length = faces.length;\r\n  var planes = result.planes;\r\n  planes.length = 2 * length;\r\n\r\n  var center = boundingSphere.center;\r\n  var radius = boundingSphere.radius;\r\n\r\n  var planeIndex = 0;\r\n\r\n  for (var i = 0; i < length; ++i) {\r\n    var faceNormal = faces[i];\r\n\r\n    var plane0 = planes[planeIndex];\r\n    var plane1 = planes[planeIndex + 1];\r\n\r\n    if (!defined(plane0)) {\r\n      plane0 = planes[planeIndex] = new Cartesian4();\r\n    }\r\n    if (!defined(plane1)) {\r\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\r\n    }\r\n\r\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\r\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\r\n\r\n    plane0.x = faceNormal.x;\r\n    plane0.y = faceNormal.y;\r\n    plane0.z = faceNormal.z;\r\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\r\n\r\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\r\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\r\n\r\n    plane1.x = -faceNormal.x;\r\n    plane1.y = -faceNormal.y;\r\n    plane1.z = -faceNormal.z;\r\n    plane1.w = -Cartesian3.dot(\r\n      Cartesian3.negate(faceNormal, scratchPlaneNormal),\r\n      scratchPlaneCenter\r\n    );\r\n\r\n    planeIndex += 2;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Determines whether a bounding volume intersects the culling volume.\r\n *\r\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\r\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\r\n */\r\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(boundingVolume)) {\r\n    throw new DeveloperError(\"boundingVolume is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var planes = this.planes;\r\n  var intersecting = false;\r\n  for (var k = 0, len = planes.length; k < len; ++k) {\r\n    var result = boundingVolume.intersectPlane(\r\n      Plane.fromCartesian4(planes[k], scratchPlane)\r\n    );\r\n    if (result === Intersect.OUTSIDE) {\r\n      return Intersect.OUTSIDE;\r\n    } else if (result === Intersect.INTERSECTING) {\r\n      intersecting = true;\r\n    }\r\n  }\r\n\r\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\r\n};\r\n\r\n/**\r\n * Determines whether a bounding volume intersects the culling volume.\r\n *\r\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\r\n * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\r\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\r\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\r\n *                                 and that plane check can be skipped.\r\n * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).\r\n *\r\n * @private\r\n */\r\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (\r\n  boundingVolume,\r\n  parentPlaneMask\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(boundingVolume)) {\r\n    throw new DeveloperError(\"boundingVolume is required.\");\r\n  }\r\n  if (!defined(parentPlaneMask)) {\r\n    throw new DeveloperError(\"parentPlaneMask is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (\r\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\r\n    parentPlaneMask === CullingVolume.MASK_INSIDE\r\n  ) {\r\n    // parent is completely outside or completely inside, so this child is as well.\r\n    return parentPlaneMask;\r\n  }\r\n\r\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\r\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\r\n  var mask = CullingVolume.MASK_INSIDE;\r\n\r\n  var planes = this.planes;\r\n  for (var k = 0, len = planes.length; k < len; ++k) {\r\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\r\n    var flag = k < 31 ? 1 << k : 0;\r\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\r\n      // boundingVolume is known to be INSIDE this plane.\r\n      continue;\r\n    }\r\n\r\n    var result = boundingVolume.intersectPlane(\r\n      Plane.fromCartesian4(planes[k], scratchPlane)\r\n    );\r\n    if (result === Intersect.OUTSIDE) {\r\n      return CullingVolume.MASK_OUTSIDE;\r\n    } else if (result === Intersect.INTERSECTING) {\r\n      mask |= flag;\r\n    }\r\n  }\r\n\r\n  return mask;\r\n};\r\n\r\n/**\r\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\r\n * represents the case where the object bounding volume is entirely outside the culling volume.\r\n *\r\n * @type {Number}\r\n * @private\r\n */\r\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\r\n\r\n/**\r\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\r\n * represents the case where the object bounding volume is entirely inside the culling volume.\r\n *\r\n * @type {Number}\r\n * @private\r\n */\r\nCullingVolume.MASK_INSIDE = 0x00000000;\r\n\r\n/**\r\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\r\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\r\n *\r\n * @type {Number}\r\n * @private\r\n */\r\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\r\nexport default CullingVolume;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport CullingVolume from \"./CullingVolume.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\n\r\n/**\r\n * The viewing frustum is defined by 6 planes.\r\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n * define the unit vector normal to the plane, and the w component is the distance of the\r\n * plane from the origin/camera position.\r\n *\r\n * @alias OrthographicOffCenterFrustum\r\n * @constructor\r\n *\r\n * @param {Object} [options] An object with the following properties:\r\n * @param {Number} [options.left] The left clipping plane distance.\r\n * @param {Number} [options.right] The right clipping plane distance.\r\n * @param {Number} [options.top] The top clipping plane distance.\r\n * @param {Number} [options.bottom] The bottom clipping plane distance.\r\n * @param {Number} [options.near=1.0] The near clipping plane distance.\r\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\r\n *\r\n * @example\r\n * var maxRadii = ellipsoid.maximumRadius;\r\n *\r\n * var frustum = new Cesium.OrthographicOffCenterFrustum();\r\n * frustum.right = maxRadii * Cesium.Math.PI;\r\n * frustum.left = -c.frustum.right;\r\n * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\r\n * frustum.bottom = -c.frustum.top;\r\n * frustum.near = 0.01 * maxRadii;\r\n * frustum.far = 50.0 * maxRadii;\r\n */\r\nfunction OrthographicOffCenterFrustum(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  /**\r\n   * The left clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.left = options.left;\r\n  this._left = undefined;\r\n\r\n  /**\r\n   * The right clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.right = options.right;\r\n  this._right = undefined;\r\n\r\n  /**\r\n   * The top clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.top = options.top;\r\n  this._top = undefined;\r\n\r\n  /**\r\n   * The bottom clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.bottom = options.bottom;\r\n  this._bottom = undefined;\r\n\r\n  /**\r\n   * The distance of the near plane.\r\n   * @type {Number}\r\n   * @default 1.0\r\n   */\r\n  this.near = defaultValue(options.near, 1.0);\r\n  this._near = this.near;\r\n\r\n  /**\r\n   * The distance of the far plane.\r\n   * @type {Number}\r\n   * @default 500000000.0;\r\n   */\r\n  this.far = defaultValue(options.far, 500000000.0);\r\n  this._far = this.far;\r\n\r\n  this._cullingVolume = new CullingVolume();\r\n  this._orthographicMatrix = new Matrix4();\r\n}\r\n\r\nfunction update(frustum) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(frustum.right) ||\r\n    !defined(frustum.left) ||\r\n    !defined(frustum.top) ||\r\n    !defined(frustum.bottom) ||\r\n    !defined(frustum.near) ||\r\n    !defined(frustum.far)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"right, left, top, bottom, near, or far parameters are not set.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (\r\n    frustum.top !== frustum._top ||\r\n    frustum.bottom !== frustum._bottom ||\r\n    frustum.left !== frustum._left ||\r\n    frustum.right !== frustum._right ||\r\n    frustum.near !== frustum._near ||\r\n    frustum.far !== frustum._far\r\n  ) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (frustum.left > frustum.right) {\r\n      throw new DeveloperError(\"right must be greater than left.\");\r\n    }\r\n    if (frustum.bottom > frustum.top) {\r\n      throw new DeveloperError(\"top must be greater than bottom.\");\r\n    }\r\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\r\n      throw new DeveloperError(\r\n        \"near must be greater than zero and less than far.\"\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    frustum._left = frustum.left;\r\n    frustum._right = frustum.right;\r\n    frustum._top = frustum.top;\r\n    frustum._bottom = frustum.bottom;\r\n    frustum._near = frustum.near;\r\n    frustum._far = frustum.far;\r\n    frustum._orthographicMatrix = Matrix4.computeOrthographicOffCenter(\r\n      frustum.left,\r\n      frustum.right,\r\n      frustum.bottom,\r\n      frustum.top,\r\n      frustum.near,\r\n      frustum.far,\r\n      frustum._orthographicMatrix\r\n    );\r\n  }\r\n}\r\n\r\nObject.defineProperties(OrthographicOffCenterFrustum.prototype, {\r\n  /**\r\n   * Gets the orthographic projection matrix computed from the view frustum.\r\n   * @memberof OrthographicOffCenterFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   */\r\n  projectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._orthographicMatrix;\r\n    },\r\n  },\r\n});\r\n\r\nvar getPlanesRight = new Cartesian3();\r\nvar getPlanesNearCenter = new Cartesian3();\r\nvar getPlanesPoint = new Cartesian3();\r\nvar negateScratch = new Cartesian3();\r\n\r\n/**\r\n * Creates a culling volume for this frustum.\r\n *\r\n * @param {Cartesian3} position The eye position.\r\n * @param {Cartesian3} direction The view direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n *\r\n * @example\r\n * // Check if a bounding volume intersects the frustum.\r\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\r\n */\r\nOrthographicOffCenterFrustum.prototype.computeCullingVolume = function (\r\n  position,\r\n  direction,\r\n  up\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(position)) {\r\n    throw new DeveloperError(\"position is required.\");\r\n  }\r\n  if (!defined(direction)) {\r\n    throw new DeveloperError(\"direction is required.\");\r\n  }\r\n  if (!defined(up)) {\r\n    throw new DeveloperError(\"up is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var planes = this._cullingVolume.planes;\r\n  var t = this.top;\r\n  var b = this.bottom;\r\n  var r = this.right;\r\n  var l = this.left;\r\n  var n = this.near;\r\n  var f = this.far;\r\n\r\n  var right = Cartesian3.cross(direction, up, getPlanesRight);\r\n  Cartesian3.normalize(right, right);\r\n  var nearCenter = getPlanesNearCenter;\r\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\r\n  Cartesian3.add(position, nearCenter, nearCenter);\r\n\r\n  var point = getPlanesPoint;\r\n\r\n  // Left plane\r\n  Cartesian3.multiplyByScalar(right, l, point);\r\n  Cartesian3.add(nearCenter, point, point);\r\n\r\n  var plane = planes[0];\r\n  if (!defined(plane)) {\r\n    plane = planes[0] = new Cartesian4();\r\n  }\r\n  plane.x = right.x;\r\n  plane.y = right.y;\r\n  plane.z = right.z;\r\n  plane.w = -Cartesian3.dot(right, point);\r\n\r\n  // Right plane\r\n  Cartesian3.multiplyByScalar(right, r, point);\r\n  Cartesian3.add(nearCenter, point, point);\r\n\r\n  plane = planes[1];\r\n  if (!defined(plane)) {\r\n    plane = planes[1] = new Cartesian4();\r\n  }\r\n  plane.x = -right.x;\r\n  plane.y = -right.y;\r\n  plane.z = -right.z;\r\n  plane.w = -Cartesian3.dot(Cartesian3.negate(right, negateScratch), point);\r\n\r\n  // Bottom plane\r\n  Cartesian3.multiplyByScalar(up, b, point);\r\n  Cartesian3.add(nearCenter, point, point);\r\n\r\n  plane = planes[2];\r\n  if (!defined(plane)) {\r\n    plane = planes[2] = new Cartesian4();\r\n  }\r\n  plane.x = up.x;\r\n  plane.y = up.y;\r\n  plane.z = up.z;\r\n  plane.w = -Cartesian3.dot(up, point);\r\n\r\n  // Top plane\r\n  Cartesian3.multiplyByScalar(up, t, point);\r\n  Cartesian3.add(nearCenter, point, point);\r\n\r\n  plane = planes[3];\r\n  if (!defined(plane)) {\r\n    plane = planes[3] = new Cartesian4();\r\n  }\r\n  plane.x = -up.x;\r\n  plane.y = -up.y;\r\n  plane.z = -up.z;\r\n  plane.w = -Cartesian3.dot(Cartesian3.negate(up, negateScratch), point);\r\n\r\n  // Near plane\r\n  plane = planes[4];\r\n  if (!defined(plane)) {\r\n    plane = planes[4] = new Cartesian4();\r\n  }\r\n  plane.x = direction.x;\r\n  plane.y = direction.y;\r\n  plane.z = direction.z;\r\n  plane.w = -Cartesian3.dot(direction, nearCenter);\r\n\r\n  // Far plane\r\n  Cartesian3.multiplyByScalar(direction, f, point);\r\n  Cartesian3.add(position, point, point);\r\n\r\n  plane = planes[5];\r\n  if (!defined(plane)) {\r\n    plane = planes[5] = new Cartesian4();\r\n  }\r\n  plane.x = -direction.x;\r\n  plane.y = -direction.y;\r\n  plane.z = -direction.z;\r\n  plane.w = -Cartesian3.dot(Cartesian3.negate(direction, negateScratch), point);\r\n\r\n  return this._cullingVolume;\r\n};\r\n\r\n/**\r\n * Returns the pixel's width and height in meters.\r\n *\r\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n * @param {Number} distance The distance to the near plane in meters.\r\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n *\r\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n *\r\n * @example\r\n * // Example 1\r\n * // Get the width and height of a pixel.\r\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n */\r\nOrthographicOffCenterFrustum.prototype.getPixelDimensions = function (\r\n  drawingBufferWidth,\r\n  drawingBufferHeight,\r\n  distance,\r\n  pixelRatio,\r\n  result\r\n) {\r\n  update(this);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\r\n    throw new DeveloperError(\r\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\r\n    );\r\n  }\r\n  if (drawingBufferWidth <= 0) {\r\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\r\n  }\r\n  if (drawingBufferHeight <= 0) {\r\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\r\n  }\r\n  if (!defined(distance)) {\r\n    throw new DeveloperError(\"distance is required.\");\r\n  }\r\n  if (!defined(pixelRatio)) {\r\n    throw new DeveloperError(\"pixelRatio is required.\");\r\n  }\r\n  if (pixelRatio <= 0) {\r\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\r\n  }\r\n  if (!defined(result)) {\r\n    throw new DeveloperError(\"A result object is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var frustumWidth = this.right - this.left;\r\n  var frustumHeight = this.top - this.bottom;\r\n  var pixelWidth = (pixelRatio * frustumWidth) / drawingBufferWidth;\r\n  var pixelHeight = (pixelRatio * frustumHeight) / drawingBufferHeight;\r\n\r\n  result.x = pixelWidth;\r\n  result.y = pixelHeight;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns a duplicate of a OrthographicOffCenterFrustum instance.\r\n *\r\n * @param {OrthographicOffCenterFrustum} [result] The object onto which to store the result.\r\n * @returns {OrthographicOffCenterFrustum} The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.\r\n */\r\nOrthographicOffCenterFrustum.prototype.clone = function (result) {\r\n  if (!defined(result)) {\r\n    result = new OrthographicOffCenterFrustum();\r\n  }\r\n\r\n  result.left = this.left;\r\n  result.right = this.right;\r\n  result.top = this.top;\r\n  result.bottom = this.bottom;\r\n  result.near = this.near;\r\n  result.far = this.far;\r\n\r\n  // force update of clone to compute matrices\r\n  result._left = undefined;\r\n  result._right = undefined;\r\n  result._top = undefined;\r\n  result._bottom = undefined;\r\n  result._near = undefined;\r\n  result._far = undefined;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrthographicOffCenterFrustum} [other] The right hand side OrthographicOffCenterFrustum.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrthographicOffCenterFrustum.prototype.equals = function (other) {\r\n  return (\r\n    defined(other) &&\r\n    other instanceof OrthographicOffCenterFrustum &&\r\n    this.right === other.right &&\r\n    this.left === other.left &&\r\n    this.top === other.top &&\r\n    this.bottom === other.bottom &&\r\n    this.near === other.near &&\r\n    this.far === other.far\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {OrthographicOffCenterFrustum} other The right hand side OrthographicOffCenterFrustum.\r\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nOrthographicOffCenterFrustum.prototype.equalsEpsilon = function (\r\n  other,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return (\r\n    other === this ||\r\n    (defined(other) &&\r\n      other instanceof OrthographicOffCenterFrustum &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.right,\r\n        other.right,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.left,\r\n        other.left,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.top,\r\n        other.top,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.bottom,\r\n        other.bottom,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.near,\r\n        other.near,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.far,\r\n        other.far,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ))\r\n  );\r\n};\r\nexport default OrthographicOffCenterFrustum;\r\n","import Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport OrthographicOffCenterFrustum from \"./OrthographicOffCenterFrustum.js\";\r\n\r\n/**\r\n * The viewing frustum is defined by 6 planes.\r\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n * define the unit vector normal to the plane, and the w component is the distance of the\r\n * plane from the origin/camera position.\r\n *\r\n * @alias OrthographicFrustum\r\n * @constructor\r\n *\r\n * @param {Object} [options] An object with the following properties:\r\n * @param {Number} [options.width] The width of the frustum in meters.\r\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\r\n * @param {Number} [options.near=1.0] The distance of the near plane.\r\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\r\n *\r\n * @example\r\n * var maxRadii = ellipsoid.maximumRadius;\r\n *\r\n * var frustum = new Cesium.OrthographicFrustum();\r\n * frustum.near = 0.01 * maxRadii;\r\n * frustum.far = 50.0 * maxRadii;\r\n */\r\nfunction OrthographicFrustum(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  this._offCenterFrustum = new OrthographicOffCenterFrustum();\r\n\r\n  /**\r\n   * The horizontal width of the frustum in meters.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.width = options.width;\r\n  this._width = undefined;\r\n\r\n  /**\r\n   * The aspect ratio of the frustum's width to it's height.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.aspectRatio = options.aspectRatio;\r\n  this._aspectRatio = undefined;\r\n\r\n  /**\r\n   * The distance of the near plane.\r\n   * @type {Number}\r\n   * @default 1.0\r\n   */\r\n  this.near = defaultValue(options.near, 1.0);\r\n  this._near = this.near;\r\n\r\n  /**\r\n   * The distance of the far plane.\r\n   * @type {Number}\r\n   * @default 500000000.0;\r\n   */\r\n  this.far = defaultValue(options.far, 500000000.0);\r\n  this._far = this.far;\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nOrthographicFrustum.packedLength = 4;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {OrthographicFrustum} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nOrthographicFrustum.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value.width;\r\n  array[startingIndex++] = value.aspectRatio;\r\n  array[startingIndex++] = value.near;\r\n  array[startingIndex] = value.far;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {OrthographicFrustum} [result] The object into which to store the result.\r\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\r\n */\r\nOrthographicFrustum.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new OrthographicFrustum();\r\n  }\r\n\r\n  result.width = array[startingIndex++];\r\n  result.aspectRatio = array[startingIndex++];\r\n  result.near = array[startingIndex++];\r\n  result.far = array[startingIndex];\r\n\r\n  return result;\r\n};\r\n\r\nfunction update(frustum) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(frustum.width) ||\r\n    !defined(frustum.aspectRatio) ||\r\n    !defined(frustum.near) ||\r\n    !defined(frustum.far)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"width, aspectRatio, near, or far parameters are not set.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var f = frustum._offCenterFrustum;\r\n\r\n  if (\r\n    frustum.width !== frustum._width ||\r\n    frustum.aspectRatio !== frustum._aspectRatio ||\r\n    frustum.near !== frustum._near ||\r\n    frustum.far !== frustum._far\r\n  ) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (frustum.aspectRatio < 0) {\r\n      throw new DeveloperError(\"aspectRatio must be positive.\");\r\n    }\r\n    if (frustum.near < 0 || frustum.near > frustum.far) {\r\n      throw new DeveloperError(\r\n        \"near must be greater than zero and less than far.\"\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    frustum._aspectRatio = frustum.aspectRatio;\r\n    frustum._width = frustum.width;\r\n    frustum._near = frustum.near;\r\n    frustum._far = frustum.far;\r\n\r\n    var ratio = 1.0 / frustum.aspectRatio;\r\n    f.right = frustum.width * 0.5;\r\n    f.left = -f.right;\r\n    f.top = ratio * f.right;\r\n    f.bottom = -f.top;\r\n    f.near = frustum.near;\r\n    f.far = frustum.far;\r\n  }\r\n}\r\n\r\nObject.defineProperties(OrthographicFrustum.prototype, {\r\n  /**\r\n   * Gets the orthographic projection matrix computed from the view frustum.\r\n   * @memberof OrthographicFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   */\r\n  projectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._offCenterFrustum.projectionMatrix;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Creates a culling volume for this frustum.\r\n *\r\n * @param {Cartesian3} position The eye position.\r\n * @param {Cartesian3} direction The view direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n *\r\n * @example\r\n * // Check if a bounding volume intersects the frustum.\r\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\r\n */\r\nOrthographicFrustum.prototype.computeCullingVolume = function (\r\n  position,\r\n  direction,\r\n  up\r\n) {\r\n  update(this);\r\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\r\n};\r\n\r\n/**\r\n * Returns the pixel's width and height in meters.\r\n *\r\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n * @param {Number} distance The distance to the near plane in meters.\r\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n *\r\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n *\r\n * @example\r\n * // Example 1\r\n * // Get the width and height of a pixel.\r\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n */\r\nOrthographicFrustum.prototype.getPixelDimensions = function (\r\n  drawingBufferWidth,\r\n  drawingBufferHeight,\r\n  distance,\r\n  pixelRatio,\r\n  result\r\n) {\r\n  update(this);\r\n  return this._offCenterFrustum.getPixelDimensions(\r\n    drawingBufferWidth,\r\n    drawingBufferHeight,\r\n    distance,\r\n    pixelRatio,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Returns a duplicate of a OrthographicFrustum instance.\r\n *\r\n * @param {OrthographicFrustum} [result] The object onto which to store the result.\r\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\r\n */\r\nOrthographicFrustum.prototype.clone = function (result) {\r\n  if (!defined(result)) {\r\n    result = new OrthographicFrustum();\r\n  }\r\n\r\n  result.aspectRatio = this.aspectRatio;\r\n  result.width = this.width;\r\n  result.near = this.near;\r\n  result.far = this.far;\r\n\r\n  // force update of clone to compute matrices\r\n  result._aspectRatio = undefined;\r\n  result._width = undefined;\r\n  result._near = undefined;\r\n  result._far = undefined;\r\n\r\n  this._offCenterFrustum.clone(result._offCenterFrustum);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided OrthographicFrustum componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrthographicFrustum.prototype.equals = function (other) {\r\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\r\n    return false;\r\n  }\r\n\r\n  update(this);\r\n  update(other);\r\n\r\n  return (\r\n    this.width === other.width &&\r\n    this.aspectRatio === other.aspectRatio &&\r\n    this._offCenterFrustum.equals(other._offCenterFrustum)\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided OrthographicFrustum componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\r\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nOrthographicFrustum.prototype.equalsEpsilon = function (\r\n  other,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\r\n    return false;\r\n  }\r\n\r\n  update(this);\r\n  update(other);\r\n\r\n  return (\r\n    CesiumMath.equalsEpsilon(\r\n      this.width,\r\n      other.width,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    ) &&\r\n    CesiumMath.equalsEpsilon(\r\n      this.aspectRatio,\r\n      other.aspectRatio,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    ) &&\r\n    this._offCenterFrustum.equalsEpsilon(\r\n      other._offCenterFrustum,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    )\r\n  );\r\n};\r\nexport default OrthographicFrustum;\r\n","import Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport CullingVolume from \"./CullingVolume.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\n\r\n/**\r\n * The viewing frustum is defined by 6 planes.\r\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n * define the unit vector normal to the plane, and the w component is the distance of the\r\n * plane from the origin/camera position.\r\n *\r\n * @alias PerspectiveOffCenterFrustum\r\n * @constructor\r\n *\r\n * @param {Object} [options] An object with the following properties:\r\n * @param {Number} [options.left] The left clipping plane distance.\r\n * @param {Number} [options.right] The right clipping plane distance.\r\n * @param {Number} [options.top] The top clipping plane distance.\r\n * @param {Number} [options.bottom] The bottom clipping plane distance.\r\n * @param {Number} [options.near=1.0] The near clipping plane distance.\r\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\r\n *\r\n * @example\r\n * var frustum = new Cesium.PerspectiveOffCenterFrustum({\r\n *     left : -1.0,\r\n *     right : 1.0,\r\n *     top : 1.0,\r\n *     bottom : -1.0,\r\n *     near : 1.0,\r\n *     far : 100.0\r\n * });\r\n *\r\n * @see PerspectiveFrustum\r\n */\r\nfunction PerspectiveOffCenterFrustum(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  /**\r\n   * Defines the left clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.left = options.left;\r\n  this._left = undefined;\r\n\r\n  /**\r\n   * Defines the right clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.right = options.right;\r\n  this._right = undefined;\r\n\r\n  /**\r\n   * Defines the top clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.top = options.top;\r\n  this._top = undefined;\r\n\r\n  /**\r\n   * Defines the bottom clipping plane.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.bottom = options.bottom;\r\n  this._bottom = undefined;\r\n\r\n  /**\r\n   * The distance of the near plane.\r\n   * @type {Number}\r\n   * @default 1.0\r\n   */\r\n  this.near = defaultValue(options.near, 1.0);\r\n  this._near = this.near;\r\n\r\n  /**\r\n   * The distance of the far plane.\r\n   * @type {Number}\r\n   * @default 500000000.0\r\n   */\r\n  this.far = defaultValue(options.far, 500000000.0);\r\n  this._far = this.far;\r\n\r\n  this._cullingVolume = new CullingVolume();\r\n  this._perspectiveMatrix = new Matrix4();\r\n  this._infinitePerspective = new Matrix4();\r\n}\r\n\r\nfunction update(frustum) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(frustum.right) ||\r\n    !defined(frustum.left) ||\r\n    !defined(frustum.top) ||\r\n    !defined(frustum.bottom) ||\r\n    !defined(frustum.near) ||\r\n    !defined(frustum.far)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"right, left, top, bottom, near, or far parameters are not set.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var t = frustum.top;\r\n  var b = frustum.bottom;\r\n  var r = frustum.right;\r\n  var l = frustum.left;\r\n  var n = frustum.near;\r\n  var f = frustum.far;\r\n\r\n  if (\r\n    t !== frustum._top ||\r\n    b !== frustum._bottom ||\r\n    l !== frustum._left ||\r\n    r !== frustum._right ||\r\n    n !== frustum._near ||\r\n    f !== frustum._far\r\n  ) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\r\n      throw new DeveloperError(\r\n        \"near must be greater than zero and less than far.\"\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    frustum._left = l;\r\n    frustum._right = r;\r\n    frustum._top = t;\r\n    frustum._bottom = b;\r\n    frustum._near = n;\r\n    frustum._far = f;\r\n    frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(\r\n      l,\r\n      r,\r\n      b,\r\n      t,\r\n      n,\r\n      f,\r\n      frustum._perspectiveMatrix\r\n    );\r\n    frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(\r\n      l,\r\n      r,\r\n      b,\r\n      t,\r\n      n,\r\n      frustum._infinitePerspective\r\n    );\r\n  }\r\n}\r\n\r\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\r\n  /**\r\n   * Gets the perspective projection matrix computed from the view frustum.\r\n   * @memberof PerspectiveOffCenterFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   *\r\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\r\n   */\r\n  projectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._perspectiveMatrix;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\r\n   * @memberof PerspectiveOffCenterFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   *\r\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\r\n   */\r\n  infiniteProjectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._infinitePerspective;\r\n    },\r\n  },\r\n});\r\n\r\nvar getPlanesRight = new Cartesian3();\r\nvar getPlanesNearCenter = new Cartesian3();\r\nvar getPlanesFarCenter = new Cartesian3();\r\nvar getPlanesNormal = new Cartesian3();\r\n/**\r\n * Creates a culling volume for this frustum.\r\n *\r\n * @param {Cartesian3} position The eye position.\r\n * @param {Cartesian3} direction The view direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n *\r\n * @example\r\n * // Check if a bounding volume intersects the frustum.\r\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\r\n */\r\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (\r\n  position,\r\n  direction,\r\n  up\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(position)) {\r\n    throw new DeveloperError(\"position is required.\");\r\n  }\r\n\r\n  if (!defined(direction)) {\r\n    throw new DeveloperError(\"direction is required.\");\r\n  }\r\n\r\n  if (!defined(up)) {\r\n    throw new DeveloperError(\"up is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var planes = this._cullingVolume.planes;\r\n\r\n  var t = this.top;\r\n  var b = this.bottom;\r\n  var r = this.right;\r\n  var l = this.left;\r\n  var n = this.near;\r\n  var f = this.far;\r\n\r\n  var right = Cartesian3.cross(direction, up, getPlanesRight);\r\n\r\n  var nearCenter = getPlanesNearCenter;\r\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\r\n  Cartesian3.add(position, nearCenter, nearCenter);\r\n\r\n  var farCenter = getPlanesFarCenter;\r\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\r\n  Cartesian3.add(position, farCenter, farCenter);\r\n\r\n  var normal = getPlanesNormal;\r\n\r\n  //Left plane computation\r\n  Cartesian3.multiplyByScalar(right, l, normal);\r\n  Cartesian3.add(nearCenter, normal, normal);\r\n  Cartesian3.subtract(normal, position, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n  Cartesian3.cross(normal, up, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n\r\n  var plane = planes[0];\r\n  if (!defined(plane)) {\r\n    plane = planes[0] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, position);\r\n\r\n  //Right plane computation\r\n  Cartesian3.multiplyByScalar(right, r, normal);\r\n  Cartesian3.add(nearCenter, normal, normal);\r\n  Cartesian3.subtract(normal, position, normal);\r\n  Cartesian3.cross(up, normal, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n\r\n  plane = planes[1];\r\n  if (!defined(plane)) {\r\n    plane = planes[1] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, position);\r\n\r\n  //Bottom plane computation\r\n  Cartesian3.multiplyByScalar(up, b, normal);\r\n  Cartesian3.add(nearCenter, normal, normal);\r\n  Cartesian3.subtract(normal, position, normal);\r\n  Cartesian3.cross(right, normal, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n\r\n  plane = planes[2];\r\n  if (!defined(plane)) {\r\n    plane = planes[2] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, position);\r\n\r\n  //Top plane computation\r\n  Cartesian3.multiplyByScalar(up, t, normal);\r\n  Cartesian3.add(nearCenter, normal, normal);\r\n  Cartesian3.subtract(normal, position, normal);\r\n  Cartesian3.cross(normal, right, normal);\r\n  Cartesian3.normalize(normal, normal);\r\n\r\n  plane = planes[3];\r\n  if (!defined(plane)) {\r\n    plane = planes[3] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, position);\r\n\r\n  //Near plane computation\r\n  plane = planes[4];\r\n  if (!defined(plane)) {\r\n    plane = planes[4] = new Cartesian4();\r\n  }\r\n  plane.x = direction.x;\r\n  plane.y = direction.y;\r\n  plane.z = direction.z;\r\n  plane.w = -Cartesian3.dot(direction, nearCenter);\r\n\r\n  //Far plane computation\r\n  Cartesian3.negate(direction, normal);\r\n\r\n  plane = planes[5];\r\n  if (!defined(plane)) {\r\n    plane = planes[5] = new Cartesian4();\r\n  }\r\n  plane.x = normal.x;\r\n  plane.y = normal.y;\r\n  plane.z = normal.z;\r\n  plane.w = -Cartesian3.dot(normal, farCenter);\r\n\r\n  return this._cullingVolume;\r\n};\r\n\r\n/**\r\n * Returns the pixel's width and height in meters.\r\n *\r\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n * @param {Number} distance The distance to the near plane in meters.\r\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n *\r\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n *\r\n * @example\r\n * // Example 1\r\n * // Get the width and height of a pixel.\r\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n *\r\n * @example\r\n * // Example 2\r\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\r\n * // For example, get the size of a pixel of an image on a billboard.\r\n * var position = camera.position;\r\n * var direction = camera.direction;\r\n * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\r\n * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\r\n * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\r\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\r\n */\r\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (\r\n  drawingBufferWidth,\r\n  drawingBufferHeight,\r\n  distance,\r\n  pixelRatio,\r\n  result\r\n) {\r\n  update(this);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\r\n    throw new DeveloperError(\r\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\r\n    );\r\n  }\r\n  if (drawingBufferWidth <= 0) {\r\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\r\n  }\r\n  if (drawingBufferHeight <= 0) {\r\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\r\n  }\r\n  if (!defined(distance)) {\r\n    throw new DeveloperError(\"distance is required.\");\r\n  }\r\n  if (!defined(pixelRatio)) {\r\n    throw new DeveloperError(\"pixelRatio is required\");\r\n  }\r\n  if (pixelRatio <= 0) {\r\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\r\n  }\r\n  if (!defined(result)) {\r\n    throw new DeveloperError(\"A result object is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var inverseNear = 1.0 / this.near;\r\n  var tanTheta = this.top * inverseNear;\r\n  var pixelHeight =\r\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferHeight;\r\n  tanTheta = this.right * inverseNear;\r\n  var pixelWidth =\r\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferWidth;\r\n\r\n  result.x = pixelWidth;\r\n  result.y = pixelHeight;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\r\n *\r\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\r\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n */\r\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\r\n  if (!defined(result)) {\r\n    result = new PerspectiveOffCenterFrustum();\r\n  }\r\n\r\n  result.right = this.right;\r\n  result.left = this.left;\r\n  result.top = this.top;\r\n  result.bottom = this.bottom;\r\n  result.near = this.near;\r\n  result.far = this.far;\r\n\r\n  // force update of clone to compute matrices\r\n  result._left = undefined;\r\n  result._right = undefined;\r\n  result._top = undefined;\r\n  result._bottom = undefined;\r\n  result._near = undefined;\r\n  result._far = undefined;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\r\n  return (\r\n    defined(other) &&\r\n    other instanceof PerspectiveOffCenterFrustum &&\r\n    this.right === other.right &&\r\n    this.left === other.left &&\r\n    this.top === other.top &&\r\n    this.bottom === other.bottom &&\r\n    this.near === other.near &&\r\n    this.far === other.far\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\r\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (\r\n  other,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  return (\r\n    other === this ||\r\n    (defined(other) &&\r\n      other instanceof PerspectiveOffCenterFrustum &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.right,\r\n        other.right,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.left,\r\n        other.left,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.top,\r\n        other.top,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.bottom,\r\n        other.bottom,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.near,\r\n        other.near,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ) &&\r\n      CesiumMath.equalsEpsilon(\r\n        this.far,\r\n        other.far,\r\n        relativeEpsilon,\r\n        absoluteEpsilon\r\n      ))\r\n  );\r\n};\r\nexport default PerspectiveOffCenterFrustum;\r\n","import Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PerspectiveOffCenterFrustum from \"./PerspectiveOffCenterFrustum.js\";\r\n\r\n/**\r\n * The viewing frustum is defined by 6 planes.\r\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n * define the unit vector normal to the plane, and the w component is the distance of the\r\n * plane from the origin/camera position.\r\n *\r\n * @alias PerspectiveFrustum\r\n * @constructor\r\n *\r\n * @param {Object} [options] An object with the following properties:\r\n * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.\r\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\r\n * @param {Number} [options.near=1.0] The distance of the near plane.\r\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\r\n * @param {Number} [options.xOffset=0.0] The offset in the x direction.\r\n * @param {Number} [options.yOffset=0.0] The offset in the y direction.\r\n *\r\n * @example\r\n * var frustum = new Cesium.PerspectiveFrustum({\r\n *     fov : Cesium.Math.PI_OVER_THREE,\r\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\r\n *     near : 1.0,\r\n *     far : 1000.0\r\n * });\r\n *\r\n * @see PerspectiveOffCenterFrustum\r\n */\r\nfunction PerspectiveFrustum(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  this._offCenterFrustum = new PerspectiveOffCenterFrustum();\r\n\r\n  /**\r\n   * The angle of the field of view (FOV), in radians.  This angle will be used\r\n   * as the horizontal FOV if the width is greater than the height, otherwise\r\n   * it will be the vertical FOV.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.fov = options.fov;\r\n  this._fov = undefined;\r\n  this._fovy = undefined;\r\n\r\n  this._sseDenominator = undefined;\r\n\r\n  /**\r\n   * The aspect ratio of the frustum's width to it's height.\r\n   * @type {Number}\r\n   * @default undefined\r\n   */\r\n  this.aspectRatio = options.aspectRatio;\r\n  this._aspectRatio = undefined;\r\n\r\n  /**\r\n   * The distance of the near plane.\r\n   * @type {Number}\r\n   * @default 1.0\r\n   */\r\n  this.near = defaultValue(options.near, 1.0);\r\n  this._near = this.near;\r\n\r\n  /**\r\n   * The distance of the far plane.\r\n   * @type {Number}\r\n   * @default 500000000.0\r\n   */\r\n  this.far = defaultValue(options.far, 500000000.0);\r\n  this._far = this.far;\r\n\r\n  /**\r\n   * Offsets the frustum in the x direction.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.xOffset = defaultValue(options.xOffset, 0.0);\r\n  this._xOffset = this.xOffset;\r\n\r\n  /**\r\n   * Offsets the frustum in the y direction.\r\n   * @type {Number}\r\n   * @default 0.0\r\n   */\r\n  this.yOffset = defaultValue(options.yOffset, 0.0);\r\n  this._yOffset = this.yOffset;\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nPerspectiveFrustum.packedLength = 6;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PerspectiveFrustum} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nPerspectiveFrustum.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  array[startingIndex++] = value.fov;\r\n  array[startingIndex++] = value.aspectRatio;\r\n  array[startingIndex++] = value.near;\r\n  array[startingIndex++] = value.far;\r\n  array[startingIndex++] = value.xOffset;\r\n  array[startingIndex] = value.yOffset;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PerspectiveFrustum} [result] The object into which to store the result.\r\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n */\r\nPerspectiveFrustum.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new PerspectiveFrustum();\r\n  }\r\n\r\n  result.fov = array[startingIndex++];\r\n  result.aspectRatio = array[startingIndex++];\r\n  result.near = array[startingIndex++];\r\n  result.far = array[startingIndex++];\r\n  result.xOffset = array[startingIndex++];\r\n  result.yOffset = array[startingIndex];\r\n\r\n  return result;\r\n};\r\n\r\nfunction update(frustum) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(frustum.fov) ||\r\n    !defined(frustum.aspectRatio) ||\r\n    !defined(frustum.near) ||\r\n    !defined(frustum.far)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"fov, aspectRatio, near, or far parameters are not set.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var f = frustum._offCenterFrustum;\r\n\r\n  if (\r\n    frustum.fov !== frustum._fov ||\r\n    frustum.aspectRatio !== frustum._aspectRatio ||\r\n    frustum.near !== frustum._near ||\r\n    frustum.far !== frustum._far ||\r\n    frustum.xOffset !== frustum._xOffset ||\r\n    frustum.yOffset !== frustum._yOffset\r\n  ) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (frustum.fov < 0 || frustum.fov >= Math.PI) {\r\n      throw new DeveloperError(\"fov must be in the range [0, PI).\");\r\n    }\r\n\r\n    if (frustum.aspectRatio < 0) {\r\n      throw new DeveloperError(\"aspectRatio must be positive.\");\r\n    }\r\n\r\n    if (frustum.near < 0 || frustum.near > frustum.far) {\r\n      throw new DeveloperError(\r\n        \"near must be greater than zero and less than far.\"\r\n      );\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    frustum._aspectRatio = frustum.aspectRatio;\r\n    frustum._fov = frustum.fov;\r\n    frustum._fovy =\r\n      frustum.aspectRatio <= 1\r\n        ? frustum.fov\r\n        : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\r\n    frustum._near = frustum.near;\r\n    frustum._far = frustum.far;\r\n    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\r\n    frustum._xOffset = frustum.xOffset;\r\n    frustum._yOffset = frustum.yOffset;\r\n\r\n    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\r\n    f.bottom = -f.top;\r\n    f.right = frustum.aspectRatio * f.top;\r\n    f.left = -f.right;\r\n    f.near = frustum.near;\r\n    f.far = frustum.far;\r\n\r\n    f.right += frustum.xOffset;\r\n    f.left += frustum.xOffset;\r\n    f.top += frustum.yOffset;\r\n    f.bottom += frustum.yOffset;\r\n  }\r\n}\r\n\r\nObject.defineProperties(PerspectiveFrustum.prototype, {\r\n  /**\r\n   * Gets the perspective projection matrix computed from the view frustum.\r\n   * @memberof PerspectiveFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   *\r\n   * @see PerspectiveFrustum#infiniteProjectionMatrix\r\n   */\r\n  projectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._offCenterFrustum.projectionMatrix;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\r\n   * @memberof PerspectiveFrustum.prototype\r\n   * @type {Matrix4}\r\n   * @readonly\r\n   *\r\n   * @see PerspectiveFrustum#projectionMatrix\r\n   */\r\n  infiniteProjectionMatrix: {\r\n    get: function () {\r\n      update(this);\r\n      return this._offCenterFrustum.infiniteProjectionMatrix;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the angle of the vertical field of view, in radians.\r\n   * @memberof PerspectiveFrustum.prototype\r\n   * @type {Number}\r\n   * @readonly\r\n   * @default undefined\r\n   */\r\n  fovy: {\r\n    get: function () {\r\n      update(this);\r\n      return this._fovy;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * @readonly\r\n   * @private\r\n   */\r\n  sseDenominator: {\r\n    get: function () {\r\n      update(this);\r\n      return this._sseDenominator;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Creates a culling volume for this frustum.\r\n *\r\n * @param {Cartesian3} position The eye position.\r\n * @param {Cartesian3} direction The view direction.\r\n * @param {Cartesian3} up The up direction.\r\n * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n *\r\n * @example\r\n * // Check if a bounding volume intersects the frustum.\r\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\r\n */\r\nPerspectiveFrustum.prototype.computeCullingVolume = function (\r\n  position,\r\n  direction,\r\n  up\r\n) {\r\n  update(this);\r\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\r\n};\r\n\r\n/**\r\n * Returns the pixel's width and height in meters.\r\n *\r\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n * @param {Number} distance The distance to the near plane in meters.\r\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n * @param {Cartesian2} result The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n *\r\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n *\r\n * @example\r\n * // Example 1\r\n * // Get the width and height of a pixel.\r\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n *\r\n * @example\r\n * // Example 2\r\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\r\n * // For example, get the size of a pixel of an image on a billboard.\r\n * var position = camera.position;\r\n * var direction = camera.direction;\r\n * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\r\n * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\r\n * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\r\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\r\n */\r\nPerspectiveFrustum.prototype.getPixelDimensions = function (\r\n  drawingBufferWidth,\r\n  drawingBufferHeight,\r\n  distance,\r\n  pixelRatio,\r\n  result\r\n) {\r\n  update(this);\r\n  return this._offCenterFrustum.getPixelDimensions(\r\n    drawingBufferWidth,\r\n    drawingBufferHeight,\r\n    distance,\r\n    pixelRatio,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Returns a duplicate of a PerspectiveFrustum instance.\r\n *\r\n * @param {PerspectiveFrustum} [result] The object onto which to store the result.\r\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n */\r\nPerspectiveFrustum.prototype.clone = function (result) {\r\n  if (!defined(result)) {\r\n    result = new PerspectiveFrustum();\r\n  }\r\n\r\n  result.aspectRatio = this.aspectRatio;\r\n  result.fov = this.fov;\r\n  result.near = this.near;\r\n  result.far = this.far;\r\n\r\n  // force update of clone to compute matrices\r\n  result._aspectRatio = undefined;\r\n  result._fov = undefined;\r\n  result._near = undefined;\r\n  result._far = undefined;\r\n\r\n  this._offCenterFrustum.clone(result._offCenterFrustum);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Compares the provided PerspectiveFrustum componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nPerspectiveFrustum.prototype.equals = function (other) {\r\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\r\n    return false;\r\n  }\r\n\r\n  update(this);\r\n  update(other);\r\n\r\n  return (\r\n    this.fov === other.fov &&\r\n    this.aspectRatio === other.aspectRatio &&\r\n    this._offCenterFrustum.equals(other._offCenterFrustum)\r\n  );\r\n};\r\n\r\n/**\r\n * Compares the provided PerspectiveFrustum componentwise and returns\r\n * <code>true</code> if they pass an absolute or relative tolerance test,\r\n * <code>false</code> otherwise.\r\n *\r\n * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\r\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n */\r\nPerspectiveFrustum.prototype.equalsEpsilon = function (\r\n  other,\r\n  relativeEpsilon,\r\n  absoluteEpsilon\r\n) {\r\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\r\n    return false;\r\n  }\r\n\r\n  update(this);\r\n  update(other);\r\n\r\n  return (\r\n    CesiumMath.equalsEpsilon(\r\n      this.fov,\r\n      other.fov,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    ) &&\r\n    CesiumMath.equalsEpsilon(\r\n      this.aspectRatio,\r\n      other.aspectRatio,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    ) &&\r\n    this._offCenterFrustum.equalsEpsilon(\r\n      other._offCenterFrustum,\r\n      relativeEpsilon,\r\n      absoluteEpsilon\r\n    )\r\n  );\r\n};\r\nexport default PerspectiveFrustum;\r\n","import BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\r\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport VertexFormat from \"./VertexFormat.js\";\r\n\r\nvar PERSPECTIVE = 0;\r\nvar ORTHOGRAPHIC = 1;\r\n\r\n/**\r\n * Describes a frustum at the given the origin and orientation.\r\n *\r\n * @alias FrustumGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\r\n * @param {Cartesian3} options.origin The origin of the frustum.\r\n * @param {Quaternion} options.orientation The orientation of the frustum.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n */\r\nfunction FrustumGeometry(options) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.frustum\", options.frustum);\r\n  Check.typeOf.object(\"options.origin\", options.origin);\r\n  Check.typeOf.object(\"options.orientation\", options.orientation);\r\n  //>>includeEnd('debug');\r\n\r\n  var frustum = options.frustum;\r\n  var orientation = options.orientation;\r\n  var origin = options.origin;\r\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n\r\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\r\n  // creating multiple FrustumGeometrys. This way the near plane of one frustum doesn't overlap\r\n  // the far plane of another.\r\n  var drawNearPlane = defaultValue(options._drawNearPlane, true);\r\n\r\n  var frustumType;\r\n  var frustumPackedLength;\r\n  if (frustum instanceof PerspectiveFrustum) {\r\n    frustumType = PERSPECTIVE;\r\n    frustumPackedLength = PerspectiveFrustum.packedLength;\r\n  } else if (frustum instanceof OrthographicFrustum) {\r\n    frustumType = ORTHOGRAPHIC;\r\n    frustumPackedLength = OrthographicFrustum.packedLength;\r\n  }\r\n\r\n  this._frustumType = frustumType;\r\n  this._frustum = frustum.clone();\r\n  this._origin = Cartesian3.clone(origin);\r\n  this._orientation = Quaternion.clone(orientation);\r\n  this._drawNearPlane = drawNearPlane;\r\n  this._vertexFormat = vertexFormat;\r\n  this._workerName = \"createFrustumGeometry\";\r\n\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @type {Number}\r\n   */\r\n  this.packedLength =\r\n    2 +\r\n    frustumPackedLength +\r\n    Cartesian3.packedLength +\r\n    Quaternion.packedLength +\r\n    VertexFormat.packedLength;\r\n}\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {FrustumGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nFrustumGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  var frustumType = value._frustumType;\r\n  var frustum = value._frustum;\r\n\r\n  array[startingIndex++] = frustumType;\r\n\r\n  if (frustumType === PERSPECTIVE) {\r\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\r\n    startingIndex += PerspectiveFrustum.packedLength;\r\n  } else {\r\n    OrthographicFrustum.pack(frustum, array, startingIndex);\r\n    startingIndex += OrthographicFrustum.packedLength;\r\n  }\r\n\r\n  Cartesian3.pack(value._origin, array, startingIndex);\r\n  startingIndex += Cartesian3.packedLength;\r\n  Quaternion.pack(value._orientation, array, startingIndex);\r\n  startingIndex += Quaternion.packedLength;\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\r\n\r\n  return array;\r\n};\r\n\r\nvar scratchPackPerspective = new PerspectiveFrustum();\r\nvar scratchPackOrthographic = new OrthographicFrustum();\r\nvar scratchPackQuaternion = new Quaternion();\r\nvar scratchPackorigin = new Cartesian3();\r\nvar scratchVertexFormat = new VertexFormat();\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {FrustumGeometry} [result] The object into which to store the result.\r\n */\r\nFrustumGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  var frustumType = array[startingIndex++];\r\n\r\n  var frustum;\r\n  if (frustumType === PERSPECTIVE) {\r\n    frustum = PerspectiveFrustum.unpack(\r\n      array,\r\n      startingIndex,\r\n      scratchPackPerspective\r\n    );\r\n    startingIndex += PerspectiveFrustum.packedLength;\r\n  } else {\r\n    frustum = OrthographicFrustum.unpack(\r\n      array,\r\n      startingIndex,\r\n      scratchPackOrthographic\r\n    );\r\n    startingIndex += OrthographicFrustum.packedLength;\r\n  }\r\n\r\n  var origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\r\n  startingIndex += Cartesian3.packedLength;\r\n  var orientation = Quaternion.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchPackQuaternion\r\n  );\r\n  startingIndex += Quaternion.packedLength;\r\n  var vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n  var drawNearPlane = array[startingIndex] === 1.0;\r\n\r\n  if (!defined(result)) {\r\n    return new FrustumGeometry({\r\n      frustum: frustum,\r\n      origin: origin,\r\n      orientation: orientation,\r\n      vertexFormat: vertexFormat,\r\n      _drawNearPlane: drawNearPlane,\r\n    });\r\n  }\r\n\r\n  var frustumResult =\r\n    frustumType === result._frustumType ? result._frustum : undefined;\r\n  result._frustum = frustum.clone(frustumResult);\r\n\r\n  result._frustumType = frustumType;\r\n  result._origin = Cartesian3.clone(origin, result._origin);\r\n  result._orientation = Quaternion.clone(orientation, result._orientation);\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._drawNearPlane = drawNearPlane;\r\n\r\n  return result;\r\n};\r\n\r\nfunction getAttributes(\r\n  offset,\r\n  normals,\r\n  tangents,\r\n  bitangents,\r\n  st,\r\n  normal,\r\n  tangent,\r\n  bitangent\r\n) {\r\n  var stOffset = (offset / 3) * 2;\r\n\r\n  for (var i = 0; i < 4; ++i) {\r\n    if (defined(normals)) {\r\n      normals[offset] = normal.x;\r\n      normals[offset + 1] = normal.y;\r\n      normals[offset + 2] = normal.z;\r\n    }\r\n    if (defined(tangents)) {\r\n      tangents[offset] = tangent.x;\r\n      tangents[offset + 1] = tangent.y;\r\n      tangents[offset + 2] = tangent.z;\r\n    }\r\n    if (defined(bitangents)) {\r\n      bitangents[offset] = bitangent.x;\r\n      bitangents[offset + 1] = bitangent.y;\r\n      bitangents[offset + 2] = bitangent.z;\r\n    }\r\n    offset += 3;\r\n  }\r\n\r\n  st[stOffset] = 0.0;\r\n  st[stOffset + 1] = 0.0;\r\n  st[stOffset + 2] = 1.0;\r\n  st[stOffset + 3] = 0.0;\r\n  st[stOffset + 4] = 1.0;\r\n  st[stOffset + 5] = 1.0;\r\n  st[stOffset + 6] = 0.0;\r\n  st[stOffset + 7] = 1.0;\r\n}\r\n\r\nvar scratchRotationMatrix = new Matrix3();\r\nvar scratchViewMatrix = new Matrix4();\r\nvar scratchInverseMatrix = new Matrix4();\r\n\r\nvar scratchXDirection = new Cartesian3();\r\nvar scratchYDirection = new Cartesian3();\r\nvar scratchZDirection = new Cartesian3();\r\nvar scratchNegativeX = new Cartesian3();\r\nvar scratchNegativeY = new Cartesian3();\r\nvar scratchNegativeZ = new Cartesian3();\r\n\r\nvar frustumSplits = new Array(3);\r\n\r\nvar frustumCornersNDC = new Array(4);\r\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\r\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\r\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\r\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\r\n\r\nvar scratchFrustumCorners = new Array(4);\r\nfor (var i = 0; i < 4; ++i) {\r\n  scratchFrustumCorners[i] = new Cartesian4();\r\n}\r\n\r\nFrustumGeometry._computeNearFarPlanes = function (\r\n  origin,\r\n  orientation,\r\n  frustumType,\r\n  frustum,\r\n  positions,\r\n  xDirection,\r\n  yDirection,\r\n  zDirection\r\n) {\r\n  var rotationMatrix = Matrix3.fromQuaternion(\r\n    orientation,\r\n    scratchRotationMatrix\r\n  );\r\n  var x = defaultValue(xDirection, scratchXDirection);\r\n  var y = defaultValue(yDirection, scratchYDirection);\r\n  var z = defaultValue(zDirection, scratchZDirection);\r\n\r\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\r\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\r\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\r\n\r\n  Cartesian3.normalize(x, x);\r\n  Cartesian3.normalize(y, y);\r\n  Cartesian3.normalize(z, z);\r\n\r\n  Cartesian3.negate(x, x);\r\n\r\n  var view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\r\n\r\n  var inverseView;\r\n  var inverseViewProjection;\r\n  if (frustumType === PERSPECTIVE) {\r\n    var projection = frustum.projectionMatrix;\r\n    var viewProjection = Matrix4.multiply(\r\n      projection,\r\n      view,\r\n      scratchInverseMatrix\r\n    );\r\n    inverseViewProjection = Matrix4.inverse(\r\n      viewProjection,\r\n      scratchInverseMatrix\r\n    );\r\n  } else {\r\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\r\n  }\r\n\r\n  if (defined(inverseViewProjection)) {\r\n    frustumSplits[0] = frustum.near;\r\n    frustumSplits[1] = frustum.far;\r\n  } else {\r\n    frustumSplits[0] = 0.0;\r\n    frustumSplits[1] = frustum.near;\r\n    frustumSplits[2] = frustum.far;\r\n  }\r\n\r\n  for (var i = 0; i < 2; ++i) {\r\n    for (var j = 0; j < 4; ++j) {\r\n      var corner = Cartesian4.clone(\r\n        frustumCornersNDC[j],\r\n        scratchFrustumCorners[j]\r\n      );\r\n\r\n      if (!defined(inverseViewProjection)) {\r\n        if (defined(frustum._offCenterFrustum)) {\r\n          frustum = frustum._offCenterFrustum;\r\n        }\r\n\r\n        var near = frustumSplits[i];\r\n        var far = frustumSplits[i + 1];\r\n\r\n        corner.x =\r\n          (corner.x * (frustum.right - frustum.left) +\r\n            frustum.left +\r\n            frustum.right) *\r\n          0.5;\r\n        corner.y =\r\n          (corner.y * (frustum.top - frustum.bottom) +\r\n            frustum.bottom +\r\n            frustum.top) *\r\n          0.5;\r\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\r\n        corner.w = 1.0;\r\n\r\n        Matrix4.multiplyByVector(inverseView, corner, corner);\r\n      } else {\r\n        corner = Matrix4.multiplyByVector(\r\n          inverseViewProjection,\r\n          corner,\r\n          corner\r\n        );\r\n\r\n        // Reverse perspective divide\r\n        var w = 1.0 / corner.w;\r\n        Cartesian3.multiplyByScalar(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, origin, corner);\r\n        Cartesian3.normalize(corner, corner);\r\n\r\n        var fac = Cartesian3.dot(z, corner);\r\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\r\n        Cartesian3.add(corner, origin, corner);\r\n      }\r\n\r\n      positions[12 * i + j * 3] = corner.x;\r\n      positions[12 * i + j * 3 + 1] = corner.y;\r\n      positions[12 * i + j * 3 + 2] = corner.z;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nFrustumGeometry.createGeometry = function (frustumGeometry) {\r\n  var frustumType = frustumGeometry._frustumType;\r\n  var frustum = frustumGeometry._frustum;\r\n  var origin = frustumGeometry._origin;\r\n  var orientation = frustumGeometry._orientation;\r\n  var drawNearPlane = frustumGeometry._drawNearPlane;\r\n  var vertexFormat = frustumGeometry._vertexFormat;\r\n\r\n  var numberOfPlanes = drawNearPlane ? 6 : 5;\r\n  var positions = new Float64Array(3 * 4 * 6);\r\n  FrustumGeometry._computeNearFarPlanes(\r\n    origin,\r\n    orientation,\r\n    frustumType,\r\n    frustum,\r\n    positions\r\n  );\r\n\r\n  // -x plane\r\n  var offset = 3 * 4 * 2;\r\n  positions[offset] = positions[3 * 4];\r\n  positions[offset + 1] = positions[3 * 4 + 1];\r\n  positions[offset + 2] = positions[3 * 4 + 2];\r\n  positions[offset + 3] = positions[0];\r\n  positions[offset + 4] = positions[1];\r\n  positions[offset + 5] = positions[2];\r\n  positions[offset + 6] = positions[3 * 3];\r\n  positions[offset + 7] = positions[3 * 3 + 1];\r\n  positions[offset + 8] = positions[3 * 3 + 2];\r\n  positions[offset + 9] = positions[3 * 7];\r\n  positions[offset + 10] = positions[3 * 7 + 1];\r\n  positions[offset + 11] = positions[3 * 7 + 2];\r\n\r\n  // -y plane\r\n  offset += 3 * 4;\r\n  positions[offset] = positions[3 * 5];\r\n  positions[offset + 1] = positions[3 * 5 + 1];\r\n  positions[offset + 2] = positions[3 * 5 + 2];\r\n  positions[offset + 3] = positions[3];\r\n  positions[offset + 4] = positions[3 + 1];\r\n  positions[offset + 5] = positions[3 + 2];\r\n  positions[offset + 6] = positions[0];\r\n  positions[offset + 7] = positions[1];\r\n  positions[offset + 8] = positions[2];\r\n  positions[offset + 9] = positions[3 * 4];\r\n  positions[offset + 10] = positions[3 * 4 + 1];\r\n  positions[offset + 11] = positions[3 * 4 + 2];\r\n\r\n  // +x plane\r\n  offset += 3 * 4;\r\n  positions[offset] = positions[3];\r\n  positions[offset + 1] = positions[3 + 1];\r\n  positions[offset + 2] = positions[3 + 2];\r\n  positions[offset + 3] = positions[3 * 5];\r\n  positions[offset + 4] = positions[3 * 5 + 1];\r\n  positions[offset + 5] = positions[3 * 5 + 2];\r\n  positions[offset + 6] = positions[3 * 6];\r\n  positions[offset + 7] = positions[3 * 6 + 1];\r\n  positions[offset + 8] = positions[3 * 6 + 2];\r\n  positions[offset + 9] = positions[3 * 2];\r\n  positions[offset + 10] = positions[3 * 2 + 1];\r\n  positions[offset + 11] = positions[3 * 2 + 2];\r\n\r\n  // +y plane\r\n  offset += 3 * 4;\r\n  positions[offset] = positions[3 * 2];\r\n  positions[offset + 1] = positions[3 * 2 + 1];\r\n  positions[offset + 2] = positions[3 * 2 + 2];\r\n  positions[offset + 3] = positions[3 * 6];\r\n  positions[offset + 4] = positions[3 * 6 + 1];\r\n  positions[offset + 5] = positions[3 * 6 + 2];\r\n  positions[offset + 6] = positions[3 * 7];\r\n  positions[offset + 7] = positions[3 * 7 + 1];\r\n  positions[offset + 8] = positions[3 * 7 + 2];\r\n  positions[offset + 9] = positions[3 * 3];\r\n  positions[offset + 10] = positions[3 * 3 + 1];\r\n  positions[offset + 11] = positions[3 * 3 + 2];\r\n\r\n  if (!drawNearPlane) {\r\n    positions = positions.subarray(3 * 4);\r\n  }\r\n\r\n  var attributes = new GeometryAttributes({\r\n    position: new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.DOUBLE,\r\n      componentsPerAttribute: 3,\r\n      values: positions,\r\n    }),\r\n  });\r\n\r\n  if (\r\n    defined(vertexFormat.normal) ||\r\n    defined(vertexFormat.tangent) ||\r\n    defined(vertexFormat.bitangent) ||\r\n    defined(vertexFormat.st)\r\n  ) {\r\n    var normals = defined(vertexFormat.normal)\r\n      ? new Float32Array(3 * 4 * numberOfPlanes)\r\n      : undefined;\r\n    var tangents = defined(vertexFormat.tangent)\r\n      ? new Float32Array(3 * 4 * numberOfPlanes)\r\n      : undefined;\r\n    var bitangents = defined(vertexFormat.bitangent)\r\n      ? new Float32Array(3 * 4 * numberOfPlanes)\r\n      : undefined;\r\n    var st = defined(vertexFormat.st)\r\n      ? new Float32Array(2 * 4 * numberOfPlanes)\r\n      : undefined;\r\n\r\n    var x = scratchXDirection;\r\n    var y = scratchYDirection;\r\n    var z = scratchZDirection;\r\n\r\n    var negativeX = Cartesian3.negate(x, scratchNegativeX);\r\n    var negativeY = Cartesian3.negate(y, scratchNegativeY);\r\n    var negativeZ = Cartesian3.negate(z, scratchNegativeZ);\r\n\r\n    offset = 0;\r\n    if (drawNearPlane) {\r\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\r\n      offset += 3 * 4;\r\n    }\r\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\r\n    offset += 3 * 4;\r\n    getAttributes(\r\n      offset,\r\n      normals,\r\n      tangents,\r\n      bitangents,\r\n      st,\r\n      negativeX,\r\n      negativeZ,\r\n      y\r\n    ); // -x\r\n    offset += 3 * 4;\r\n    getAttributes(\r\n      offset,\r\n      normals,\r\n      tangents,\r\n      bitangents,\r\n      st,\r\n      negativeY,\r\n      negativeZ,\r\n      negativeX\r\n    ); // -y\r\n    offset += 3 * 4;\r\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\r\n    offset += 3 * 4;\r\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\r\n\r\n    if (defined(normals)) {\r\n      attributes.normal = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: normals,\r\n      });\r\n    }\r\n    if (defined(tangents)) {\r\n      attributes.tangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: tangents,\r\n      });\r\n    }\r\n    if (defined(bitangents)) {\r\n      attributes.bitangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: bitangents,\r\n      });\r\n    }\r\n    if (defined(st)) {\r\n      attributes.st = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 2,\r\n        values: st,\r\n      });\r\n    }\r\n  }\r\n\r\n  var indices = new Uint16Array(6 * numberOfPlanes);\r\n  for (var i = 0; i < numberOfPlanes; ++i) {\r\n    var indexOffset = i * 6;\r\n    var index = i * 4;\r\n\r\n    indices[indexOffset] = index;\r\n    indices[indexOffset + 1] = index + 1;\r\n    indices[indexOffset + 2] = index + 2;\r\n    indices[indexOffset + 3] = index;\r\n    indices[indexOffset + 4] = index + 2;\r\n    indices[indexOffset + 5] = index + 3;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: indices,\r\n    primitiveType: PrimitiveType.TRIANGLES,\r\n    boundingSphere: BoundingSphere.fromVertices(positions),\r\n  });\r\n};\r\nexport default FrustumGeometry;\r\n"],"names":["CullingVolume","planes","this","defaultValue","faces","Cartesian3","clone","UNIT_X","UNIT_Y","UNIT_Z","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","Plane","OrthographicOffCenterFrustum","options","EMPTY_OBJECT","left","_left","undefined","right","_right","top","_top","bottom","_bottom","near","_near","far","_far","_cullingVolume","_orthographicMatrix","Matrix4","update","frustum","defined","DeveloperError","computeOrthographicOffCenter","fromBoundingSphere","boundingSphere","result","length","center","radius","planeIndex","i","faceNormal","plane0","plane1","Cartesian4","multiplyByScalar","add","x","y","z","w","dot","negate","prototype","computeVisibility","boundingVolume","intersecting","k","len","intersectPlane","fromCartesian4","Intersect","OUTSIDE","INTERSECTING","INSIDE","computeVisibilityWithPlaneMask","parentPlaneMask","MASK_OUTSIDE","MASK_INSIDE","mask","flag","MASK_INDETERMINATE","Object","defineProperties","projectionMatrix","get","getPlanesRight","getPlanesNearCenter","getPlanesPoint","negateScratch","OrthographicFrustum","_offCenterFrustum","width","_width","aspectRatio","_aspectRatio","f","ratio","PerspectiveOffCenterFrustum","_perspectiveMatrix","_infinitePerspective","t","b","r","l","n","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","computeCullingVolume","position","direction","up","cross","normalize","nearCenter","point","plane","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","pixelWidth","pixelHeight","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon","CesiumMath","packedLength","pack","value","array","startingIndex","Check","typeOf","object","unpack","infiniteProjectionMatrix","getPlanesFarCenter","getPlanesNormal","PerspectiveFrustum","fov","_fov","_fovy","_sseDenominator","xOffset","_xOffset","yOffset","_yOffset","Math","PI","atan","tan","farCenter","normal","subtract","inverseNear","tanTheta","fovy","sseDenominator","FrustumGeometry","origin","orientation","frustumType","frustumPackedLength","vertexFormat","VertexFormat","DEFAULT","drawNearPlane","_drawNearPlane","_frustumType","_frustum","_origin","_orientation","Quaternion","_vertexFormat","_workerName","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","scratchVertexFormat","getAttributes","offset","normals","tangents","bitangents","st","tangent","bitangent","stOffset","frustumResult","scratchRotationMatrix","Matrix3","scratchViewMatrix","scratchInverseMatrix","scratchXDirection","scratchYDirection","scratchZDirection","scratchNegativeX","scratchNegativeY","scratchNegativeZ","frustumSplits","Array","frustumCornersNDC","scratchFrustumCorners","_computeNearFarPlanes","positions","xDirection","yDirection","zDirection","rotationMatrix","fromQuaternion","getColumn","inverseView","inverseViewProjection","view","computeView","projection","viewProjection","multiply","inverse","inverseTransformation","j","corner","multiplyByVector","fac","createGeometry","frustumGeometry","numberOfPlanes","Float64Array","subarray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","Float32Array","negativeX","negativeY","negativeZ","FLOAT","indices","Uint16Array","indexOffset","index","Geometry","primitiveType","PrimitiveType","TRIANGLES","BoundingSphere","fromVertices"],"mappings":"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"}