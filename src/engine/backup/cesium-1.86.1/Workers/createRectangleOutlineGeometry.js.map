{"version":3,"file":"createRectangleOutlineGeometry.js","sources":["../../../../Source/Core/RectangleOutlineGeometry.js","../../../../Source/WorkersES6/createRectangleOutlineGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport GeometryAttributes from \"./GeometryAttributes.js\";\r\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\r\nimport IndexDatatype from \"./IndexDatatype.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport PolygonPipeline from \"./PolygonPipeline.js\";\r\nimport PrimitiveType from \"./PrimitiveType.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\r\n\r\nvar bottomBoundingSphere = new BoundingSphere();\r\nvar topBoundingSphere = new BoundingSphere();\r\nvar positionScratch = new Cartesian3();\r\nvar rectangleScratch = new Rectangle();\r\n\r\nfunction constructRectangle(geometry, computedOptions) {\r\n  var ellipsoid = geometry._ellipsoid;\r\n  var height = computedOptions.height;\r\n  var width = computedOptions.width;\r\n  var northCap = computedOptions.northCap;\r\n  var southCap = computedOptions.southCap;\r\n\r\n  var rowHeight = height;\r\n  var widthMultiplier = 2;\r\n  var size = 0;\r\n  var corners = 4;\r\n  if (northCap) {\r\n    widthMultiplier -= 1;\r\n    rowHeight -= 1;\r\n    size += 1;\r\n    corners -= 2;\r\n  }\r\n  if (southCap) {\r\n    widthMultiplier -= 1;\r\n    rowHeight -= 1;\r\n    size += 1;\r\n    corners -= 2;\r\n  }\r\n  size += widthMultiplier * width + 2 * rowHeight - corners;\r\n\r\n  var positions = new Float64Array(size * 3);\r\n\r\n  var posIndex = 0;\r\n  var row = 0;\r\n  var col;\r\n  var position = positionScratch;\r\n  if (northCap) {\r\n    RectangleGeometryLibrary.computePosition(\r\n      computedOptions,\r\n      ellipsoid,\r\n      false,\r\n      row,\r\n      0,\r\n      position\r\n    );\r\n    positions[posIndex++] = position.x;\r\n    positions[posIndex++] = position.y;\r\n    positions[posIndex++] = position.z;\r\n  } else {\r\n    for (col = 0; col < width; col++) {\r\n      RectangleGeometryLibrary.computePosition(\r\n        computedOptions,\r\n        ellipsoid,\r\n        false,\r\n        row,\r\n        col,\r\n        position\r\n      );\r\n      positions[posIndex++] = position.x;\r\n      positions[posIndex++] = position.y;\r\n      positions[posIndex++] = position.z;\r\n    }\r\n  }\r\n\r\n  col = width - 1;\r\n  for (row = 1; row < height; row++) {\r\n    RectangleGeometryLibrary.computePosition(\r\n      computedOptions,\r\n      ellipsoid,\r\n      false,\r\n      row,\r\n      col,\r\n      position\r\n    );\r\n    positions[posIndex++] = position.x;\r\n    positions[posIndex++] = position.y;\r\n    positions[posIndex++] = position.z;\r\n  }\r\n\r\n  row = height - 1;\r\n  if (!southCap) {\r\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\r\n    for (col = width - 2; col >= 0; col--) {\r\n      RectangleGeometryLibrary.computePosition(\r\n        computedOptions,\r\n        ellipsoid,\r\n        false,\r\n        row,\r\n        col,\r\n        position\r\n      );\r\n      positions[posIndex++] = position.x;\r\n      positions[posIndex++] = position.y;\r\n      positions[posIndex++] = position.z;\r\n    }\r\n  }\r\n\r\n  col = 0;\r\n  for (row = height - 2; row > 0; row--) {\r\n    RectangleGeometryLibrary.computePosition(\r\n      computedOptions,\r\n      ellipsoid,\r\n      false,\r\n      row,\r\n      col,\r\n      position\r\n    );\r\n    positions[posIndex++] = position.x;\r\n    positions[posIndex++] = position.y;\r\n    positions[posIndex++] = position.z;\r\n  }\r\n\r\n  var indicesSize = (positions.length / 3) * 2;\r\n  var indices = IndexDatatype.createTypedArray(\r\n    positions.length / 3,\r\n    indicesSize\r\n  );\r\n\r\n  var index = 0;\r\n  for (var i = 0; i < positions.length / 3 - 1; i++) {\r\n    indices[index++] = i;\r\n    indices[index++] = i + 1;\r\n  }\r\n  indices[index++] = positions.length / 3 - 1;\r\n  indices[index++] = 0;\r\n\r\n  var geo = new Geometry({\r\n    attributes: new GeometryAttributes(),\r\n    primitiveType: PrimitiveType.LINES,\r\n  });\r\n\r\n  geo.attributes.position = new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.DOUBLE,\r\n    componentsPerAttribute: 3,\r\n    values: positions,\r\n  });\r\n  geo.indices = indices;\r\n\r\n  return geo;\r\n}\r\n\r\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\r\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\r\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\r\n  var ellipsoid = rectangleGeometry._ellipsoid;\r\n  var minHeight = extrudedHeight;\r\n  var maxHeight = surfaceHeight;\r\n  var geo = constructRectangle(rectangleGeometry, computedOptions);\r\n\r\n  var height = computedOptions.height;\r\n  var width = computedOptions.width;\r\n\r\n  var topPositions = PolygonPipeline.scaleToGeodeticHeight(\r\n    geo.attributes.position.values,\r\n    maxHeight,\r\n    ellipsoid,\r\n    false\r\n  );\r\n  var length = topPositions.length;\r\n  var positions = new Float64Array(length * 2);\r\n  positions.set(topPositions);\r\n  var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\r\n    geo.attributes.position.values,\r\n    minHeight,\r\n    ellipsoid\r\n  );\r\n  positions.set(bottomPositions, length);\r\n  geo.attributes.position.values = positions;\r\n\r\n  var northCap = computedOptions.northCap;\r\n  var southCap = computedOptions.southCap;\r\n  var corners = 4;\r\n  if (northCap) {\r\n    corners -= 1;\r\n  }\r\n  if (southCap) {\r\n    corners -= 1;\r\n  }\r\n\r\n  var indicesSize = (positions.length / 3 + corners) * 2;\r\n  var indices = IndexDatatype.createTypedArray(\r\n    positions.length / 3,\r\n    indicesSize\r\n  );\r\n  length = positions.length / 6;\r\n  var index = 0;\r\n  for (var i = 0; i < length - 1; i++) {\r\n    indices[index++] = i;\r\n    indices[index++] = i + 1;\r\n    indices[index++] = i + length;\r\n    indices[index++] = i + length + 1;\r\n  }\r\n  indices[index++] = length - 1;\r\n  indices[index++] = 0;\r\n  indices[index++] = length + length - 1;\r\n  indices[index++] = length;\r\n\r\n  indices[index++] = 0;\r\n  indices[index++] = length;\r\n\r\n  var bottomCorner;\r\n  if (northCap) {\r\n    bottomCorner = height - 1;\r\n  } else {\r\n    var topRightCorner = width - 1;\r\n    indices[index++] = topRightCorner;\r\n    indices[index++] = topRightCorner + length;\r\n    bottomCorner = width + height - 2;\r\n  }\r\n\r\n  indices[index++] = bottomCorner;\r\n  indices[index++] = bottomCorner + length;\r\n\r\n  if (!southCap) {\r\n    var bottomLeftCorner = width + bottomCorner - 1;\r\n    indices[index++] = bottomLeftCorner;\r\n    indices[index] = bottomLeftCorner + length;\r\n  }\r\n\r\n  geo.indices = indices;\r\n\r\n  return geo;\r\n}\r\n\r\n/**\r\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\r\n *\r\n * @alias RectangleOutlineGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\r\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\r\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\r\n *\r\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\r\n *\r\n * @see RectangleOutlineGeometry#createGeometry\r\n *\r\n * @example\r\n * var rectangle = new Cesium.RectangleOutlineGeometry({\r\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\r\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\r\n *   height : 10000.0\r\n * });\r\n * var geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\r\n */\r\nfunction RectangleOutlineGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  var rectangle = options.rectangle;\r\n  var granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  var rotation = defaultValue(options.rotation, 0.0);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(rectangle)) {\r\n    throw new DeveloperError(\"rectangle is required.\");\r\n  }\r\n  Rectangle.validate(rectangle);\r\n  if (rectangle.north < rectangle.south) {\r\n    throw new DeveloperError(\r\n      \"options.rectangle.north must be greater than options.rectangle.south\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var height = defaultValue(options.height, 0.0);\r\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n  this._rectangle = Rectangle.clone(rectangle);\r\n  this._granularity = granularity;\r\n  this._ellipsoid = ellipsoid;\r\n  this._surfaceHeight = Math.max(height, extrudedHeight);\r\n  this._rotation = rotation;\r\n  this._extrudedHeight = Math.min(height, extrudedHeight);\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._workerName = \"createRectangleOutlineGeometry\";\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nRectangleOutlineGeometry.packedLength =\r\n  Rectangle.packedLength + Ellipsoid.packedLength + 5;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {RectangleOutlineGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(value)) {\r\n    throw new DeveloperError(\"value is required\");\r\n  }\r\n\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  Rectangle.pack(value._rectangle, array, startingIndex);\r\n  startingIndex += Rectangle.packedLength;\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  array[startingIndex++] = value._granularity;\r\n  array[startingIndex++] = value._surfaceHeight;\r\n  array[startingIndex++] = value._rotation;\r\n  array[startingIndex++] = value._extrudedHeight;\r\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n  return array;\r\n};\r\n\r\nvar scratchRectangle = new Rectangle();\r\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\nvar scratchOptions = {\r\n  rectangle: scratchRectangle,\r\n  ellipsoid: scratchEllipsoid,\r\n  granularity: undefined,\r\n  height: undefined,\r\n  rotation: undefined,\r\n  extrudedHeight: undefined,\r\n  offsetAttribute: undefined,\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\r\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\r\n */\r\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(array)) {\r\n    throw new DeveloperError(\"array is required\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\r\n  startingIndex += Rectangle.packedLength;\r\n\r\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  var granularity = array[startingIndex++];\r\n  var height = array[startingIndex++];\r\n  var rotation = array[startingIndex++];\r\n  var extrudedHeight = array[startingIndex++];\r\n  var offsetAttribute = array[startingIndex];\r\n\r\n  if (!defined(result)) {\r\n    scratchOptions.granularity = granularity;\r\n    scratchOptions.height = height;\r\n    scratchOptions.rotation = rotation;\r\n    scratchOptions.extrudedHeight = extrudedHeight;\r\n    scratchOptions.offsetAttribute =\r\n      offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n    return new RectangleOutlineGeometry(scratchOptions);\r\n  }\r\n\r\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\r\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n  result._surfaceHeight = height;\r\n  result._rotation = rotation;\r\n  result._extrudedHeight = extrudedHeight;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n  return result;\r\n};\r\n\r\nvar nwScratch = new Cartographic();\r\n/**\r\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n *\r\n * @exception {DeveloperError} Rotated rectangle is invalid.\r\n */\r\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\r\n  var rectangle = rectangleGeometry._rectangle;\r\n  var ellipsoid = rectangleGeometry._ellipsoid;\r\n  var computedOptions = RectangleGeometryLibrary.computeOptions(\r\n    rectangle,\r\n    rectangleGeometry._granularity,\r\n    rectangleGeometry._rotation,\r\n    0,\r\n    rectangleScratch,\r\n    nwScratch\r\n  );\r\n\r\n  var geometry;\r\n  var boundingSphere;\r\n\r\n  if (\r\n    CesiumMath.equalsEpsilon(\r\n      rectangle.north,\r\n      rectangle.south,\r\n      CesiumMath.EPSILON10\r\n    ) ||\r\n    CesiumMath.equalsEpsilon(\r\n      rectangle.east,\r\n      rectangle.west,\r\n      CesiumMath.EPSILON10\r\n    )\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\r\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\r\n  var extrude = !CesiumMath.equalsEpsilon(\r\n    surfaceHeight,\r\n    extrudedHeight,\r\n    0,\r\n    CesiumMath.EPSILON2\r\n  );\r\n  var offsetValue;\r\n  if (extrude) {\r\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\r\n    if (defined(rectangleGeometry._offsetAttribute)) {\r\n      var size = geometry.attributes.position.values.length / 3;\r\n      var offsetAttribute = new Uint8Array(size);\r\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\r\n      } else {\r\n        offsetValue =\r\n          rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n            ? 0\r\n            : 1;\r\n        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\r\n      }\r\n\r\n      geometry.attributes.applyOffset = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n        componentsPerAttribute: 1,\r\n        values: offsetAttribute,\r\n      });\r\n    }\r\n    var topBS = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      surfaceHeight,\r\n      topBoundingSphere\r\n    );\r\n    var bottomBS = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      extrudedHeight,\r\n      bottomBoundingSphere\r\n    );\r\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\r\n  } else {\r\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\r\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n      geometry.attributes.position.values,\r\n      surfaceHeight,\r\n      ellipsoid,\r\n      false\r\n    );\r\n\r\n    if (defined(rectangleGeometry._offsetAttribute)) {\r\n      var length = geometry.attributes.position.values.length;\r\n      var applyOffset = new Uint8Array(length / 3);\r\n      offsetValue =\r\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n          ? 0\r\n          : 1;\r\n      arrayFill(applyOffset, offsetValue);\r\n      geometry.attributes.applyOffset = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n        componentsPerAttribute: 1,\r\n        values: applyOffset,\r\n      });\r\n    }\r\n\r\n    boundingSphere = BoundingSphere.fromRectangle3D(\r\n      rectangle,\r\n      ellipsoid,\r\n      surfaceHeight\r\n    );\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: geometry.attributes,\r\n    indices: geometry.indices,\r\n    primitiveType: PrimitiveType.LINES,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: rectangleGeometry._offsetAttribute,\r\n  });\r\n};\r\nexport default RectangleOutlineGeometry;\r\n","import defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\r\n\r\nfunction createRectangleOutlineGeometry(rectangleGeometry, offset) {\r\n  if (defined(offset)) {\r\n    rectangleGeometry = RectangleOutlineGeometry.unpack(\r\n      rectangleGeometry,\r\n      offset\r\n    );\r\n  }\r\n  rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\r\n  rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\r\n  return RectangleOutlineGeometry.createGeometry(rectangleGeometry);\r\n}\r\nexport default createRectangleOutlineGeometry;\r\n"],"names":["bottomBoundingSphere","BoundingSphere","topBoundingSphere","positionScratch","Cartesian3","rectangleScratch","Rectangle","constructRectangle","geometry","computedOptions","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowHeight","widthMultiplier","size","corners","col","positions","Float64Array","posIndex","row","position","RectangleGeometryLibrary","computePosition","x","y","z","indicesSize","length","indices","IndexDatatype","createTypedArray","index","i","geo","Geometry","attributes","GeometryAttributes","primitiveType","PrimitiveType","LINES","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","RectangleOutlineGeometry","options","rectangle","defaultValue","EMPTY_OBJECT","granularity","CesiumMath","RADIANS_PER_DEGREE","Ellipsoid","WGS84","rotation","defined","DeveloperError","validate","north","south","extrudedHeight","this","_rectangle","clone","_granularity","_surfaceHeight","Math","max","_rotation","_extrudedHeight","min","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","nwScratch","Cartographic","createGeometry","rectangleGeometry","boundingSphere","computeOptions","equalsEpsilon","EPSILON10","east","west","offsetValue","surfaceHeight","EPSILON2","minHeight","maxHeight","topPositions","PolygonPipeline","scaleToGeodeticHeight","set","bottomPositions","bottomCorner","topRightCorner","bottomLeftCorner","constructExtrudedRectangle","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","topBS","fromRectangle3D","bottomBS","union","offset"],"mappings":"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"}