{"version":3,"file":"CorridorGeometryLibrary-edf2593a.js","sources":["../../../../Source/Core/CorridorGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\r\nimport CornerType from \"./CornerType.js\";\r\nimport defined from \"./defined.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport PolylinePipeline from \"./PolylinePipeline.js\";\r\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\n\r\n/**\r\n * @private\r\n */\r\nvar CorridorGeometryLibrary = {};\r\n\r\nvar scratch1 = new Cartesian3();\r\nvar scratch2 = new Cartesian3();\r\nvar scratch3 = new Cartesian3();\r\nvar scratch4 = new Cartesian3();\r\n\r\nvar scaleArray2 = [new Cartesian3(), new Cartesian3()];\r\n\r\nvar cartesian1 = new Cartesian3();\r\nvar cartesian2 = new Cartesian3();\r\nvar cartesian3 = new Cartesian3();\r\nvar cartesian4 = new Cartesian3();\r\nvar cartesian5 = new Cartesian3();\r\nvar cartesian6 = new Cartesian3();\r\nvar cartesian7 = new Cartesian3();\r\nvar cartesian8 = new Cartesian3();\r\nvar cartesian9 = new Cartesian3();\r\nvar cartesian10 = new Cartesian3();\r\n\r\nvar quaterion = new Quaternion();\r\nvar rotMatrix = new Matrix3();\r\nfunction computeRoundCorner(\r\n  cornerPoint,\r\n  startPoint,\r\n  endPoint,\r\n  cornerType,\r\n  leftIsOutside\r\n) {\r\n  var angle = Cartesian3.angleBetween(\r\n    Cartesian3.subtract(startPoint, cornerPoint, scratch1),\r\n    Cartesian3.subtract(endPoint, cornerPoint, scratch2)\r\n  );\r\n  var granularity =\r\n    cornerType === CornerType.BEVELED\r\n      ? 1\r\n      : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\r\n\r\n  var size = granularity * 3;\r\n  var array = new Array(size);\r\n\r\n  array[size - 3] = endPoint.x;\r\n  array[size - 2] = endPoint.y;\r\n  array[size - 1] = endPoint.z;\r\n\r\n  var m;\r\n  if (leftIsOutside) {\r\n    m = Matrix3.fromQuaternion(\r\n      Quaternion.fromAxisAngle(\r\n        Cartesian3.negate(cornerPoint, scratch1),\r\n        angle / granularity,\r\n        quaterion\r\n      ),\r\n      rotMatrix\r\n    );\r\n  } else {\r\n    m = Matrix3.fromQuaternion(\r\n      Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion),\r\n      rotMatrix\r\n    );\r\n  }\r\n\r\n  var index = 0;\r\n  startPoint = Cartesian3.clone(startPoint, scratch1);\r\n  for (var i = 0; i < granularity; i++) {\r\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\r\n    array[index++] = startPoint.x;\r\n    array[index++] = startPoint.y;\r\n    array[index++] = startPoint.z;\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nfunction addEndCaps(calculatedPositions) {\r\n  var cornerPoint = cartesian1;\r\n  var startPoint = cartesian2;\r\n  var endPoint = cartesian3;\r\n\r\n  var leftEdge = calculatedPositions[1];\r\n  startPoint = Cartesian3.fromArray(\r\n    calculatedPositions[1],\r\n    leftEdge.length - 3,\r\n    startPoint\r\n  );\r\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\r\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\r\n  var firstEndCap = computeRoundCorner(\r\n    cornerPoint,\r\n    startPoint,\r\n    endPoint,\r\n    CornerType.ROUNDED,\r\n    false\r\n  );\r\n\r\n  var length = calculatedPositions.length - 1;\r\n  var rightEdge = calculatedPositions[length - 1];\r\n  leftEdge = calculatedPositions[length];\r\n  startPoint = Cartesian3.fromArray(\r\n    rightEdge,\r\n    rightEdge.length - 3,\r\n    startPoint\r\n  );\r\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\r\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\r\n  var lastEndCap = computeRoundCorner(\r\n    cornerPoint,\r\n    startPoint,\r\n    endPoint,\r\n    CornerType.ROUNDED,\r\n    false\r\n  );\r\n\r\n  return [firstEndCap, lastEndCap];\r\n}\r\n\r\nfunction computeMiteredCorner(\r\n  position,\r\n  leftCornerDirection,\r\n  lastPoint,\r\n  leftIsOutside\r\n) {\r\n  var cornerPoint = scratch1;\r\n  if (leftIsOutside) {\r\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\r\n  } else {\r\n    leftCornerDirection = Cartesian3.negate(\r\n      leftCornerDirection,\r\n      leftCornerDirection\r\n    );\r\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\r\n  }\r\n  return [\r\n    cornerPoint.x,\r\n    cornerPoint.y,\r\n    cornerPoint.z,\r\n    lastPoint.x,\r\n    lastPoint.y,\r\n    lastPoint.z,\r\n  ];\r\n}\r\n\r\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\r\n  var rightPositions = new Array(positions.length);\r\n  var leftPositions = new Array(positions.length);\r\n  var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\r\n  var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\r\n  var rightIndex = 0;\r\n  var leftIndex = positions.length - 1;\r\n\r\n  for (var i = 0; i < positions.length; i += 3) {\r\n    var pos = Cartesian3.fromArray(positions, i, scratch3);\r\n    var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\r\n    rightPositions[rightIndex++] = rightPos.x;\r\n    rightPositions[rightIndex++] = rightPos.y;\r\n    rightPositions[rightIndex++] = rightPos.z;\r\n\r\n    var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\r\n    leftPositions[leftIndex--] = leftPos.z;\r\n    leftPositions[leftIndex--] = leftPos.y;\r\n    leftPositions[leftIndex--] = leftPos.x;\r\n  }\r\n  calculatedPositions.push(rightPositions, leftPositions);\r\n\r\n  return calculatedPositions;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nCorridorGeometryLibrary.addAttribute = function (\r\n  attribute,\r\n  value,\r\n  front,\r\n  back\r\n) {\r\n  var x = value.x;\r\n  var y = value.y;\r\n  var z = value.z;\r\n  if (defined(front)) {\r\n    attribute[front] = x;\r\n    attribute[front + 1] = y;\r\n    attribute[front + 2] = z;\r\n  }\r\n  if (defined(back)) {\r\n    attribute[back] = z;\r\n    attribute[back - 1] = y;\r\n    attribute[back - 2] = x;\r\n  }\r\n};\r\n\r\nvar scratchForwardProjection = new Cartesian3();\r\nvar scratchBackwardProjection = new Cartesian3();\r\n\r\n/**\r\n * @private\r\n */\r\nCorridorGeometryLibrary.computePositions = function (params) {\r\n  var granularity = params.granularity;\r\n  var positions = params.positions;\r\n  var ellipsoid = params.ellipsoid;\r\n  var width = params.width / 2;\r\n  var cornerType = params.cornerType;\r\n  var saveAttributes = params.saveAttributes;\r\n  var normal = cartesian1;\r\n  var forward = cartesian2;\r\n  var backward = cartesian3;\r\n  var left = cartesian4;\r\n  var cornerDirection = cartesian5;\r\n  var startPoint = cartesian6;\r\n  var previousPos = cartesian7;\r\n  var rightPos = cartesian8;\r\n  var leftPos = cartesian9;\r\n  var center = cartesian10;\r\n  var calculatedPositions = [];\r\n  var calculatedLefts = saveAttributes ? [] : undefined;\r\n  var calculatedNormals = saveAttributes ? [] : undefined;\r\n  var position = positions[0]; //add first point\r\n  var nextPosition = positions[1];\r\n\r\n  forward = Cartesian3.normalize(\r\n    Cartesian3.subtract(nextPosition, position, forward),\r\n    forward\r\n  );\r\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\r\n  if (saveAttributes) {\r\n    calculatedLefts.push(left.x, left.y, left.z);\r\n    calculatedNormals.push(normal.x, normal.y, normal.z);\r\n  }\r\n  previousPos = Cartesian3.clone(position, previousPos);\r\n  position = nextPosition;\r\n  backward = Cartesian3.negate(forward, backward);\r\n\r\n  var subdividedPositions;\r\n  var corners = [];\r\n  var i;\r\n  var length = positions.length;\r\n  for (i = 1; i < length - 1; i++) {\r\n    // add middle points and corners\r\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n    nextPosition = positions[i + 1];\r\n    forward = Cartesian3.normalize(\r\n      Cartesian3.subtract(nextPosition, position, forward),\r\n      forward\r\n    );\r\n    cornerDirection = Cartesian3.normalize(\r\n      Cartesian3.add(forward, backward, cornerDirection),\r\n      cornerDirection\r\n    );\r\n\r\n    var forwardProjection = Cartesian3.multiplyByScalar(\r\n      normal,\r\n      Cartesian3.dot(forward, normal),\r\n      scratchForwardProjection\r\n    );\r\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\r\n    Cartesian3.normalize(forwardProjection, forwardProjection);\r\n\r\n    var backwardProjection = Cartesian3.multiplyByScalar(\r\n      normal,\r\n      Cartesian3.dot(backward, normal),\r\n      scratchBackwardProjection\r\n    );\r\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\r\n    Cartesian3.normalize(backwardProjection, backwardProjection);\r\n\r\n    var doCorner = !CesiumMath.equalsEpsilon(\r\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\r\n      1.0,\r\n      CesiumMath.EPSILON7\r\n    );\r\n\r\n    if (doCorner) {\r\n      cornerDirection = Cartesian3.cross(\r\n        cornerDirection,\r\n        normal,\r\n        cornerDirection\r\n      );\r\n      cornerDirection = Cartesian3.cross(\r\n        normal,\r\n        cornerDirection,\r\n        cornerDirection\r\n      );\r\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\r\n      var scalar =\r\n        width /\r\n        Math.max(\r\n          0.25,\r\n          Cartesian3.magnitude(\r\n            Cartesian3.cross(cornerDirection, backward, scratch1)\r\n          )\r\n        );\r\n      var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\r\n        forward,\r\n        backward,\r\n        position,\r\n        ellipsoid\r\n      );\r\n      cornerDirection = Cartesian3.multiplyByScalar(\r\n        cornerDirection,\r\n        scalar,\r\n        cornerDirection\r\n      );\r\n      if (leftIsOutside) {\r\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\r\n        center = Cartesian3.add(\r\n          rightPos,\r\n          Cartesian3.multiplyByScalar(left, width, center),\r\n          center\r\n        );\r\n        leftPos = Cartesian3.add(\r\n          rightPos,\r\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\r\n          leftPos\r\n        );\r\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\r\n        subdividedPositions = PolylinePipeline.generateArc({\r\n          positions: scaleArray2,\r\n          granularity: granularity,\r\n          ellipsoid: ellipsoid,\r\n        });\r\n        calculatedPositions = addShiftedPositions(\r\n          subdividedPositions,\r\n          left,\r\n          width,\r\n          calculatedPositions\r\n        );\r\n        if (saveAttributes) {\r\n          calculatedLefts.push(left.x, left.y, left.z);\r\n          calculatedNormals.push(normal.x, normal.y, normal.z);\r\n        }\r\n        startPoint = Cartesian3.clone(leftPos, startPoint);\r\n        left = Cartesian3.normalize(\r\n          Cartesian3.cross(normal, forward, left),\r\n          left\r\n        );\r\n        leftPos = Cartesian3.add(\r\n          rightPos,\r\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\r\n          leftPos\r\n        );\r\n        previousPos = Cartesian3.add(\r\n          rightPos,\r\n          Cartesian3.multiplyByScalar(left, width, previousPos),\r\n          previousPos\r\n        );\r\n        if (\r\n          cornerType === CornerType.ROUNDED ||\r\n          cornerType === CornerType.BEVELED\r\n        ) {\r\n          corners.push({\r\n            leftPositions: computeRoundCorner(\r\n              rightPos,\r\n              startPoint,\r\n              leftPos,\r\n              cornerType,\r\n              leftIsOutside\r\n            ),\r\n          });\r\n        } else {\r\n          corners.push({\r\n            leftPositions: computeMiteredCorner(\r\n              position,\r\n              Cartesian3.negate(cornerDirection, cornerDirection),\r\n              leftPos,\r\n              leftIsOutside\r\n            ),\r\n          });\r\n        }\r\n      } else {\r\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\r\n        center = Cartesian3.add(\r\n          leftPos,\r\n          Cartesian3.negate(\r\n            Cartesian3.multiplyByScalar(left, width, center),\r\n            center\r\n          ),\r\n          center\r\n        );\r\n        rightPos = Cartesian3.add(\r\n          leftPos,\r\n          Cartesian3.negate(\r\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\r\n            rightPos\r\n          ),\r\n          rightPos\r\n        );\r\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\r\n        subdividedPositions = PolylinePipeline.generateArc({\r\n          positions: scaleArray2,\r\n          granularity: granularity,\r\n          ellipsoid: ellipsoid,\r\n        });\r\n        calculatedPositions = addShiftedPositions(\r\n          subdividedPositions,\r\n          left,\r\n          width,\r\n          calculatedPositions\r\n        );\r\n        if (saveAttributes) {\r\n          calculatedLefts.push(left.x, left.y, left.z);\r\n          calculatedNormals.push(normal.x, normal.y, normal.z);\r\n        }\r\n        startPoint = Cartesian3.clone(rightPos, startPoint);\r\n        left = Cartesian3.normalize(\r\n          Cartesian3.cross(normal, forward, left),\r\n          left\r\n        );\r\n        rightPos = Cartesian3.add(\r\n          leftPos,\r\n          Cartesian3.negate(\r\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\r\n            rightPos\r\n          ),\r\n          rightPos\r\n        );\r\n        previousPos = Cartesian3.add(\r\n          leftPos,\r\n          Cartesian3.negate(\r\n            Cartesian3.multiplyByScalar(left, width, previousPos),\r\n            previousPos\r\n          ),\r\n          previousPos\r\n        );\r\n        if (\r\n          cornerType === CornerType.ROUNDED ||\r\n          cornerType === CornerType.BEVELED\r\n        ) {\r\n          corners.push({\r\n            rightPositions: computeRoundCorner(\r\n              leftPos,\r\n              startPoint,\r\n              rightPos,\r\n              cornerType,\r\n              leftIsOutside\r\n            ),\r\n          });\r\n        } else {\r\n          corners.push({\r\n            rightPositions: computeMiteredCorner(\r\n              position,\r\n              cornerDirection,\r\n              rightPos,\r\n              leftIsOutside\r\n            ),\r\n          });\r\n        }\r\n      }\r\n      backward = Cartesian3.negate(forward, backward);\r\n    }\r\n    position = nextPosition;\r\n  }\r\n\r\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\r\n  subdividedPositions = PolylinePipeline.generateArc({\r\n    positions: scaleArray2,\r\n    granularity: granularity,\r\n    ellipsoid: ellipsoid,\r\n  });\r\n  calculatedPositions = addShiftedPositions(\r\n    subdividedPositions,\r\n    left,\r\n    width,\r\n    calculatedPositions\r\n  );\r\n  if (saveAttributes) {\r\n    calculatedLefts.push(left.x, left.y, left.z);\r\n    calculatedNormals.push(normal.x, normal.y, normal.z);\r\n  }\r\n\r\n  var endPositions;\r\n  if (cornerType === CornerType.ROUNDED) {\r\n    endPositions = addEndCaps(calculatedPositions);\r\n  }\r\n\r\n  return {\r\n    positions: calculatedPositions,\r\n    corners: corners,\r\n    lefts: calculatedLefts,\r\n    normals: calculatedNormals,\r\n    endPositions: endPositions,\r\n  };\r\n};\r\nexport default CorridorGeometryLibrary;\r\n"],"names":["CorridorGeometryLibrary","scratch1","Cartesian3","scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","Quaternion","rotMatrix","Matrix3","computeRoundCorner","cornerPoint","startPoint","endPoint","cornerType","leftIsOutside","m","angle","angleBetween","subtract","granularity","CornerType","BEVELED","Math","ceil","CesiumMath","toRadians","size","array","Array","x","y","z","fromQuaternion","fromAxisAngle","negate","index","clone","i","multiplyByVector","computeMiteredCorner","position","leftCornerDirection","lastPoint","add","addShiftedPositions","positions","left","scalar","calculatedPositions","rightPositions","length","leftPositions","scaledLeft","multiplyByScalar","scaledRight","rightIndex","leftIndex","pos","fromArray","rightPos","leftPos","push","addAttribute","attribute","value","front","back","defined","scratchForwardProjection","scratchBackwardProjection","computePositions","params","ellipsoid","width","saveAttributes","normal","forward","backward","cornerDirection","previousPos","center","calculatedLefts","undefined","calculatedNormals","nextPosition","normalize","geodeticSurfaceNormal","cross","endPositions","corners","forwardProjection","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","max","magnitude","PolylineVolumeGeometryLibrary","angleIsGreaterThanPi","PolylinePipeline","generateArc","ROUNDED","leftEdge","firstEndCap","midpoint","rightEdge","addEndCaps","lefts","normals"],"mappings":"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"}