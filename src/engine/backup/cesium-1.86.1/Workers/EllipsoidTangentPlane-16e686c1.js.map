{"version":3,"file":"EllipsoidTangentPlane-16e686c1.js","sources":["../../../../Source/Core/EllipsoidTangentPlane.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartesian4 from \"./Cartesian4.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport IntersectionTests from \"./IntersectionTests.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport Plane from \"./Plane.js\";\r\nimport Ray from \"./Ray.js\";\r\nimport Transforms from \"./Transforms.js\";\r\n\r\nvar scratchCart4 = new Cartesian4();\r\n/**\r\n * A plane tangent to the provided ellipsoid at the provided origin.\r\n * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\r\n * If origin is at the center of the ellipsoid, an exception will be thrown.\r\n * @alias EllipsoidTangentPlane\r\n * @constructor\r\n *\r\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\r\n *\r\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\r\n */\r\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"origin\", origin);\r\n  //>>includeEnd('debug');\r\n\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n  origin = ellipsoid.scaleToGeodeticSurface(origin);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(origin)) {\r\n    throw new DeveloperError(\r\n      \"origin must not be at the center of the ellipsoid.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\r\n  this._ellipsoid = ellipsoid;\r\n  this._origin = origin;\r\n  this._xAxis = Cartesian3.fromCartesian4(\r\n    Matrix4.getColumn(eastNorthUp, 0, scratchCart4)\r\n  );\r\n  this._yAxis = Cartesian3.fromCartesian4(\r\n    Matrix4.getColumn(eastNorthUp, 1, scratchCart4)\r\n  );\r\n\r\n  var normal = Cartesian3.fromCartesian4(\r\n    Matrix4.getColumn(eastNorthUp, 2, scratchCart4)\r\n  );\r\n  this._plane = Plane.fromPointNormal(origin, normal);\r\n}\r\n\r\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\r\n  /**\r\n   * Gets the ellipsoid.\r\n   * @memberof EllipsoidTangentPlane.prototype\r\n   * @type {Ellipsoid}\r\n   */\r\n  ellipsoid: {\r\n    get: function () {\r\n      return this._ellipsoid;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the origin.\r\n   * @memberof EllipsoidTangentPlane.prototype\r\n   * @type {Cartesian3}\r\n   */\r\n  origin: {\r\n    get: function () {\r\n      return this._origin;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the plane which is tangent to the ellipsoid.\r\n   * @memberof EllipsoidTangentPlane.prototype\r\n   * @readonly\r\n   * @type {Plane}\r\n   */\r\n  plane: {\r\n    get: function () {\r\n      return this._plane;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the local X-axis (east) of the tangent plane.\r\n   * @memberof EllipsoidTangentPlane.prototype\r\n   * @readonly\r\n   * @type {Cartesian3}\r\n   */\r\n  xAxis: {\r\n    get: function () {\r\n      return this._xAxis;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the local Y-axis (north) of the tangent plane.\r\n   * @memberof EllipsoidTangentPlane.prototype\r\n   * @readonly\r\n   * @type {Cartesian3}\r\n   */\r\n  yAxis: {\r\n    get: function () {\r\n      return this._yAxis;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the local Z-axis (up) of the tangent plane.\r\n   * @memberof EllipsoidTangentPlane.prototype\r\n   * @readonly\r\n   * @type {Cartesian3}\r\n   */\r\n  zAxis: {\r\n    get: function () {\r\n      return this._plane.normal;\r\n    },\r\n  },\r\n});\r\n\r\nvar tmp = new AxisAlignedBoundingBox();\r\n/**\r\n * Creates a new instance from the provided ellipsoid and the center\r\n * point of the provided Cartesians.\r\n *\r\n * @param {Cartesian3[]} cartesians The list of positions surrounding the center point.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\r\n * @returns {EllipsoidTangentPlane} The new instance of EllipsoidTangentPlane.\r\n */\r\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesians\", cartesians);\r\n  //>>includeEnd('debug');\r\n\r\n  var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\r\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\r\n};\r\n\r\nvar scratchProjectPointOntoPlaneRay = new Ray();\r\nvar scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\r\n\r\n/**\r\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\r\n *\r\n * @param {Cartesian3} cartesian The point to project.\r\n * @param {Cartesian2} [result] The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\r\n */\r\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (\r\n  cartesian,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  var ray = scratchProjectPointOntoPlaneRay;\r\n  ray.origin = cartesian;\r\n  Cartesian3.normalize(cartesian, ray.direction);\r\n\r\n  var intersectionPoint = IntersectionTests.rayPlane(\r\n    ray,\r\n    this._plane,\r\n    scratchProjectPointOntoPlaneCartesian3\r\n  );\r\n  if (!defined(intersectionPoint)) {\r\n    Cartesian3.negate(ray.direction, ray.direction);\r\n    intersectionPoint = IntersectionTests.rayPlane(\r\n      ray,\r\n      this._plane,\r\n      scratchProjectPointOntoPlaneCartesian3\r\n    );\r\n  }\r\n\r\n  if (defined(intersectionPoint)) {\r\n    var v = Cartesian3.subtract(\r\n      intersectionPoint,\r\n      this._origin,\r\n      intersectionPoint\r\n    );\r\n    var x = Cartesian3.dot(this._xAxis, v);\r\n    var y = Cartesian3.dot(this._yAxis, v);\r\n\r\n    if (!defined(result)) {\r\n      return new Cartesian2(x, y);\r\n    }\r\n    result.x = x;\r\n    result.y = y;\r\n    return result;\r\n  }\r\n  return undefined;\r\n};\r\n\r\n/**\r\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\r\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\r\n *\r\n * @see EllipsoidTangentPlane.projectPointOntoPlane\r\n *\r\n * @param {Cartesian3[]} cartesians The array of points to project.\r\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\r\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\r\n */\r\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (\r\n  cartesians,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesians\", cartesians);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = [];\r\n  }\r\n\r\n  var count = 0;\r\n  var length = cartesians.length;\r\n  for (var i = 0; i < length; i++) {\r\n    var p = this.projectPointOntoPlane(cartesians[i], result[count]);\r\n    if (defined(p)) {\r\n      result[count] = p;\r\n      count++;\r\n    }\r\n  }\r\n  result.length = count;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\r\n *\r\n * @param {Cartesian3} cartesian The point to project.\r\n * @param {Cartesian2} [result] The object onto which to store the result.\r\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\r\n */\r\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (\r\n  cartesian,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian2();\r\n  }\r\n\r\n  var ray = scratchProjectPointOntoPlaneRay;\r\n  ray.origin = cartesian;\r\n  Cartesian3.clone(this._plane.normal, ray.direction);\r\n\r\n  var intersectionPoint = IntersectionTests.rayPlane(\r\n    ray,\r\n    this._plane,\r\n    scratchProjectPointOntoPlaneCartesian3\r\n  );\r\n  if (!defined(intersectionPoint)) {\r\n    Cartesian3.negate(ray.direction, ray.direction);\r\n    intersectionPoint = IntersectionTests.rayPlane(\r\n      ray,\r\n      this._plane,\r\n      scratchProjectPointOntoPlaneCartesian3\r\n    );\r\n  }\r\n\r\n  var v = Cartesian3.subtract(\r\n    intersectionPoint,\r\n    this._origin,\r\n    intersectionPoint\r\n  );\r\n  var x = Cartesian3.dot(this._xAxis, v);\r\n  var y = Cartesian3.dot(this._yAxis, v);\r\n\r\n  result.x = x;\r\n  result.y = y;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\r\n *\r\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\r\n *\r\n * @param {Cartesian3[]} cartesians The array of points to project.\r\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\r\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\r\n */\r\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (\r\n  cartesians,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesians\", cartesians);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = [];\r\n  }\r\n\r\n  var length = cartesians.length;\r\n  result.length = length;\r\n  for (var i = 0; i < length; i++) {\r\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\r\n  }\r\n  return result;\r\n};\r\n\r\nvar projectPointsOntoEllipsoidScratch = new Cartesian3();\r\n/**\r\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\r\n *\r\n * @param {Cartesian2} cartesian The points to project.\r\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\r\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n */\r\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (\r\n  cartesian,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesian\", cartesian);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Cartesian3();\r\n  }\r\n\r\n  var ellipsoid = this._ellipsoid;\r\n  var origin = this._origin;\r\n  var xAxis = this._xAxis;\r\n  var yAxis = this._yAxis;\r\n  var tmp = projectPointsOntoEllipsoidScratch;\r\n\r\n  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\r\n  result = Cartesian3.add(origin, tmp, result);\r\n  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\r\n  Cartesian3.add(result, tmp, result);\r\n  ellipsoid.scaleToGeocentricSurface(result, result);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\r\n *\r\n * @param {Cartesian2[]} cartesians The array of points to project.\r\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\r\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\r\n */\r\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (\r\n  cartesians,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"cartesians\", cartesians);\r\n  //>>includeEnd('debug');\r\n\r\n  var length = cartesians.length;\r\n  if (!defined(result)) {\r\n    result = new Array(length);\r\n  } else {\r\n    result.length = length;\r\n  }\r\n\r\n  for (var i = 0; i < length; ++i) {\r\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\r\n  }\r\n\r\n  return result;\r\n};\r\nexport default EllipsoidTangentPlane;\r\n"],"names":["scratchCart4","Cartesian4","EllipsoidTangentPlane","origin","ellipsoid","Check","defined","defaultValue","Ellipsoid","WGS84","scaleToGeodeticSurface","DeveloperError","eastNorthUp","Transforms","eastNorthUpToFixedFrame","this","_ellipsoid","_origin","_xAxis","Cartesian3","fromCartesian4","Matrix4","getColumn","_yAxis","normal","_plane","Plane","fromPointNormal","Object","defineProperties","prototype","get","plane","xAxis","yAxis","zAxis","tmp","AxisAlignedBoundingBox","fromPoints","cartesians","center","scratchProjectPointOntoPlaneRay","Ray","scratchProjectPointOntoPlaneCartesian3","projectPointOntoPlane","cartesian","result","ray","normalize","direction","intersectionPoint","IntersectionTests","rayPlane","negate","v","subtract","x","dot","y","Cartesian2","projectPointsOntoPlane","count","length","i","p","projectPointToNearestOnPlane","clone","projectPointsToNearestOnPlane","projectPointsOntoEllipsoidScratch","projectPointOntoEllipsoid","multiplyByScalar","add","scaleToGeocentricSurface","projectPointsOntoEllipsoid","Array"],"mappings":"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"}