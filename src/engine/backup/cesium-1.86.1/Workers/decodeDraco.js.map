{"version":3,"file":"decodeDraco.js","sources":["../../../../Source/WorkersES6/decodeDraco.js"],"sourcesContent":["/* global require */\r\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\r\nimport RuntimeError from \"../Core/RuntimeError.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nvar draco;\r\n\r\nfunction decodeIndexArray(dracoGeometry, dracoDecoder) {\r\n  var numPoints = dracoGeometry.num_points();\r\n  var numFaces = dracoGeometry.num_faces();\r\n  var faceIndices = new draco.DracoInt32Array();\r\n  var numIndices = numFaces * 3;\r\n  var indexArray = IndexDatatype.createTypedArray(numPoints, numIndices);\r\n\r\n  var offset = 0;\r\n  for (var i = 0; i < numFaces; ++i) {\r\n    dracoDecoder.GetFaceFromMesh(dracoGeometry, i, faceIndices);\r\n\r\n    indexArray[offset + 0] = faceIndices.GetValue(0);\r\n    indexArray[offset + 1] = faceIndices.GetValue(1);\r\n    indexArray[offset + 2] = faceIndices.GetValue(2);\r\n    offset += 3;\r\n  }\r\n\r\n  draco.destroy(faceIndices);\r\n\r\n  return {\r\n    typedArray: indexArray,\r\n    numberOfIndices: numIndices,\r\n  };\r\n}\r\n\r\nfunction decodeQuantizedDracoTypedArray(\r\n  dracoGeometry,\r\n  dracoDecoder,\r\n  dracoAttribute,\r\n  quantization,\r\n  vertexArrayLength\r\n) {\r\n  var vertexArray;\r\n  var attributeData;\r\n  if (quantization.quantizationBits <= 8) {\r\n    attributeData = new draco.DracoUInt8Array();\r\n    vertexArray = new Uint8Array(vertexArrayLength);\r\n    dracoDecoder.GetAttributeUInt8ForAllPoints(\r\n      dracoGeometry,\r\n      dracoAttribute,\r\n      attributeData\r\n    );\r\n  } else {\r\n    attributeData = new draco.DracoUInt16Array();\r\n    vertexArray = new Uint16Array(vertexArrayLength);\r\n    dracoDecoder.GetAttributeUInt16ForAllPoints(\r\n      dracoGeometry,\r\n      dracoAttribute,\r\n      attributeData\r\n    );\r\n  }\r\n\r\n  for (var i = 0; i < vertexArrayLength; ++i) {\r\n    vertexArray[i] = attributeData.GetValue(i);\r\n  }\r\n\r\n  draco.destroy(attributeData);\r\n  return vertexArray;\r\n}\r\n\r\nfunction decodeDracoTypedArray(\r\n  dracoGeometry,\r\n  dracoDecoder,\r\n  dracoAttribute,\r\n  vertexArrayLength\r\n) {\r\n  var vertexArray;\r\n  var attributeData;\r\n\r\n  // Some attribute types are casted down to 32 bit since Draco only returns 32 bit values\r\n  switch (dracoAttribute.data_type()) {\r\n    case 1:\r\n    case 11: // DT_INT8 or DT_BOOL\r\n      attributeData = new draco.DracoInt8Array();\r\n      vertexArray = new Int8Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeInt8ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 2: // DT_UINT8\r\n      attributeData = new draco.DracoUInt8Array();\r\n      vertexArray = new Uint8Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeUInt8ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 3: // DT_INT16\r\n      attributeData = new draco.DracoInt16Array();\r\n      vertexArray = new Int16Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeInt16ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 4: // DT_UINT16\r\n      attributeData = new draco.DracoUInt16Array();\r\n      vertexArray = new Uint16Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeUInt16ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 5:\r\n    case 7: // DT_INT32 or DT_INT64\r\n      attributeData = new draco.DracoInt32Array();\r\n      vertexArray = new Int32Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeInt32ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 6:\r\n    case 8: // DT_UINT32 or DT_UINT64\r\n      attributeData = new draco.DracoUInt32Array();\r\n      vertexArray = new Uint32Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeUInt32ForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n    case 9:\r\n    case 10: // DT_FLOAT32 or DT_FLOAT64\r\n      attributeData = new draco.DracoFloat32Array();\r\n      vertexArray = new Float32Array(vertexArrayLength);\r\n      dracoDecoder.GetAttributeFloatForAllPoints(\r\n        dracoGeometry,\r\n        dracoAttribute,\r\n        attributeData\r\n      );\r\n      break;\r\n  }\r\n\r\n  for (var i = 0; i < vertexArrayLength; ++i) {\r\n    vertexArray[i] = attributeData.GetValue(i);\r\n  }\r\n\r\n  draco.destroy(attributeData);\r\n  return vertexArray;\r\n}\r\n\r\nfunction decodeAttribute(dracoGeometry, dracoDecoder, dracoAttribute) {\r\n  var numPoints = dracoGeometry.num_points();\r\n  var numComponents = dracoAttribute.num_components();\r\n\r\n  var quantization;\r\n  var transform = new draco.AttributeQuantizationTransform();\r\n  if (transform.InitFromAttribute(dracoAttribute)) {\r\n    var minValues = new Array(numComponents);\r\n    for (var i = 0; i < numComponents; ++i) {\r\n      minValues[i] = transform.min_value(i);\r\n    }\r\n    quantization = {\r\n      quantizationBits: transform.quantization_bits(),\r\n      minValues: minValues,\r\n      range: transform.range(),\r\n      octEncoded: false,\r\n    };\r\n  }\r\n  draco.destroy(transform);\r\n\r\n  transform = new draco.AttributeOctahedronTransform();\r\n  if (transform.InitFromAttribute(dracoAttribute)) {\r\n    quantization = {\r\n      quantizationBits: transform.quantization_bits(),\r\n      octEncoded: true,\r\n    };\r\n  }\r\n  draco.destroy(transform);\r\n\r\n  var vertexArrayLength = numPoints * numComponents;\r\n  var vertexArray;\r\n  if (defined(quantization)) {\r\n    vertexArray = decodeQuantizedDracoTypedArray(\r\n      dracoGeometry,\r\n      dracoDecoder,\r\n      dracoAttribute,\r\n      quantization,\r\n      vertexArrayLength\r\n    );\r\n  } else {\r\n    vertexArray = decodeDracoTypedArray(\r\n      dracoGeometry,\r\n      dracoDecoder,\r\n      dracoAttribute,\r\n      vertexArrayLength\r\n    );\r\n  }\r\n\r\n  var componentDatatype = ComponentDatatype.fromTypedArray(vertexArray);\r\n\r\n  return {\r\n    array: vertexArray,\r\n    data: {\r\n      componentsPerAttribute: numComponents,\r\n      componentDatatype: componentDatatype,\r\n      byteOffset: dracoAttribute.byte_offset(),\r\n      byteStride:\r\n        ComponentDatatype.getSizeInBytes(componentDatatype) * numComponents,\r\n      normalized: dracoAttribute.normalized(),\r\n      quantization: quantization,\r\n    },\r\n  };\r\n}\r\n\r\nfunction decodePointCloud(parameters) {\r\n  var dracoDecoder = new draco.Decoder();\r\n\r\n  if (parameters.dequantizeInShader) {\r\n    dracoDecoder.SkipAttributeTransform(draco.POSITION);\r\n    dracoDecoder.SkipAttributeTransform(draco.NORMAL);\r\n  }\r\n\r\n  var buffer = new draco.DecoderBuffer();\r\n  buffer.Init(parameters.buffer, parameters.buffer.length);\r\n\r\n  var geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\r\n  if (geometryType !== draco.POINT_CLOUD) {\r\n    throw new RuntimeError(\"Draco geometry type must be POINT_CLOUD.\");\r\n  }\r\n\r\n  var dracoPointCloud = new draco.PointCloud();\r\n  var decodingStatus = dracoDecoder.DecodeBufferToPointCloud(\r\n    buffer,\r\n    dracoPointCloud\r\n  );\r\n  if (!decodingStatus.ok() || dracoPointCloud.ptr === 0) {\r\n    throw new RuntimeError(\r\n      \"Error decoding draco point cloud: \" + decodingStatus.error_msg()\r\n    );\r\n  }\r\n\r\n  draco.destroy(buffer);\r\n\r\n  var result = {};\r\n\r\n  var properties = parameters.properties;\r\n  for (var propertyName in properties) {\r\n    if (properties.hasOwnProperty(propertyName)) {\r\n      var attributeId = properties[propertyName];\r\n      var dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\r\n        dracoPointCloud,\r\n        attributeId\r\n      );\r\n      result[propertyName] = decodeAttribute(\r\n        dracoPointCloud,\r\n        dracoDecoder,\r\n        dracoAttribute\r\n      );\r\n    }\r\n  }\r\n\r\n  draco.destroy(dracoPointCloud);\r\n  draco.destroy(dracoDecoder);\r\n\r\n  return result;\r\n}\r\n\r\nfunction decodePrimitive(parameters) {\r\n  var dracoDecoder = new draco.Decoder();\r\n\r\n  var bufferView = parameters.bufferView;\r\n  var buffer = new draco.DecoderBuffer();\r\n  buffer.Init(parameters.array, bufferView.byteLength);\r\n\r\n  var geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\r\n  if (geometryType !== draco.TRIANGULAR_MESH) {\r\n    throw new RuntimeError(\"Unsupported draco mesh geometry type.\");\r\n  }\r\n\r\n  var dracoGeometry = new draco.Mesh();\r\n  var decodingStatus = dracoDecoder.DecodeBufferToMesh(buffer, dracoGeometry);\r\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\r\n    throw new RuntimeError(\r\n      \"Error decoding draco mesh geometry: \" + decodingStatus.error_msg()\r\n    );\r\n  }\r\n\r\n  draco.destroy(buffer);\r\n\r\n  var attributeData = {};\r\n\r\n  var compressedAttributes = parameters.compressedAttributes;\r\n  for (var attributeName in compressedAttributes) {\r\n    if (compressedAttributes.hasOwnProperty(attributeName)) {\r\n      var compressedAttribute = compressedAttributes[attributeName];\r\n      var dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\r\n        dracoGeometry,\r\n        compressedAttribute\r\n      );\r\n      attributeData[attributeName] = decodeAttribute(\r\n        dracoGeometry,\r\n        dracoDecoder,\r\n        dracoAttribute\r\n      );\r\n    }\r\n  }\r\n\r\n  var result = {\r\n    indexArray: decodeIndexArray(dracoGeometry, dracoDecoder),\r\n    attributeData: attributeData,\r\n  };\r\n\r\n  draco.destroy(dracoGeometry);\r\n  draco.destroy(dracoDecoder);\r\n\r\n  return result;\r\n}\r\n\r\nfunction decode(parameters) {\r\n  if (defined(parameters.bufferView)) {\r\n    return decodePrimitive(parameters);\r\n  }\r\n  return decodePointCloud(parameters);\r\n}\r\n\r\nfunction initWorker(dracoModule) {\r\n  draco = dracoModule;\r\n  self.onmessage = createTaskProcessorWorker(decode);\r\n  self.postMessage(true);\r\n}\r\n\r\nfunction decodeDraco(event) {\r\n  var data = event.data;\r\n\r\n  // Expect the first message to be to load a web assembly module\r\n  var wasmConfig = data.webAssemblyConfig;\r\n  if (defined(wasmConfig)) {\r\n    // Require and compile WebAssembly module, or use fallback if not supported\r\n    return require([wasmConfig.modulePath], function (dracoModule) {\r\n      if (defined(wasmConfig.wasmBinaryFile)) {\r\n        if (!defined(dracoModule)) {\r\n          dracoModule = self.DracoDecoderModule;\r\n        }\r\n\r\n        dracoModule(wasmConfig).then(function (compiledModule) {\r\n          initWorker(compiledModule);\r\n        });\r\n      } else {\r\n        initWorker(dracoModule());\r\n      }\r\n    });\r\n  }\r\n}\r\nexport default decodeDraco;\r\n"],"names":["draco","decodeIndexArray","dracoGeometry","dracoDecoder","numPoints","num_points","numFaces","num_faces","faceIndices","DracoInt32Array","numIndices","indexArray","IndexDatatype","createTypedArray","offset","i","GetFaceFromMesh","GetValue","destroy","typedArray","numberOfIndices","decodeAttribute","dracoAttribute","quantization","numComponents","num_components","transform","AttributeQuantizationTransform","InitFromAttribute","minValues","Array","min_value","quantizationBits","quantization_bits","range","octEncoded","AttributeOctahedronTransform","vertexArray","vertexArrayLength","defined","attributeData","DracoUInt8Array","Uint8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","Uint16Array","GetAttributeUInt16ForAllPoints","decodeQuantizedDracoTypedArray","data_type","DracoInt8Array","Int8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","Int16Array","GetAttributeInt16ForAllPoints","Int32Array","GetAttributeInt32ForAllPoints","DracoUInt32Array","Uint32Array","GetAttributeUInt32ForAllPoints","DracoFloat32Array","Float32Array","GetAttributeFloatForAllPoints","decodeDracoTypedArray","componentDatatype","ComponentDatatype","fromTypedArray","array","data","componentsPerAttribute","byteOffset","byte_offset","byteStride","getSizeInBytes","normalized","decode","parameters","bufferView","Decoder","buffer","DecoderBuffer","Init","byteLength","GetEncodedGeometryType","TRIANGULAR_MESH","RuntimeError","Mesh","decodingStatus","DecodeBufferToMesh","ok","ptr","error_msg","compressedAttributes","attributeName","hasOwnProperty","compressedAttribute","GetAttributeByUniqueId","result","decodePrimitive","dequantizeInShader","SkipAttributeTransform","POSITION","NORMAL","length","POINT_CLOUD","dracoPointCloud","PointCloud","DecodeBufferToPointCloud","properties","propertyName","attributeId","decodePointCloud","initWorker","dracoModule","self","onmessage","createTaskProcessorWorker","postMessage","event","wasmConfig","webAssemblyConfig","require","modulePath","wasmBinaryFile","DracoDecoderModule","then","compiledModule"],"mappings":"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"}