define(["exports","./GeometryOffsetAttribute-036749bc","./Transforms-e254a706","./Matrix2-b06ef836","./ComponentDatatype-dc3af6a4","./CylinderGeometryLibrary-421d70ff","./when-229515d6","./RuntimeError-ffe03243","./GeometryAttribute-b662d87a","./GeometryAttributes-b253752a","./IndexDatatype-87b580b0","./VertexFormat-64c5c4fb"],(function(t,e,r,a,o,n,i,s,u,f,m,d){"use strict";var p=new a.Cartesian2,l=new a.Cartesian3,y=new a.Cartesian3,b=new a.Cartesian3,v=new a.Cartesian3;function c(t){var r=(t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT)).length,a=t.topRadius,o=t.bottomRadius,n=i.defaultValue(t.vertexFormat,d.VertexFormat.DEFAULT),u=i.defaultValue(t.slices,128);if(!i.defined(r))throw new s.DeveloperError("options.length must be defined.");if(!i.defined(a))throw new s.DeveloperError("options.topRadius must be defined.");if(!i.defined(o))throw new s.DeveloperError("options.bottomRadius must be defined.");if(u<3)throw new s.DeveloperError("options.slices must be greater than or equal to 3.");if(i.defined(t.offsetAttribute)&&t.offsetAttribute===e.GeometryOffsetAttribute.TOP)throw new s.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=r,this._topRadius=a,this._bottomRadius=o,this._vertexFormat=d.VertexFormat.clone(n),this._slices=u,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}c.packedLength=d.VertexFormat.packedLength+5,c.pack=function(t,e,r){if(!i.defined(t))throw new s.DeveloperError("value is required");if(!i.defined(e))throw new s.DeveloperError("array is required");return r=i.defaultValue(r,0),d.VertexFormat.pack(t._vertexFormat,e,r),r+=d.VertexFormat.packedLength,e[r++]=t._length,e[r++]=t._topRadius,e[r++]=t._bottomRadius,e[r++]=t._slices,e[r]=i.defaultValue(t._offsetAttribute,-1),e};var A,h=new d.VertexFormat,w={vertexFormat:h,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};c.unpack=function(t,e,r){if(!i.defined(t))throw new s.DeveloperError("array is required");e=i.defaultValue(e,0);var a=d.VertexFormat.unpack(t,e,h);e+=d.VertexFormat.packedLength;var o=t[e++],n=t[e++],u=t[e++],f=t[e++],m=t[e];return i.defined(r)?(r._vertexFormat=d.VertexFormat.clone(a,r._vertexFormat),r._length=o,r._topRadius=n,r._bottomRadius=u,r._slices=f,r._offsetAttribute=-1===m?void 0:m,r):(w.length=o,w.topRadius=n,w.bottomRadius=u,w.slices=f,w.offsetAttribute=-1===m?void 0:m,new c(w))},c.createGeometry=function(t){var s=t._length,d=t._topRadius,c=t._bottomRadius,A=t._vertexFormat,h=t._slices;if(!(s<=0||d<0||c<0||0===d&&0===c)){var w,g=h+h,x=h+g,_=g+g,F=n.CylinderGeometryLibrary.computePositions(s,d,c,h,!0),C=A.st?new Float32Array(2*_):void 0,D=A.normal?new Float32Array(3*_):void 0,G=A.tangent?new Float32Array(3*_):void 0,R=A.bitangent?new Float32Array(3*_):void 0,O=A.normal||A.tangent||A.bitangent;if(O){var E=A.tangent||A.bitangent,T=0,V=0,L=0,P=Math.atan2(c-d,s),M=l;M.z=Math.sin(P);var k=Math.cos(P),z=b,N=y;for(w=0;w<h;w++){var I=w/h*o.CesiumMath.TWO_PI,U=k*Math.cos(I),S=k*Math.sin(I);O&&(M.x=U,M.y=S,E&&(z=a.Cartesian3.normalize(a.Cartesian3.cross(a.Cartesian3.UNIT_Z,M,z),z)),A.normal&&(D[T++]=M.x,D[T++]=M.y,D[T++]=M.z,D[T++]=M.x,D[T++]=M.y,D[T++]=M.z),A.tangent&&(G[V++]=z.x,G[V++]=z.y,G[V++]=z.z,G[V++]=z.x,G[V++]=z.y,G[V++]=z.z),A.bitangent&&(N=a.Cartesian3.normalize(a.Cartesian3.cross(M,z,N),N),R[L++]=N.x,R[L++]=N.y,R[L++]=N.z,R[L++]=N.x,R[L++]=N.y,R[L++]=N.z))}for(w=0;w<h;w++)A.normal&&(D[T++]=0,D[T++]=0,D[T++]=-1),A.tangent&&(G[V++]=1,G[V++]=0,G[V++]=0),A.bitangent&&(R[L++]=0,R[L++]=-1,R[L++]=0);for(w=0;w<h;w++)A.normal&&(D[T++]=0,D[T++]=0,D[T++]=1),A.tangent&&(G[V++]=1,G[V++]=0,G[V++]=0),A.bitangent&&(R[L++]=0,R[L++]=1,R[L++]=0)}var q=12*h-12,B=m.IndexDatatype.createTypedArray(_,q),Y=0,Z=0;for(w=0;w<h-1;w++)B[Y++]=Z,B[Y++]=Z+2,B[Y++]=Z+3,B[Y++]=Z,B[Y++]=Z+3,B[Y++]=Z+1,Z+=2;for(B[Y++]=g-2,B[Y++]=0,B[Y++]=1,B[Y++]=g-2,B[Y++]=1,B[Y++]=g-1,w=1;w<h-1;w++)B[Y++]=g+w+1,B[Y++]=g+w,B[Y++]=g;for(w=1;w<h-1;w++)B[Y++]=x,B[Y++]=x+w,B[Y++]=x+w+1;var J=0;if(A.st){var W=Math.max(d,c);for(w=0;w<_;w++){var j=a.Cartesian3.fromArray(F,3*w,v);C[J++]=(j.x+W)/(2*W),C[J++]=(j.y+W)/(2*W)}}var H=new f.GeometryAttributes;A.position&&(H.position=new u.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F})),A.normal&&(H.normal=new u.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),A.tangent&&(H.tangent=new u.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),A.bitangent&&(H.bitangent=new u.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),A.st&&(H.st=new u.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:C})),p.x=.5*s,p.y=Math.max(c,d);var K=new r.BoundingSphere(a.Cartesian3.ZERO,a.Cartesian2.magnitude(p));if(i.defined(t._offsetAttribute)){s=F.length;var Q=new Uint8Array(s/3),X=t._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(Q,X),H.applyOffset=new u.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:Q})}return new u.Geometry({attributes:H,indices:B,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:K,offsetAttribute:t._offsetAttribute})}},c.getUnitCylinder=function(){return i.defined(A)||(A=c.createGeometry(new c({topRadius:1,bottomRadius:1,length:1,vertexFormat:d.VertexFormat.POSITION_ONLY}))),A},t.CylinderGeometry=c}));
//# sourceMappingURL=CylinderGeometry-d63cea8c.js.map
