{"version":3,"file":"OrientedBoundingBox-e0ef2593.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\r\nimport Intersect from \"./Intersect.js\";\r\nimport Interval from \"./Interval.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Plane from \"./Plane.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\n\r\n/**\r\n * Creates an instance of an OrientedBoundingBox.\r\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\r\n * @alias OrientedBoundingBox\r\n * @constructor\r\n *\r\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\r\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\r\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\r\n *                                          cube centered at the origin.\r\n *\r\n *\r\n * @example\r\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\r\n * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\r\n * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\r\n *\r\n * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\r\n *\r\n * @see BoundingSphere\r\n * @see BoundingRectangle\r\n */\r\nfunction OrientedBoundingBox(center, halfAxes) {\r\n  /**\r\n   * The center of the box.\r\n   * @type {Cartesian3}\r\n   * @default {@link Cartesian3.ZERO}\r\n   */\r\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\r\n  /**\r\n   * The transformation matrix, to rotate the box to the right position.\r\n   * @type {Matrix3}\r\n   * @default {@link Matrix3.ZERO}\r\n   */\r\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nOrientedBoundingBox.packedLength =\r\n  Cartesian3.packedLength + Matrix3.packedLength;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {OrientedBoundingBox} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  Cartesian3.pack(value.center, array, startingIndex);\r\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  Cartesian3.unpack(array, startingIndex, result.center);\r\n  Matrix3.unpack(\r\n    array,\r\n    startingIndex + Cartesian3.packedLength,\r\n    result.halfAxes\r\n  );\r\n  return result;\r\n};\r\n\r\nvar scratchCartesian1 = new Cartesian3();\r\nvar scratchCartesian2 = new Cartesian3();\r\nvar scratchCartesian3 = new Cartesian3();\r\nvar scratchCartesian4 = new Cartesian3();\r\nvar scratchCartesian5 = new Cartesian3();\r\nvar scratchCartesian6 = new Cartesian3();\r\nvar scratchCovarianceResult = new Matrix3();\r\nvar scratchEigenResult = {\r\n  unitary: new Matrix3(),\r\n  diagonal: new Matrix3(),\r\n};\r\n\r\n/**\r\n * Computes an instance of an OrientedBoundingBox of the given positions.\r\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\r\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\r\n *\r\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n *\r\n * @example\r\n * // Compute an object oriented bounding box enclosing two points.\r\n * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n */\r\nOrientedBoundingBox.fromPoints = function (positions, result) {\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  if (!defined(positions) || positions.length === 0) {\r\n    result.halfAxes = Matrix3.ZERO;\r\n    result.center = Cartesian3.ZERO;\r\n    return result;\r\n  }\r\n\r\n  var i;\r\n  var length = positions.length;\r\n\r\n  var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\r\n  for (i = 1; i < length; i++) {\r\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\r\n  }\r\n  var invLength = 1.0 / length;\r\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\r\n\r\n  var exx = 0.0;\r\n  var exy = 0.0;\r\n  var exz = 0.0;\r\n  var eyy = 0.0;\r\n  var eyz = 0.0;\r\n  var ezz = 0.0;\r\n  var p;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\r\n    exx += p.x * p.x;\r\n    exy += p.x * p.y;\r\n    exz += p.x * p.z;\r\n    eyy += p.y * p.y;\r\n    eyz += p.y * p.z;\r\n    ezz += p.z * p.z;\r\n  }\r\n\r\n  exx *= invLength;\r\n  exy *= invLength;\r\n  exz *= invLength;\r\n  eyy *= invLength;\r\n  eyz *= invLength;\r\n  ezz *= invLength;\r\n\r\n  var covarianceMatrix = scratchCovarianceResult;\r\n  covarianceMatrix[0] = exx;\r\n  covarianceMatrix[1] = exy;\r\n  covarianceMatrix[2] = exz;\r\n  covarianceMatrix[3] = exy;\r\n  covarianceMatrix[4] = eyy;\r\n  covarianceMatrix[5] = eyz;\r\n  covarianceMatrix[6] = exz;\r\n  covarianceMatrix[7] = eyz;\r\n  covarianceMatrix[8] = ezz;\r\n\r\n  var eigenDecomposition = Matrix3.computeEigenDecomposition(\r\n    covarianceMatrix,\r\n    scratchEigenResult\r\n  );\r\n  var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\r\n\r\n  var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\r\n  var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\r\n  var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\r\n\r\n  var u1 = -Number.MAX_VALUE;\r\n  var u2 = -Number.MAX_VALUE;\r\n  var u3 = -Number.MAX_VALUE;\r\n  var l1 = Number.MAX_VALUE;\r\n  var l2 = Number.MAX_VALUE;\r\n  var l3 = Number.MAX_VALUE;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    p = positions[i];\r\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\r\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\r\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\r\n\r\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\r\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\r\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\r\n  }\r\n\r\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\r\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\r\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\r\n\r\n  var center = Cartesian3.add(v1, v2, result.center);\r\n  Cartesian3.add(center, v3, center);\r\n\r\n  var scale = scratchCartesian3;\r\n  scale.x = u1 - l1;\r\n  scale.y = u2 - l2;\r\n  scale.z = u3 - l3;\r\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\r\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\r\n\r\n  return result;\r\n};\r\n\r\nvar scratchOffset = new Cartesian3();\r\nvar scratchScale = new Cartesian3();\r\nfunction fromPlaneExtents(\r\n  planeOrigin,\r\n  planeXAxis,\r\n  planeYAxis,\r\n  planeZAxis,\r\n  minimumX,\r\n  maximumX,\r\n  minimumY,\r\n  maximumY,\r\n  minimumZ,\r\n  maximumZ,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(minimumX) ||\r\n    !defined(maximumX) ||\r\n    !defined(minimumY) ||\r\n    !defined(maximumY) ||\r\n    !defined(minimumZ) ||\r\n    !defined(maximumZ)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  var halfAxes = result.halfAxes;\r\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\r\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\r\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\r\n\r\n  var centerOffset = scratchOffset;\r\n  centerOffset.x = (minimumX + maximumX) / 2.0;\r\n  centerOffset.y = (minimumY + maximumY) / 2.0;\r\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\r\n\r\n  var scale = scratchScale;\r\n  scale.x = (maximumX - minimumX) / 2.0;\r\n  scale.y = (maximumY - minimumY) / 2.0;\r\n  scale.z = (maximumZ - minimumZ) / 2.0;\r\n\r\n  var center = result.center;\r\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\r\n  Cartesian3.add(planeOrigin, centerOffset, center);\r\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\r\n\r\n  return result;\r\n}\r\n\r\nvar scratchRectangleCenterCartographic = new Cartographic();\r\nvar scratchRectangleCenter = new Cartesian3();\r\nvar scratchPerimeterCartographicNC = new Cartographic();\r\nvar scratchPerimeterCartographicNW = new Cartographic();\r\nvar scratchPerimeterCartographicCW = new Cartographic();\r\nvar scratchPerimeterCartographicSW = new Cartographic();\r\nvar scratchPerimeterCartographicSC = new Cartographic();\r\nvar scratchPerimeterCartesianNC = new Cartesian3();\r\nvar scratchPerimeterCartesianNW = new Cartesian3();\r\nvar scratchPerimeterCartesianCW = new Cartesian3();\r\nvar scratchPerimeterCartesianSW = new Cartesian3();\r\nvar scratchPerimeterCartesianSC = new Cartesian3();\r\nvar scratchPerimeterProjectedNC = new Cartesian2();\r\nvar scratchPerimeterProjectedNW = new Cartesian2();\r\nvar scratchPerimeterProjectedCW = new Cartesian2();\r\nvar scratchPerimeterProjectedSW = new Cartesian2();\r\nvar scratchPerimeterProjectedSC = new Cartesian2();\r\n\r\nvar scratchPlaneOrigin = new Cartesian3();\r\nvar scratchPlaneNormal = new Cartesian3();\r\nvar scratchPlaneXAxis = new Cartesian3();\r\nvar scratchHorizonCartesian = new Cartesian3();\r\nvar scratchHorizonProjected = new Cartesian2();\r\nvar scratchMaxY = new Cartesian3();\r\nvar scratchMinY = new Cartesian3();\r\nvar scratchZ = new Cartesian3();\r\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n\r\n/**\r\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\r\n * There are no guarantees about the orientation of the bounding box.\r\n *\r\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\r\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\r\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n *\r\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\r\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\r\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\r\n */\r\nOrientedBoundingBox.fromRectangle = function (\r\n  rectangle,\r\n  minimumHeight,\r\n  maximumHeight,\r\n  ellipsoid,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(rectangle)) {\r\n    throw new DeveloperError(\"rectangle is required\");\r\n  }\r\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\r\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\r\n  }\r\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\r\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\r\n  }\r\n  if (\r\n    defined(ellipsoid) &&\r\n    !CesiumMath.equalsEpsilon(\r\n      ellipsoid.radii.x,\r\n      ellipsoid.radii.y,\r\n      CesiumMath.EPSILON15\r\n    )\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  minimumHeight = defaultValue(minimumHeight, 0.0);\r\n  maximumHeight = defaultValue(maximumHeight, 0.0);\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  var minX, maxX, minY, maxY, minZ, maxZ, plane;\r\n\r\n  if (rectangle.width <= CesiumMath.PI) {\r\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\r\n    var tangentPointCartographic = Rectangle.center(\r\n      rectangle,\r\n      scratchRectangleCenterCartographic\r\n    );\r\n    var tangentPoint = ellipsoid.cartographicToCartesian(\r\n      tangentPointCartographic,\r\n      scratchRectangleCenter\r\n    );\r\n    var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\r\n    plane = tangentPlane.plane;\r\n\r\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\r\n    var lonCenter = tangentPointCartographic.longitude;\r\n    var latCenter =\r\n      rectangle.south < 0.0 && rectangle.north > 0.0\r\n        ? 0.0\r\n        : tangentPointCartographic.latitude;\r\n\r\n    // Compute XY extents using the rectangle at maximum height\r\n    var perimeterCartographicNC = Cartographic.fromRadians(\r\n      lonCenter,\r\n      rectangle.north,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicNC\r\n    );\r\n    var perimeterCartographicNW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      rectangle.north,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicNW\r\n    );\r\n    var perimeterCartographicCW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      latCenter,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicCW\r\n    );\r\n    var perimeterCartographicSW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      rectangle.south,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicSW\r\n    );\r\n    var perimeterCartographicSC = Cartographic.fromRadians(\r\n      lonCenter,\r\n      rectangle.south,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicSC\r\n    );\r\n\r\n    var perimeterCartesianNC = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNC,\r\n      scratchPerimeterCartesianNC\r\n    );\r\n    var perimeterCartesianNW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNW,\r\n      scratchPerimeterCartesianNW\r\n    );\r\n    var perimeterCartesianCW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicCW,\r\n      scratchPerimeterCartesianCW\r\n    );\r\n    var perimeterCartesianSW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSW,\r\n      scratchPerimeterCartesianSW\r\n    );\r\n    var perimeterCartesianSC = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSC,\r\n      scratchPerimeterCartesianSC\r\n    );\r\n\r\n    var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianNC,\r\n      scratchPerimeterProjectedNC\r\n    );\r\n    var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianNW,\r\n      scratchPerimeterProjectedNW\r\n    );\r\n    var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianCW,\r\n      scratchPerimeterProjectedCW\r\n    );\r\n    var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianSW,\r\n      scratchPerimeterProjectedSW\r\n    );\r\n    var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianSC,\r\n      scratchPerimeterProjectedSC\r\n    );\r\n\r\n    minX = Math.min(\r\n      perimeterProjectedNW.x,\r\n      perimeterProjectedCW.x,\r\n      perimeterProjectedSW.x\r\n    );\r\n    maxX = -minX; // symmetrical\r\n\r\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\r\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\r\n\r\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\r\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\r\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNW,\r\n      scratchPerimeterCartesianNW\r\n    );\r\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSW,\r\n      scratchPerimeterCartesianSW\r\n    );\r\n\r\n    minZ = Math.min(\r\n      Plane.getPointDistance(plane, perimeterCartesianNW),\r\n      Plane.getPointDistance(plane, perimeterCartesianSW)\r\n    );\r\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\r\n\r\n    return fromPlaneExtents(\r\n      tangentPlane.origin,\r\n      tangentPlane.xAxis,\r\n      tangentPlane.yAxis,\r\n      tangentPlane.zAxis,\r\n      minX,\r\n      maxX,\r\n      minY,\r\n      maxY,\r\n      minZ,\r\n      maxZ,\r\n      result\r\n    );\r\n  }\r\n\r\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\r\n  var fullyAboveEquator = rectangle.south > 0.0;\r\n  var fullyBelowEquator = rectangle.north < 0.0;\r\n  var latitudeNearestToEquator = fullyAboveEquator\r\n    ? rectangle.south\r\n    : fullyBelowEquator\r\n    ? rectangle.north\r\n    : 0.0;\r\n  var centerLongitude = Rectangle.center(\r\n    rectangle,\r\n    scratchRectangleCenterCartographic\r\n  ).longitude;\r\n\r\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\r\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\r\n  var planeOrigin = Cartesian3.fromRadians(\r\n    centerLongitude,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchPlaneOrigin\r\n  );\r\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\r\n  var isPole =\r\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\r\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\r\n  var planeNormal = !isPole\r\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\r\n    : Cartesian3.UNIT_X;\r\n  var planeYAxis = Cartesian3.UNIT_Z;\r\n  var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\r\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\r\n\r\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\r\n  var horizonCartesian = Cartesian3.fromRadians(\r\n    centerLongitude + CesiumMath.PI_OVER_TWO,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchHorizonCartesian\r\n  );\r\n  maxX = Cartesian3.dot(\r\n    Plane.projectPointOntoPlane(\r\n      plane,\r\n      horizonCartesian,\r\n      scratchHorizonProjected\r\n    ),\r\n    planeXAxis\r\n  );\r\n  minX = -maxX; // symmetrical\r\n\r\n  // Get the min and max Y, using the height that will give the largest extent\r\n  maxY = Cartesian3.fromRadians(\r\n    0.0,\r\n    rectangle.north,\r\n    fullyBelowEquator ? minimumHeight : maximumHeight,\r\n    ellipsoid,\r\n    scratchMaxY\r\n  ).z;\r\n  minY = Cartesian3.fromRadians(\r\n    0.0,\r\n    rectangle.south,\r\n    fullyAboveEquator ? minimumHeight : maximumHeight,\r\n    ellipsoid,\r\n    scratchMinY\r\n  ).z;\r\n\r\n  var farZ = Cartesian3.fromRadians(\r\n    rectangle.east,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchZ\r\n  );\r\n  minZ = Plane.getPointDistance(plane, farZ);\r\n  maxZ = 0.0; // plane origin starts at maxZ already\r\n\r\n  // min and max are local to the plane axes\r\n  return fromPlaneExtents(\r\n    planeOrigin,\r\n    planeXAxis,\r\n    planeYAxis,\r\n    planeNormal,\r\n    minX,\r\n    maxX,\r\n    minY,\r\n    maxY,\r\n    minZ,\r\n    maxZ,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Duplicates a OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n */\r\nOrientedBoundingBox.clone = function (box, result) {\r\n  if (!defined(box)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new OrientedBoundingBox(box.center, box.halfAxes);\r\n  }\r\n\r\n  Cartesian3.clone(box.center, result.center);\r\n  Matrix3.clone(box.halfAxes, result.halfAxes);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.intersectPlane = function (box, plane) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n\r\n  if (!defined(plane)) {\r\n    throw new DeveloperError(\"plane is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var center = box.center;\r\n  var normal = plane.normal;\r\n  var halfAxes = box.halfAxes;\r\n  var normalX = normal.x,\r\n    normalY = normal.y,\r\n    normalZ = normal.z;\r\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\r\n  var radEffective =\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\r\n    ) +\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\r\n    ) +\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\r\n    );\r\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\r\n\r\n  if (distanceToPlane <= -radEffective) {\r\n    // The entire box is on the negative side of the plane normal\r\n    return Intersect.OUTSIDE;\r\n  } else if (distanceToPlane >= radEffective) {\r\n    // The entire box is on the positive side of the plane normal\r\n    return Intersect.INSIDE;\r\n  }\r\n  return Intersect.INTERSECTING;\r\n};\r\n\r\nvar scratchCartesianU = new Cartesian3();\r\nvar scratchCartesianV = new Cartesian3();\r\nvar scratchCartesianW = new Cartesian3();\r\nvar scratchValidAxis2 = new Cartesian3();\r\nvar scratchValidAxis3 = new Cartesian3();\r\nvar scratchPPrime = new Cartesian3();\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {OrientedBoundingBox} box The box.\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\r\n  // See Geometric Tools for Computer Graphics 10.4.2\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n  if (!defined(cartesian)) {\r\n    throw new DeveloperError(\"cartesian is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\r\n\r\n  var halfAxes = box.halfAxes;\r\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n  var uHalf = Cartesian3.magnitude(u);\r\n  var vHalf = Cartesian3.magnitude(v);\r\n  var wHalf = Cartesian3.magnitude(w);\r\n\r\n  var uValid = true;\r\n  var vValid = true;\r\n  var wValid = true;\r\n\r\n  if (uHalf > 0) {\r\n    Cartesian3.divideByScalar(u, uHalf, u);\r\n  } else {\r\n    uValid = false;\r\n  }\r\n\r\n  if (vHalf > 0) {\r\n    Cartesian3.divideByScalar(v, vHalf, v);\r\n  } else {\r\n    vValid = false;\r\n  }\r\n\r\n  if (wHalf > 0) {\r\n    Cartesian3.divideByScalar(w, wHalf, w);\r\n  } else {\r\n    wValid = false;\r\n  }\r\n\r\n  var numberOfDegenerateAxes = !uValid + !vValid + !wValid;\r\n  var validAxis1;\r\n  var validAxis2;\r\n  var validAxis3;\r\n\r\n  if (numberOfDegenerateAxes === 1) {\r\n    var degenerateAxis = u;\r\n    validAxis1 = v;\r\n    validAxis2 = w;\r\n    if (!vValid) {\r\n      degenerateAxis = v;\r\n      validAxis1 = u;\r\n    } else if (!wValid) {\r\n      degenerateAxis = w;\r\n      validAxis2 = u;\r\n    }\r\n\r\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\r\n\r\n    if (degenerateAxis === u) {\r\n      u = validAxis3;\r\n    } else if (degenerateAxis === v) {\r\n      v = validAxis3;\r\n    } else if (degenerateAxis === w) {\r\n      w = validAxis3;\r\n    }\r\n  } else if (numberOfDegenerateAxes === 2) {\r\n    validAxis1 = u;\r\n    if (vValid) {\r\n      validAxis1 = v;\r\n    } else if (wValid) {\r\n      validAxis1 = w;\r\n    }\r\n\r\n    var crossVector = Cartesian3.UNIT_Y;\r\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\r\n      crossVector = Cartesian3.UNIT_X;\r\n    }\r\n\r\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\r\n    Cartesian3.normalize(validAxis2, validAxis2);\r\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\r\n    Cartesian3.normalize(validAxis3, validAxis3);\r\n\r\n    if (validAxis1 === u) {\r\n      v = validAxis2;\r\n      w = validAxis3;\r\n    } else if (validAxis1 === v) {\r\n      w = validAxis2;\r\n      u = validAxis3;\r\n    } else if (validAxis1 === w) {\r\n      u = validAxis2;\r\n      v = validAxis3;\r\n    }\r\n  } else if (numberOfDegenerateAxes === 3) {\r\n    u = Cartesian3.UNIT_X;\r\n    v = Cartesian3.UNIT_Y;\r\n    w = Cartesian3.UNIT_Z;\r\n  }\r\n\r\n  var pPrime = scratchPPrime;\r\n  pPrime.x = Cartesian3.dot(offset, u);\r\n  pPrime.y = Cartesian3.dot(offset, v);\r\n  pPrime.z = Cartesian3.dot(offset, w);\r\n\r\n  var distanceSquared = 0.0;\r\n  var d;\r\n\r\n  if (pPrime.x < -uHalf) {\r\n    d = pPrime.x + uHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.x > uHalf) {\r\n    d = pPrime.x - uHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  if (pPrime.y < -vHalf) {\r\n    d = pPrime.y + vHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.y > vHalf) {\r\n    d = pPrime.y - vHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  if (pPrime.z < -wHalf) {\r\n    d = pPrime.z + wHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.z > wHalf) {\r\n    d = pPrime.z - wHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  return distanceSquared;\r\n};\r\n\r\nvar scratchCorner = new Cartesian3();\r\nvar scratchToCenter = new Cartesian3();\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.computePlaneDistances = function (\r\n  box,\r\n  position,\r\n  direction,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n\r\n  if (!defined(position)) {\r\n    throw new DeveloperError(\"position is required.\");\r\n  }\r\n\r\n  if (!defined(direction)) {\r\n    throw new DeveloperError(\"direction is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Interval();\r\n  }\r\n\r\n  var minDist = Number.POSITIVE_INFINITY;\r\n  var maxDist = Number.NEGATIVE_INFINITY;\r\n\r\n  var center = box.center;\r\n  var halfAxes = box.halfAxes;\r\n\r\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n  // project first corner\r\n  var corner = Cartesian3.add(u, v, scratchCorner);\r\n  Cartesian3.add(corner, w, corner);\r\n  Cartesian3.add(corner, center, corner);\r\n\r\n  var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\r\n  var mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project second corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project third corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project fourth corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project fifth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project sixth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project seventh corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project eighth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  result.start = minDist;\r\n  result.stop = maxDist;\r\n  return result;\r\n};\r\n\r\nvar scratchBoundingSphere = new BoundingSphere();\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.isOccluded = function (box, occluder) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n  if (!defined(occluder)) {\r\n    throw new DeveloperError(\"occluder is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var sphere = BoundingSphere.fromOrientedBoundingBox(\r\n    box,\r\n    scratchBoundingSphere\r\n  );\r\n\r\n  return !occluder.isBoundingSphereVisible(sphere);\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\r\n  return OrientedBoundingBox.intersectPlane(this, plane);\r\n};\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\r\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\r\n};\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.prototype.computePlaneDistances = function (\r\n  position,\r\n  direction,\r\n  result\r\n) {\r\n  return OrientedBoundingBox.computePlaneDistances(\r\n    this,\r\n    position,\r\n    direction,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\r\n  return OrientedBoundingBox.isOccluded(this, occluder);\r\n};\r\n\r\n/**\r\n * Compares the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\r\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Cartesian3.equals(left.center, right.center) &&\r\n      Matrix3.equals(left.halfAxes, right.halfAxes))\r\n  );\r\n};\r\n\r\n/**\r\n * Duplicates this OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.prototype.clone = function (result) {\r\n  return OrientedBoundingBox.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.prototype.equals = function (right) {\r\n  return OrientedBoundingBox.equals(this, right);\r\n};\r\nexport default OrientedBoundingBox;\r\n"],"names":["OrientedBoundingBox","center","halfAxes","this","Cartesian3","clone","defaultValue","ZERO","Matrix3","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","i","meanPoint","add","invLength","multiplyByScalar","p","exx","exy","exz","eyy","eyz","ezz","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","DeveloperError","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","Cartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","Cartesian2","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","Plane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","CesiumMath","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","minX","maxX","minY","maxY","minZ","maxZ","plane","Ellipsoid","WGS84","tangentPointCartographic","Rectangle","tangentPoint","cartographicToCartesian","tangentPlane","EllipsoidTangentPlane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","planeNormal","abs","EPSILON10","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","box","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","Intersect","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchValidAxis2","scratchValidAxis3","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","uValid","vValid","wValid","divideByScalar","validAxis1","validAxis2","validAxis3","numberOfDegenerateAxes","degenerateAxis","crossVector","UNIT_Y","EPSILON3","pPrime","d","distanceSquared","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","Interval","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchBoundingSphere","BoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"mappings":"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"}