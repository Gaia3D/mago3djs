{"version":3,"file":"createVerticesFromGoogleEarthEnterpriseBuffer.js","sources":["../../../../Source/WorkersES6/createVerticesFromGoogleEarthEnterpriseBuffer.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"../Core/AxisAlignedBoundingBox.js\";\r\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\r\nimport Cartesian2 from \"../Core/Cartesian2.js\";\r\nimport Cartesian3 from \"../Core/Cartesian3.js\";\r\nimport Cartographic from \"../Core/Cartographic.js\";\r\nimport defaultValue from \"../Core/defaultValue.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\r\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\r\nimport CesiumMath from \"../Core/Math.js\";\r\nimport Matrix4 from \"../Core/Matrix4.js\";\r\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\r\nimport Rectangle from \"../Core/Rectangle.js\";\r\nimport RuntimeError from \"../Core/RuntimeError.js\";\r\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\r\nimport Transforms from \"../Core/Transforms.js\";\r\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\r\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\r\n\r\nvar sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\r\nvar sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\r\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\r\nvar sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\r\nvar sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\r\n\r\nfunction indexOfEpsilon(arr, elem, elemType) {\r\n  elemType = defaultValue(elemType, CesiumMath);\r\n  var count = arr.length;\r\n  for (var i = 0; i < count; ++i) {\r\n    if (elemType.equalsEpsilon(arr[i], elem, CesiumMath.EPSILON12)) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction createVerticesFromGoogleEarthEnterpriseBuffer(\r\n  parameters,\r\n  transferableObjects\r\n) {\r\n  parameters.ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\r\n  parameters.rectangle = Rectangle.clone(parameters.rectangle);\r\n\r\n  var statistics = processBuffer(\r\n    parameters.buffer,\r\n    parameters.relativeToCenter,\r\n    parameters.ellipsoid,\r\n    parameters.rectangle,\r\n    parameters.nativeRectangle,\r\n    parameters.exaggeration,\r\n    parameters.exaggerationRelativeHeight,\r\n    parameters.skirtHeight,\r\n    parameters.includeWebMercatorT,\r\n    parameters.negativeAltitudeExponentBias,\r\n    parameters.negativeElevationThreshold\r\n  );\r\n  var vertices = statistics.vertices;\r\n  transferableObjects.push(vertices.buffer);\r\n  var indices = statistics.indices;\r\n  transferableObjects.push(indices.buffer);\r\n\r\n  return {\r\n    vertices: vertices.buffer,\r\n    indices: indices.buffer,\r\n    numberOfAttributes: statistics.encoding.stride,\r\n    minimumHeight: statistics.minimumHeight,\r\n    maximumHeight: statistics.maximumHeight,\r\n    boundingSphere3D: statistics.boundingSphere3D,\r\n    orientedBoundingBox: statistics.orientedBoundingBox,\r\n    occludeePointInScaledSpace: statistics.occludeePointInScaledSpace,\r\n    encoding: statistics.encoding,\r\n    vertexCountWithoutSkirts: statistics.vertexCountWithoutSkirts,\r\n    indexCountWithoutSkirts: statistics.indexCountWithoutSkirts,\r\n    westIndicesSouthToNorth: statistics.westIndicesSouthToNorth,\r\n    southIndicesEastToWest: statistics.southIndicesEastToWest,\r\n    eastIndicesNorthToSouth: statistics.eastIndicesNorthToSouth,\r\n    northIndicesWestToEast: statistics.northIndicesWestToEast,\r\n  };\r\n}\r\n\r\nvar scratchCartographic = new Cartographic();\r\nvar scratchCartesian = new Cartesian3();\r\nvar minimumScratch = new Cartesian3();\r\nvar maximumScratch = new Cartesian3();\r\nvar matrix4Scratch = new Matrix4();\r\n\r\nfunction processBuffer(\r\n  buffer,\r\n  relativeToCenter,\r\n  ellipsoid,\r\n  rectangle,\r\n  nativeRectangle,\r\n  exaggeration,\r\n  exaggerationRelativeHeight,\r\n  skirtHeight,\r\n  includeWebMercatorT,\r\n  negativeAltitudeExponentBias,\r\n  negativeElevationThreshold\r\n) {\r\n  var geographicWest;\r\n  var geographicSouth;\r\n  var geographicEast;\r\n  var geographicNorth;\r\n  var rectangleWidth, rectangleHeight;\r\n\r\n  if (!defined(rectangle)) {\r\n    geographicWest = CesiumMath.toRadians(nativeRectangle.west);\r\n    geographicSouth = CesiumMath.toRadians(nativeRectangle.south);\r\n    geographicEast = CesiumMath.toRadians(nativeRectangle.east);\r\n    geographicNorth = CesiumMath.toRadians(nativeRectangle.north);\r\n    rectangleWidth = CesiumMath.toRadians(rectangle.width);\r\n    rectangleHeight = CesiumMath.toRadians(rectangle.height);\r\n  } else {\r\n    geographicWest = rectangle.west;\r\n    geographicSouth = rectangle.south;\r\n    geographicEast = rectangle.east;\r\n    geographicNorth = rectangle.north;\r\n    rectangleWidth = rectangle.width;\r\n    rectangleHeight = rectangle.height;\r\n  }\r\n\r\n  // Keep track of quad borders so we can remove duplicates around the borders\r\n  var quadBorderLatitudes = [geographicSouth, geographicNorth];\r\n  var quadBorderLongitudes = [geographicWest, geographicEast];\r\n\r\n  var fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\r\n  var toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\r\n\r\n  var southMercatorY;\r\n  var oneOverMercatorHeight;\r\n  if (includeWebMercatorT) {\r\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\r\n      geographicSouth\r\n    );\r\n    oneOverMercatorHeight =\r\n      1.0 /\r\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\r\n        southMercatorY);\r\n  }\r\n\r\n  var hasExaggeration = exaggeration !== 1.0;\r\n  var includeGeodeticSurfaceNormals = hasExaggeration;\r\n\r\n  var dv = new DataView(buffer);\r\n\r\n  var minHeight = Number.POSITIVE_INFINITY;\r\n  var maxHeight = Number.NEGATIVE_INFINITY;\r\n\r\n  var minimum = minimumScratch;\r\n  minimum.x = Number.POSITIVE_INFINITY;\r\n  minimum.y = Number.POSITIVE_INFINITY;\r\n  minimum.z = Number.POSITIVE_INFINITY;\r\n\r\n  var maximum = maximumScratch;\r\n  maximum.x = Number.NEGATIVE_INFINITY;\r\n  maximum.y = Number.NEGATIVE_INFINITY;\r\n  maximum.z = Number.NEGATIVE_INFINITY;\r\n\r\n  // Compute sizes\r\n  var offset = 0;\r\n  var size = 0;\r\n  var indicesSize = 0;\r\n  var quadSize;\r\n  var quad;\r\n  for (quad = 0; quad < 4; ++quad) {\r\n    var o = offset;\r\n    quadSize = dv.getUint32(o, true);\r\n    o += sizeOfUint32;\r\n\r\n    var x = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\r\n    o += sizeOfDouble;\r\n    if (indexOfEpsilon(quadBorderLongitudes, x) === -1) {\r\n      quadBorderLongitudes.push(x);\r\n    }\r\n\r\n    var y = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\r\n    o += sizeOfDouble;\r\n    if (indexOfEpsilon(quadBorderLatitudes, y) === -1) {\r\n      quadBorderLatitudes.push(y);\r\n    }\r\n\r\n    o += 2 * sizeOfDouble; // stepX + stepY\r\n\r\n    var c = dv.getInt32(o, true); // Read point count\r\n    o += sizeOfInt32;\r\n    size += c;\r\n\r\n    c = dv.getInt32(o, true); // Read index count\r\n    indicesSize += c * 3;\r\n\r\n    offset += quadSize + sizeOfUint32; // Jump to next quad\r\n  }\r\n\r\n  // Quad Border points to remove duplicates\r\n  var quadBorderPoints = [];\r\n  var quadBorderIndices = [];\r\n\r\n  // Create arrays\r\n  var positions = new Array(size);\r\n  var uvs = new Array(size);\r\n  var heights = new Array(size);\r\n  var webMercatorTs = includeWebMercatorT ? new Array(size) : [];\r\n  var geodeticSurfaceNormals = includeGeodeticSurfaceNormals\r\n    ? new Array(size)\r\n    : [];\r\n  var indices = new Array(indicesSize);\r\n\r\n  // Points are laid out in rows starting at SW, so storing border points as we\r\n  //  come across them all points will be adjacent.\r\n  var westBorder = [];\r\n  var southBorder = [];\r\n  var eastBorder = [];\r\n  var northBorder = [];\r\n\r\n  // Each tile is split into 4 parts\r\n  var pointOffset = 0;\r\n  var indicesOffset = 0;\r\n  offset = 0;\r\n  for (quad = 0; quad < 4; ++quad) {\r\n    quadSize = dv.getUint32(offset, true);\r\n    offset += sizeOfUint32;\r\n    var startQuad = offset;\r\n\r\n    var originX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n    offset += sizeOfDouble;\r\n\r\n    var originY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n    offset += sizeOfDouble;\r\n\r\n    var stepX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n    var halfStepX = stepX * 0.5;\r\n    offset += sizeOfDouble;\r\n\r\n    var stepY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n    var halfStepY = stepY * 0.5;\r\n    offset += sizeOfDouble;\r\n\r\n    var numPoints = dv.getInt32(offset, true);\r\n    offset += sizeOfInt32;\r\n\r\n    var numFaces = dv.getInt32(offset, true);\r\n    offset += sizeOfInt32;\r\n\r\n    //var level = dv.getInt32(offset, true);\r\n    offset += sizeOfInt32;\r\n\r\n    // Keep track of quad indices to overall tile indices\r\n    var indicesMapping = new Array(numPoints);\r\n    for (var i = 0; i < numPoints; ++i) {\r\n      var longitude = originX + dv.getUint8(offset++) * stepX;\r\n      scratchCartographic.longitude = longitude;\r\n      var latitude = originY + dv.getUint8(offset++) * stepY;\r\n      scratchCartographic.latitude = latitude;\r\n\r\n      var height = dv.getFloat32(offset, true);\r\n      offset += sizeOfFloat;\r\n\r\n      // In order to support old clients, negative altitude values are stored as\r\n      // height/-2^32. Old clients see the value as really close to 0 but new clients multiply\r\n      // by -2^32 to get the real negative altitude value.\r\n      if (height !== 0 && height < negativeElevationThreshold) {\r\n        height *= -Math.pow(2, negativeAltitudeExponentBias);\r\n      }\r\n\r\n      // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\r\n      height *= 6371010.0;\r\n\r\n      scratchCartographic.height = height;\r\n\r\n      // Is it along a quad border - if so check if already exists and use that index\r\n      if (\r\n        indexOfEpsilon(quadBorderLongitudes, longitude) !== -1 ||\r\n        indexOfEpsilon(quadBorderLatitudes, latitude) !== -1\r\n      ) {\r\n        var index = indexOfEpsilon(\r\n          quadBorderPoints,\r\n          scratchCartographic,\r\n          Cartographic\r\n        );\r\n        if (index === -1) {\r\n          quadBorderPoints.push(Cartographic.clone(scratchCartographic));\r\n          quadBorderIndices.push(pointOffset);\r\n        } else {\r\n          indicesMapping[i] = quadBorderIndices[index];\r\n          continue;\r\n        }\r\n      }\r\n      indicesMapping[i] = pointOffset;\r\n\r\n      if (Math.abs(longitude - geographicWest) < halfStepX) {\r\n        westBorder.push({\r\n          index: pointOffset,\r\n          cartographic: Cartographic.clone(scratchCartographic),\r\n        });\r\n      } else if (Math.abs(longitude - geographicEast) < halfStepX) {\r\n        eastBorder.push({\r\n          index: pointOffset,\r\n          cartographic: Cartographic.clone(scratchCartographic),\r\n        });\r\n      } else if (Math.abs(latitude - geographicSouth) < halfStepY) {\r\n        southBorder.push({\r\n          index: pointOffset,\r\n          cartographic: Cartographic.clone(scratchCartographic),\r\n        });\r\n      } else if (Math.abs(latitude - geographicNorth) < halfStepY) {\r\n        northBorder.push({\r\n          index: pointOffset,\r\n          cartographic: Cartographic.clone(scratchCartographic),\r\n        });\r\n      }\r\n\r\n      minHeight = Math.min(height, minHeight);\r\n      maxHeight = Math.max(height, maxHeight);\r\n      heights[pointOffset] = height;\r\n\r\n      var pos = ellipsoid.cartographicToCartesian(scratchCartographic);\r\n      positions[pointOffset] = pos;\r\n\r\n      if (includeWebMercatorT) {\r\n        webMercatorTs[pointOffset] =\r\n          (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\r\n            southMercatorY) *\r\n          oneOverMercatorHeight;\r\n      }\r\n\r\n      if (includeGeodeticSurfaceNormals) {\r\n        var normal = ellipsoid.geodeticSurfaceNormal(pos);\r\n        geodeticSurfaceNormals[pointOffset] = normal;\r\n      }\r\n\r\n      Matrix4.multiplyByPoint(toENU, pos, scratchCartesian);\r\n\r\n      Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\r\n      Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\r\n\r\n      var u = (longitude - geographicWest) / (geographicEast - geographicWest);\r\n      u = CesiumMath.clamp(u, 0.0, 1.0);\r\n      var v =\r\n        (latitude - geographicSouth) / (geographicNorth - geographicSouth);\r\n      v = CesiumMath.clamp(v, 0.0, 1.0);\r\n\r\n      uvs[pointOffset] = new Cartesian2(u, v);\r\n      ++pointOffset;\r\n    }\r\n\r\n    var facesElementCount = numFaces * 3;\r\n    for (var j = 0; j < facesElementCount; ++j, ++indicesOffset) {\r\n      indices[indicesOffset] = indicesMapping[dv.getUint16(offset, true)];\r\n      offset += sizeOfUint16;\r\n    }\r\n\r\n    if (quadSize !== offset - startQuad) {\r\n      throw new RuntimeError(\"Invalid terrain tile.\");\r\n    }\r\n  }\r\n\r\n  positions.length = pointOffset;\r\n  uvs.length = pointOffset;\r\n  heights.length = pointOffset;\r\n  if (includeWebMercatorT) {\r\n    webMercatorTs.length = pointOffset;\r\n  }\r\n  if (includeGeodeticSurfaceNormals) {\r\n    geodeticSurfaceNormals.length = pointOffset;\r\n  }\r\n\r\n  var vertexCountWithoutSkirts = pointOffset;\r\n  var indexCountWithoutSkirts = indicesOffset;\r\n\r\n  // Add skirt points\r\n  var skirtOptions = {\r\n    hMin: minHeight,\r\n    lastBorderPoint: undefined,\r\n    skirtHeight: skirtHeight,\r\n    toENU: toENU,\r\n    ellipsoid: ellipsoid,\r\n    minimum: minimum,\r\n    maximum: maximum,\r\n  };\r\n\r\n  // Sort counter clockwise from NW corner\r\n  // Corner points are in the east/west arrays\r\n  westBorder.sort(function (a, b) {\r\n    return b.cartographic.latitude - a.cartographic.latitude;\r\n  });\r\n  southBorder.sort(function (a, b) {\r\n    return a.cartographic.longitude - b.cartographic.longitude;\r\n  });\r\n  eastBorder.sort(function (a, b) {\r\n    return a.cartographic.latitude - b.cartographic.latitude;\r\n  });\r\n  northBorder.sort(function (a, b) {\r\n    return b.cartographic.longitude - a.cartographic.longitude;\r\n  });\r\n\r\n  var percentage = 0.00001;\r\n  addSkirt(\r\n    positions,\r\n    heights,\r\n    uvs,\r\n    webMercatorTs,\r\n    geodeticSurfaceNormals,\r\n    indices,\r\n    skirtOptions,\r\n    westBorder,\r\n    -percentage * rectangleWidth,\r\n    true,\r\n    -percentage * rectangleHeight\r\n  );\r\n  addSkirt(\r\n    positions,\r\n    heights,\r\n    uvs,\r\n    webMercatorTs,\r\n    geodeticSurfaceNormals,\r\n    indices,\r\n    skirtOptions,\r\n    southBorder,\r\n    -percentage * rectangleHeight,\r\n    false\r\n  );\r\n  addSkirt(\r\n    positions,\r\n    heights,\r\n    uvs,\r\n    webMercatorTs,\r\n    geodeticSurfaceNormals,\r\n    indices,\r\n    skirtOptions,\r\n    eastBorder,\r\n    percentage * rectangleWidth,\r\n    true,\r\n    percentage * rectangleHeight\r\n  );\r\n  addSkirt(\r\n    positions,\r\n    heights,\r\n    uvs,\r\n    webMercatorTs,\r\n    geodeticSurfaceNormals,\r\n    indices,\r\n    skirtOptions,\r\n    northBorder,\r\n    percentage * rectangleHeight,\r\n    false\r\n  );\r\n\r\n  // Since the corner between the north and west sides is in the west array, generate the last\r\n  //  two triangles between the last north vertex and the first west vertex\r\n  if (westBorder.length > 0 && northBorder.length > 0) {\r\n    var firstBorderIndex = westBorder[0].index;\r\n    var firstSkirtIndex = vertexCountWithoutSkirts;\r\n    var lastBorderIndex = northBorder[northBorder.length - 1].index;\r\n    var lastSkirtIndex = positions.length - 1;\r\n\r\n    indices.push(\r\n      lastBorderIndex,\r\n      lastSkirtIndex,\r\n      firstSkirtIndex,\r\n      firstSkirtIndex,\r\n      firstBorderIndex,\r\n      lastBorderIndex\r\n    );\r\n  }\r\n\r\n  size = positions.length; // Get new size with skirt vertices\r\n\r\n  var boundingSphere3D = BoundingSphere.fromPoints(positions);\r\n  var orientedBoundingBox;\r\n  if (defined(rectangle)) {\r\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\r\n      rectangle,\r\n      minHeight,\r\n      maxHeight,\r\n      ellipsoid\r\n    );\r\n  }\r\n\r\n  var occluder = new EllipsoidalOccluder(ellipsoid);\r\n  var occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\r\n    relativeToCenter,\r\n    positions,\r\n    minHeight\r\n  );\r\n\r\n  var aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\r\n  var encoding = new TerrainEncoding(\r\n    relativeToCenter,\r\n    aaBox,\r\n    skirtOptions.hMin,\r\n    maxHeight,\r\n    fromENU,\r\n    false,\r\n    includeWebMercatorT,\r\n    includeGeodeticSurfaceNormals,\r\n    exaggeration,\r\n    exaggerationRelativeHeight\r\n  );\r\n  var vertices = new Float32Array(size * encoding.stride);\r\n\r\n  var bufferIndex = 0;\r\n  for (var k = 0; k < size; ++k) {\r\n    bufferIndex = encoding.encode(\r\n      vertices,\r\n      bufferIndex,\r\n      positions[k],\r\n      uvs[k],\r\n      heights[k],\r\n      undefined,\r\n      webMercatorTs[k],\r\n      geodeticSurfaceNormals[k]\r\n    );\r\n  }\r\n\r\n  var westIndicesSouthToNorth = westBorder\r\n    .map(function (vertex) {\r\n      return vertex.index;\r\n    })\r\n    .reverse();\r\n  var southIndicesEastToWest = southBorder\r\n    .map(function (vertex) {\r\n      return vertex.index;\r\n    })\r\n    .reverse();\r\n  var eastIndicesNorthToSouth = eastBorder\r\n    .map(function (vertex) {\r\n      return vertex.index;\r\n    })\r\n    .reverse();\r\n  var northIndicesWestToEast = northBorder\r\n    .map(function (vertex) {\r\n      return vertex.index;\r\n    })\r\n    .reverse();\r\n\r\n  southIndicesEastToWest.unshift(\r\n    eastIndicesNorthToSouth[eastIndicesNorthToSouth.length - 1]\r\n  );\r\n  southIndicesEastToWest.push(westIndicesSouthToNorth[0]);\r\n\r\n  northIndicesWestToEast.unshift(\r\n    westIndicesSouthToNorth[westIndicesSouthToNorth.length - 1]\r\n  );\r\n  northIndicesWestToEast.push(eastIndicesNorthToSouth[0]);\r\n\r\n  return {\r\n    vertices: vertices,\r\n    indices: new Uint16Array(indices),\r\n    maximumHeight: maxHeight,\r\n    minimumHeight: minHeight,\r\n    encoding: encoding,\r\n    boundingSphere3D: boundingSphere3D,\r\n    orientedBoundingBox: orientedBoundingBox,\r\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\r\n    vertexCountWithoutSkirts: vertexCountWithoutSkirts,\r\n    indexCountWithoutSkirts: indexCountWithoutSkirts,\r\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\r\n    southIndicesEastToWest: southIndicesEastToWest,\r\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\r\n    northIndicesWestToEast: northIndicesWestToEast,\r\n  };\r\n}\r\n\r\nfunction addSkirt(\r\n  positions,\r\n  heights,\r\n  uvs,\r\n  webMercatorTs,\r\n  geodeticSurfaceNormals,\r\n  indices,\r\n  skirtOptions,\r\n  borderPoints,\r\n  fudgeFactor,\r\n  eastOrWest,\r\n  cornerFudge\r\n) {\r\n  var count = borderPoints.length;\r\n  for (var j = 0; j < count; ++j) {\r\n    var borderPoint = borderPoints[j];\r\n    var borderCartographic = borderPoint.cartographic;\r\n    var borderIndex = borderPoint.index;\r\n    var currentIndex = positions.length;\r\n\r\n    var longitude = borderCartographic.longitude;\r\n    var latitude = borderCartographic.latitude;\r\n    latitude = CesiumMath.clamp(\r\n      latitude,\r\n      -CesiumMath.PI_OVER_TWO,\r\n      CesiumMath.PI_OVER_TWO\r\n    ); // Don't go over the poles\r\n    var height = borderCartographic.height - skirtOptions.skirtHeight;\r\n    skirtOptions.hMin = Math.min(skirtOptions.hMin, height);\r\n\r\n    Cartographic.fromRadians(longitude, latitude, height, scratchCartographic);\r\n\r\n    // Adjust sides to angle out\r\n    if (eastOrWest) {\r\n      scratchCartographic.longitude += fudgeFactor;\r\n    }\r\n\r\n    // Adjust top or bottom to angle out\r\n    // Since corners are in the east/west arrays angle the first and last points as well\r\n    if (!eastOrWest) {\r\n      scratchCartographic.latitude += fudgeFactor;\r\n    } else if (j === count - 1) {\r\n      scratchCartographic.latitude += cornerFudge;\r\n    } else if (j === 0) {\r\n      scratchCartographic.latitude -= cornerFudge;\r\n    }\r\n\r\n    var pos = skirtOptions.ellipsoid.cartographicToCartesian(\r\n      scratchCartographic\r\n    );\r\n    positions.push(pos);\r\n    heights.push(height);\r\n    uvs.push(Cartesian2.clone(uvs[borderIndex])); // Copy UVs from border point\r\n    if (webMercatorTs.length > 0) {\r\n      webMercatorTs.push(webMercatorTs[borderIndex]);\r\n    }\r\n    if (geodeticSurfaceNormals.length > 0) {\r\n      geodeticSurfaceNormals.push(geodeticSurfaceNormals[borderIndex]);\r\n    }\r\n\r\n    Matrix4.multiplyByPoint(skirtOptions.toENU, pos, scratchCartesian);\r\n\r\n    var minimum = skirtOptions.minimum;\r\n    var maximum = skirtOptions.maximum;\r\n    Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\r\n    Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\r\n\r\n    var lastBorderPoint = skirtOptions.lastBorderPoint;\r\n    if (defined(lastBorderPoint)) {\r\n      var lastBorderIndex = lastBorderPoint.index;\r\n      indices.push(\r\n        lastBorderIndex,\r\n        currentIndex - 1,\r\n        currentIndex,\r\n        currentIndex,\r\n        borderIndex,\r\n        lastBorderIndex\r\n      );\r\n    }\r\n\r\n    skirtOptions.lastBorderPoint = borderPoint;\r\n  }\r\n}\r\nexport default createTaskProcessorWorker(\r\n  createVerticesFromGoogleEarthEnterpriseBuffer\r\n);\r\n"],"names":["sizeOfUint16","Uint16Array","BYTES_PER_ELEMENT","sizeOfInt32","Int32Array","sizeOfUint32","Uint32Array","sizeOfFloat","Float32Array","sizeOfDouble","Float64Array","indexOfEpsilon","arr","elem","elemType","defaultValue","CesiumMath","count","length","i","equalsEpsilon","EPSILON12","scratchCartographic","Cartographic","scratchCartesian","Cartesian3","minimumScratch","maximumScratch","matrix4Scratch","Matrix4","addSkirt","positions","heights","uvs","webMercatorTs","geodeticSurfaceNormals","indices","skirtOptions","borderPoints","fudgeFactor","eastOrWest","cornerFudge","j","borderPoint","borderCartographic","cartographic","borderIndex","index","currentIndex","longitude","latitude","clamp","PI_OVER_TWO","height","skirtHeight","hMin","Math","min","fromRadians","pos","ellipsoid","cartographicToCartesian","push","Cartesian2","clone","multiplyByPoint","toENU","minimum","maximum","minimumByComponent","maximumByComponent","lastBorderPoint","defined","lastBorderIndex","createTaskProcessorWorker","parameters","transferableObjects","Ellipsoid","rectangle","Rectangle","statistics","buffer","relativeToCenter","nativeRectangle","exaggeration","exaggerationRelativeHeight","includeWebMercatorT","negativeAltitudeExponentBias","negativeElevationThreshold","geographicWest","geographicSouth","geographicEast","geographicNorth","rectangleWidth","rectangleHeight","west","south","east","north","width","toRadians","southMercatorY","oneOverMercatorHeight","quadBorderLatitudes","quadBorderLongitudes","fromENU","Transforms","eastNorthUpToFixedFrame","inverseTransformation","WebMercatorProjection","geodeticLatitudeToMercatorAngle","includeGeodeticSurfaceNormals","dv","DataView","minHeight","Number","POSITIVE_INFINITY","maxHeight","NEGATIVE_INFINITY","x","y","z","quadSize","quad","offset","size","indicesSize","o","getUint32","getFloat64","c","getInt32","quadBorderPoints","quadBorderIndices","Array","westBorder","southBorder","eastBorder","northBorder","pointOffset","indicesOffset","startQuad","originX","originY","stepX","halfStepX","stepY","halfStepY","numPoints","numFaces","indicesMapping","getUint8","getFloat32","pow","abs","max","normal","geodeticSurfaceNormal","u","v","facesElementCount","getUint16","RuntimeError","vertexCountWithoutSkirts","indexCountWithoutSkirts","undefined","sort","a","b","percentage","firstBorderIndex","firstSkirtIndex","lastSkirtIndex","orientedBoundingBox","boundingSphere3D","BoundingSphere","fromPoints","OrientedBoundingBox","fromRectangle","occludeePointInScaledSpace","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","AxisAlignedBoundingBox","encoding","TerrainEncoding","vertices","stride","bufferIndex","k","encode","westIndicesSouthToNorth","map","vertex","reverse","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","unshift","maximumHeight","minimumHeight","processBuffer","numberOfAttributes"],"mappings":"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"}