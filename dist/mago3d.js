'use strict';

/**
 * 하늘에 구름을 관리하는 매니저
 *
 * @class Atmosphere
 */
var Atmosphere = function() 
{
	if (!(this instanceof Atmosphere)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.cloudsManager = new CloudsManager();
	this.shadowBlendingCube = new ShadowBlendingCube();
};

/**
 * 구름이 땅에 그림자를 그릴때 사용함
 *
 * @class ShadowBlendingCube
 */
var ShadowBlendingCube = function() 
{
	if (!(this instanceof ShadowBlendingCube)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertexMatrix = new VertexMatrix();
	this.tTrianglesMatrix = new TTrianglesMatrix();
	this.init(this.vertexMatrix, this.tTrianglesMatrix);

	this.vboVertexCacheKey;
	this.vboIndexCacheKey;
	this.indicesCount = 0;
};

/**
 * 구름이 땅에 그림자를 그릴때 초기화
 *
 * @param vtxMat 변수
 * @param tTriMat 변수
 */
ShadowBlendingCube.prototype.init = function(vtxMat, tTriMat) 
{
	// create a blending cube, with faces inverted.***
	var cubeSideSemiLength = 150.5;

	var r = 0.1;
	var g = 0.1;
	var b = 0.1;
	var alpha = 0.6;

	// Center Bottom of the cube.***
	var vertexList = vtxMat.newVertexList();
	var vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, -cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, -cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, -cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, -cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	// Bottom of the cube.***
	vertexList = vtxMat.newVertexList();
	vertex = vertexList.newVertex();
	vertex.setPosition(-cubeSideSemiLength, -cubeSideSemiLength,
		-cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(cubeSideSemiLength, -cubeSideSemiLength,
		-cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(cubeSideSemiLength, cubeSideSemiLength,
		-cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(-cubeSideSemiLength, cubeSideSemiLength,
		-cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	// Top of the cube.***
	vertexList = vtxMat.newVertexList();
	vertex = vertexList.newVertex();
	vertex.setPosition(-cubeSideSemiLength, -cubeSideSemiLength,
		cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(cubeSideSemiLength, -cubeSideSemiLength,
		cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(cubeSideSemiLength, cubeSideSemiLength,
		cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(-cubeSideSemiLength, cubeSideSemiLength,
		cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	// Center Top of the cube.***
	vertexList = vtxMat.newVertexList();
	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	vertex = vertexList.newVertex();
	vertex.setPosition(0.0, 0.0, cubeSideSemiLength);
	vertex.setColorRGBA(r, g, b, alpha);

	// Now, make the tTrianglesMatrix.***
	vtxMat.makeTTrianglesLateralSidesLOOP(tTriMat);
	// tTriMat.invert_trianglesSense();
};

/**
 * 그래픽 카드에 데이터를 올릴때 요청
 *
 * @returns floatArray
 */
ShadowBlendingCube.prototype.getVBOVertexColorRGBAFloatArray = function() 
{
	var floatArray = this.vertexMatrix.getVBOVertexColorRGBAFloatArray();
	return floatArray;
};

/**
 * 그래픽 카드에 데이터를 올릴때 사용(삼각형을 이루어 주는 순서)
 *
 * @returns shortArray
 */
ShadowBlendingCube.prototype.getVBOIndicesShortArray = function() 
{
	this.vertexMatrix.setVertexIdxInList();
	var shortArray = this.tTrianglesMatrix.getVBOIndicesShortArray();
	this.indicesCount = shortArray.length;

	return shortArray;
};

/**
 * 구름 매니저
 *
 * @class CloudsManager
 */
var CloudsManager = function() 
{
	if (!(this instanceof CloudsManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.circularCloudsArray = [];
};

/**
 * 원형 구름 생성
 *
 * @returns circularCloud
 */
CloudsManager.prototype.newCircularCloud = function() 
{
	var circularCloud = new CircularCloud();
	this.circularCloudsArray.push(circularCloud);
	return circularCloud;
};

/**
 * 원형 구름
 *
 * @class CircularCloud
 */
var CircularCloud = function() 
{
	if (!(this instanceof CircularCloud)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.radius = 200.0;
	this.depth = 150.0;
	this.numPointsForCicle = 8;

	this.vertexMatrix = new VertexMatrix();
	this.tTrianglesMatrix = new TTrianglesMatrix();
	this.shadowVertexMatrix = new VertexMatrix();
	this.shadowTTrianglesMatrix = new TTrianglesMatrix();

	this.sunLightDirection = new Point3D();
	this.sunLightDirection.set(1, 1, -5);
	this.sunLightDirection.unitary();

	this.longitude;
	this.latitude;
	this.altitude;
	this.position;
	this.positionHIGH;
	this.positionLOW;

	this.bbox = new BoundingBox();
	this.cullingPosition;
	this.cullingRadius;

	this.vboVertexCacheKey;
	this.vboIndexCacheKey;
	this.vboShadowVertexCacheKey;
	this.vboShadowIndexCacheKey;
	this.indicesCount = 0;

	this.rendered = false; // Test.***

	// SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.***
	// SCRATCH.*** SCRATCH.***
	this.point3dSC = new Point3D();
	this.vertexSC = new Vertex();
};

/**
 * 그래픽 카드에 올릴 데이터를 요청
 *
 * @returns floatArray
 */
CircularCloud.prototype.getVBOVertexColorFloatArray = function() 
{
	var floatArray;
	floatArray = this.vertexMatrix.getVBOVertexColorFloatArray(floatArray);
	return floatArray;
};

/**
 * 그래픽 카드에 올릴 데이터를 요청(삼각형)
 *
 * @returns floatArray
 */
CircularCloud.prototype.getVBOIndicesShortArray = function() 
{
	this.vertexMatrix.setVertexIdxInList();
	var shortArray = this.tTrianglesMatrix.getVBOIndicesShortArray();
	this.indicesCount = shortArray.length;

	return shortArray;
};

/**
 * 그래픽 카드에 올릴 데이터를 요청(Vertex)
 *
 * @returns floatArray
 */
CircularCloud.prototype.getVBOShadowVertexFloatArray = function() 
{
	var floatArray;
	floatArray = this.shadowVertexMatrix.getVBOVertexFloatArray(floatArray);
	return floatArray;
};

/**
 * 그래픽 카드에 올릴 데이터를 요청(삼삭형 순서)
 *
 * @returns shortArray
 */
CircularCloud.prototype.getVBOShadowIndicesShortArray = function() 
{
	this.shadowVertexMatrix.setVertexIdxInList();
	var shortArray = this.shadowTTrianglesMatrix.getVBOIndicesShortArray();
	this.indicesCount = shortArray.length;

	return shortArray;
};

/**
 * 로케이션을 따라서 회전
 *
 * @param vtxMat
 *            변수
 */
CircularCloud.prototype.rotateMeshByLocation = function(vtxMat) 
{
	// we rotate the cloud mesh by longitude, latitude.***
	var matrix = new Matrix4();

	// 1) Rotation Z. Longitude.***
	matrix.rotationAxisAngDeg(-this.longitude, 0.0, 0.0, 1.0);
	vtxMat.transformPointsByMatrix4(matrix);

	// 2) Rotation X'. Latitude.***
	var longitudeRad = this.longitude * Math.PI / 180.0;

	var cloudEquatorialPos = new Point3D();
	var zAxis = new Point3D();
	var pitchAxis;
	cloudEquatorialPos.set(Math.cos(longitudeRad), Math.sin(longitudeRad), 0.0);
	zAxis.set(0.0, 0.0, 1.0);
	pitchAxis = cloudEquatorialPos.crossProduct(zAxis, pitchAxis);
	pitchAxis.unitary();

	// matrix.rotationAxisAngDeg(90.0-this.latitude, Math.cos(longitudeRad-90),
	// -Math.sin(longitudeRad-90), 0.0);
	matrix.rotationAxisAngDeg(90.0 - this.latitude, pitchAxis.x, pitchAxis.y,
		0.0);
	vtxMat.transformPointsByMatrix4(matrix);
};

/**
 * 햇빛 방향으로 시작
 */
CircularCloud.prototype.doShadowMeshWithSunDirection = function() 
{
	var distance = 3000.0;
	var vertexList = this.shadowVertexMatrix.getVertexList(5); // Bottom radius
	// zero ring.***
	vertexList.translateVertices(this.sunLightDirection.x,
		this.sunLightDirection.y, this.sunLightDirection.z, distance);

	vertexList = this.shadowVertexMatrix.getVertexList(4); // Bottom minor
	// ring.***
	vertexList.translateVertices(this.sunLightDirection.x,
		this.sunLightDirection.y, this.sunLightDirection.z, distance);

	vertexList = this.shadowVertexMatrix.getVertexList(3); // Bottom major
	// ring.***
	vertexList.translateVertices(this.sunLightDirection.x,
		this.sunLightDirection.y, this.sunLightDirection.z, distance);
};

/**
 * 구름 생성
 *
 * @param logitude
 *            경도
 * @param latitude
 *            위도
 * @param radius
 *            반지름
 * @param depth
 *            깊이
 * @param numPointsForCircle
 *            동그라미 하나당 점의 갯수
 */
CircularCloud.prototype.createCloud = function(longitude, latitude, altitude,
	radius, depth, numPointsForCircle) 
{
	this.longitude = longitude;
	this.latitude = latitude;
	this.altitude = altitude;
	this.radius = radius;
	this.depth = depth;
	this.numPointsForCicle = numPointsForCircle;

	this.makeMesh(this.vertexMatrix, this.tTrianglesMatrix,
		this.shadowVertexMatrix, this.shadowTTrianglesMatrix);
	// this.makeMesh(this.shadowVertexMatrix, this.shadowTTrianglesMatrix,
	// true);
	// this.shadowTTrianglesMatrix.invertTrianglesSense();// TEST!!!!!!
	this.doShadowMeshWithSunDirection();

	this.rotateMeshByLocation(this.vertexMatrix);
	this.rotateMeshByLocation(this.shadowVertexMatrix);

	var position = Cesium.Cartesian3.fromDegrees(this.longitude, this.latitude,
		this.altitude);
	this.position = position;

	// var splitValue = Cesium.EncodedCartesian3.encode(position);
	var splitVelueX = Cesium.EncodedCartesian3.encode(position.x);
	var splitVelueY = Cesium.EncodedCartesian3.encode(position.y);
	var splitVelueZ = Cesium.EncodedCartesian3.encode(position.z);

	this.positionHIGH = new Float32Array([ splitVelueX.high, splitVelueY.high,
		splitVelueZ.high ]);
	this.positionLOW = new Float32Array([ splitVelueX.low, splitVelueY.low,
		splitVelueZ.low ]);

	this.bbox = this.shadowVertexMatrix.getBoundingBox(this.bbox);
	var cloudPoint3d;
	cloudPoint3d = this.bbox.getCenterPoint(cloudPoint3d);
	this.cullingPosition = new Cesium.Cartesian3(cloudPoint3d.x
			+ this.position.x, cloudPoint3d.y + this.position.y, cloudPoint3d.z
			+ this.position.z);
	this.cullingRadius = this.bbox.getMaxLength() / 2;
};

/**
 * mesh 생성
 *
 * @param vtxMat
 *            변수
 * @param tTriMat
 *            변수
 * @param shadowVtxMat
 *            변수
 * @param shadowTTriMat
 *            변수
 */
CircularCloud.prototype.makeMesh = function(vtxMat, tTriMat, shadowVtxMat,
	shadowTTriMat) 
{
	// use vertex_matrix.***
	// our cloud has 6 rings. Top ring and the bottom ring has radius zero.***
	var numPointsForRing = 16;
	var increAngRad = (2.0 * Math.PI) / numPointsForRing;
	var angRad = 0.0;
	var vertex;
	var shadowVertex;
	var semiDepth = this.depth / 2.0;
	var x = 0.0;
	var y = 0.0;
	var randomValue = 0;
	// var cloudWhite = 0.98;

	// 1) Top ring. radius zero.***
	var vertexList = vtxMat.newVertexList();
	var shadowVertexList = shadowVtxMat.newVertexList();
	randomValue = 0.9 + 0.3 * Math.random();
	for (var i = 0; i < numPointsForRing; i++) 
	{
		vertex = vertexList.newVertex();
		vertex.setPosition(x, y, semiDepth);
		shadowVertex = shadowVertexList.newVertex();
		shadowVertex.setPosition(x, y, -semiDepth * 1.2);
		vertex.setColorRGB(randomValue, randomValue, randomValue);
	}

	// 2) Top menor_ring.***
	angRad = 0.0;
	var menorRingRadius = this.radius * 0.7;
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	for (var i = 0; i < numPointsForRing; i++) 
	{
		// Math.random(); // returns from 0.0 to 1.0.***
		randomValue = (2 + Math.random()) / 2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		x = menorRingRadius * Math.cos(angRad) * randomValue;
		y = menorRingRadius * Math.sin(angRad) * randomValue;
		shadowVertex.setPosition(x, y, -semiDepth * 2);
		vertex.setPosition(x, y, semiDepth * 0.8);
		randomValue = 0.9 + 0.3 * Math.random();
		vertex.setColorRGB(randomValue, randomValue, randomValue);
		angRad += increAngRad;
	}

	// 3) Top major_ring.***
	angRad = 0.0;
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	for (var i = 0; i < numPointsForRing; i++) 
	{
		randomValue = (2 + Math.random()) / 2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		x = this.radius * Math.cos(angRad) * randomValue;
		y = this.radius * Math.sin(angRad) * randomValue;
		shadowVertex.setPosition(x, y, -semiDepth * 2);
		vertex.setPosition(x, y, semiDepth * 0.4);

		randomValue = 0.9 + 0.3 * Math.random();
		vertex.setColorRGB(randomValue, randomValue, randomValue);
		angRad += increAngRad;
	}

	// 4) Bottom major_ring.***
	angRad = 0.0;
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	for ( var i = 0; i < numPointsForRing; i++ ) 
	{
		randomValue = (2 + Math.random()) / 2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		x = this.radius * Math.cos(angRad) * randomValue;
		y = this.radius * Math.sin(angRad) * randomValue;
		shadowVertex.setPosition(x, y, -semiDepth * 2);
		vertex.setPosition(x, y, -semiDepth * 0.4);
		randomValue = 0.8 + 0.3 * Math.random();
		vertex.setColorRGB(randomValue, randomValue, randomValue);
		angRad += increAngRad;
	}

	// 5) Bottom menor_ring.***
	angRad = 0.0;
	menorRingRadius = this.radius * 0.7;
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	for (var i = 0; i < numPointsForRing; i++ ) 
	{
		randomValue = (2 + Math.random()) / 2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		x = menorRingRadius * Math.cos(angRad) * randomValue;
		y = menorRingRadius * Math.sin(angRad) * randomValue;
		vertex.setPosition(x, y, -semiDepth * 0.8);
		shadowVertex.setPosition(x, y, -semiDepth * 1.2);

		randomValue = 0.6 + 0.3 * Math.random();
		vertex.setColorRGB(randomValue, randomValue, randomValue);
		// vertex.setColorRGB(0.58, 0.58, 0.58);
		angRad += increAngRad;
	}

	// 6) Bottom ring. radius zero.***
	vertexList = vtxMat.newVertexList();
	shadowVertexList = shadowVtxMat.newVertexList();
	randomValue = 0.6 + 0.3 * Math.random();
	for ( var i = 0; i < numPointsForRing; i++ ) 
	{
		// randomValue = (2+Math.random())/2;
		vertex = vertexList.newVertex();
		shadowVertex = shadowVertexList.newVertex();
		vertex.setPosition(0.0, 0.0, -semiDepth);
		shadowVertex.setPosition(0.0, 0.0, -semiDepth);

		vertex.setColorRGB(randomValue, randomValue, randomValue);
		// vertex.setColorRGB(0.58, 0.58, 0.58);
	}

	// Now, make the tTrianglesMatrix.***
	vtxMat.makeTTrianglesLateralSidesLOOP(tTriMat);
	shadowVtxMat.makeTTrianglesLateralSidesLOOP(shadowTTriMat);
	// tTriMat.invertTrianglesSense(); // No.***

	// Now, calculate the culling bbox.***
};

'use strict';

/**
 * 영역 박스
 * @class AuxiliarSegment
 */
var AuxiliarSegment = function() 
{
	if (!(this instanceof AuxiliarSegment)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.point1; //auxSegment.point1 = new WorldWind.Vec3();
	this.point2; //auxSegment.point2 = new WorldWind.Vec3();
};

AuxiliarSegment.prototype.setPoints = function(point1X, point1Y, point1Z,   point2X, point2Y, point2Z)
{
	this.point1[0] = point1X;
	this.point1[1] = point1Y;
	this.point1[2] = point1Z;
	
	this.point2[0] = point2X;
	this.point2[1] = point2Y;
	this.point2[2] = point2Z;
};
'use strict';

/**
 * 영역박스
 * 
 * @alias BoundingBox
 * @class BoundingBox
 */
var BoundingBox = function() 
{
	if (!(this instanceof BoundingBox)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.minX = 1000000.0;
	this.minY = 1000000.0;
	this.minZ = 1000000.0;

	this.maxX = -1000000.0;
	this.maxY = -1000000.0;
	this.maxZ = -1000000.0;
};

/**
 * 영역박스 초기화
 * 
 * @param {Point3D} point 3차원 점
 */
BoundingBox.prototype.init = function(point) 
{
	point = point || new Point3D();

	this.minX = point.x;
	this.minY = point.y;
	this.minZ = point.z;

	this.maxX = point.x;
	this.maxY = point.y;
	this.maxZ = point.z;
};

/**
 * 영역박스 삭제
 * 
 */
BoundingBox.prototype.deleteObjects = function() 
{
	this.minX = undefined;
	this.minY = undefined;
	this.minZ = undefined;

	this.maxX = undefined;
	this.maxY = undefined;
	this.maxZ = undefined;
};

/**
 * 영역박스 확대
 * 
 * @param {Number} distance
 */
BoundingBox.prototype.copyFrom = function(bbox) 
{
	this.minX = bbox.minX;
	this.minY = bbox.minY;
	this.minZ = bbox.minZ;

	this.maxX = bbox.maxX;
	this.maxY = bbox.maxY;
	this.maxZ = bbox.maxZ;
};

/**
 * 영역박스 확대
 * 
 */
BoundingBox.prototype.translateToOrigin = function() 
{
	var semiXLength = this.getXLength() /2;
	var semiYLength = this.getYLength() /2;
	var semiZLength = this.getZLength() /2;
	
	this.minX = -semiXLength;
	this.minY = -semiYLength;
	this.minZ = -semiZLength;

	this.maxX = semiXLength;
	this.maxY = semiYLength;
	this.maxZ = semiZLength;
};

/**
 * 영역박스 확대
 * 
 * @param {Number} distance
 */
BoundingBox.prototype.expand = function(distance) 
{
	distance = distance || 0.0;
	distance = Math.abs(distance);

	this.minX -= distance;
	this.minY -= distance;
	this.minZ -= distance;

	this.maxX += distance;
	this.maxY += distance;
	this.maxZ += distance;
};

/**
 * 주어진 3차원 점을 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {Point3D} point 3차원 점
 */
BoundingBox.prototype.addPoint = function(point) 
{
	if (point === undefined)	{ return; }

	if (point.x < this.minX) { this.minX = point.x; }
	else if (point.x > this.maxX) { this.maxX = point.x; }

	if (point.y < this.minY) { this.minY = point.y; }
	else if (point.y > this.maxY) { this.maxY = point.y; }

	if (point.z < this.minZ) { this.minZ = point.z; }
	else if (point.z > this.maxZ) { this.maxZ = point.z; }
};

/**
 * 주어진 영역박스를 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {BoundingBox} box 영역박스
 */
BoundingBox.prototype.addBox = function(box) 
{
	if (box === undefined)	{ return; }

	if (box.minX < this.minX) { this.minX = box.minX; }
	if (box.maxX > this.maxX) { this.maxX = box.maxX; }

	if (box.minY < this.minY) { this.minY = box.minY; }
	if (box.maxY > this.maxY) { this.maxY = box.maxY; }

	if (box.minZ < this.minZ) { this.minZ = box.minZ; }
	if (box.maxZ > this.maxZ) { this.maxZ = box.maxZ; }
};

/**
 * 영역박스의 가로, 세로, 높이 중에서 최소값
 * 
 * @returns {Number} 최소값
 */
BoundingBox.prototype.getMinLength = function() 
{
	return Math.min(this.maxX - this.minX, this.maxY - this.minY, this.maxZ - this.minZ);
};

/**
 * 영역박스의 가로, 세로, 높이 중에서 최대값
 * 
 * @returns {Number} 최대값
 */
BoundingBox.prototype.getMaxLength = function() 
{
	return Math.max(this.maxX - this.minX, this.maxY - this.minY, this.maxZ - this.minZ);
};

/**
 * 영역박스의 X축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getXLength = function() 
{
	return this.maxX - this.minX;
};

/**
 * 영역박스의 Y축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getYLength = function() 
{
	return this.maxY - this.minY;
};

/**
 * 영역박스의 Z축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getZLength = function() 
{
	return this.maxZ - this.minZ;
};

/**
 * 영역박스의 중심점을 구한다.
 * 
 * @param {Point3D} result 영역박스의 중심점
 * 
 * @returns {Point3D} 영역박스의 중심점
 */
BoundingBox.prototype.getCenterPoint = function(result) 
{
	if ( result === undefined ) { result = new Point3D(); }

	result.set((this.maxX + this.minX)/2, (this.maxY + this.minY)/2, (this.maxZ + this.minZ)/2);

	return result;
};

/**
 * 영역박스의 중심점을 구한다.
 * 
 * @returns {float} apriximately radius.
 */
BoundingBox.prototype.getRadiusAprox = function() 
{
	var maxLength = this.getMaxLength();
	return maxLength/1.5;
};


/**
 * 영역박스와 점과의 교차 여부를 판단
 * 
 * @param {Point3D} point 3차원 점
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.intersectWithPoint = function(point) 
{
	if (point === undefined)	{ return false; }

	if (point.x < this.minX || point.x > this.maxX || 
		point.y < this.minY || point.y > this.maxY ||
		point.z < this.minZ || point.z > this.maxZ) 
	{
		return false;
	}

	//return this.isPoint3dInside(point.x, point.y, point.z);
	return true;
};

/**
 * 영역박스와 점과의 교차 여부를 판단
 * 
 * @param {Number} x x성분
 * @param {Number} y y성분
 * @param {Number} z z성분
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.isPoint3dInside = function(x, y, z) 
{
	if (x < this.minX || x > this.maxX) 
	{
		return false;
	}
	else if (y < this.minY || y > this.maxY) 
	{
		return false;
	}
	else if (z < this.minZ || z > this.maxZ) 
	{
		return false;
	}

	return true;
};

/**
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {BoundingBox} box 영역박스
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.intersectWithBox = function(box)
{
	if (box === undefined)	{ return false; }

	if (box.minX > this.maxX || box.maxX < this.minX ||
		box.minY > this.maxY || box.maxY < this.minY ||
		box.minZ > this.maxZ || box.maxZ < this.minZ)
	{
		return false;
	}

	return true;
};

/**
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {BoundingBox} box 영역박스
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.intersectsWithBBox = function(box) 
{
	var intersection = true;

	if (this.maxX < box.minX)
	{
		intersection = false;
	}
	else if (this.minX > box.maxX)
	{
		intersection = false;
	}
	else if (this.maxY < box.minY)
	{
		intersection = false;
	}
	else if (this.minY > box.maxY)
	{
		intersection = false;
	}
	else if (this.maxZ < box.minZ)
	{
		intersection = false;
	}
	else if (this.minZ > box.maxZ)
	{
		intersection = false;
	}

	return intersection;
};

'use strict';

/**
 * 영역 박스
 * @class BoundingSphere
 */
var BoundingSphere = function() 
{
	if (!(this instanceof BoundingSphere)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.center = new Point3D();
	this.radius = 0.0;
};
'use strict';

/**
 * 영역 박스
 * @class Box
 */
var Box = function() 
{
	if (!(this instanceof Box)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	this.vbo_vicks_containerEdges;
	this.centerPoint;
	this.width;
	this.length;
	this.height;

};

/**
 * box
 */
Box.prototype.getVboKeysContainer = function()
{
	return this.vbo_vicks_container;
};

/**
 * box
 */
Box.prototype.makeMesh = function(width, length, height)
{
	// check dimensions of the box.***
	if (width !== undefined)
	{ this.width = width; }
	
	if (length !== undefined)
	{ this.length = length; }
	
	if (height !== undefined)
	{ this.height = height; }
	
	if (this.width === undefined)
	{ this.width = 1; }
	
	if (this.length === undefined)
	{ this.length = 1; }
	
	if (this.height === undefined)
	{ this.height = 1; }
	
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point3D(0, 0, 0); }
	
	if (this.vbo_vicks_container === undefined)
	{ this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer(); }
	
	if (this.vbo_vicks_containerEdges === undefined)
	{ this.vbo_vicks_containerEdges = new VBOVertexIdxCacheKeysContainer(); }
	
	// Create a parametric mesh.***
	var pMesh = new ParametricMesh();
		
	// Create a Profile2d.***
	pMesh.profile = new Profile(); 
	var profileAux = pMesh.profile; 
	
	// Create a outer ring in the Profile2d.***
	var outerRing = profileAux.newOuterRing();
	var rect = outerRing.newElement("RECTANGLE");
	rect.setCenterPosition(this.centerPoint.x, this.centerPoint.y);
	rect.setDimensions(this.width, this.length);
	
	// Extrude the Profile.***
	var extrudeSegmentsCount = 1;
	var extrusionVector = undefined;
	pMesh.extrude(profileAux, this.height, extrudeSegmentsCount, extrusionVector);
	
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	var mesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	
	// translate the box bcos center the origen to the center of the box.***
	mesh.translate(0, 0, -this.height/2);

	return mesh;
};





































'use strict';

/**
 * buildings seed
 * @class BuildingSeed
 */
var BuildingSeed = function() 
{
	if (!(this instanceof BuildingSeed)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.fisrtName;
	this.name = "";
	this.buildingId;
	this.buildingFileName;
	this.geographicCoord; // class : GeographicCoord.
	this.rotationsDegree; // class : Point3D. (heading, pitch, roll).
	this.bBox;            // class : BoundingBox.
	this.geographicCoordOfBBox; // class : GeographicCoord.
};

/**
 * 어떤 일을 하고 있습니까?
 */
BuildingSeed.prototype.deleteObjects = function() 
{
	this.fisrtName = undefined;
	this.name = undefined;
	this.buildingId = undefined;
	this.buildingFileName = undefined;
	
	this.geographicCoord.deleteObjects(); 
	this.rotationsDegree.deleteObjects();
	this.bBox.deleteObjects();           
	this.geographicCoordOfBBox.deleteObjects(); 
	
	this.geographicCoord = undefined; 
	this.rotationsDegree = undefined;
	this.bBox = undefined;           
	this.geographicCoordOfBBox = undefined; 
};

/**
 * buildings seed list
 * @class BuildingSeedList
 */
var BuildingSeedList = function() 
{
	if (!(this instanceof BuildingSeedList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.buildingSeedArray = [];
	this.minGeographicCoord; // longitude, latitude, altitude.
	this.maxGeographicCoord; // longitude, latitude, altitude.
	
	this.dataArrayBuffer; // binary data.
};

/**
 * 어떤 일을 하고 있습니까?
 */
BuildingSeedList.prototype.deleteObjects = function() 
{
	this.minGeographicCoord.deleteObjects(); 
	this.maxGeographicCoord.deleteObjects(); 
	
	this.minGeographicCoord = undefined; 
	this.maxGeographicCoord = undefined;
	
	if (this.buildingSeedArray)
	{
		var buildingSeedsCount = this.buildingSeedArray.length;
		for (var i=0; i<buildingSeedsCount; i++)
		{
			this.buildingSeedArray[i].deleteObjects();
			this.buildingSeedArray[i] = undefined;
		}
		this.buildingSeedArray = undefined;
	}
	
	this.dataArrayBuffer = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 */
BuildingSeedList.prototype.newBuildingSeed = function() 
{
	var buildingSeed = new BuildingSeed();
	this.buildingSeedArray.push(buildingSeed);
	return buildingSeed;
};

/**
 * 어떤 일을 하고 있습니까?
 */
BuildingSeedList.prototype.parseBuildingSeedArrayBuffer = function() 
{
	if (this.dataArrayBuffer === undefined)
	{ return false; }
	
	var arrayBuffer = this.dataArrayBuffer;
	var bytesReaded = 0;
	var buildingNameLength;
	var longitude;
	var latitude;
	var altitude;

	var buildingsCount = new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0];
	bytesReaded += 4;
	for (var i =0; i<buildingsCount; i++) 
	{
		var buildingSeed = this.newBuildingSeed();

		if (buildingSeed.geographicCoord === undefined)
		{ buildingSeed.geographicCoord = new GeographicCoord(); }

		if (buildingSeed.bBox === undefined) 
		{ buildingSeed.bBox = new BoundingBox(); }

		buildingNameLength = new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0];
		bytesReaded += 4;
		var decoder = new TextDecoder('utf-8');
		var buildingName = decoder.decode(new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		//var buildingName = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		bytesReaded += buildingNameLength;

		// now the geographic coords, but this is provisional coords.
		longitude = new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8))[0]; bytesReaded += 8;
		latitude = new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8))[0]; bytesReaded += 8;
		altitude = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;

		buildingSeed.bBox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;

		// create a building and set the location.***
		buildingSeed.buildingId = buildingName.substr(4, buildingNameLength-4);
		buildingSeed.buildingFileName = buildingName;
		buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
	}
	
	return true;
};




























'use strict';

/**
 * 카메라
 * @class Camera
 */
var Camera = function() 
{
	if (!(this instanceof Camera)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.position = new Point3D(); 
	this.direction = new Point3D(); 
	this.up = new Point3D();
	this.right = new Point3D();
	this.frustum = new Frustum(); // current frustum.***
	this.bigFrustum = new Frustum(); // sum of all frustums.***
	this.dirty = true;
	this.frustumsArray = [];
	this.frustumsArray.push(this.frustum);
	
	// auxiliar vars.
	// points.
	this.nearCenterPoint = new Point3D();
	this.farCenterPoint = new Point3D();
	
	this.farLeftBottomPoint = new Point3D();
	this.farRightTopPoint = new Point3D();
	
	// directions.
	this.leftBottomDir = new Point3D();
	this.rightTopDir = new Point3D();
	
	// normals.
	this.leftNormal = new Point3D();
	this.rightNormal = new Point3D();
	this.bottomNormal = new Point3D();
	this.topNormal = new Point3D();
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.copyPosDirUpFrom = function(camera)
{
	this.position.copyFrom(camera.position);
	this.direction.copyFrom(camera.direction);
	this.up.copyFrom(camera.up);
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.transformByMatrix4 = function(mat)
{
	// transform position, direction and up.***
	/*
	var camePosHIGH = new Float32Array(3);
	var camPosLOW = new Float32Array(3);
	var pos = vec3.clone([this.position.x, this.position.y, this.position.z]);
	ManagerUtils.calculateSplited3fv(pos, camePosHIGH, camPosLOW);
	
	camePosHIGH = vec3.transformMat4(camePosHIGH, camePosHIGH, mat);
	camPosLOW = vec3.transformMat4(camPosLOW, camPosLOW, mat);
	this.position.set(camePosHIGH[0] + camPosLOW[0], camePosHIGH[1] + camPosLOW[1], camePosHIGH[2] + camPosLOW[2]);
	*/
	this.position = this.transformPoint3DByMatrix4(this.position, mat);
	
	if (this.rotMat === undefined)
	{ this.rotMat = mat3.create(); }
	
	this.rotMat = mat3.fromMat4(this.rotMat, mat);

	this.direction = this.rotatePoint3DByMatrix3(this.direction, this.rotMat);
	this.up = this.rotatePoint3DByMatrix3(this.up, this.rotMat);
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.getCameraDirectionLine = function(resultLine)
{
	if (resultLine === undefined)
	{ resultLine = new Line(); }
	
	resultLine.point.set(this.position.x, this.position.y, this.position.z);
	resultLine.direction.set(this.direction.x, this.direction.y, this.direction.z);
	
	return resultLine;
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.getCameraElevation = function()
{
	// determine camHeight.***
	var camModul = this.position.getModul();
	// this.equatorialRadius = 6378137.0;
	//this.polarRadius = 6356752.3142;
	return  camModul - 6356752.3142;
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.getCameraRight = function()
{
	if (this.right === undefined)
	{ this.right = new Point3D(); }
	
	this.right = this.direction.crossProduct(this.up, this.right);
	return this.right;
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.transformPoint3DByMatrix4 = function(point, mat)
{
	var pos = vec3.clone([point.x, point.y, point.z]);
	var tPos = vec3.create();
	tPos = vec3.transformMat4(tPos, pos, mat);
	point.set(tPos[0], tPos[1], tPos[2]);
	
	return point;
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.rotatePoint3DByMatrix3 = function(point, mat)
{
	var pos = vec3.clone([point.x, point.y, point.z]);
	var tPos = vec3.create();
	tPos = vec3.transformMat3(tPos, pos, mat);
	point.set(tPos[0], tPos[1], tPos[2]);
	
	return point;
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.setDirty = function(cameraIsDirty)
{
	this.dirty = cameraIsDirty;
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.getDirty = function()
{
	return this.dirty;
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.isCameraMoved = function(newPosX, newPosY, newPosZ, newDirX, newDirY, newDirZ, newUpX, newUpY, newUpZ )
{
	if (this.position.x === newPosX && this.position.y === newPosY && this.position.z === newPosZ && 
		this.direction.x === newDirX && this.direction.y === newDirY && this.direction.z === newDirZ && 
		this.up.x === newUpX && this.up.y === newUpY && this.up.z === newUpZ)
	{ return false; }
	else
	{ return true; }
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.getFrustum = function(idx)
{
	if (this.frustumsArray[idx] === undefined)
	{
		this.frustumsArray[idx] = new Frustum();
		this.frustumsArray[idx].fovRad[0] = this.frustumsArray[0].fovRad[0];
		this.frustumsArray[idx].fovyRad[0]= this.frustumsArray[0].fovyRad[0];
		this.frustumsArray[idx].aspectRatio[0] = this.frustumsArray[0].aspectRatio[0];
		this.frustumsArray[idx].tangentOfHalfFovy[0] = this.frustumsArray[0].tangentOfHalfFovy[0];
	}
	
	return this.frustumsArray[idx];
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.getLastFrustum = function()
{
	return this.getFrustum(this.frustumsArray.length - 1);
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.setFrustumsDistances = function(numFrustums, distancesArray)
{
	var nearFarDistances;
	var frustum;
	for (var i=0; i<numFrustums; i++)
	{
		nearFarDistances = distancesArray[i];
		frustum = this.getFrustum(i);
		frustum.near[0] = distancesArray[i*2];
		frustum.far[0] = distancesArray[i*2+1];
		if (i === 0)
		{
			this.bigFrustum.near[0] = distancesArray[i*2];
		}
		if (i === numFrustums - 1)
		{
			this.bigFrustum.far[0] = distancesArray[i*2+1];
		}
	}
	
	// provisionally fix the far.***
	if (this.bigFrustum.far[0] > 20000.0)
	{ this.bigFrustum.far[0] = 20000.0; }
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.setAspectRatioAndFovyRad = function(aspectRatio, fovyRad)
{
	var frustum, frustum0;
	
	frustum0 = this.getFrustum(0);
	frustum0.aspectRatio[0] = aspectRatio;
	frustum0.fovyRad[0] = fovyRad; 
	frustum0.fovRad[0] = fovyRad*aspectRatio;
	frustum0.tangentOfHalfFovy[0] = Math.tan(fovyRad/2);
		
	var frustumsCount = this.frustumsArray.length;
	for (var i=1; i<frustumsCount; i++)
	{
		frustum = this.getFrustum(i);
		frustum.aspectRatio[0] = frustum0.aspectRatio[0];
		frustum.fovyRad[0] = frustum0.fovyRad[0]; 
		frustum.fovRad[0] = frustum0.fovRad[0];
		frustum.tangentOfHalfFovy[0] = frustum0.tangentOfHalfFovy[0];
	}
	
	this.bigFrustum.aspectRatio[0] = frustum0.aspectRatio[0];
	this.bigFrustum.fovyRad[0] = frustum0.fovyRad[0]; 
	this.bigFrustum.fovRad[0] = frustum0.fovRad[0];
	this.bigFrustum.tangentOfHalfFovy[0] = frustum0.tangentOfHalfFovy[0];
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.setCurrentFrustum = function(frustumIdx)
{
	this.frustum = this.getFrustum(frustumIdx);
};

/**
 * 카메라
 * @class Camera
 */
Camera.prototype.calculateFrustumsPlanes = function()
{
	var plane;
	var frustum0; // the 1rst frustum.***
	
	// Use the frustum0 to calculate nearWidth, nearHeight, farWidth & farHeight.
	frustum0 = this.getFrustum(0);
	var nearHeight = frustum0.tangentOfHalfFovy * frustum0.near * 2;
	var farHeight = frustum0.tangentOfHalfFovy * frustum0.far * 2;
	var nearWidth = nearHeight * frustum0.aspectRatio;
	var farWidht = farHeight * frustum0.aspectRatio;
	
	var px = this.position.x;
	var py = this.position.y;
	var pz = this.position.z;

	var dx = this.direction.x;
	var dy = this.direction.y;
	var dz = this.direction.z;
	
	// calculate right direction. "up" and "direction" must be unitaries.
	this.right = this.direction.crossProduct(this.up, this.right);
	
	// calculate the near and far points.
	this.nearCenterPoint.set(px + dx * frustum0.near, py + dy * frustum0.near, pz + dz * frustum0.near);
	this.farCenterPoint.set(px + dx * frustum0.far, py + dy * frustum0.far, pz + dz * frustum0.far);
	
	// far plane points.
	this.farLeftBottomPoint.set(this.farCenterPoint.x - this.right.x*farWidht*0.5 - this.up.x*farHeight*0.5, 
		this.farCenterPoint.y - this.right.y*farWidht*0.5 - this.up.y*farHeight*0.5, 
		this.farCenterPoint.z - this.right.z*farWidht*0.5 - this.up.z*farHeight*0.5);
								
	this.farRightTopPoint.set(this.farLeftBottomPoint.x + this.right.x*farWidht + this.up.x*farHeight, 
		this.farLeftBottomPoint.y + this.right.y*farWidht + this.up.y*farHeight, 
		this.farLeftBottomPoint.z + this.right.z*farWidht + this.up.z*farHeight);				
	
	// calculate directions.
	this.leftBottomDir.set(this.farLeftBottomPoint.x - px, this.farLeftBottomPoint.y - py, this.farLeftBottomPoint.z - pz);
	this.leftBottomDir.unitary(); // no necessary.
	
	this.rightTopDir.set(this.farRightTopPoint.x - px, this.farRightTopPoint.y - py, this.farRightTopPoint.z - pz);
	this.rightTopDir.unitary(); // no necessary.
	
	// near plane.
	plane = frustum0.planesArray[0];
	plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
							
	// far plane.
	plane = frustum0.planesArray[1];
	plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);

	// The 4 lateral planes are the same for all frustum0s.***
	// left plane.
	this.leftNormal = this.leftBottomDir.crossProduct(this.up, this.leftNormal);
	this.leftNormal.unitary();
	plane = frustum0.planesArray[2];
	plane.setPointAndNormal(px, py, pz, this.leftNormal.x, this.leftNormal.y, this.leftNormal.z);
							
	// bottom plane.
	this.bottomNormal = this.right.crossProduct(this.leftBottomDir, this.bottomNormal);
	this.bottomNormal.unitary();
	plane = frustum0.planesArray[3];
	plane.setPointAndNormal(px, py, pz, this.bottomNormal.x, this.bottomNormal.y, this.bottomNormal.z);
							
	// right plane.
	this.rightNormal = this.up.crossProduct(this.rightTopDir, this.rightNormal);
	this.rightNormal.unitary();
	plane = frustum0.planesArray[4];
	plane.setPointAndNormal(px, py, pz, this.rightNormal.x, this.rightNormal.y, this.rightNormal.z);
	
	// top plane.
	this.topNormal = this.rightTopDir.crossProduct(this.right, this.topNormal);
	this.topNormal.unitary();
	plane = frustum0.planesArray[5];
	plane.setPointAndNormal(px, py, pz, this.topNormal.x, this.topNormal.y, this.topNormal.z);
	
	// once finished, calculate the rest of frustums.***
	var frustum;
	var frustumsCount = this.frustumsArray.length;
	for (var i=1; i<frustumsCount; i++)
	{
		frustum = this.getFrustum(i);
		
		// calculate the near and far points.
		this.nearCenterPoint.set(px + dx * frustum.near, py + dy * frustum.near, pz + dz * frustum.near);
		this.farCenterPoint.set(px + dx * frustum.far, py + dy * frustum.far, pz + dz * frustum.far);
		
		// near plane.
		plane = frustum.planesArray[0];
		plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
								
		// far plane.
		plane = frustum.planesArray[1];
		plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);
		
		// the lateral planes.***
		for (var j=2; j<6; j++)
		{
			frustum.planesArray[j] = frustum0.planesArray[j];
		}
	}
	
	// finally calculate the totalFrustum(BigFrustum).***
	// calculate the near and far points.
	this.nearCenterPoint.set(px + dx * this.bigFrustum.near, py + dy * this.bigFrustum.near, pz + dz * this.bigFrustum.near);
	this.farCenterPoint.set(px + dx * this.bigFrustum.far, py + dy * this.bigFrustum.far, pz + dz * this.bigFrustum.far);
	
	// near plane.
	plane = this.bigFrustum.planesArray[0];
	plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
							
	// far plane.
	plane = this.bigFrustum.planesArray[1];
	plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);
		
	var lastFrustum = this.getLastFrustum();
	for (var j=2; j<6; j++) // starting in i==2.***
	{
		// the bigFrustum is esqual to frustum0 except in the "far".***
		this.bigFrustum.planesArray[j] = frustum0.planesArray[j];
	}
};
























'use strict';

/**
 * 카메라
 * @class CCTV
 */
var CCTV = function(name) 
{
	if (!(this instanceof CCTV)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.name = "noName";
	if (name !== undefined)
	{ this.name = name; }

	this.geoLocationData = new GeoLocationData();
	this.minHeading = 0.0;
	this.maxHeading = 90.0;
	this.heading = 30.0;
	this.pitch = 60.0;
	this.roll = 0.0;
	this.rotMat = new Matrix4();
	this.camera = new Camera();
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.***
	this.vboKeyContainerEdges; // class: VBOVertexIdxCacheKeyContainer.***
	this.color = new Color();
	this.color.setRGBA(0.0, 0.5, 0.9, 0.3);
	this.greenFactorSpeed = 1.0;
	this.blueFactorSpeed = 2.0;
	this.alphaFactorSpeed = 2.0;
	
	this.headingAngularSpeed = 25.0; // 1 deg per second.***
	this.lastTime;
};

/**
 */
CCTV.prototype.updateHeading = function(currTime)
{
	if (this.lastTime === undefined)
	{ this.lastTime = currTime; }

	var timeAmount = (currTime - this.lastTime)/1000;
	this.heading += timeAmount * this.headingAngularSpeed;
	
	if (this.heading > this.maxHeading)
	{
		this.heading = this.maxHeading;
		this.headingAngularSpeed *= -1.0;
	}
	else if (this.heading < this.minHeading)
	{
		this.heading = this.minHeading;
		this.headingAngularSpeed *= -1.0;
	}
	
	this.lastTime = currTime;
	this.calculateRotationMatrix();
	
	// change color.***
	if (this.greenFactor === undefined)
	{ this.greenFactor = 1.0; }
	
	if (this.blueFactor === undefined)
	{ this.blueFactor = 1.0; }
	
	if (this.alphaFactor === undefined)
	{ this.alphaFactor = 1.0; }
	
	this.greenFactor += this.greenFactorSpeed * timeAmount;
	this.blueFactor += this.blueFactorSpeed * timeAmount;
	
	if (this.greenFactor > 0.5 )
	{
		this.greenFactor = 0.5;
		this.greenFactorSpeed *= -1;
	}
	
	if (this.greenFactor < 0.0 )
	{
		this.greenFactor = 0.0;
		this.greenFactorSpeed *= -1;
	}
	
	if (this.blueFactor > 0.9 )
	{
		this.blueFactor = 0.9;
		this.blueFactorSpeed *= -1;
	}
	
	if (this.blueFactor < 0.0 )
	{
		this.blueFactor = 0.0;
		this.blueFactorSpeed *= -1;
	}
	
	
	if (this.alphaFactor > 0.6 )
	{
		this.alphaFactor = 0.6;
		this.alphaFactorSpeed *= -1;
	}
	
	if (this.alphaFactor < 0.0 )
	{
		this.alphaFactor = 0.0;
		this.alphaFactorSpeed *= -1;
	}
	
	this.color.setRGBA(0.0, this.greenFactor, this.blueFactor, this.alphaFactor);
};

/**
 */
CCTV.prototype.calculateRotationMatrix = function()
{
	var rotMatAux;
	rotMatAux = Matrix4.getRotationDegZXYMatrix(this.heading, this.pitch, this.roll, rotMatAux);
	this.rotMat = rotMatAux.getMultipliedByMatrix(this.geoLocationData.rotMatrix, this.rotMat);
};

/**
 */
CCTV.prototype.getVbo = function(resultVboContainer, resultVboContainerEdges)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	if (this.vboKeyContainerEdges === undefined)
	{ this.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }

	var frustumMesh;
	
	/*
	frustumMesh = this.makeFrustumGeometry(frustumMesh);
	
	var surfaceIndepMesh;
	surfaceIndepMesh = frustumMesh.getCopySurfaceIndependentMesh(surfaceIndepMesh);
	resultVboContainer = surfaceIndepMesh.getVbo(resultVboContainer);
	return resultVboContainer;
	*/
	
	// make vbo.***
	frustumMesh = this.makeFrustumGeometry_2(frustumMesh);
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	
	// now rotate in X axis.***
	var rotMatAux = new Matrix4();
	var frustum = this.camera.bigFrustum;
	var halfFovyRad = frustum.fovyRad / 2.0;
	rotMatAux.rotationAxisAngDeg(-90.0 - (halfFovyRad/2) * 180.0 / Math.PI, 1.0, 0.0, 0.0);
	
	var surfIndepMesh = frustumMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	surfIndepMesh.transformByMatrix4(rotMatAux);
	surfIndepMesh.setColor(0.0, 0.5, 0.9, 0.3);
	
	surfIndepMesh.getVbo(resultVboContainer);
	surfIndepMesh.getVboEdges(this.vboKeyContainerEdges);
	
	return resultVboContainer;
};

/**
 */
CCTV.prototype.render = function(gl, magoManager, shader)
{
	if (this.vboKeyContainer === undefined)
	{ return; }
	
	var cacheKeys_count = this.vboKeyContainer.vboCacheKeysArray.length;
	
	//gl.uniform1i(shader.bApplySpecularLighting_loc, false);
	
	// Must applicate the transformMatrix.***
	gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.geoLocationData.rotMatrix._floatArrays);
	gl.uniform3fv(shader.buildingPosHIGH_loc, this.geoLocationData.positionHIGH);
	gl.uniform3fv(shader.buildingPosLOW_loc, this.geoLocationData.positionLOW);
	
	gl.uniform1i(shader.hasTexture_loc, false); //.***
	
	gl.enable(gl.POLYGON_OFFSET_FILL);
	gl.polygonOffset(1, 3);
	
	var renderWireframe;
	
	var refMatrixType = 2;
	gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
	gl.uniformMatrix4fv(shader.refMatrix_loc, false, this.rotMat._floatArrays);
	
	var renderer = magoManager.renderer;
	
	// render wireframe.***
	renderWireframe = true;
	renderer.renderNormals = false;
	gl.uniform4fv(shader.oneColor4_loc, [0.0, 0.0, 0.0, 1.0]);
	renderer.renderVboContainer(gl, this.vboKeyContainerEdges, magoManager, shader, renderWireframe);
	
	// now render fill.***
	gl.enable(gl.BLEND);
	renderWireframe = false;
	renderer.renderNormals = true;
	//gl.uniform4fv(shader.oneColor4_loc, [this.blueFactor, this.greenFactor, 0.0, this.alphaFactor]);
	gl.uniform4fv(shader.oneColor4_loc, [this.blueFactor, 0.0, 0.0, this.alphaFactor]);
	renderer.renderVboContainer(gl, this.vboKeyContainer, magoManager, shader, renderWireframe);
	gl.disable(gl.BLEND);
	
	gl.disable(gl.POLYGON_OFFSET_FILL);
};

/**
 */
CCTV.prototype.makeFrustumGeometry_2 = function(resultMesh)
{
	// 1rst, make the profile: icecream shape.***
	if (resultMesh === undefined)
	{ resultMesh = new ParametricMesh(); }

	resultMesh.profile = new Profile(); 
	var profileAux = resultMesh.profile; 
	
	// camera geometry values.***
	var frustum = this.camera.bigFrustum;
	var far = frustum.far;
	var halfFovyRad = frustum.fovyRad / 2.0;
	var halfFovxRad = frustum.fovRad / 2.0;
	
	var left = -far * Math.tan(halfFovxRad);
	var right = -left;
	var top = far * Math.tan(halfFovyRad);
	var bottom = -top;
	
	// Outer ring.**************************************
	var outerRing = profileAux.newOuterRing();
	var polyLine, point3d, arc;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad)); // 0
	point3d = polyLine.newPoint2d(0.0, 0.0); // 1
	point3d = polyLine.newPoint2d(far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad)); // 2
	
	var startAngDeg = 90.0 - halfFovxRad * 180.0 / Math.PI;
	var endAngDeg = 90.0 + halfFovxRad * 180.0 / Math.PI;
	arc = outerRing.newElement("ARC");
	this.sweepSense = 1;
	arc.setCenterPosition(0.0, 0.0);
	arc.setRadius(far);
	//arc.setStartPoint(far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad));
	//arc.setEndPoint(-far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad));
	arc.setStartAngleDegree(startAngDeg);
	arc.setSweepAngleDegree(endAngDeg - startAngDeg);
	arc.numPointsFor360Deg = 36;
	
	// now revolve.***
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = (halfFovyRad * 2) * 180.0 / Math.PI;
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(-1, 0);
	var endPoint2d = new Point2D(1, 0);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 6;
	resultMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	
	return resultMesh;
	
	
};

/**
 */
CCTV.prototype.makeFrustumGeometry = function(resultMesh)
{
	// make a frustum mesh.***
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	if (resultMesh.hedgesList === undefined)
	{ resultMesh.hedgesList = new HalfEdgesList(); }
	
	// 1rst, calculate the positions of 5 vertices.***
	var focusPosition = new Point3D(0.0, 0.0, 0.0);
	
	var frustum = this.camera.bigFrustum;
	var far = frustum.far;
	var halfFovyRad = frustum.fovyRad / 2.0;
	var halfFovxRad = frustum.fovRad / 2.0;
	
	var left = -far * Math.tan(halfFovxRad);
	var right = -left;
	var top = far * Math.tan(halfFovyRad);
	var bottom = -top;
	
	var farLeftDown = new Point3D(left, bottom, -far);
	var farRightDown = new Point3D(right, bottom, -far);
	var farRightTop = new Point3D(right, top, -far);
	var farLeftTop = new Point3D(left, top, -far);
	
	// now make vertices. 5 vertices in total.***
	var focusVertex = new Vertex(focusPosition);
	var farLeftDownVertex = new Vertex(farLeftDown);
	var farRightDownVertex = new Vertex(farRightDown);
	var farRightTopVertex = new Vertex(farRightTop);
	var farLeftTopVertex = new Vertex(farLeftTop);
	
	// provisionally make wireframe here.***
	if (this.vboKeyContainerEdges === undefined)
	{ this.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }

	var face;
	
	// there are no near polygon.***
	// 1- far polygon.***
	var farSurface = resultMesh.newSurface();
	face = farSurface.newFace();
	// ad vertices in ccw order.***
	face.addVertex(farLeftDownVertex);
	face.addVertex(farLeftTopVertex);
	face.addVertex(farRightTopVertex);
	face.addVertex(farRightDownVertex);
	
	// make wireframe vbo.************************************************
	var vertex_1, vertex_2, pos_1, pos_2;
	var next_idx;
	var curr_edge_idx = 0;
	var posDataArray = [];
	var indicesDataArray = [];
	
	var vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 2- top polygon.***
	var topSurface = resultMesh.newSurface();
	face = topSurface.newFace();
	// ad vertices in ccw order.***
	face.addVertex(focusVertex);
	face.addVertex(farRightTopVertex);
	face.addVertex(farLeftTopVertex);
	
	// make wireframe vbo.************************************************
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 3- left polygon.***
	var leftSurface = resultMesh.newSurface();
	face = leftSurface.newFace();
	// ad vertices in ccw order.***
	face.addVertex(focusVertex);
	face.addVertex(farLeftTopVertex);
	face.addVertex(farLeftDownVertex);
	
	// make wireframe vbo.************************************************
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 4- bottom polygon.***
	var bottomSurface = resultMesh.newSurface();
	face = bottomSurface.newFace();
	// ad vertices in ccw order.***
	face.addVertex(focusVertex);
	face.addVertex(farLeftDownVertex);
	face.addVertex(farRightDownVertex);
	
	// make wireframe vbo.************************************************
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 5- right polygon.***
	var rightSurface = resultMesh.newSurface();
	face = rightSurface.newFace();
	// ad vertices in ccw order.***
	face.addVertex(focusVertex);
	face.addVertex(farRightDownVertex);
	face.addVertex(farRightTopVertex);
	
	// make wireframe vbo.************************************************
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	var vboEdges = this.vboKeyContainerEdges.newVBOVertexIdxCacheKey();
	vboEdges.posVboDataArray = Float32Array.from(posDataArray);
	vboEdges.idxVboDataArray = Int16Array.from(indicesDataArray);
	vboEdges.indicesCount = vboEdges.idxVboDataArray.length;

	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

// CCTVList.*********************************************************************************
/**
 * 카메라
 * @class CCTVList
 */
var CCTVList = function() 
{
	if (!(this instanceof CCTVList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.camerasList = [];
	
	
};

/**
 */
CCTVList.prototype.new_CCTV = function(name)
{
	var cctv = new CCTV();
	if (name !== undefined)
	{ cctv.name = name; }
	
	this.camerasList.push(cctv);
	return cctv;
};

/**
 */
CCTVList.prototype.getCCTV = function(idx)
{
	return this.camerasList[idx];
};

/**
 */
CCTVList.prototype.getCCTVCount = function()
{
	return this.camerasList.length;
};


































'use strict';



/**
 * 어떤 일을 하고 있습니까?
 * @class Color
 */
var Color = function() 
{
	if (!(this instanceof Color)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	//this[0] = 0.0;
	//this[1] = 0.0;
	//this[2] = 0.0;
	//this[3] = 1.0;

	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 1;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param red 변수
 * @param green 변수
 * @param blue 변수
 * @param alpha 변수
 */
Color.prototype.copyFrom = function(color) 
{
	this.r = color.r;
	this.g = color.g;
	this.b = color.b;
	this.a = color.a;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param red 변수
 * @param green 변수
 * @param blue 변수
 * @param alpha 변수
 */
Color.prototype.deleteObjects = function() 
{
	this.r = undefined;
	this.g = undefined;
	this.b = undefined;
	this.a = undefined;
};
  
/**
 * 어떤 일을 하고 있습니까?
 * @param red 변수
 * @param green 변수
 * @param blue 변수
 * @param alpha 변수
 */
Color.prototype.set = function(red, green, blue, alpha) 
{
	//this[0] = red;
	//this[1] = green;
	//this[2] = blue;
	//this[3] = alpha;
	this.r = red; this.g = green; this.b = blue; this.a = alpha;
};
  
/**
 * 어떤 일을 하고 있습니까?
 * @param red 변수
 * @param green 변수
 * @param blue 변수
 */
Color.prototype.setRGB = function(red, green, blue) 
{
	//this[0] = red;
	//this[1] = green;
	//this[2] = blue;
	this.r = red; this.g = green; this.b = blue;
};
  
/**
 * 어떤 일을 하고 있습니까?
 * @param red 변수
 * @param green 변수
 * @param blue 변수
 * @param alpha 변수
 */
Color.prototype.setRGBA = function(red, green, blue, alpha) 
{
	//this[0] = red;
	//this[1] = green;
	//this[2] = blue;
	//this[3] = alpha;
	this.r = red; this.g = green; this.b = blue; this.a = alpha;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class SelectionColor
 */
var SelectionColor = function() 
{
	if (!(this instanceof SelectionColor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.color = new Color();
};

/**
 * 어떤 일을 하고 있습니까?
 */
SelectionColor.prototype.init = function() 
{
	this.color.r = 0;
	this.color.g = 0;
	this.color.b = 0;
	this.cycle = 0;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SelectionColor.prototype.getAvailableColor = function(resultColor) 
{
	if (resultColor === undefined)
	{ resultColor = new Color(); }
	
	resultColor.setRGB(this.color.r, this.color.g, this.color.b);
	
	this.color.b += 1;
	if (this.color.b >= 254)
	{
		this.color.b = 0;
		this.color.g += 1;
		if (this.color.g >= 254)
		{
			this.color.g = 0;
			this.color.r += 1;
			if (this.color.r >= 254)
			{
				this.color.r = 0;
				this.cycle += 1;
			}
		}
	}
	
	return resultColor;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SelectionColor.prototype.decodeColor3 = function(r, g, b) 
{
	return 64516*r + 254*g + b;
};







'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class FBO
 * @param gl 변수
 * @param width 변수
 * @param height 변수
 */
var FBO = function(gl, width, height) 
{
	if (!(this instanceof FBO)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.gl = gl;
	this.width = new Int32Array(1);
	this.height = new Int32Array(1);
	this.width[0] = width;
	this.height[0] = height;
	this.fbo = gl.createFramebuffer();
	this.depthBuffer = gl.createRenderbuffer();
	this.colorBuffer = gl.createTexture();
	this.dirty = true;
  
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, this.colorBuffer);  
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); //LINEAR_MIPMAP_LINEAR
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	//gl.generateMipmap(gl.TEXTURE_2D)
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); 
  
	gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
	gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.colorBuffer, 0);
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) 
	{
		throw "Incomplete frame buffer object.";
	}

	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};    

/**
 * 어떤 일을 하고 있습니까?
 */
FBO.prototype.bind = function() 
{
	this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
};

/**
 * 어떤 일을 하고 있습니까?
 */
FBO.prototype.unbind = function() 
{
	this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
};

/**
 * 어떤 일을 하고 있습니까?
 */
FBO.prototype.deleteObjects = function(gl) 
{
	if (this.depthBuffer)
	{ gl.deleteRenderbuffer(this.depthBuffer); }
	this.depthBuffer = undefined;
	
	if (this.colorBuffer)
	{ gl.deleteTexture(this.colorBuffer); }
	this.colorBuffer = undefined;
	
	if (this.fbo)
	{ gl.deleteFramebuffer(this.fbo); }
	this.fbo = undefined;
	
	
};


















































'use strict';

/**
 * xmlhttprequest 요청 개수를 저장하기 위한 객체
 * @class FileRequestControler
 */
var FileRequestControler = function() 
{
	if (!(this instanceof FileRequestControler)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.maxFilesRequestedCount = 1;
	this.filesRequestedCount = 0;
	this.headerFilesRequestedCount = 0;
	this.modelRefFilesRequestedCount = 0;
	this.lowLodDataRequestedCount = 0;
	this.lowLodImagesRequestedCount = 0;
};

FileRequestControler.prototype.isFull = function ()
{
	return this.filesRequestedCount >= this.maxFilesRequestedCount; 
};

FileRequestControler.prototype.isFullHeaders = function ()
{
	return this.headerFilesRequestedCount >= 1; 
};

FileRequestControler.prototype.isFullPlus = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.filesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusModelReferences = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.modelRefFilesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusLowLodData = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.lowLodDataRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusLowLodImages = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.lowLodImagesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

'use strict';

var keyFlags = {
	moveForward  : false,
	moveBackward : false,
	moveLeft     : false,
	moveRight    : false
};

function getFlagFromKeyCode(code)
{
	switch (code)
	{
	case 37 :	// Arrow-Left
	{
		//console.log("KeyDown Left");
		return 'moveLeft';
	}
	case 38 :	// Arrow-Up
	{
		//console.log("KeyDown Up");
		return 'moveForward';
	}
	case 39 :	// Arrow-Right
	{
		//console.log("KeyDown Right");
		return 'moveRight';
	}
	case 40 :	// Arrow-Down
	{
		//console.log("KeyDown Down");
		return 'moveBackward';
	}
	default :
	{
		return undefined;
	}
	}
};

function onKeyDown(event)
{
	var flag = getFlagFromKeyCode(event.keyCode);
	if ( typeof flag !== 'undefined')
	{
		keyFlags[flag] = true;
	}
};

function onKeyUp(event)
{
	var flag = getFlagFromKeyCode(event.keyCode);
	if ( typeof flag !== 'undefined')
	{
		keyFlags[flag] = false;
	}
};

/**
 * 카메라 1인칭 시점 모드
 * 
 */
function FirstPersonView ()
{
	this._camera = undefined;
	this._cameraBAK = undefined;
	this._position = new Point3D();
	this._rotation = new Point3D();
	this._positionSpeed = 1.0;
	this._ratationSpeed = 1.0;
}

Object.defineProperties(FirstPersonView.prototype, {
	"camera": {
		get : function () { return this._camera; },
		set : function (value) { this._camera = value; }
	},
	"position": {
		get : function () { return this._position; },
		set : function (value) { this._position = value; }		
	},
	"rotation": {
		get : function () { return this._rotation; },
		set : function (value) { this._rotation = value; }
	},
	"positionSpeed": {
		get : function () { return this._positionSpeed; },
		set : function (value) { this._positionSpeed = value; }
	},
	"rotationSpeed": {
		get : function () { return this._ratationSpeed; },
		set : function (value) { this._ratationSpeed = value; }
	}
});

FirstPersonView.prototype.init = function ()
{
	this._position.set(0.0, 0.0, 0.0);
	this._rotation.set(0.0, 0.0, 0.0);

	document.addEventListener('keydown', onKeyDown, false);
	document.addEventListener('keyup', onKeyUp, false);
};

FirstPersonView.prototype.release = function ()
{
	this._camera = undefined;
	this._cameraBAK = undefined;
	document.removeEventListener('keydown', onKeyDown, false);
	document.removeEventListener('keyup', onKeyUp, false);
};

FirstPersonView.prototype.move = function (vector)
{
	var position = vec3.fromValues(this._position.x, this._position.y, this.position.z);
	var matrix = mat4.create();
	mat4.rotateY(matrix, matrix, this._rotation.y);
	vec3.transformMat4(vector, vector, matrix);
	vec3.add(position, position, vector);
	this._position.set(position[0], position[1], position[2]);
};
FirstPersonView.prototype.update = function(manager)
{
	if (this._camera === undefined)	{ return; }
	/*
	var scratchLookAtMatrix4 = new Cesium.Matrix4();
	var scratchFlyToBoundingSphereCart4 = new Cesium.Cartesian4();
	var transform = Cesium.Transforms.eastNorthUpToFixedFrame(this._camera.position, Cesium.Ellipsoid.WGS84, scratchLookAtMatrix4);
	Cesium.Cartesian3.fromCartesian4(Cesium.Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4), this._camera.direction);
	Cesium.Cartesian3.fromCartesian4(Cesium.Matrix4.getColumn(transform, 2, scratchFlyToBoundingSphereCart4), this._camera.up);
	
	var pos1 = Cesium.Cartesian3.fromDegrees(126.60795289318042, 37.58281268636716, 28.0);
	var pos2 = Cesium.Cartesian3.fromDegrees(126.60795243349536, 37.58283027052396, 28.0);
	console.log(Cesium.Cartesian3.distance(pos1, pos2));
	*/
	if (keyFlags.moveForward)
	{
		//var isBlocked = manager.checkCollision(this._camera.position, this._camera.direction);
		//if (isBlocked)	{ return; }
		this._camera.moveForward(0.5);
		this.move(vec3.fromValues(0.0, 1.0, 0.0));
	}
	if (keyFlags.moveBackward)
	{
		this._camera.moveBackward(0.5);
		this.move(vec3.fromValues(0.0, -1.0, 0.0));
	}
	if (keyFlags.moveLeft)
	{
		this._camera.lookLeft(0.1);
		this.move(vec3.fromValues(-1.0, 0.0, 0.0));	
	}		
	if (keyFlags.moveRight)
	{
		this._camera.lookRight(0.1);
		this.move(vec3.fromValues(1.0, 0.0, 0.0));	
	}
};

'use strict';

/**
 * 카메라
 * @class Frustum
 */
var Frustum = function() 
{
	if (!(this instanceof Frustum)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.near = new Float32Array([0.1]);
	this.far = new Float32Array([1000.0]);
	this.fovyRad = new Float32Array([0.8037]);
	this.tangentOfHalfFovy = new Float32Array([0.0]);
	this.fovRad = new Float32Array([1.047]);
	this.aspectRatio = new Float32Array([1.3584]);
	this.planesArray = [];
	this.dirty = true;
	
	// plane[0] = near, plane[1] = far.***
	for (var i=0; i<6; i++)
	{
		var plane = new Plane();
		this.planesArray.push(plane);
	}
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Frustum.prototype.copyParametersFrom = function(frustum) 
{
	this.near[0] = frustum.near[0];
	this.far[0] = frustum.far[0];
	this.fovyRad[0] = frustum.fovyRad[0];
	this.tangentOfHalfFovy[0] = frustum.tangentOfHalfFovy[0];
	this.fovRad[0] = frustum.fovRad[0];
	this.aspectRatio[0] = frustum.aspectRatio[0];
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Frustum.prototype.setNear = function(near) 
{
	this.near[0] = near;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Frustum.prototype.setFar = function(far) 
{
	this.far[0] = far;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Frustum.prototype.intersectionNearFarSphere = function(sphere) 
{
	var intersects = false;
	for (var i=0; i<2; i++)
	{
		var intersectionType = this.planesArray[i].intersectionSphere(sphere);
		if (intersectionType === Constant.INTERSECTION_OUTSIDE)
		{ return Constant.INTERSECTION_OUTSIDE; }
		else if (intersectionType === Constant.INTERSECTION_INTERSECT)
		{ intersects = true; }
	}
	
	if (intersects)
	{ return Constant.INTERSECTION_INTERSECT; }
	else
	{ return Constant.INTERSECTION_INSIDE; }
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Frustum.prototype.intersectionSphere = function(sphere) 
{
	var intersects = false;
	for (var i=0; i<6; i++)
	{
		var intersectionType = this.planesArray[i].intersectionSphere(sphere);
		if (intersectionType === Constant.INTERSECTION_OUTSIDE)
		{ return Constant.INTERSECTION_OUTSIDE; }
		else if (intersectionType === Constant.INTERSECTION_INTERSECT)
		{ intersects = true; }
	}
	
	if (intersects)
	{ return Constant.INTERSECTION_INTERSECT; }
	else
	{ return Constant.INTERSECTION_INSIDE; }
};






























'use strict';

/**
 * 카메라
 * @class FrustumVolumeControl
 */
var FrustumVolumeControl = function() 
{
	if (!(this instanceof FrustumVolumeControl)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.frustumVolumensMap = {};
};

FrustumVolumeControl.prototype.getFrustumVolumeCulling = function(key)
{
	// 1rst, check if exist. If no exist create it.***
	if (!this.frustumVolumensMap.hasOwnProperty(key))
	{
		this.frustumVolumensMap[key] = {};
		this.frustumVolumensMap[key].fullyIntersectedLowestTilesArray = [];
		this.frustumVolumensMap[key].partiallyIntersectedLowestTilesArray = [];
		this.frustumVolumensMap[key].visibleNodes = new VisibleObjectsController();
	}
	
	return this.frustumVolumensMap[key];
};

FrustumVolumeControl.prototype.initArrays = function()
{
	var frustumVolumeObject;
	for (var key in this.frustumVolumensMap)
	{
		frustumVolumeObject = this.frustumVolumensMap[key];
		frustumVolumeObject.fullyIntersectedLowestTilesArray.length = 0;
		frustumVolumeObject.partiallyIntersectedLowestTilesArray.length = 0;
		frustumVolumeObject.visibleNodes.initArrays();
	}
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class GeographicCoord
 */
var GeographicCoord = function(lon, lat, alt) 
{
	if (!(this instanceof GeographicCoord)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.longitude;
	this.latitude;
	this.altitude;
	
	if (lon !== undefined)
	{ this.longitude = lon; }
	
	if (lat !== undefined)
	{ this.latitude = lat; }
	
	if (alt !== undefined)
	{ this.altitude = alt; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param longitude 경도
 * @param latitude 위도
 * @param altitude 고도
 */
GeographicCoord.prototype.deleteObjects = function() 
{
	this.longitude = undefined;
	this.latitude = undefined;
	this.altitude = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param longitude 경도
 * @param latitude 위도
 * @param altitude 고도
 */
GeographicCoord.prototype.copyFrom = function(geographicCoord) 
{
	this.longitude = geographicCoord.longitude;
	this.latitude = geographicCoord.latitude;
	this.altitude = geographicCoord.altitude;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param longitude 경도
 * @param latitude 위도
 * @param altitude 고도
 */
GeographicCoord.prototype.setLonLatAlt = function(longitude, latitude, altitude) 
{
	this.longitude = longitude;
	this.latitude = latitude;
	this.altitude = altitude;
};

/**
 * 어떤 일을 하고 있습니까?
 */
GeographicCoord.getMidPoint = function(geographicCoordA, geographicCoordB, resultGeographicCoord) 
{
	var midLat = ( geographicCoordA.latitude + geographicCoordB.latitude) / 2.0;
	var midLon = ( geographicCoordA.longitude + geographicCoordB.longitude) / 2.0;
	var midAlt = ( geographicCoordA.altitude + geographicCoordB.altitude) / 2.0;
	
	if (resultGeographicCoord === undefined)
	{ resultGeographicCoord = new GeographicCoord(midLon, midLat, midAlt); }
	else 
	{
		resultGeographicCoord.setLonLatAlt(midLon, midLat, midAlt);
	}
	
	return resultGeographicCoord;
};

















































'use strict';

/**
 * GeographicExtent
 * @class GeographicExtent
 */
var GeographicExtent = function() 
{
	if (!(this instanceof GeographicExtent)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.minGeographicCoord;
	this.maxGeographicCoord;
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocationDataName 변수
 */
var GeoLocationData = function(geoLocationDataName) 
{
	if (!(this instanceof GeoLocationData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.name;
	
	if (geoLocationDataName === undefined) { this.name = "noName"; }
	else { this.name = geoLocationDataName; }
	
	this.geographicCoord; // longitude, latitude, altitude.***
	
	this.heading;
	this.pitch;
	this.roll;
	
	this.date; // year - month - day - hour - min - seg - miliseg.***
	
	this.position;   // Point3D().***
	this.positionHIGH; // Float32Array[3].***
	this.positionLOW; // Float32Array[3].***
	this.pivotPoint; // Point3D().*** // Actually position = pivotPoint.
	
	// F4D Matrix4.****
	this.geoLocMatrix; // this is just the cartographic transformation matrix determined by (lon, lat, elev).***
	this.geoLocMatrixInv; // this is just the cartographic transformation matrixInv determined by (lon, lat, elev).***
	this.tMatrix;      // this contains translation & rotations.***
	this.tMatrixInv;   // this contains translation & rotations.***
	this.rotMatrix;    // this contains only rotation.***
	this.rotMatrixInv; // this contains only rotation.***
	
	// Aditional.***
	this.pivotPointTraslation; // made when translate the pivot point.***
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
GeoLocationData.prototype.deleteObjects = function() 
{
	this.name = undefined;
	if (this.geographicCoord)
	{ this.geographicCoord.deleteObjects(); }
	this.geographicCoord = undefined;
	
	this.heading = undefined;
	this.pitch = undefined;
	this.roll = undefined;
	
	this.date = undefined; 
	
	if (this.position)
	{ this.position.deleteObjects(); }  
	this.position = undefined;
	this.positionHIGH = undefined;
	this.positionLOW = undefined; 
	if (this.pivotPoint)
	{ this.pivotPoint.deleteObjects(); }  
	this.pivotPoint = undefined;
	
	// F4D Matrix4.****
	if (this.geoLocMatrix)
	{ this.geoLocMatrix.deleteObjects(); }
	if (this.geoLocMatrixInv)
	{ this.geoLocMatrixInv.deleteObjects(); }
	if (this.tMatrix)
	{ this.tMatrix.deleteObjects(); } 
	if (this.tMatrixInv)
	{ this.tMatrixInv.deleteObjects(); } 
	if (this.rotMatrix)
	{ this.rotMatrix.deleteObjects(); }  
	if (this.rotMatrixInv)
	{ this.rotMatrixInv.deleteObjects(); } 
	
	this.geoLocMatrix = undefined;
	this.geoLocMatrixInv = undefined; 
	this.tMatrix = undefined;     
	this.tMatrixInv = undefined;  
	this.rotMatrix = undefined;   
	this.rotMatrixInv = undefined; 
	
	// Aditional.***
	if (this.pivotPointTraslation)
	{ this.pivotPointTraslation.deleteObjects(); }
	this.pivotPointTraslation = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
GeoLocationData.prototype.doEffectivePivotPointTranslation = function() 
{
	// this function adds the "pivotPointTraslation" to the positions.
	// this function is not for move the building on the globe. This function is only for translate the pivot point of the building.
	if (this.pivotPointTraslation === undefined)
	{ return; }
	
	var traslationVector;
	traslationVector = this.tMatrix.rotatePoint3D(this.pivotPointTraslation, traslationVector );
	
	this.position.x += traslationVector.x;
	this.position.y += traslationVector.y;
	this.position.z += traslationVector.z;

	this.positionLOW[0] += traslationVector.x;
	this.positionLOW[1] += traslationVector.y;
	this.positionLOW[2] += traslationVector.z;

	if (this.pivotPoint === undefined)
	{ this.pivotPoint = new Point3D(); }

	this.pivotPoint.set(this.position.x, this.position.y, this.position.z);
};


/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
GeoLocationData.prototype.copyFrom = function(geoLocData) 
{
	if (geoLocData === undefined)
	{ return; }
	
	this.name = geoLocData.name;
	if (geoLocData.geographicCoord)
	{
		if (this.geographicCoord === undefined)
		{ this.geographicCoord = new GeographicCoord(); }
		
		this.geographicCoord.copyFrom(geoLocData.geographicCoord); // longitude, latitude, altitude.***
	}
	
	this.heading = geoLocData.heading;
	this.pitch = geoLocData.pitch;
	this.roll = geoLocData.roll;
	
	this.date = geoLocData.date; // year - month - day - hour - min - seg - miliseg.***
	
	if (geoLocData.position)
	{
		if (this.position === undefined)
		{ this.position = new Point3D(); }
		this.position.copyFrom(geoLocData.position);
	}
	if (geoLocData.positionHIGH)
	{
		if (this.positionHIGH === undefined)
		{ this.positionHIGH = new Float32Array(3); }
		
		this.positionHIGH[0]= geoLocData.positionHIGH[0];
		this.positionHIGH[1]= geoLocData.positionHIGH[1];
		this.positionHIGH[2]= geoLocData.positionHIGH[2];
	}
	if (geoLocData.positionLOW)
	{
		if (this.positionLOW === undefined)
		{ this.positionLOW = new Float32Array(3); }
		
		this.positionLOW[0]= geoLocData.positionLOW[0];
		this.positionLOW[1]= geoLocData.positionLOW[1];
		this.positionLOW[2]= geoLocData.positionLOW[2];
	}
	if (geoLocData.pivotPoint)
	{
		if (this.pivotPoint === undefined)
		{ this.pivotPoint = new Point3D(); }
		
		this.pivotPoint.copyFrom(geoLocData.pivotPoint);
	}
	
	// F4D Matrix4.****
	if (geoLocData.geoLocMatrix)
	{
		if (this.geoLocMatrix === undefined)
		{ this.geoLocMatrix = new Matrix4(); }
		
		this.geoLocMatrix.copyFromMatrix4(geoLocData.geoLocMatrix);
	}
	if (geoLocData.geoLocMatrixInv)
	{
		if (this.geoLocMatrixInv === undefined)
		{ this.geoLocMatrixInv = new Matrix4(); }
		
		this.geoLocMatrixInv.copyFromMatrix4(geoLocData.geoLocMatrixInv);
	}
	if (geoLocData.tMatrix)
	{
		if (this.tMatrix === undefined)
		{ this.tMatrix = new Matrix4(); }
		
		this.tMatrix.copyFromMatrix4(geoLocData.tMatrix);
	}
	if (geoLocData.tMatrixInv)
	{
		if (this.tMatrixInv === undefined)
		{ this.tMatrixInv = new Matrix4(); }
		
		this.tMatrixInv.copyFromMatrix4(geoLocData.tMatrixInv);
	}
	if (geoLocData.rotMatrix)
	{
		if (this.rotMatrix === undefined)
		{ this.rotMatrix = new Matrix4(); }
		
		this.rotMatrix.copyFromMatrix4(geoLocData.rotMatrix);
	}
	if (geoLocData.rotMatrixInv)
	{
		if (this.rotMatrixInv === undefined)
		{ this.rotMatrixInv = new Matrix4(); }
		
		this.rotMatrixInv.copyFromMatrix4(geoLocData.rotMatrixInv);
	}
	
	if (geoLocData.aditionalTraslation)
	{
		if (this.aditionalTraslation === undefined)
		{ this.aditionalTraslation = new Point3D(); }
		
		this.aditionalTraslation.copyFrom(geoLocData.aditionalTraslation);
	}
	
};

/**
 * This function transforms a local position of this geoLocation to world position.
 * @param localCoord  instance of Point3D.
 * @param resultWorldCoord. instance of Point3D.
 * @returns resultWorldCoord. instance of Point3D.
 */
GeoLocationData.prototype.localCoordToWorldCoord = function(localCoord, resultWorldCoord) 
{
	if (localCoord === undefined || this.tMatrix === undefined)
	{ return undefined; }
	
	if (resultWorldCoord === undefined)
	{ resultWorldCoord = new Point3D(); }
	
	resultWorldCoord = this.tMatrix.transformPoint3D(localCoord, resultWorldCoord); 
	return resultWorldCoord;
};

/**
 * This function transforms an absolute position to local position for this geoLocation.
 * @param worldCoord  instance of Point3D.
 * @param resultLocalCoord. instance of Point3D.
 * @returns resultLocalCoord. instance of Point3D.
 */
GeoLocationData.prototype.worldCoordToLocalCoord = function(worldCoord, resultLocalCoord) 
{
	if (worldCoord === undefined || this.tMatrixInv === undefined)
	{ return undefined; }
	
	if (resultLocalCoord === undefined)
	{ resultLocalCoord = new Point3D(); }
	
	resultLocalCoord = this.tMatrixInv.transformPoint3D(worldCoord, resultLocalCoord); 
	return resultLocalCoord;
};

/**
 * This function transforms an absolute camera (world coord) into a relative camera (local coord) for this geoLocation.
 * @param absoluteCamera instance of Camera. 
 * @param resultCamera instance of Camera. This is the transformed camera.
 * @returns resultCamera
 */
GeoLocationData.prototype.getTransformedRelativeCamera = function(absoluteCamera, resultCamera) 
{
	var pointAux = new Point3D();
	
	pointAux.set(absoluteCamera.position.x - this.position.x, 
		absoluteCamera.position.y - this.position.y, 
		absoluteCamera.position.z - this.position.z);
	
	resultCamera.position = this.rotMatrixInv.transformPoint3D(pointAux, resultCamera.position);
	
	pointAux.set(absoluteCamera.direction.x, absoluteCamera.direction.y, absoluteCamera.direction.z);
	resultCamera.direction = this.rotMatrixInv.transformPoint3D(pointAux, resultCamera.direction);
	
	pointAux.set(absoluteCamera.up.x, absoluteCamera.up.y, absoluteCamera.up.z);
	resultCamera.up = this.rotMatrixInv.transformPoint3D(pointAux, resultCamera.up);
  
	pointAux.x = undefined;
	pointAux.y = undefined;
	pointAux.z = undefined;
	pointAux = undefined;
	
	return resultCamera;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationDataManager
 */
var GeoLocationDataManager = function() 
{
	if (!(this instanceof GeoLocationDataManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.geoLocationDataArray = [];
	//this.geoLocationDataCache = {}; // use this.***
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocationName 변수
 * @returns geoLocationData
 */
GeoLocationDataManager.prototype.deleteObjects = function() 
{
	if (this.geoLocationDataArray)
	{
		for (var i=0; i<this.geoLocationDataArray.length; i++)
		{
			this.geoLocationDataArray[i].deleteObjects();
			this.geoLocationDataArray[i] = undefined;
		}
		this.geoLocationDataArray = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocationName 변수
 * @returns geoLocationData
 */
GeoLocationDataManager.prototype.newGeoLocationData = function(geoLocationName) 
{
	if (geoLocationName === undefined)
	{ geoLocationName = "noName" + this.geoLocationDataArray.length.toString(); }
	var geoLocationData = new GeoLocationData(geoLocationName);
	this.geoLocationDataArray.push(geoLocationData);
	//this.geoLocationDataCache[geoLocationName] = geoLocationData;
	return geoLocationData;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param idx
 * @returns this.geoLoactionDataArray[idx]
 */
GeoLocationDataManager.prototype.getGeoLocationData = function(idx) 
{
	if (idx > this.geoLocationDataArray.length - 1)
	{ return undefined; }
	return this.geoLocationDataArray[idx];
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param idx
 * @returns this.geoLoactionDataArray[idx]
 */
GeoLocationDataManager.prototype.getCurrentGeoLocationData = function() 
{
	if (this.geoLocationDataArray.length === 0)
	{
		return undefined;
	}
	return this.geoLocationDataArray[0]; // provisionally return the 1rst.
};






























'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class GeometryModifier
 */
var GeometryModifier = function() 
{
	if (!(this instanceof GeometryModifier)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param f4dPoint3d 변수
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 */
GeometryModifier.prototype.setPoint3d = function(f4dPoint3d, px, py, pz) 
{
	f4dPoint3d.x = px;
	f4dPoint3d.y = py;
	f4dPoint3d.z = pz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 * @param f4dPoint3d 변수
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @retuns dx*dx + dy*dy + dz*dz
 */
GeometryModifier.prototype.point3dSquareDistTo = function(f4dPoint3d, px, py, pz) 
{
	var dx = f4dPoint3d.x - px;
	var dy = f4dPoint3d.y - py;
	var dz = f4dPoint3d.z - pz;

	return dx*dx + dy*dy + dz*dz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param matrix4 변수
 * @param float32array 변수
 */
GeometryModifier.prototype.Matrix4SetByFloat32Array = function(matrix4, float32array) 
{
	for (var i = 0; i < 16; i++) 
	{
		matrix4._floatArrays[i] = float32array[i];
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param matrix4 변수
 * @param point3d 변수
 * @returns transformedPoint3d
 */
GeometryModifier.prototype.Matrix4TransformPoint3D = function(matrix4, point3d) 
{
	var transformedPoint3d = new Point3D();
	//		t.x= q.x*m[0][0] + q.y*m[1][0] + q.z*m[2][0] + m[3][0];
	//		t.y= q.x*m[0][1] + q.y*m[1][1] + q.z*m[2][1] + m[3][1];
	//		t.z= q.x*m[0][2] + q.y*m[1][2] + q.z*m[2][2] + m[3][2];

	// Note: idx = 4*col+row;.***
	//_floatArrays

	// Old version.*************************************************************************************************************************
	//transformedPoint3d.x = point3d.x*matrix4.get(0,0) + point3d.y*matrix4.get(1,0) + point3d.z*matrix4.get(2,0) + matrix4.get(3,0);
	//transformedPoint3d.y = point3d.x*matrix4.get(0,1) + point3d.y*matrix4.get(1,1) + point3d.z*matrix4.get(2,1) + matrix4.get(3,1);
	//transformedPoint3d.z = point3d.x*matrix4.get(0,2) + point3d.y*matrix4.get(1,2) + point3d.z*matrix4.get(2,2) + matrix4.get(3,2);
	//--------------------------------------------------------------------------------------------------------------------------------------

	// New version. Acces directly to the array.**********************************************************************************************************************
	transformedPoint3d.x = point3d.x*matrix4._floatArrays[0] + point3d.y*matrix4._floatArrays[4] + point3d.z*matrix4._floatArrays[8] + matrix4._floatArrays[12];
	transformedPoint3d.y = point3d.x*matrix4._floatArrays[1] + point3d.y*matrix4._floatArrays[5] + point3d.z*matrix4._floatArrays[9] + matrix4._floatArrays[13];
	transformedPoint3d.z = point3d.x*matrix4._floatArrays[2] + point3d.y*matrix4._floatArrays[6] + point3d.z*matrix4._floatArrays[10] + matrix4._floatArrays[14];
	//----------------------------------------------------------------------------------------------------------------------------------------------------------------

	return transformedPoint3d;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param matrixA 변수
 * @param matrixB 변수
 * @retuns resultMat
 */
GeometryModifier.prototype.Matrix4GetMultipliedByMatrix = function(matrixA, matrixB) 
{
	//CKK_Matrix4 operator*(const CKK_Matrix4 &A)
	//{
	//	// Copied From Carve.***
	//	CKK_Matrix4 c;
	//	for (int i = 0; i < 4; i++) {
	//		for (int j = 0; j < 4; j++) {
	//			c.m[i][j] = 0.0;
	//			for (int k = 0; k < 4; k++) {
	//				c.m[i][j] += A.m[k][j] * m[i][k];
	//			}
	//		}
	//	}
	//	return c;
	//}

	var resultMat = new Matrix4();
	for (var i = 0; i < 4; i++)
	{
		for (var j = 0; j < 4; j++)
		{
			// Note: idx = 4*col+row;.***
			//var idx = matrixA.getIndexOfArray(i, j); // Old.***
			var idx = 4*i + j;
			resultMat._floatArrays[idx] = 0.0;
			for (var k = 0; k < 4; k++)
			{
				resultMat._floatArrays[idx] += matrixB._floatArrays[4*k + j] * matrixA._floatArrays[4*i + k];
			}
		}
	}
	return resultMat;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param reference 변수
 * @param matrix 변수
 */
GeometryModifier.prototype.referenceMultiplyTransformMatrix = function(reference, matrix) 
{
	//var multipliedMat = reference._matrix4.getMultipliedByMatrix(matrix); // Original.***
	var multipliedMat = this.Matrix4GetMultipliedByMatrix(reference._matrix4, matrix); // Original.***
	reference._matrix4 = multipliedMat;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param compRefList 변수
 * @param matrix 변수
 */
GeometryModifier.prototype.compoundReferencesListMultiplyReferencesMatrices = function(compRefList, matrix) 
{
	var compRefsCount = compRefList._compoundRefsArray.length;
	for (var i = 0; i < compRefsCount; i++)
	{
		var compRef = compRefList._compoundRefsArray[i];
		var refsCount = compRef._referencesList.length;
		for (var j = 0; j < refsCount; j++)
		{
			var reference = compRef._referencesList[j];
			//reference.multiplyTransformMatrix(matrix);// Old.***
			this.referenceMultiplyTransformMatrix(reference, matrix);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param compRefList 변수
 * @param eyeX 변수
 * @param eyeY 변수
 * @param eyeZ 변수
 * @returns visibleCompRefObjectsArray
 */
GeometryModifier.prototype.compoundReferencesListGetVisibleCompRefObjectsList = function(compRefList, eyeX, eyeY, eyeZ) 
{
	/*
	// https://gist.github.com/72lions/4528834
	var _appendBuffer = function(buffer1, buffer2) {
  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
};
*/

	var visibleCompRefObjectsArray = new CompoundReferencesList();
	visibleCompRefObjectsArray._myBlocksList = compRefList._myBlocksList;

	var ocCullingBox = compRefList._ocCulling._ocCulling_box;
	var indicesVisiblesArrayInterior = this.occlusionCullingOctreeCellGetIndicesVisiblesForEye(ocCullingBox, eyeX, eyeY, eyeZ);
	if (indicesVisiblesArrayInterior)
	{
		var indicesCount = indicesVisiblesArrayInterior.length;
		for (var i = 0; i < indicesCount; i++)
		{
			visibleCompRefObjectsArray._compoundRefsArray.push(compRefList._compoundRefsArray[indicesVisiblesArrayInterior[i]]);
		}

	}

	var infiniteOcCullingBox = compRefList._ocCulling._infinite_ocCulling_box;
	var indicesVisiblesArrayExterior = this.occlusionCullingOctreeCellGetIndicesVisiblesForEye(infiniteOcCullingBox, eye_x, eye_y, eye_z);
	if (indicesVisiblesArrayExterior)
	{
		var indicesCount = indicesVisiblesArrayExterior.length;
		for (var i = 0; i < indicesCount; i++)
		{
			visibleCompRefObjectsArray._compoundRefsArray.push(compRefList._compoundRefsArray[indicesVisiblesArrayExterior[i]]);
		}
	}

	if (visibleCompRefObjectsArray && visibleCompRefObjectsArray.length === 0) { return null; }

	return visibleCompRefObjectsArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param compRefListContainer 변수
 * @param eyeX 변수
 * @param eyeY 변수
 * @param eyeZ 변수
 * @returns visibleCompRefObjectsArrayTotal
 */
GeometryModifier.prototype.compoundReferencesListContainerGetVisibleCompRefObjectsList = function(compRefListContainer, eyeX, eyeY, eyeZ) 
{
	var visibleCompRefObjectsArrayTotal = [];
	var compRefList = undefined;
	var compRefListsCount = compRefListContainer.compRefsListArray.length;
	for (var i = 0; i < compRefListsCount; i++)
	{
		compRefList = compRefListContainer.compRefsListArray[i];
		var visibleCompRefObjectsArray = this.compoundReferencesListGetVisibleCompRefObjectsList(compRefList, eyeX, eyeY, eyeZ);
		if (visibleCompRefObjectsArray !== null)
		{ visibleCompRefObjectsArrayTotal.push(visibleCompRefObjectsArray); }
	}
	return visibleCompRefObjectsArrayTotal;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param buildingProject 변수
 * @param eyeX 변수
 * @param eyeY 변수
 * @param eyeZ 변수
 * @returns totalVisibleCompRefLists
 */
GeometryModifier.prototype.bRbuildingProjectGetVisibleCompRefLists = function(buildingProject, eyeX, eyeY, eyeZ) 
{
	// 1rst, check if the eye is in the building.***
	var InteriorCompRefListContainer = buildingProject._interiorCompRefList_Container;
	var interior_visibleCompRefLists = this.compoundReferencesListContainerGetVisibleCompRefObjectsList(InteriorCompRefListContainer, eye_x, eye_y, eye_z);

	var compRefListContainer = buildingProject._compRefList_Container;
	var visibleCompRefLists = this.compoundReferencesListContainerGetVisibleCompRefObjectsList(compRefListContainer, eyeX, eyeY, eyeZ);

	var totalVisibleCompRefLists = visibleCompRefLists.concat(interior_visibleCompRefLists);

	return totalVisibleCompRefLists;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param ocCullOctreeCell 변수
 * @param minX 변수
 * @param maxX 변수
 * @param minY 변수
 * @param maxY 변수
 * @param minZ 변수
 * @param maxZ 변수
 */
GeometryModifier.prototype.occlusionCullingOctreeCellSetDimensions = function(ocCullOctreeCell, minX, maxX, minY, maxY, minZ, maxZ) 
{
	ocCullOctreeCell.minX = minX;
	ocCullOctreeCell.maxX = maxX;
	ocCullOctreeCell.minY = minY;
	ocCullOctreeCell.maxY = maxY;
	ocCullOctreeCell.minZ = minZ;
	ocCullOctreeCell.maxZ = maxZ;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param ocCullOctreeCell 변수
 */
GeometryModifier.prototype.occlusionCullingOctreeCellSetSizesSubBoxes = function(ocCullOctreeCell) 
{
	// Bottom                      Top
	// |----------|----------|     |----------|----------|
	// |          |          |     |          |          |       Y
	// |    3     |    2     |	   |    7     |    6     |       ^
	// |          |          |     |          |          |       |
	// |----------|----------|     |----------|----------|       |
	// |          |          |     |          |          |       |
	// |     0    |     1    |     |    4     |    5     |       |
	// |          |          |     |          |          |       -----------------> X
	// |----------|----------|     |----------|----------|

	if (ocCullOctreeCell._subBoxesArray.length > 0)
	{
		var halfX = (ocCullOctreeCell.maxX + ocCullOctreeCell.minX)/2.0;
		var halfY = (ocCullOctreeCell.maxY + ocCullOctreeCell.minY)/2.0;
		var halfZ = (ocCullOctreeCell.maxZ + ocCullOctreeCell.minZ)/2.0;

		// Old.***************************************************************************************************************************************************
		//ocCullOctreeCell._subBoxesArray[0].setDimensions(ocCullOctreeCell.minX, halfX,   ocCullOctreeCell.minY, halfY,   ocCullOctreeCell.minZ, halfZ);
		//ocCullOctreeCell._subBoxesArray[1].setDimensions(halfX, ocCullOctreeCell.maxX,   ocCullOctreeCell.minY, halfY,   ocCullOctreeCell.minZ, halfZ);
		//ocCullOctreeCell._subBoxesArray[2].setDimensions(halfX, ocCullOctreeCell.maxX,   halfY, ocCullOctreeCell.maxY,   ocCullOctreeCell.minZ, halfZ);
		//ocCullOctreeCell._subBoxesArray[3].setDimensions(ocCullOctreeCell.minX, halfX,   halfY, ocCullOctreeCell.maxY,   ocCullOctreeCell.minZ, halfZ);

		//ocCullOctreeCell._subBoxesArray[4].setDimensions(ocCullOctreeCell.minX, halfX,   ocCullOctreeCell.minY, halfY,   halfZ, ocCullOctreeCell.maxZ);
		//ocCullOctreeCell._subBoxesArray[5].setDimensions(halfX, ocCullOctreeCell.maxX,   ocCullOctreeCell.minY, halfY,   halfZ, ocCullOctreeCell.maxZ);
		//ocCullOctreeCell._subBoxesArray[6].setDimensions(halfX, ocCullOctreeCell.maxX,   halfY, ocCullOctreeCell.maxY,   halfZ, ocCullOctreeCell.maxZ);
		//ocCullOctreeCell._subBoxesArray[7].setDimensions(ocCullOctreeCell.minX, halfX,   halfY, ocCullOctreeCell.maxY,   halfZ, ocCullOctreeCell.maxZ);

		// New version.*********************************************************************************************************************************************
		this.occlusionCullingOctreeCellSetDimensions(ocCullOctreeCell._subBoxesArray[0], ocCullOctreeCell.minX, halfX,   ocCullOctreeCell.minY, halfY,   ocCullOctreeCell.minZ, halfZ);
		this.occlusionCullingOctreeCellSetDimensions(ocCullOctreeCell._subBoxesArray[1], halfX, ocCullOctreeCell.maxX,   ocCullOctreeCell.minY, halfY,   ocCullOctreeCell.minZ, halfZ);
		this.occlusionCullingOctreeCellSetDimensions(ocCullOctreeCell._subBoxesArray[2], halfX, ocCullOctreeCell.maxX,   halfY, ocCullOctreeCell.maxY,   ocCullOctreeCell.minZ, halfZ);
		this.occlusionCullingOctreeCellSetDimensions(ocCullOctreeCell._subBoxesArray[3], ocCullOctreeCell.minX, halfX,   halfY, ocCullOctreeCell.maxY,   ocCullOctreeCell.minZ, half_z);

		this.occlusionCullingOctreeCellSetDimensions(ocCullOctreeCell._subBoxesArray[4], ocCullOctreeCell.minX, halfX,   ocCullOctreeCell.minY, halfY,   halfZ, ocCullOctreeCell.maxZ);
		this.occlusionCullingOctreeCellSetDimensions(ocCullOctreeCell._subBoxesArray[5], halfX, ocCullOctreeCell.maxX,   ocCullOctreeCell.minY, halfY,   halfZ, ocCullOctreeCell.maxZ);
		this.occlusionCullingOctreeCellSetDimensions(ocCullOctreeCell._subBoxesArray[6], halfX, ocCullOctreeCell.maxX,   halfY, ocCullOctreeCell.maxY,   halfZ, ocCullOctreeCell.maxZ);
		this.occlusionCullingOctreeCellSetDimensions(ocCullOctreeCell._subBoxesArray[7], ocCullOctreeCell.minX, halfX,   halfY, ocCullOctreeCell.maxY,   halfZ, ocCullOctreeCell.maxZ);
		//-------------------------------------------------------------------------------------------------------------------------------------------------------------

		for (var i = 0; i < ocCullOctreeCell._subBoxesArray.length; i++)
		{
			//ocCullOctreeCell._subBoxesArray[i].setSizesSubBoxes(); // Old.***
			this.occlusionCullingOctreeCellSetSizesSubBoxes(ocCullOctreeCell._subBoxesArray[i]);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param ocCullOctreeCell 변수
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
GeometryModifier.prototype.occlusionCullingOctreeCellIntersectsWithPoint3D = function(ocCullOctreeCell, x, y, z) 
{
	var intersects = false;

	if (x > ocCullOctreeCell.minX && x < ocCullOctreeCell.maxX) 
	{
		if (y > ocCullOctreeCell.minY && y < ocCullOctreeCell.maxY) 
		{
			if (z > ocCullOctreeCell.minZ && z < ocCullOctreeCell.maxZ) 
			{
				intersects = true;
			}
		}
	}

	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param ocCullOctreeCell 변수
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersectedSubBox
 */
GeometryModifier.prototype.occlusionCullingOctreeCellGetIntersectedSubBoxByPoint3D = function(ocCullOctreeCell, x, y, z) 
{
	var intersectedSubBox = null;

	if (ocCullOctreeCell._ocCulling_Cell_owner === null)
	{
		// This is the mother_cell.***
		if (!this.occlusionCullingOctreeCellIntersectsWithPoint3D(ocCullOctreeCell, x, y, z))
		{
			return null;
		}
	}

	var subBoxesCount = ocCullOctreeCell._subBoxesArray.length;
	if (subBoxesCount > 0)
	{
		var centerX = (ocCullOctreeCell.minX + ocCullOctreeCell.maxX)/2.0;
		var centerY = (ocCullOctreeCell.minY + ocCullOctreeCell.maxY)/2.0;
		var centerZ = (ocCullOctreeCell.minZ + ocCullOctreeCell.maxZ)/2.0;

		var intersectedSubBoxAux = null;
		var intersectedSubBoxIdx = undefined;

		if (x < centerX)
		{
			// Here are the boxes number 0, 3, 4, 7.***
			if (y < centerY)
			{
				// Here are 0, 4.***
				if (z < centerZ) { intersectedSubBoxIdx = 0; }
				else { intersectedSubBoxIdx = 4; }
			}
			else
			{
				// Here are 3, 7.***
				if (z < centerZ) { intersectedSubBoxIdx = 3; }
				else { intersectedSubBoxIdx = 7; }
			}
		}
		else
		{
			// Here are the boxes number 1, 2, 5, 6.***
			if (y<center_y)
			{
				// Here are 1, 5.***
				if (z<center_z) { intersectedSubBoxIdx = 1; }
				else { intersectedSubBoxIdx = 5; }
			}
			else
			{
				// Here are 2, 6.***
				if (z<center_z) { intersectedSubBoxIdx = 2; }
				else { intersectedSubBoxIdx = 6; }
			}
		}

		intersectedSubBoxAux = ocCullOctreeCell._subBoxesArray[intersectedSubBoxIdx];
		intersectedSubBox = this.occlusionCullingOctreeCellGetIntersectedSubBoxByPoint3D(intersectedSubBoxAux, x, y, z);

	}
	else
	{
		intersectedSubBox = ocCullOctreeCell;
	}

	return intersectedSubBox;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param ocCullOctreeCell 변수
 * @param eyeX 변수
 * @param eyeY 변수
 * @param eyeZ 변수
 * @returns indicesVisiblesArray
 */
GeometryModifier.prototype.occlusionCullingOctreeCellGetIndicesVisiblesForEye = function(ocCullOctreeCell, eyeX, eyeY, eyeZ) 
{
	var indicesVisiblesArray = null;
	var intersectedSubBox = this.occlusionCullingOctreeCellGetIntersectedSubBoxByPoint3D(ocCullOctreeCell, eyeX, eyeY, eyeZ);

	if (intersectedSubBox !== null && intersectedSubBox._indicesArray.length > 0)
	{
		indicesVisiblesArray = intersectedSubBox._indicesArray;
	}

	return indicesVisiblesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param ocCullOctreeCell 변수
 * @param expansionDist 변수
 */
GeometryModifier.prototype.occlusionCullingOctreeCellExpandBox = function(ocCullOctreeCell, expansionDist) 
{
	ocCullOctreeCell.minX -= expansionDist;
	ocCullOctreeCell.maxX += expansionDist;
	ocCullOctreeCell.minY -= expansionDist;
	ocCullOctreeCell.maxY += expansionDist;
	ocCullOctreeCell.minZ -= expansionDist;
	ocCullOctreeCell.maxZ += expansionDist;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param vtArraysCacheKeys_container 변수
 * @returns vtCacheKey
 */
GeometryModifier.prototype.vertexTexcoordsArraysCacheKeysContainerNewVertexTexcoordsArraysCacheKey = function(vtArraysCacheKeys_container) 
{
	var vtCacheKey = new VertexTexcoordsArraysCacheKeys();
	vtArraysCacheKeys_container._vtArrays_cacheKeys_array.push(vtCacheKey);
	return vtCacheKey;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param blockList 변수
 * @param idx 변수
 * @returns block
 */
GeometryModifier.prototype.blocksListGetBlock = function(blockList, idx) 
{
	var block = null;

	if (idx >= 0 && idx < blockList.blocksArray.length) 
	{
		block = blockList.blocksArray[idx];
	}
	return block;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param blockListContainer 변수
 * @param blocksListName 변수
 * @returns blocksList
 */
GeometryModifier.prototype.blocksListsContainerNewBlocksList = function(blockListContainer, blocksListName) 
{
	var blocksList = new BlocksList();
	blocksList.name = blocksListName;
	blockListContainer.blocksListsArray.push(blocksList);
	return blocksList;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param blockListContainer 변수
 * @param blocksListName 변수
 * @returns blocksList
 */
GeometryModifier.prototype.blocksListsContainerGetBlockList = function(blockListContainer, blocksListName) 
{
	var blocksListsCount = blockListContainer.blocksListsArray.length;
	var found = false;
	var i = 0;
	var blocksList = null;
	while (!found && i < blocksListsCount)
	{
		var currentBlocksList = blockListContainer.blocksListsArray[i];
		if (currentBlocksList.name === blocksListName)
		{
			found = true;
			blocksList = currentBlocksList;
		}
		i++;
	}
	return blocksList;
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param buildingProject 변수
 */
GeometryModifier.prototype.bRbuildingProjectCreateDefaultBlockReferencesLists = function(buildingProject) 
{
	// Create 5 BlocksLists: "Blocks1", "Blocks2", "Blocks3", Blocks4" and "BlocksBone".***

	// Old.*********************************************************
	//this._blocksList_Container.newBlocksList("Blocks1");
	//this._blocksList_Container.newBlocksList("Blocks2");
	//this._blocksList_Container.newBlocksList("Blocks3");
	//this._blocksList_Container.newBlocksList("Blocks4");
	//this._blocksList_Container.newBlocksList("BlocksBone");
	//----------------------------------------------------------------

	this.f4dBlocksListsContainerNewBlocksList(buildingProject._blocksList_Container, "Blocks1");
	this.f4dBlocksListsContainerNewBlocksList(buildingProject._blocksList_Container, "Blocks2");
	this.f4dBlocksListsContainerNewBlocksList(buildingProject._blocksList_Container, "Blocks3");
	this.f4dBlocksListsContainerNewBlocksList(buildingProject._blocksList_Container, "Blocks4");
	this.f4dBlocksListsContainerNewBlocksList(buildingProject._blocksList_Container, "BlocksBone");
};

/**
 * 어떤 일을 하고 있습니까?
 * @memberof GeometryModifier
 *
 * @param buildingProjectsList 변수
 * @returns brBuildingProject
 */
GeometryModifier.prototype.bRbuildingProjectsListNewBRProject = function(buildingProjectsList) 
{
	//var titol = "holes a tothom"
	//var brBuildingProject = new BRBuildingProject({Titol : titol});
	var brBuildingProject = new BRBuildingProject();

	// Create the blocks lists default.***
	this.bRbuildingProjectCreateDefaultBlockReferencesLists(brBuildingProject);

	buildingProjectsList._BR_buildingsArray.push(brBuildingProject);
	return brBuildingProject;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Globe
 */
var Globe = function() 
{
	if (!(this instanceof Globe)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	//WGS 84.***************************************************
	// Extracted from WikiPedia "Geodetic datum".
	// WGS 84 Defining Parameters
	// semi-major axis	a	6378137.0 m
	// Reciprocal of flattening	1/f	298.257223563
	
	// WGS 84 derived geometric constants
	// Semi-minor axis	b = a(1 − f)	6356752.3142 m
	// First eccentricity squared	e2 = (1 − b2/a2 = 2f − f2) =	6.69437999014 x 10−3
	// Second eccentricity squared	e′2	= (a2/b2 − 1 = f(2 − f)/(1 − f)2) = 6.73949674228 x 10−3
	//----------------------------------------------------------
	
	this.equatorialRadius = 6378137.0; // meters.
	this.polarRadius = 6356752.3142; // meters.
	this.firstEccentricitySquared = 6.69437999014E-3;
	this.secondEccentricitySquared = 6.73949674228E-3;
	this.degToRadFactor = Math.PI/180.0;
};

Globe.equatorialRadius = function()
{
	return 6378137.0;;
};

Globe.prototype.normalizeCartesian = function(cartesian)
{
	if (cartesian === undefined)
	{ return; }

	var modul = Math.sqrt(cartesian[0]*cartesian[0] + cartesian[1]*cartesian[1] + cartesian[2]*cartesian[2] );
	cartesian[0] /= modul;
	cartesian[1] /= modul;
	cartesian[2] /= modul;
	
	return cartesian;
};

Globe.prototype.transformMatrixAtCartesianPointWgs84 = function(x, y, z, float32Array)
{
	var xAxis, yAxis, zAxis;
	
	zAxis = this.normalAtCartesianPointWgs84(x, y, z, zAxis);
	
	// Check if zAxis is vertical vector. PENDENT.***
	
	// now, calculate the east direction. 
	// project zAxis to plane XY and calculate the left perpendicular.***
	xAxis = new Float32Array(3);
	xAxis[0] = -y;
	xAxis[1] = x;
	xAxis[2] = 0.0;
	xAxis = this.normalizeCartesian(xAxis);
	
	// finally calculate the north direction.***
	var xAxisVector = new Point3D(xAxis[0], xAxis[1], xAxis[2]);
	var yAxisVector = new Point3D();
	var zAxisVector = new Point3D(zAxis[0], zAxis[1], zAxis[2]);
	
	yAxisVector = zAxisVector.crossProduct(xAxisVector, yAxisVector);
	
	if (float32Array === undefined)
	{ float32Array = new Float32Array(16); }
	
	float32Array[0] = xAxisVector.x;
	float32Array[1] = xAxisVector.y;
	float32Array[2] = xAxisVector.z;
	float32Array[3] = 0.0;
	
	float32Array[4] = yAxisVector.x;
	float32Array[5] = yAxisVector.y;
	float32Array[6] = yAxisVector.z;
	float32Array[7] = 0.0;
	
	float32Array[8] = zAxisVector.x;
	float32Array[9] = zAxisVector.y;
	float32Array[10] = zAxisVector.z;
	float32Array[11] = 0.0;
	
	float32Array[12] = x;
	float32Array[13] = y;
	float32Array[14] = z;
	float32Array[15] = 1.0;
	
	return float32Array;
};

Globe.prototype.intersectionLineWgs84 = function(line, resultCartesian, radius)
{
	// line: (x, y, z) = x1 + t(x2 - x1), y1 + t(y2 - y1), z1 + t(z2 - z1)
	// sphere: (x - x3)^2 + (y - y3)^2 + (z - z3)^2 = r^2, where x3, y3, z3 is the center of the sphere.
	
	// line:
	var p1 = line.point;
	var lineDir = line.direction;
	var dist = 1000.0;// any value is ok.***
	var p2 = new Point3D(p1.x + lineDir.x * dist, p1.y + lineDir.y * dist, p1.z + lineDir.z * dist);
	var x1 = p1.x;
	var y1 = p1.y;
	var z1 = p1.z;
	var x2 = p2.x;
	var y2 = p2.y;
	var z2 = p2.z;

	// sphere:
	var x3 = 0;
	var y3 = 0;
	var z3 = 0;
	var r = this.equatorialRadius; // provisionally.***
	if (radius !== undefined)
	{ r = radius; }
	
	// resolve:
	var x21 = (x2-x1);
	var y21 = (y2-y1);
	var z21 = (z2-z1);
	
	var a = x21*x21 + y21*y21 + z21*z21;
	
	var x13 = (x1-x3);
	var y13 = (y1-y3);
	var z13 = (z1-z3);
	
	var b = 2*(x21 * x13 + y21 * y13 + z21 * z13);
	
	var c = x3*x3 + y3*y3 + z3*z3 + x1*x1 + y1*y1 + z1*z1 - 2*(x3*x1 + y3*y1+ z3*z1) - r*r;
	
	var discriminant = b*b - 4*a*c;
	
	if (discriminant < 0)
	{
		// no intersection.***
		return undefined;
	}
	else if (discriminant === 0)
	{
		// this is tangent.***
		if (resultCartesian === undefined)
		{ resultCartesian = new Float32Array(3); }
		
		var t1 = (-b)/(2*a);
		var intersectPoint1 = new Point3D(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);
		resultCartesian[0] = intersectPoint1.x;
		resultCartesian[1] = intersectPoint1.y;
		resultCartesian[2] = intersectPoint1.z;
		
	}
	else
	{
		// find the nearest to p1.***
		var t1 = (-b + Math.sqrt(discriminant))/(2*a);
		var t2 = (-b - Math.sqrt(discriminant))/(2*a);
		
		// solution 1.***
		var intersectPoint1 = new Point3D(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);
		var intersectPoint2 = new Point3D(x1 + (x2 - x1)*t2, y1 + (y2 - y1)*t2, z1 + (z2 - z1)*t2);
		
		var dist1 = p1.squareDistToPoint(intersectPoint1);
		var dist2 = p1.squareDistToPoint(intersectPoint2);
		
		if (resultCartesian === undefined)
		{ resultCartesian = new Float32Array(3); }
		
		if (dist1 < dist2)
		{
			resultCartesian[0] = intersectPoint1.x;
			resultCartesian[1] = intersectPoint1.y;
			resultCartesian[2] = intersectPoint1.z;
		}
		else
		{
			resultCartesian[0] = intersectPoint2.x;
			resultCartesian[1] = intersectPoint2.y;
			resultCartesian[2] = intersectPoint2.z;
		}
	}
	
	return resultCartesian;
	
};

Globe.prototype.normalAtCartesianPointWgs84 = function(x, y, z, resultNormal)
{
	if (resultNormal === undefined)
	{ resultNormal = new Float32Array(3); }

	var equatorialRadiusSquared = this.equatorialRadius * this.equatorialRadius;
	var polarRadiusSquared = this.polarRadius * this.polarRadius;

	resultNormal[0] = x / equatorialRadiusSquared;
	resultNormal[1] = y / equatorialRadiusSquared;
	resultNormal[2] = z / polarRadiusSquared;
	
	// Normalize cartesian.***
	resultNormal = this.normalizeCartesian(resultNormal);
	
	return resultNormal;
};

Globe.CartesianToGeographicWgs84 = function (x, y, z, result) 
{
	// Copied from WebWorldWind.***
	// According to H. Vermeille, "An analytical method to transform geocentric into geodetic coordinates"
	// http://www.springerlink.com/content/3t6837t27t351227/fulltext.pdf
	// Journal of Geodesy, accepted 10/2010, not yet published
	
	/*
	this.equatorialRadius = 6378137.0; // meters.
	this.polarRadius = 6356752.3142; // meters.
	this.firstEccentricitySquared = 6.69437999014E-3;
	this.secondEccentricitySquared = 6.73949674228E-3;
	this.degToRadFactor = Math.PI/180.0;
	*/
	var firstEccentricitySquared = 6.69437999014E-3;
	var equatorialRadius = 6378137.0;
	/*
	var X = z,
		Y = x,
		Z = y,
		*/
	var X = x,
		Y = y,
		Z = z,
		XXpYY = X * X + Y * Y,
		sqrtXXpYY = Math.sqrt(XXpYY),
		a = equatorialRadius,
		ra2 = 1 / (a * a),
		e2 = firstEccentricitySquared,
		e4 = e2 * e2,
		p = XXpYY * ra2,
		q = Z * Z * (1 - e2) * ra2,
		r = (p + q - e4) / 6,
		h,
		phi,
		u,
		evoluteBorderTest = 8 * r * r * r + e4 * p * q,
		rad1,
		rad2,
		rad3,
		atan,
		v,
		w,
		k,
		D,
		sqrtDDpZZ,
		e,
		lambda,
		s2;

	if (evoluteBorderTest > 0 || q != 0) 
	{
		if (evoluteBorderTest > 0) 
		{
			// Step 2: general case
			rad1 = Math.sqrt(evoluteBorderTest);
			rad2 = Math.sqrt(e4 * p * q);

			// 10*e2 is my arbitrary decision of what Vermeille means by "near... the cusps of the evolute".
			if (evoluteBorderTest > 10 * e2) 
			{
				rad3 = Math.cbrt((rad1 + rad2) * (rad1 + rad2));
				u = r + 0.5 * rad3 + 2 * r * r / rad3;
			}
			else 
			{
				u = r + 0.5 * Math.cbrt((rad1 + rad2) * (rad1 + rad2))
					+ 0.5 * Math.cbrt((rad1 - rad2) * (rad1 - rad2));
			}
		}
		else 
		{
			// Step 3: near evolute
			rad1 = Math.sqrt(-evoluteBorderTest);
			rad2 = Math.sqrt(-8 * r * r * r);
			rad3 = Math.sqrt(e4 * p * q);
			atan = 2 * Math.atan2(rad3, rad1 + rad2) / 3;

			u = -4 * r * Math.sin(atan) * Math.cos(Math.PI / 6 + atan);
		}

		v = Math.sqrt(u * u + e4 * q);
		w = e2 * (u + v - q) / (2 * v);
		k = (u + v) / (Math.sqrt(w * w + u + v) + w);
		D = k * sqrtXXpYY / (k + e2);
		sqrtDDpZZ = Math.sqrt(D * D + Z * Z);

		h = (k + e2 - 1) * sqrtDDpZZ / k;
		phi = 2 * Math.atan2(Z, sqrtDDpZZ + D);
	}
	else 
	{
		// Step 4: singular disk
		rad1 = Math.sqrt(1 - e2);
		rad2 = Math.sqrt(e2 - p);
		e = Math.sqrt(e2);

		h = -a * rad1 * rad2 / e;
		phi = rad2 / (e * rad2 + rad1 * Math.sqrt(p));
	}

	// Compute lambda
	s2 = Math.sqrt(2);
	if ((s2 - 1) * Y < sqrtXXpYY + X) 
	{
		// case 1 - -135deg < lambda < 135deg
		lambda = 2 * Math.atan2(Y, sqrtXXpYY + X);
	}
	else if (sqrtXXpYY + Y < (s2 + 1) * X) 
	{
		// case 2 - -225deg < lambda < 45deg
		lambda = -Math.PI * 0.5 + 2 * Math.atan2(X, sqrtXXpYY - Y);
	}
	else 
	{
		// if (sqrtXXpYY-Y<(s2=1)*X) {  // is the test, if needed, but it's not
		// case 3: - -45deg < lambda < 225deg
		lambda = Math.PI * 0.5 - 2 * Math.atan2(X, sqrtXXpYY + Y);
	}

	if (result === undefined)
	{ result = new GeographicCoord(); }

	var factor = 180.0 / Math.PI;
	result.latitude = factor * phi;
	result.longitude = factor * lambda;
	result.altitude = h;

	return result;
};
/*
Globe.CartesianToGeographicWgs84 = function(x, y, z, resultGeographic)
{
	// defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)
	// https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum
	var a = 6378137.0;
	var f = 1.0 / 298.257223563;
	var f2 = f*f;
	var e2 = 2*f - f2;
	var p = Math.sqrt(x*x + y*y);
	var r = Math.sqrt(p*p + z*z);
	
	var nu = Math.atan(z/2 *((1-f) + (e2*a/r)));
	var lambda = Math.atan(y/x);
	
	var sin_nu = Math.sin(nu);
	var cos_nu = Math.cos(nu);
	var sin3_nu = sin_nu * sin_nu * sin_nu;
	var cos3_nu = cos_nu * cos_nu * cos_nu;
	
	var numerator = z*(1-f)+e2*a*sin3_nu;
	var denominator = (1-f)*(p-e2*a*cos3_nu);
	var fita = Math.atan(numerator/denominator);
	var sin_fita = Math.sin(fita);
	var h = p*Math.cos(fita) + z*sin_fita - a*Math.sqrt(1-e2*sin_fita*sin_fita);
	
	var radToDegFactor = 180.0/Math.PI;
	if (resultGeographic === undefined)
	{ resultGeographic = new GeographicCoord(); }
	
	resultGeographic.setLonLatAlt(lambda * radToDegFactor, fita * radToDegFactor, h);
	return resultGeographic;
};
*/

Globe.geographicToCartesianWgs84 = function(longitude, latitude, altitude, resultCartesian)
{
	// defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)
	// https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum
	// a = semi-major axis.
	// e2 = firstEccentricitySquared.
	// v = a / sqrt(1 - e2 * sin2(lat)).
	// x = (v+h)*cos(lat)*cos(lon).
	// y = (v+h)*cos(lat)*sin(lon).
	// z = [v*(1-e2)+h]*sin(lat).
	var degToRadFactor = Math.PI/180.0;
	var equatorialRadius = 6378137.0; // meters.
	var firstEccentricitySquared = 6.69437999014E-3;
	var lonRad = longitude * degToRadFactor;
	var latRad = latitude * degToRadFactor;
	var cosLon = Math.cos(lonRad);
	var cosLat = Math.cos(latRad);
	var sinLon = Math.sin(lonRad);
	var sinLat = Math.sin(latRad);
	var a = equatorialRadius;
	var e2 = firstEccentricitySquared;
	var v = a/Math.sqrt(1.0 - e2 * sinLat * sinLat);
	var h = altitude;
	
	if (resultCartesian === undefined)
	{ resultCartesian = new Float32Array(3); }
	
	resultCartesian[0]=(v+h)*cosLat*cosLon;
	resultCartesian[1]=(v+h)*cosLat*sinLon;
	resultCartesian[2]=(v*(1.0-e2)+h)*sinLat;
	
	return resultCartesian;
};

Globe.geographicRadianArrayToFloat32ArrayWgs84 = function(lonArray, latArray, altArray, resultCartesianArray)
{
	// defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)
	// https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum
	// a = semi-major axis.
	// e2 = firstEccentricitySquared.
	// v = a / sqrt(1 - e2 * sin2(lat)).
	// x = (v+h)*cos(lat)*cos(lon).
	// y = (v+h)*cos(lat)*sin(lon).
	// z = [v*(1-e2)+h]*sin(lat).
	var equatorialRadius = 6378137.0; // meters.
	var firstEccentricitySquared = 6.69437999014E-3;
	
	var lonRad;
	var latRad;
	var cosLon;
	var cosLat;
	var sinLon;
	var sinLat;
	var a = equatorialRadius;
	var e2 = firstEccentricitySquared;
	var e2a = 1.0 - e2;
	var v;
	var h;
	var resultCartesian;
	
	var coordsCount = lonArray.length;
	resultCartesianArray = new Float32Array(coordsCount*3);
	for (var i=0; i<coordsCount; i++)
	{
		lonRad = lonArray[i];
		latRad = latArray[i];
		cosLon = Math.cos(lonRad);
		cosLat = Math.cos(latRad);
		sinLon = Math.sin(lonRad);
		sinLat = Math.sin(latRad);
		v = a/Math.sqrt(1.0 - e2 * sinLat * sinLat);
		h = altArray[i];
		
		resultCartesianArray[i*3] = (v+h)*cosLat*cosLon;
		resultCartesianArray[i*3+1] = (v+h)*cosLat*sinLon;
		resultCartesianArray[i*3+2] = (v*e2a+h)*sinLat;
	}
	
	return resultCartesianArray;
};

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class GlobeTile
 */
var GlobeTile = function() 
{
	if (!(this instanceof GlobeTile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.globeTileOwner;
	this.depth;
	this.numberName;
	this.minGeographicCoord;
	this.maxGeographicCoord;
	this.subTilesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns subTile
 */
GlobeTile.prototype.newSubTile = function() 
{
	var subTilesCount = this.subTilesArray.length;
	var subTile = new GlobeTile();
	subTile.depth = this.depth + 1;
	subTile.numberName = this.numberName*10 + subTilesCount + 1;
	this.subTilesArray.push(subTile);
	return subTile;
};


'use strict';

/**
 * Main Mago class.
 * @class MagoManager
 */
var MagoManager = function() 
{
	if (!(this instanceof MagoManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// F4D Data structure & objects.*****************************************
	//this.terranTile = new TerranTile();
	this.tinTerrainManager = new TinTerrainManager();
	this.renderer = new Renderer();
	this.selectionCandidates = new SelectionCandidates();
	this.shadersManager = new ShadersManager();
	this.postFxShadersManager = new PostFxShadersManager();
	this.vBOManager = new VBOManager();
	this.readerWriter = new ReaderWriter();
	this.magoPolicy = new Policy();
	
	var serverPolicy = MagoConfig.getPolicy();
	if (serverPolicy !== undefined)
	{
		this.magoPolicy.setLod0DistInMeters(serverPolicy.geo_lod0);
		this.magoPolicy.setLod1DistInMeters(serverPolicy.geo_lod1);
		this.magoPolicy.setLod2DistInMeters(serverPolicy.geo_lod2);
		this.magoPolicy.setLod3DistInMeters(serverPolicy.geo_lod3);
		this.magoPolicy.setLod4DistInMeters(serverPolicy.geo_lod4);
		this.magoPolicy.setLod5DistInMeters(serverPolicy.geo_lod5);
	}
	
	this.smartTileManager = new SmartTileManager();
	this.processQueue = new ProcessQueue();
	this.parseQueue = new ParseQueue();
	this.loadQueue = new LoadQueue(this);
	this.hierarchyManager = new HierarchyManager();
	this.inspectorBox = new InspectorBox();

	// SSAO.***************************************************
	this.noiseTexture;
	this.depthFbo;
	this.normalFbo; // Only for test disply normals. No use this in release.***
	this.ssaoFbo;

	this.pixels = new Uint8Array(4*4*4); // really this is no necessary.***

	this.depthFboNeo;
	this.ssaoFboNeo;
	this.selectionFbo; // framebuffer for selection.***

	// Mouse handler.***********************************************************************
	this.handler; // mouse handlers. mouse_DOWN, mouse_MOVE, mouse_UP.***
	this.mouse_x = 0;
	this.mouse_y = 0;
	this.mouseLeftDown = false;
	this.mouseMiddleDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane;

	this.objectSelected;
	this.buildingSelected;
	this.octreeSelected;
	this.nodeSelected;

	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;
	this.startMovPoint = new Point3D();
	
	this.TEST_maxWheelZoomAmount = 0;
	this.TEST_maxZoomAmount = 0;
	
	this.configInformation;
	this.cameraFPV = new FirstPersonView();
	this.myCameraSCX;
	this.lightCam;
	this.magoGeometryTest;

	this.kernel = [ 0.33, 0.0, 0.85,
		0.25, 0.3, 0.5,
		0.1, 0.3, 0.85,
		-0.15, 0.2, 0.85,
		-0.33, 0.05, 0.6,
		-0.1, -0.15, 0.85,
		-0.05, -0.32, 0.25,
		0.2, -0.15, 0.85,
		0.6, 0.0, 0.55,
		0.5, 0.6, 0.45,
		-0.01, 0.7, 0.35,
		-0.33, 0.5, 0.45,
		-0.45, 0.0, 0.55,
		-0.65, -0.5, 0.7,
		0.0, -0.5, 0.55,
		0.33, 0.3, 0.35];

	// Original for hemisphere.***
	/*
	for(var i=0; i<kernelSize; i++) {
		var x = 2.0 * (Math.random() - 0.5);
		var y = 2.0 * (Math.random() - 0.5);
		var z = Math.random();
		if(z<0.15)z = 0.15;
		this.kernel.push(x);
		this.kernel.push(y);
		this.kernel.push(z);
	}
	*/

	/* Test for sphere.***
	for(var i=0; i<kernelSize; i++) {
		this.kernel.push(2.0 * (Math.random() - 0.5));
		this.kernel.push(2.0 * (Math.random() - 0.5));
		this.kernel.push(2.0 * (Math.random() - 0.5));
	}
	*/
	// End ssao.------------------------------------------------

	this.atmosphere = new Atmosphere();

	// Vars.****************************************************************
	this.sceneState = new SceneState(); // this contains all scene mtrices and camera position.***
	this.selectionColor = new SelectionColor();
	this.vboMemoryManager = new VBOMemoryManager();

	this.fileRequestControler = new FileRequestControler();
	this.visibleObjControlerOctrees = new VisibleObjectsController(); 
	this.visibleObjControlerNodes = new VisibleObjectsController(); 
	this.visibleObjControlerTerrain = new VisibleObjectsController(); 
	
	this.boundingSphere_Aux; 
	this.radiusAprox_aux;

	this.lastCamPos = new Point3D();
	this.squareDistUmbral = 22.0;

	this.lowestOctreeArray = [];

	this.backGround_fileReadings_count = 0; // this can be as max = 9.***
	this.backGround_imageReadings_count = 0;
	this.isCameraMoving = false; 
	this.isCameraInsideNeoBuilding = false;
	this.renderingFase = 0;

	this.bPicking = false;
	this.scene;

	this.numFrustums;
	this.isLastFrustum = false;
	this.currentFrustumIdx = 0;
	this.highLightColor4 = new Float32Array([0.2, 1.0, 0.2, 1.0]);
	this.thereAreUrgentOctrees = false;
	
	this.hierarchyManager = new HierarchyManager();
	
	// small object size.
	this.smallObjectSize = 0.153;
	
	// sqrtTable.
	
	this.sqrtTable = new Float32Array(11);
	// make 100 values.
	var increValue = 0.1;
	for (var i=0; i<11; i++)
	{
		this.sqrtTable[i] = Math.sqrt(1+(increValue*i)*(increValue*i));
	}
	
	this.managerUtil = new ManagerUtils();

	// CURRENTS.********************************************************************
	this.currentSelectedObj_idx = -1;
	this.currentByteColorPicked = new Uint8Array(4);
	this.currentShader;

	// SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.***
	this.pointSC= new Point3D();
	this.pointSC_2= new Point3D();
	this.arrayAuxSC = [];

	this.currentTimeSC;
	this.dateSC;
	this.startTimeSC;
	this.maxMilisecondsForRender = 10;

	this.terranTileSC;

	this.textureAux_1x1;
	this.resultRaySC = new Float32Array(3);
	this.matrix4SC = new Matrix4();

	this.unitaryBoxSC = new BoxAux();
	this.unitaryBoxSC.makeAABB(1.0, 1.0, 1.0); // make a unitary box.***
	this.unitaryBoxSC.vBOVertexIdxCacheKey = this.unitaryBoxSC.triPolyhedron.getVBOArrayModePosNorCol(this.unitaryBoxSC.vBOVertexIdxCacheKey);
	
	this.axisXYZ = new AxisXYZ();
	
	this.invertedBox = new Box();
	var mesh = this.invertedBox.makeMesh(1.5, 1.5, 1.5);
	mesh.reverseSense();
	//mesh.setColor(0.5, 0.5, 0.5, 0.5);
	mesh.getVbo(this.invertedBox.vbo_vicks_container);
	mesh.getVboEdges(this.invertedBox.vbo_vicks_containerEdges);

	this.demoBlocksLoaded = false;

	this.objMarkerManager = new ObjectMarkerManager();
	this.pin = new Pin();
};

/**
 * noise texture를 생성
 * @param gl 변수
 * @param w 변수
 * @param h 변수
 * @param pixels 변수
 * @returns texture
 */
function genNoiseTextureRGBA(gl, w, h, pixels) 
{
	var texture = gl.createTexture();
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, texture);
	//	var b = new ArrayBuffer(w*h*4);
	//var pixels = new Uint8Array(b);

	if (w === 4 && h === 4) 
	{
		/*
	  	pixels[0] = 149; pixels[1] = 16; pixels[2] = 2; pixels[3] = 197;
	  	pixels[4] = 79; pixels[5] = 76; pixels[6] = 11; pixels[7] = 53;
	  	pixels[8] = 83; pixels[9] = 74; pixels[10] = 155; pixels[11] = 159;
	  	pixels[12] = 19; pixels[13] = 232; pixels[14] = 183; pixels[15] = 27;

	  	pixels[16] = 200; pixels[17] = 248; pixels[18] = 98; pixels[19] = 10;
	  	pixels[20] = 63; pixels[21] = 75; pixels[22] = 229; pixels[23] = 231;
	  	pixels[24] = 162; pixels[25] = 85; pixels[26] = 114; pixels[27] = 243;
	  	pixels[28] = 149; pixels[29] = 136; pixels[30] = 210; pixels[31] = 59;

	  	pixels[32] = 210; pixels[33] = 233; pixels[34] = 117; pixels[35] = 103;
	  	pixels[36] = 83; pixels[37] = 214; pixels[38] = 42; pixels[39] = 175;
	  	pixels[40] = 117; pixels[41] = 223; pixels[42] = 87; pixels[43] = 197;
	  	pixels[44] = 99; pixels[45] = 254; pixels[46] = 128; pixels[47] = 9;

	  	pixels[48] = 137; pixels[49] = 99; pixels[50] = 146; pixels[51] = 38;
	  	pixels[52] = 145; pixels[53] = 76; pixels[54] = 178; pixels[55] = 133;
	  	pixels[56] = 202; pixels[57] = 11; pixels[58] = 220; pixels[59] = 34;
	  	pixels[60] = 61; pixels[61] = 216; pixels[62] = 95; pixels[63] = 249;
		 */
		var i = 0;
		pixels[i] = 50; i++;
		pixels[i] = 58; i++;
		pixels[i] = 229; i++;
		pixels[i] = 120; i++;
		pixels[i] = 212; i++;
		pixels[i] = 236; i++;
		pixels[i] = 251; i++;
		pixels[i] = 148; i++;
		pixels[i] = 75; i++;
		pixels[i] = 92; i++;
		pixels[i] = 246; i++;
		pixels[i] = 59; i++;
		pixels[i] = 197; i++;
		pixels[i] = 95; i++;
		pixels[i] = 235; i++;
		pixels[i] = 216; i++;
		pixels[i] = 130; i++;
		pixels[i] = 124; i++;
		pixels[i] = 215; i++;
		pixels[i] = 154; i++;
		pixels[i] = 25; i++;
		pixels[i] = 41; i++;
		pixels[i] = 221; i++;
		pixels[i] = 146; i++;
		pixels[i] = 187; i++;
		pixels[i] = 217; i++;
		pixels[i] = 130; i++;
		pixels[i] = 199; i++;
		pixels[i] = 142; i++;
		pixels[i] = 112; i++;
		pixels[i] = 61; i++;
		pixels[i] = 135; i++;
		pixels[i] = 67; i++;
		pixels[i] = 125; i++;
		pixels[i] = 159; i++;
		pixels[i] = 153; i++;
		pixels[i] = 215; i++;
		pixels[i] = 49; i++;
		pixels[i] = 49; i++;
		pixels[i] = 69; i++;
		pixels[i] = 126; i++;
		pixels[i] = 168; i++;
		pixels[i] = 61; i++;
		pixels[i] = 215; i++;
		pixels[i] = 21; i++;
		pixels[i] = 93; i++;
		pixels[i] = 183; i++;
		pixels[i] = 1; i++;
		pixels[i] = 125; i++;
		pixels[i] = 44; i++;
		pixels[i] = 22; i++;
		pixels[i] = 130; i++;
		pixels[i] = 197; i++;
		pixels[i] = 118; i++;
		pixels[i] = 109; i++;
		pixels[i] = 23; i++;
		pixels[i] = 195; i++;
		pixels[i] = 4; i++;
		pixels[i] = 148; i++;
		pixels[i] = 245; i++;
		pixels[i] = 124; i++;
		pixels[i] = 125; i++;
		pixels[i] = 185; i++;
		pixels[i] = 28; i++;
	}
	else 
	{
		for (var y=0; y<h; y++) 
		{
			for (var x=0; x<w; x++) 
			{
				pixels[(y*w + x)*4+0] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+1] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+2] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+3] = Math.floor(255 * Math.random());
			}
		}
	}

	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	gl.bindTexture(gl.TEXTURE_2D, null);

	texture.width = w;
	texture.height = h;
	return texture;
}

/**
 * object 를 그리는 두가지 종류의 function을 호출
 * @param scene 변수
 * @param pass 변수
 * @param frustumIdx 변수
 * @param numFrustums 변수
 */
MagoManager.prototype.start = function(scene, pass, frustumIdx, numFrustums) 
{
	// Calculate FPS.
	//var start = new Date().getTime();
	
	// this is cesium version.***
	// mago3d 활성화가 아니면 화면을 그리지 않음
	if (!this.magoPolicy.getMagoEnable()) { return; }

	var isLastFrustum = false;
	this.numFrustums = numFrustums;
	this.currentFrustumIdx = this.numFrustums-frustumIdx-1;
	if (this.currentFrustumIdx === numFrustums-1) 
	{
		isLastFrustum = true;
		this.isLastFrustum = true;
	}

	// cesium 새 버전에서 지원하지 않음
	var picking = pass.pick;
	if (picking) 
	{
		//
	}
	else 
	{
		if (this.configInformation === undefined)
		{
			this.configInformation = MagoConfig.getPolicy();
		}
		if (scene)
		{
			var gl = scene.context._gl;
			gl.getExtension("EXT_frag_depth");
		
			if (gl.isContextLost())
			{ return; }

			this.sceneState.gl = gl;
		}

		this.startRender(scene, isLastFrustum, this.currentFrustumIdx, numFrustums);
			
	}
};

MagoManager.prototype.render = function(dc)
{
	// Function for WebWorldWind.*********************************************************************************************************
	// Function for WebWorldWind.*********************************************************************************************************

	// Now, we add to orderedRenderable the buildings that wants to render. PENDENT.***
	dc.addOrderedRenderable(this, 1000.0); // 1000 = distance to eye.*** Provisionally, we render all.***
	
};

/**
 * object 를 그리는 두가지 종류의 function을 호출
 * @param scene 변수
 * @param pass 변수
 * @param frustumIdx 변수
 * @param numFrustums 변수
 */
MagoManager.prototype.renderOrdered = function(dc)
{
	// Function for WebWorldWind.*********************************************************************************************************
	// Function for WebWorldWind.*********************************************************************************************************

	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}
		
	var isLastFrustum = true;
	var frustumIdx = 0;
	var numFrustums = 1;
	this.sceneState.dc = dc;
	this.sceneState.gl = dc.currentGlContext;
	var scene;
	
	this.startRender(scene, isLastFrustum, frustumIdx, numFrustums);
};


/**
 * 카메라가 이동중인지를 확인
 * @param cameraPosition 변수
 * @param squareDistUmbral 변수
 * @returns camera_was_moved
 */
MagoManager.prototype.swapRenderingFase = function() 
{
	this.renderingFase = !this.renderingFase;
};

/**
 * 기상 데이터를 그림
 * @param gl 변수
 * @param cameraPosition 변수
 * @param cullingVolume 변수
 * @param _modelViewProjectionRelativeToEye 변수
 * @param scene 변수
 * @param isLastFrustum 변수
 */
MagoManager.prototype.renderAtmosphere = function(gl, cameraPosition, cullingVolume, _modelViewProjectionRelativeToEye) 
{
	var clouds_count = this.atmosphere.cloudsManager.circularCloudsArray.length;
	if (clouds_count === 0) { return; }

	var camSplitVelue_X  = Cesium.EncodedCartesian3.encode(cameraPosition.x);
	var camSplitVelue_Y  = Cesium.EncodedCartesian3.encode(cameraPosition.y);
	var camSplitVelue_Z  = Cesium.EncodedCartesian3.encode(cameraPosition.z);

	this.encodedCamPosMC_High[0] = camSplitVelue_X.high;
	this.encodedCamPosMC_High[1] = camSplitVelue_Y.high;
	this.encodedCamPosMC_High[2] = camSplitVelue_Z.high;

	this.encodedCamPosMC_Low[0] = camSplitVelue_X.low;
	this.encodedCamPosMC_Low[1] = camSplitVelue_Y.low;
	this.encodedCamPosMC_Low[2] = camSplitVelue_Z.low;
	// Test using f4d_shaderManager.************************
	var shadersManager = this.shadersManager;
	var standardShader = shadersManager.getMagoShader(4); // 4 = cloud-shader.***
	var shaderProgram = standardShader.SHADER_PROGRAM;

	gl.useProgram(shaderProgram);
	gl.enableVertexAttribArray(standardShader._color);
	gl.enableVertexAttribArray(standardShader._position);

	// Calculate "modelViewProjectionRelativeToEye".*********************************************************
	Cesium.Matrix4.toArray(_modelViewProjectionRelativeToEye, this.modelViewProjRelToEye_matrix);
	//End Calculate "modelViewProjectionRelativeToEye".------------------------------------------------------

	gl.uniformMatrix4fv(standardShader._ModelViewProjectionMatrixRelToEye, false, this.modelViewProjRelToEye_matrix);
	gl.uniform3fv(standardShader._encodedCamPosHIGH, this.encodedCamPosMC_High);
	gl.uniform3fv(standardShader._encodedCamPosLOW, this.encodedCamPosMC_Low);

	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.depthRange(0, 1);

	// Clouds.***************************************************
	var cloud;
	for (var i=0; i<clouds_count; i++) 
	{
		cloud = this.atmosphere.cloudsManager.circularCloudsArray[i];

		gl.uniform3fv(standardShader._cloudPosHIGH, cloud.positionHIGH);
		gl.uniform3fv(standardShader._cloudPosLOW, cloud.positionLOW);

		if (cloud.vbo_vertexCacheKey === undefined) 
		{
			cloud.vbo_vertexCacheKey = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, cloud.vbo_vertexCacheKey);
			gl.bufferData(gl.ARRAY_BUFFER, cloud.getVBOVertexColorFloatArray(), gl.STATIC_DRAW);
		}
		if (cloud.vbo_indexCacheKey === undefined) 
		{
			cloud.vbo_indexCacheKey = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cloud.vbo_indexCacheKey);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cloud.getVBOIndicesShortArray(), gl.STATIC_DRAW);
		}

		// Interleaved mode.***
		gl.bindBuffer(gl.ARRAY_BUFFER, cloud.vbo_vertexCacheKey);
		gl.vertexAttribPointer(standardShader._position, 3, gl.FLOAT, false, 24, 0);
		gl.vertexAttribPointer(standardShader._color, 3, gl.FLOAT, false, 24, 12);

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cloud.vbo_indexCacheKey);
		gl.drawElements(gl.TRIANGLES, cloud.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
		//gl.drawElements(gl.LINE_LOOP, cloud.indicesCount, gl.UNSIGNED_SHORT, 0); // Wireframe.***
	}

	gl.disableVertexAttribArray(standardShader._color);
	gl.disableVertexAttribArray(standardShader._position);

	gl.bindBuffer(gl.ARRAY_BUFFER, null);
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
};

/**
 * 구름 그림자를 그림
 * @param gl 변수
 * @param cameraPosition 변수
 * @param cullingVolume 변수
 * @param _modelViewProjectionRelativeToEye 변수
 * @param scene 변수
 * @param isLastFrustum 변수
 */
MagoManager.prototype.renderCloudShadows = function(gl, cameraPosition, cullingVolume, _modelViewProjectionRelativeToEye) 
{
	//if(!isLastFrustum)
	//	return;
	//this.doFrustumCullingClouds(cullingVolume, this.atmosphere.cloudsManager.circularCloudsArray, cameraPosition);

	var clouds_count = this.atmosphere.cloudsManager.circularCloudsArray.length;
	if (clouds_count === 0) { return; }

	var camSplitVelue_X  = Cesium.EncodedCartesian3.encode(cameraPosition.x);
	var camSplitVelue_Y  = Cesium.EncodedCartesian3.encode(cameraPosition.y);
	var camSplitVelue_Z  = Cesium.EncodedCartesian3.encode(cameraPosition.z);

	this.encodedCamPosMC_High[0] = camSplitVelue_X.high;
	this.encodedCamPosMC_High[1] = camSplitVelue_Y.high;
	this.encodedCamPosMC_High[2] = camSplitVelue_Z.high;

	this.encodedCamPosMC_Low[0] = camSplitVelue_X.low;
	this.encodedCamPosMC_Low[1] = camSplitVelue_Y.low;
	this.encodedCamPosMC_Low[2] = camSplitVelue_Z.low;
	// Test using f4d_shaderManager.************************
	var shadersManager = this.shadersManager;
	var standardShader = shadersManager.getMagoShader(4); // 4 = cloud-shader.***
	var shaderProgram = standardShader.SHADER_PROGRAM;

	gl.useProgram(shaderProgram);
	//gl.enableVertexAttribArray(standardShader._color);
	//gl.disableVertexAttribArray(standardShader._color);
	gl.enableVertexAttribArray(standardShader._position);

	// Calculate "modelViewProjectionRelativeToEye".*********************************************************
	Cesium.Matrix4.toArray(_modelViewProjectionRelativeToEye, this.modelViewProjRelToEye_matrix);
	//End Calculate "modelViewProjectionRelativeToEye".------------------------------------------------------

	gl.uniformMatrix4fv(standardShader._ModelViewProjectionMatrixRelToEye, false, this.modelViewProjRelToEye_matrix);
	gl.uniform3fv(standardShader._encodedCamPosHIGH, this.encodedCamPosMC_High);
	gl.uniform3fv(standardShader._encodedCamPosLOW, this.encodedCamPosMC_Low);

	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.depthRange(0, 1);

	// SHADOW SETTINGS.**********************************************************************************
	gl.colorMask(false, false, false, false);
	gl.depthMask(false);
	gl.enable(gl.CULL_FACE);
	gl.enable(gl.STENCIL_TEST);
	gl.enable(gl.POLYGON_OFFSET_FILL);
	gl.polygonOffset(1.0, 2.0); // Original.***
	//gl.polygonOffset(1.0, 1.0);

	// First pas.****************************************************************************************************
	gl.cullFace(gl.FRONT);
	gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
	gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP);
	gl.clearStencil(0);
	//gl.clear(gl.STENCIL_BUFFER_BIT);

	// Clouds.***
	//clouds_count = this.currentVisibleClouds_array.length;
	var cloud;
	for (var i=0; i<clouds_count; i++) 
	{
		cloud = this.atmosphere.cloudsManager.circularCloudsArray[i]; // Original.***
		//cloud = this.currentVisibleClouds_array[i];

		gl.uniform3fv(standardShader._cloudPosHIGH, cloud.positionHIGH);
		gl.uniform3fv(standardShader._cloudPosLOW, cloud.positionLOW);

		// Provisionally render sadow.***
		if (cloud.vbo_shadowVertexCacheKey === undefined) 
		{
			cloud.vbo_shadowVertexCacheKey = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, cloud.vbo_shadowVertexCacheKey);
			gl.bufferData(gl.ARRAY_BUFFER, cloud.getVBOShadowVertexFloatArray(), gl.STATIC_DRAW);
		}
		if (cloud.vbo_shadowIndexCacheKey === undefined) 
		{
			cloud.vbo_shadowIndexCacheKey = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cloud.vbo_shadowIndexCacheKey);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cloud.getVBOShadowIndicesShortArray(), gl.STATIC_DRAW);
		}

		// Interleaved mode.***
		gl.bindBuffer(gl.ARRAY_BUFFER, cloud.vbo_shadowVertexCacheKey);
		gl.vertexAttribPointer(standardShader._position, 3, gl.FLOAT, false, 0, 0);

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cloud.vbo_shadowIndexCacheKey);
		gl.drawElements(gl.TRIANGLES, cloud.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
		//gl.drawElements(gl.LINE_LOOP, cloud.indicesCount, gl.UNSIGNED_SHORT, 0); // Wireframe.***
	}

	// Second pass.****************************************************************************************************
	gl.cullFace(gl.BACK);
	gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
	gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP);

	// Clouds.***
	for (var i=0; i<clouds_count; i++) 
	{
		cloud = this.atmosphere.cloudsManager.circularCloudsArray[i];

		gl.uniform3fv(standardShader._cloudPosHIGH, cloud.positionHIGH);
		gl.uniform3fv(standardShader._cloudPosLOW, cloud.positionLOW);

		// Provisionally render sadow.***
		if (cloud.vbo_shadowVertexCacheKey === undefined) 
		{
			cloud.vbo_shadowVertexCacheKey = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, cloud.vbo_shadowVertexCacheKey);
			gl.bufferData(gl.ARRAY_BUFFER, cloud.getVBOShadowVertexFloatArray(), gl.STATIC_DRAW);
		}
		if (cloud.vbo_shadowIndexCacheKey === undefined) 
		{
			cloud.vbo_shadowIndexCacheKey = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cloud.vbo_shadowIndexCacheKey);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cloud.getVBOShadowIndicesShortArray(), gl.STATIC_DRAW);
		}

		// Interleaved mode.***
		gl.bindBuffer(gl.ARRAY_BUFFER, cloud.vbo_shadowVertexCacheKey);
		gl.vertexAttribPointer(standardShader._position, 3, gl.FLOAT, false, 0, 0);

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cloud.vbo_shadowIndexCacheKey);
		gl.drawElements(gl.TRIANGLES, cloud.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
		//gl.drawElements(gl.LINE_LOOP, cloud.indicesCount, gl.UNSIGNED_SHORT, 0); // Wireframe.***
	}
	//gl.disableVertexAttribArray(standardShader._color);
	gl.disableVertexAttribArray(standardShader._position);

	// Render the shadow.*********************************************************************************************
	gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.disable(gl.CULL_FACE);
	gl.colorMask(true, true, true, true);
	gl.depthMask(false);
	gl.stencilMask(0x00);

	gl.stencilFunc(gl.NOTEQUAL, 1, 0xff);
	gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);

	gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Original.***
	//gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	// must draw a rectangle for blending.***
	gl.cullFace(gl.FRONT);

	// render the shadowBlendingCube.***
	standardShader = shadersManager.getMagoShader(5); // 5 = blendingCube-shader.***
	gl.useProgram(standardShader.SHADER_PROGRAM);

	gl.enableVertexAttribArray(standardShader._color);
	gl.enableVertexAttribArray(standardShader._position);

	gl.uniformMatrix4fv(standardShader._ModelViewProjectionMatrixRelToEye, false, this.modelViewProjRelToEye_matrix);
	gl.uniform3fv(standardShader._encodedCamPosHIGH, this.encodedCamPosMC_High);
	gl.uniform3fv(standardShader._encodedCamPosLOW, this.encodedCamPosMC_Low);

	var shadowBC = this.atmosphere.shadowBlendingCube;
	if (shadowBC.vbo_vertexCacheKey === undefined) 
	{
		shadowBC.vbo_vertexCacheKey = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, shadowBC.vbo_vertexCacheKey);
		gl.bufferData(gl.ARRAY_BUFFER, shadowBC.getVBOVertexColorRGBAFloatArray(), gl.STATIC_DRAW);
	}
	if (shadowBC.vbo_indexCacheKey === undefined) 
	{
		shadowBC.vbo_indexCacheKey = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shadowBC.vbo_indexCacheKey);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shadowBC.getVBOIndicesShortArray(), gl.STATIC_DRAW);
	}

	// Interleaved mode.***
	gl.bindBuffer(gl.ARRAY_BUFFER, shadowBC.vbo_vertexCacheKey);
	gl.vertexAttribPointer(standardShader._position, 3, gl.FLOAT, false, 28, 0);
	gl.vertexAttribPointer(standardShader._color, 4, gl.FLOAT, false, 28, 12);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shadowBC.vbo_indexCacheKey);
	gl.drawElements(gl.TRIANGLES, shadowBC.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***

	gl.disableVertexAttribArray(standardShader._position);
	gl.disableVertexAttribArray(standardShader._color);

	gl.enable(gl.DEPTH_TEST);
	gl.disable(gl.BLEND);
	gl.disable(gl.STENCIL_TEST);
};

/**
 * 텍스처를 읽어서 그래픽 카드에 올림
 * Loading Texture
 * 
 * @param {any} gl 
 * @param {any} image 
 * @param {any} texture 
 */
function handleTextureLoaded(gl, image, texture) 
{
	// https://developer.mozilla.org/en-US/docs/Web/API/Webgl_API/Tutorial/Using_textures_in_Webgl
	gl.bindTexture(gl.TEXTURE_2D, texture);
	//gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBgl,true); // if need vertical mirror of the image.***
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Original.***
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
	gl.generateMipmap(gl.TEXTURE_2D);
	gl.bindTexture(gl.TEXTURE_2D, null);
};

/**
 * 빌딩을 준비(새버전)
 * @param {gl} gl
 */
MagoManager.prototype.prepareNeoBuildingsAsimetricVersion = function(gl, visibleObjControlerNodes) 
{
	// for all renderables, prepare data.***
	var neoBuilding;
	var node, rootNode;
	var projectFolderName;
	
	//var geometryDataPath = this.readerWriter.getCurrentDataPath();
	var geometryDataPath = this.readerWriter.geometryDataPath;
	if (this.headersRequestedCounter === undefined)
	{ this.headersRequestedCounter = 0; }

	var currentVisibleNodes = [].concat(visibleObjControlerNodes.currentVisibles0, visibleObjControlerNodes.currentVisibles2, visibleObjControlerNodes.currentVisibles3);
	for (var i=0, length = currentVisibleNodes.length; i<length; i++) 
	{
		node = currentVisibleNodes[i];
		projectFolderName = node.data.projectFolderName;
		
		neoBuilding = currentVisibleNodes[i].data.neoBuilding;
		
		// check if this building is ready to render.***
		//if (!neoBuilding.allFilesLoaded) // no used yet.
		{
			// 1) MetaData
			var metaData = neoBuilding.metaData;
			if (metaData.fileLoadState === CODE.fileLoadState.READY) 
			{
				if (this.fileRequestControler.isFullHeaders())	{ return; }
				var neoBuildingHeaderPath = geometryDataPath + "/"  + projectFolderName + "/"  + neoBuilding.buildingFileName + "/HeaderAsimetric.hed";
				this.readerWriter.getNeoHeaderAsimetricVersion(gl, neoBuildingHeaderPath, neoBuilding, this.readerWriter, this); // Here makes the tree of octree.***
			}
		}
	}
	currentVisibleNodes.length = 0;
};

/**
 * Here updates the modelView matrices.
 * @param {SceneState} sceneState
 */
MagoManager.prototype.upDateSceneStateMatrices = function(sceneState) 
{
	if (this.myCameraSCX === undefined) 
	{ this.myCameraSCX = new Camera(); }

	if (this.configInformation === undefined) 
	{
		// MagoWorld. No need update matrices.***
		return;
	}

	// here updates the modelView and modelViewProjection matrices of the scene.***
	if (this.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		// * else if this is in WebWorldWind:
		// www dependency.****
		var dc = sceneState.dc;
		
		var columnMajorArray = WorldWind.Matrix.fromIdentity();
		var columnMajorArrayAux = WorldWind.Matrix.fromIdentity();
		
		var modelViewRelToEye = WorldWind.Matrix.fromIdentity();
		modelViewRelToEye.copy(dc.navigatorState.modelview);
		modelViewRelToEye[3] = 0.0;
		modelViewRelToEye[7] = 0.0;
		modelViewRelToEye[11] = 0.0;
		
		// ModelViewMatrix.***
		var modelView = WorldWind.Matrix.fromIdentity();
		modelView.copy(dc.navigatorState.modelview);
		columnMajorArray = modelView.columnMajorComponents(columnMajorArrayAux);
		sceneState.modelViewMatrix.copyFromFloatArray(columnMajorArray);
		
		// ModelViewMatrix Inverse.***
		var matrixInv = WorldWind.Matrix.fromIdentity();
		//matrixInv.invertMatrix(modelView);
		matrixInv.invertOrthonormalMatrix(modelView);
		columnMajorArray = matrixInv.columnMajorComponents(columnMajorArrayAux);
		sceneState.modelViewMatrixInv.copyFromFloatArray(columnMajorArray);
		
		// NormalMatrix.***
		sceneState.normalMatrix4.copyFromFloatArray(matrixInv);
	  
		// Projection Matrix.***
		var projection = WorldWind.Matrix.fromIdentity();
		projection.copy(dc.navigatorState.projection);
		columnMajorArray = projection.columnMajorComponents(columnMajorArrayAux);
		sceneState.projectionMatrix.copyFromFloatArray(columnMajorArray);
		
		// ModelViewRelToEyeMatrix.***
		modelView = WorldWind.Matrix.fromIdentity();
		modelView.copy(dc.navigatorState.modelview);
		columnMajorArray = modelViewRelToEye.columnMajorComponents(columnMajorArray);
		sceneState.modelViewRelToEyeMatrix.copyFromFloatArray(columnMajorArray);
		
		// ModelViewRelToEyeMatrixInv.***
		var mvRelToEyeInv = WorldWind.Matrix.fromIdentity();
		mvRelToEyeInv.invertOrthonormalMatrix(modelViewRelToEye);
		columnMajorArray = mvRelToEyeInv.columnMajorComponents(columnMajorArrayAux);
		sceneState.modelViewRelToEyeMatrixInv.copyFromFloatArray(columnMajorArray);
		
		// ModelViewProjectionRelToEyeMatrix.***
		var modelViewProjectionRelToEye_aux = WorldWind.Matrix.fromIdentity();
		modelViewProjectionRelToEye_aux.copy(projection);
		modelViewProjectionRelToEye_aux.multiplyMatrix(modelViewRelToEye);
		var columnMajorArrayAux = WorldWind.Matrix.fromIdentity();
		var columnMajorArray = modelViewProjectionRelToEye_aux.columnMajorComponents(columnMajorArrayAux); // Original.***
		sceneState.modelViewProjRelToEyeMatrix.copyFromFloatArray(columnMajorArray);
		
		// ModelViewProjectionMatrix.***
		var modelViewProjection_aux = WorldWind.Matrix.fromIdentity();
		modelViewProjection_aux.copy(projection);
		modelViewProjection_aux.multiplyMatrix(modelView);
		var columnMajorArrayAux = WorldWind.Matrix.fromIdentity();
		var columnMajorArray = modelViewProjection_aux.columnMajorComponents(columnMajorArrayAux); // Original.***
		sceneState.modelViewProjMatrix.copyFromFloatArray(columnMajorArray);
		
		/*
		// ModelViewProjectionRelToEyeMatrix.***
		columnMajorArray = WorldWind.Matrix.fromIdentity();
		var modelViewProjection = WorldWind.Matrix.fromIdentity();
		modelViewProjection.copy(dc.navigatorState.modelviewProjection);
		columnMajorArray = modelViewProjection.columnMajorComponents(columnMajorArrayAux);
		columnMajorArray[12] = 0.0;
		columnMajorArray[13] = 0.0;
		columnMajorArray[14] = 0.0;
		sceneState.modelViewProjRelToEyeMatrix.copyFromFloatArray(columnMajorArray);
		*/
		
		
		
		var cameraHeading = dc.navigatorState.heading;
		var cameraTilt = dc.navigatorState.tilt;
		
		// now, calculate camera direction and up from cameraHeading and cameraTilt.
		var cameraDirection = new Point3D();
		cameraDirection.set(0, 0, -1);
		var rotatedCameraDirection = new Point3D();
		rotatedCameraDirection.set(0, 0, 0);
		
		var cameraUp = new Point3D();
		cameraUp.set(0, 1, 0);
		var rotatedCameraUp = new Point3D();
		rotatedCameraUp.set(0, 0, 0);
		
		rotatedCameraDirection = sceneState.modelViewMatrixInv.rotatePoint3D(cameraDirection, rotatedCameraDirection);
		rotatedCameraDirection.unitary();
		rotatedCameraUp = sceneState.modelViewMatrixInv.rotatePoint3D(cameraUp, rotatedCameraUp);
		rotatedCameraUp.unitary();
			
		var cameraPosition = dc.navigatorState.eyePoint;
		sceneState.camera.position.set(cameraPosition[0], cameraPosition[1], cameraPosition[2]);
		sceneState.camera.direction.set(rotatedCameraDirection.x, rotatedCameraDirection.y, rotatedCameraDirection.z);
		sceneState.camera.up.set(rotatedCameraUp.x, rotatedCameraUp.y, rotatedCameraUp.z);
		ManagerUtils.calculateSplited3fv([cameraPosition[0], cameraPosition[1], cameraPosition[2]], sceneState.encodedCamPosHigh, sceneState.encodedCamPosLow);
		
		var viewport = this.wwd.viewport;
		sceneState.camera.frustum.aspectRatio[0] = viewport.width/viewport.height;
		sceneState.camera.frustum.near[0] = 0.1;
		sceneState.camera.frustum.far[0] = 1000.0;
		
		// Calculate FOV & FOVY.***
		if (sceneState.camera.frustum.dirty)
		{
			var projectionMatrix = dc.navigatorState.projection;
			var aspectRat = sceneState.camera.frustum.aspectRatio;
			var angleAlfa = 2*Math.atan(1/(aspectRat*projectionMatrix[0]));
			var frustum0 = sceneState.camera.getFrustum(0);
			frustum0.dirty = false;
			sceneState.camera.setAspectRatioAndFovyRad(viewport.width/viewport.height, angleAlfa);
		}

		// screen size.***
		sceneState.drawingBufferWidth[0] = viewport.width;
		sceneState.drawingBufferHeight[0] = viewport.height;
	}
	else if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		// * if this is in Cesium:
		var scene = this.scene;
		var uniformState = scene._context.uniformState;
		
		// check if the matrices changed.***
		// compare with the lastModelViewProjectionMatrix.***

		//var uniformState = scene._context._us;
		Cesium.Matrix4.toArray(uniformState._modelViewProjectionRelativeToEye, sceneState.modelViewProjRelToEyeMatrix._floatArrays);
		Cesium.Matrix4.toArray(uniformState._modelViewProjection, sceneState.modelViewProjMatrix._floatArrays); // always dirty.
		Cesium.Matrix4.toArray(uniformState._modelViewRelativeToEye, sceneState.modelViewRelToEyeMatrix._floatArrays);
		
		sceneState.modelViewRelToEyeMatrixInv._floatArrays = Cesium.Matrix4.inverseTransformation(sceneState.modelViewRelToEyeMatrix._floatArrays, sceneState.modelViewRelToEyeMatrixInv._floatArrays);// original.***
		
		//Cesium.Matrix4.toArray(uniformState._modelView, sceneState.modelViewMatrix._floatArrays);// original.***
		//sceneState.modelViewMatrix._floatArrays = Cesium.Matrix4.multiply(uniformState.model, uniformState.view, sceneState.modelViewMatrix._floatArrays);
		sceneState.modelViewMatrix._floatArrays = Cesium.Matrix4.clone(uniformState.view, sceneState.modelViewMatrix._floatArrays);
		Cesium.Matrix4.toArray(uniformState._projection, sceneState.projectionMatrix._floatArrays);
		
		//calculate modelViewProjection.
		//sceneState.modelViewProjMatrix = sceneState.modelViewMatrix.getMultipliedByMatrix(sceneState.projectionMatrix, sceneState.modelViewProjMatrix);

		var cameraPosition = scene.context._us._cameraPosition;
		ManagerUtils.calculateSplited3fv([cameraPosition.x, cameraPosition.y, cameraPosition.z], sceneState.encodedCamPosHigh, sceneState.encodedCamPosLow);

		sceneState.modelViewMatrixInv._floatArrays = Cesium.Matrix4.inverseTransformation(sceneState.modelViewMatrix._floatArrays, sceneState.modelViewMatrixInv._floatArrays);// original.***
		sceneState.normalMatrix4._floatArrays = Cesium.Matrix4.transpose(sceneState.modelViewMatrixInv._floatArrays, sceneState.normalMatrix4._floatArrays);// original.***

		var frustum0 = sceneState.camera.getFrustum(0);
		frustum0.far[0] = scene._frustumCommandsList[0].far; 
		frustum0.near[0] = scene._frustumCommandsList[0].near;
		frustum0.fovRad[0] = scene._camera.frustum._fov;
		frustum0.fovyRad[0]= scene._camera.frustum._fovy;
		frustum0.aspectRatio[0] = scene._camera.frustum._aspectRatio;
		frustum0.tangentOfHalfFovy[0] = Math.tan(frustum0.fovyRad/2);
		sceneState.camera.setCurrentFrustum(0);

		// now, determine if the camera was moved.***
		var camNewPosX = scene.context._us._cameraPosition.x;
		var camNewPosY = scene.context._us._cameraPosition.y;
		var camNewPosZ = scene.context._us._cameraPosition.z;
		
		var camNewDirX = scene._camera.direction.x;
		var camNewDirY = scene._camera.direction.y;
		var camNewDirZ = scene._camera.direction.z;
		
		var camNewUpX = scene._camera.up.x;
		var camNewUpY = scene._camera.up.y;
		var camNewUpZ = scene._camera.up.z;
		
		if (sceneState.camera.isCameraMoved(camNewPosX, camNewPosY, camNewPosZ, camNewDirX, camNewDirY, camNewDirZ, camNewUpX, camNewUpY, camNewUpZ ))
		{
			this.isCameraMoved = true;
		}
		
		sceneState.camera.position.set(scene.context._us._cameraPosition.x, scene.context._us._cameraPosition.y, scene.context._us._cameraPosition.z);
		sceneState.camera.direction.set(scene._camera.direction.x, scene._camera.direction.y, scene._camera.direction.z);
		sceneState.camera.up.set(scene._camera.up.x, scene._camera.up.y, scene._camera.up.z);
		
		
		sceneState.drawingBufferWidth[0] = scene.drawingBufferWidth;
		sceneState.drawingBufferHeight[0] = scene.drawingBufferHeight;
	}
	else if (this.configInformation.geo_view_library === Constant.MAGOWORLD)
	{
		var camera = sceneState.camera;
		var camPos = camera.position;
		var frustum0 = camera.getFrustum(0);
		sceneState.camera.frustum.aspectRatio = sceneState.drawingBufferWidth / sceneState.drawingBufferHeight;
		// determine frustum near & far.***
		var camHeight = camera.getCameraElevation();
		var eqRadius = Globe.equatorialRadius();
		frustum0.far[0] = (eqRadius + camHeight);
		//frustum0.far[0] = 30000000.0;
		frustum0.near[0] = 0.1 + camHeight / 10000000;
		
		
		ManagerUtils.calculateSplited3fv([camPos.x, camPos.y, camPos.z], sceneState.encodedCamPosHigh, sceneState.encodedCamPosLow);
		
		// projection.***
		// considere near as zero provisionally.***
		sceneState.projectionMatrix._floatArrays = mat4.perspective(sceneState.projectionMatrix._floatArrays, frustum0.fovyRad[0], frustum0.aspectRatio, 0.0, frustum0.far[0]);
		
		// modelView.***
		//sceneState.modelViewMatrix._floatArrays = 
		sceneState.modelViewMatrixInv._floatArrays = mat4.invert(sceneState.modelViewMatrixInv._floatArrays, sceneState.modelViewMatrix._floatArrays);
	
		// normalMat.***
		sceneState.normalMatrix4._floatArrays = mat4.transpose(sceneState.normalMatrix4._floatArrays, sceneState.modelViewMatrixInv._floatArrays);
		
		// modelViewRelToEye.***
		sceneState.modelViewRelToEyeMatrix._floatArrays = mat4.copy(sceneState.modelViewRelToEyeMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);
		sceneState.modelViewRelToEyeMatrix._floatArrays[12] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[13] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[14] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[15] = 1;
		sceneState.modelViewRelToEyeMatrixInv._floatArrays = mat4.invert(sceneState.modelViewRelToEyeMatrixInv._floatArrays, sceneState.modelViewRelToEyeMatrix._floatArrays);
		
		// modelViewProjection.***
		sceneState.modelViewProjMatrix._floatArrays = mat4.multiply(sceneState.modelViewProjMatrix._floatArrays, sceneState.projectionMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);

		// modelViewProjectionRelToEye.***
		sceneState.modelViewProjRelToEyeMatrix.copyFromMatrix4(sceneState.modelViewProjMatrix);
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[12] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[13] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[14] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[15] = 1;
		

		frustum0.tangentOfHalfFovy[0] = Math.tan(frustum0.fovyRad[0]/2);
		
	}
	
	if (this.depthFboNeo !== undefined)
	{
		sceneState.ssaoNoiseScale2[0] = this.depthFboNeo.width[0]/this.noiseTexture.width;
		sceneState.ssaoNoiseScale2[1] = this.depthFboNeo.height[0]/this.noiseTexture.height;
	}
	
	// set the auxiliar camera.
	this.myCameraSCX.direction.set(sceneState.camera.direction.x, sceneState.camera.direction.y, sceneState.camera.direction.z);
	this.myCameraSCX.up.set(sceneState.camera.up.x, sceneState.camera.up.y, sceneState.camera.up.z);
	var frustum0 = this.myCameraSCX.getFrustum(0);
	var sceneCamFurustum0 = sceneState.camera.getFrustum(0);
	frustum0.near[0] = sceneCamFurustum0.near[0];
	frustum0.far[0] = sceneCamFurustum0.far[0];
	frustum0.fovyRad[0] = sceneCamFurustum0.fovyRad[0];
	frustum0.tangentOfHalfFovy[0] = sceneCamFurustum0.tangentOfHalfFovy[0];
	frustum0.fovRad[0] = sceneCamFurustum0.fovRad[0];
	frustum0.aspectRatio[0] = sceneCamFurustum0.aspectRatio[0];
	
	
};

/**
 * Here updates the camera's parameters and frustum planes.
 * @param {Camera} camera
 */
MagoManager.prototype.upDateCamera = function(resultCamera) 
{
	if (this.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		var frustumIdx = this.currentFrustumIdx;
		var frustum = resultCamera.getFrustum(frustumIdx);
		var fovy = frustum.fovyRad;
		resultCamera.setAspectRatioAndFovyRad(aspectRatio, fovy);
		
		var wwwFrustumVolume = this.sceneState.dc.navigatorState.frustumInModelCoordinates;
		for (var i=0; i<6; i++)
		{
			var plane = wwwFrustumVolume._planes[i];
			resultCamera.frustum.planesArray[i].setNormalAndDistance(plane.normal[0], plane.normal[1], plane.normal[2], plane.distance);
		}
	}
	else if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		var camera = this.scene.frameState.camera;
		
		//var frustumIdx = this.numFrustums-this.currentFrustumIdx-1;
		var frustumIdx = this.currentFrustumIdx;
		var camera = this.sceneState.camera;
		var frustum = camera.getFrustum(frustumIdx);
		var aspectRatio = frustum.aspectRatio;
		var fovy = frustum.fovyRad;
		frustum.far[0] = this.scene._frustumCommandsList[frustumIdx].far; 
		frustum.near[0] = this.scene._frustumCommandsList[frustumIdx].near;
		var currentFrustumFar = this.scene._frustumCommandsList[frustumIdx].far;
		var currentFrustumNear = this.scene._frustumCommandsList[frustumIdx].near;
		
		this.sceneState.camera.frustum.near[0] = currentFrustumNear;
		this.sceneState.camera.frustum.far[0] = currentFrustumFar;
		
		// take all frustums near-far distances.***
		var numFrustums = this.scene._frustumCommandsList.length;
		var distancesArray = [];
		for (var i=0; i<numFrustums; i++)
		{
			distancesArray[i*2] = this.scene._frustumCommandsList[i].near;
			distancesArray[i*2+1] = this.scene._frustumCommandsList[i].far;
		}
		
		resultCamera.position.set(camera.position.x, camera.position.y, camera.position.z);
		resultCamera.direction.set(camera.direction.x, camera.direction.y, camera.direction.z);
		resultCamera.up.set(camera.up.x, camera.up.y, camera.up.z);
		frustum = resultCamera.getFrustum(frustumIdx);
		frustum.near[0] = currentFrustumNear;
		frustum.far[0] = currentFrustumFar;
		resultCamera.setFrustumsDistances(numFrustums, distancesArray);
		resultCamera.setAspectRatioAndFovyRad(aspectRatio, fovy);
		resultCamera.calculateFrustumsPlanes();
	}
	else if (this.configInformation.geo_view_library === Constant.MAGOWORLD)
	{
		var camera = this.sceneState.camera;
		
		var frustumIdx = 0;
		var camera = this.sceneState.camera;
		var frustum = camera.getFrustum(frustumIdx);
		var aspectRatio = frustum.aspectRatio;
		var fovy = frustum.fovyRad;
		//frustum.far[0] = this.scene._frustumCommandsList[frustumIdx].far; 
		//frustum.near[0] = this.scene._frustumCommandsList[frustumIdx].near;
		var currentFrustumFar = frustum.far;
		var currentFrustumNear = frustum.near;
		
		this.sceneState.camera.frustum.near[0] = currentFrustumNear;
		this.sceneState.camera.frustum.far[0] = currentFrustumFar;
		this.sceneState.camera.frustum.aspectRatio = aspectRatio;
		
		// take all frustums near-far distances.***
		var numFrustums = 1;
		var distancesArray = [];
		for (var i=0; i<numFrustums; i++)
		{
			distancesArray[i*2] = frustum.near;
			distancesArray[i*2+1] = frustum.far;
		}
		
		resultCamera.position.set(camera.position.x, camera.position.y, camera.position.z);
		resultCamera.direction.set(camera.direction.x, camera.direction.y, camera.direction.z);
		resultCamera.up.set(camera.up.x, camera.up.y, camera.up.z);
		frustum = resultCamera.getFrustum(frustumIdx);
		frustum.near[0] = currentFrustumNear;
		frustum.far[0] = currentFrustumFar;
		resultCamera.setFrustumsDistances(numFrustums, distancesArray);
		resultCamera.setAspectRatioAndFovyRad(aspectRatio, fovy);
		resultCamera.calculateFrustumsPlanes();
	}
};

MagoManager.prototype.renderFakeEarth = function(ssao_idx)
{
	if (ssao_idx === undefined)
	{ ssao_idx = 1; }
	
	if (this.fakeEarth === undefined)
	{
		var natProject = new MagoNativeProject();
		
		// create a sphere.***
		//equatorialRadius = 6378137.0;
		var sphere = new Sphere();
		sphere.r = 6378137.0;
		//sphere.r = 100.0;
		var pMesh = new ParametricMesh();
		//pMesh = sphere.makeMesh(pMesh);
		sphere.mesh = pMesh;
		
		pMesh.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		pMesh.vboKeyContainer = sphere.getVbo(pMesh.vboKeyContainer);
		
		this.fakeEarth = sphere;
	}
	//---------------------------------------------------------------------------------------------------------------
	
	var gl = this.sceneState.gl;
	var color;
	var node;
	var currentShader;
	if (ssao_idx === 0)
	{
		currentShader = this.postFxShadersManager.getTriPolyhedronDepthShader(); // triPolyhedron ssao.***
		gl.disable(gl.BLEND);
	}
	if (ssao_idx === 1)
	{
		currentShader = this.postFxShadersManager.getTriPolyhedronShader(); // triPolyhedron ssao.***
		gl.enable(gl.BLEND);
	}
	
	var shaderProgram = currentShader.program;
	
	gl.frontFace(gl.CCW);
	gl.useProgram(shaderProgram);
	gl.enableVertexAttribArray(currentShader.position3_loc);
	
	gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
	
	
	gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
	gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);

	gl.uniform1f(currentShader.near_loc, this.sceneState.camera.frustum.near);
	gl.uniform1f(currentShader.far_loc, this.sceneState.camera.frustum.far);
	
	//gl.uniform1f(currentShader.near_loc, 1.0);
	//gl.uniform1f(currentShader.far_loc, 1000.0);
	
	gl.uniform1i(currentShader.bApplySsao_loc, false);

	gl.uniformMatrix4fv(currentShader.normalMatrix4_loc, false, this.sceneState.normalMatrix4._floatArrays);
	//-----------------------------------------------------------------------------------------------------------
		
	if (ssao_idx === 1)
	{
		gl.uniform1i(currentShader.bApplySpecularLighting_loc, true);
		// provisionally render all native projects.***
		gl.enableVertexAttribArray(currentShader.normal3_loc);
		gl.enableVertexAttribArray(currentShader.color4_loc);

		gl.uniform1i(currentShader.bUse1Color_loc, false);
		if (color)
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, 1.0]); //.***
		}
		else 
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.***
		}
		
		gl.uniform1i(currentShader.bUseNormal_loc, true);
		
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, this.sceneState.modelViewMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, this.sceneState.projectionMatrix._floatArrays);

		gl.uniform1i(currentShader.depthTex_loc, 0);
		gl.uniform1i(currentShader.noiseTex_loc, 1);
		gl.uniform1i(currentShader.diffuseTex_loc, 2); // no used.***
		gl.uniform1f(currentShader.fov_loc, this.sceneState.camera.frustum.fovyRad);	// "frustum._fov" is in radians.***
		gl.uniform1f(currentShader.aspectRatio_loc, this.sceneState.camera.frustum.aspectRatio);
		gl.uniform1f(currentShader.screenWidth_loc, this.sceneState.drawingBufferWidth);	
		gl.uniform1f(currentShader.screenHeight_loc, this.sceneState.drawingBufferHeight);


		gl.uniform2fv(currentShader.noiseScale2_loc, [this.depthFboNeo.width/this.noiseTexture.width, this.depthFboNeo.height/this.noiseTexture.height]);
		gl.uniform3fv(currentShader.kernel16_loc, this.kernel);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
	}
	
	var neoBuilding;
	var natProject, mesh;

	// Render the fake earth.***************************************************

		
	gl.uniform3fv(currentShader.scale_loc, [1, 1, 1]); //.***
		
	gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, [1.0, 0.0, 0.0, 0.0,    0.0, 1.0, 0.0, 0.0,    0.0, 0.0, 1.0, 0.0,    0.0, 0.0, 0.0, 1.0]);
	gl.uniform3fv(currentShader.buildingPosHIGH_loc, [0.0, 0.0, 0.0]);
	gl.uniform3fv(currentShader.buildingPosLOW_loc, [0.0, 0.0, 0.0]);
	gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
	mesh = this.fakeEarth.mesh;
	this.renderer.renderObject(gl, mesh, this, currentShader, ssao_idx, false);

	// End render fake earth.---------------------------------------------------------------
	
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
};

MagoManager.prototype.test_cctv = function()
{
	if (this.cctvList === undefined)
	{
		this.cctvList = new CCTVList();
		
		/*
		var longitude = 126.61090424717905;
		var latitude = 37.58158288958673;
		var altitude = 80.0;
		*/
		
		var far = 10.0;
		var altitude = 60.0;
		
		// 2- create a cctv.*********************************************************************************
		var cctv = this.cctvList.new_CCTV("0000100001000T");
		var longitude = 128.606641;
		var latitude = 35.902546;
		var altitude_0000100001000T = 74.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_0000100001000T, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_0000100001000T, cctv.camera.position, this);
		var frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 3- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("0000100002000T");
		longitude = 128.606341;
		latitude = 35.901937;
		var altitude_0000100002000T = 82.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_0000100002000T, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_0000100002000T, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 4- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("0000100003000T");
		longitude = 128.606641;
		latitude = 35.902156;
		var altitude_0000100003000T = 80.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_0000100003000T, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_0000100003000T, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 5- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("0000100004000T");
		longitude = 128.606641;
		latitude = 35.902106;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_0000100003000T, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_0000100003000T, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 6- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV-1");
		cctv.minHeading = 45.0;
		cctv.maxHeading = 180.0;
		longitude = 127.054720;
		latitude = 37.540641;
		var altitude_CCTV_1 = 47.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_CCTV_1, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_CCTV_1, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 7- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV-2");
		longitude = 127.055259;
		latitude = 37.544781;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 8- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV-3");
		longitude = 127.043323;
		latitude = 37.548298;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 9- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV-4");
		longitude = 127.056880;
		latitude = 37.544136;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 10- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV-5");
		longitude = 127.054847;
		latitude = 37.544761;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 11- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV10");
		longitude = 127.056265;
		latitude = 37.542031;
		var altitude_CCTV10 = 43.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_CCTV10, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_CCTV10, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 12- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV11");
		cctv.minHeading = -150.0;
		cctv.maxHeading = -35.0;
		longitude = 127.054967;
		latitude = 37.539409;
		var altitude_CCTV11 = 45.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_CCTV11, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_CCTV11, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 13- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV13");
		cctv.minHeading = 90.0;
		cctv.maxHeading = 240.0;
		longitude = 127.055030;
		latitude = 37.540139;
		var altitude_CCTV13 = 46.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_CCTV13, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_CCTV13, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 14- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV14");
		longitude = 127.056001;
		latitude = 37.539940;
		var altitude_CCTV14 = 47.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude_CCTV14, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude_CCTV14, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 15- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV6");
		longitude = 127.057016;
		latitude = 37.544093;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 16- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV7");
		cctv.minHeading = -140.0;
		cctv.maxHeading = 0.0;
		longitude = 127.056593;
		latitude = 37.543283;
		altitude = 45.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 17- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV8");
		longitude = 127.055027;
		latitude = 37.545001;
		altitude = 60.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 18- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("CCTV9");
		longitude = 127.057023;
		latitude = 37.544420;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 19- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("공원3-22");
		longitude = 127.057024;
		latitude = 37.544420;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 20- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("공원4-42");
		longitude = 127.057025;
		latitude = 37.544420;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 21- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("교행1-51");
		longitude = 127.057026;
		latitude = 37.544420;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 22- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("자치15-31123");
		longitude = 127.057027;
		latitude = 37.544420;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
		// 23- create a cctv.*********************************************************************************
		cctv = this.cctvList.new_CCTV("자치6-13");
		longitude = 127.057028;
		latitude = 37.544420;
		//altitude = 70.0;
		
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, 0.0, 0.0, 0.0, cctv.geoLocationData, this);
		cctv.camera.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, cctv.camera.position, this);
		frustum = cctv.camera.bigFrustum;
		frustum.far = far;
		cctv.vboKeyContainer  = new VBOVertexIdxCacheKeysContainer();
		cctv.vboKeyContainer = cctv.getVbo(cctv.vboKeyContainer);
		cctv.calculateRotationMatrix();
		
	}
};

/**
 * start rendering.
 * @param scene 변수
 * @param isLastFrustum 변수
 */
MagoManager.prototype.startRender = function(scene, isLastFrustum, frustumIdx, numFrustums) 
{
	this.numFrustums = numFrustums;
	this.isLastFrustum = isLastFrustum;

	var gl = this.sceneState.gl;
	this.upDateSceneStateMatrices(this.sceneState);
	
	if (this.isFarestFrustum())
	{
		this.test_cctv();
		
		if (this.textureAux_1x1 === undefined) 
		{
			this.textureAux_1x1 = gl.createTexture();
			// Test wait for texture to load.********************************************
			gl.bindTexture(gl.TEXTURE_2D, this.textureAux_1x1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([200, 200, 200, 255])); // clear grey
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
		
		if (this.noiseTexture === undefined) 
		{ this.noiseTexture = genNoiseTextureRGBA(gl, 4, 4, this.pixels); }
		
		// provisional pin textures loading.
		if (this.pin.texture === undefined)
		{
			this.pin.texture = new Texture();
			var filePath_inServer = this.magoPolicy.imagePath + "/bugger.png";
			this.pin.texture.texId = gl.createTexture();
			this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, this.pin.texture, undefined, this);
			this.pin.texturesArray.push(this.pin.texture);
			
			var cabreadoTex = new Texture();
			filePath_inServer = this.magoPolicy.imagePath + "/improve.png";
			cabreadoTex.texId = gl.createTexture();
			this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, cabreadoTex, undefined, this);
			this.pin.texturesArray.push(cabreadoTex);
			
			cabreadoTex = new Texture();
			filePath_inServer = this.magoPolicy.imagePath + "/etc.png";
			cabreadoTex.texId = gl.createTexture();
			this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, cabreadoTex, undefined, this);
			this.pin.texturesArray.push(cabreadoTex);
			
			cabreadoTex = new Texture();
			filePath_inServer = this.magoPolicy.imagePath + "/new.png";
			cabreadoTex.texId = gl.createTexture();
			this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, cabreadoTex, undefined, this);
			this.pin.texturesArray.push(cabreadoTex);
			
			cabreadoTex = new Texture();
			filePath_inServer = this.magoPolicy.imagePath + "/funny.jpg";
			cabreadoTex.texId = gl.createTexture();
			this.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, cabreadoTex, undefined, this);
			this.pin.texturesArray.push(cabreadoTex);
		}
	
		if (this.depthFboNeo === undefined) { this.depthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
		if (this.sceneState.drawingBufferWidth[0] !== this.depthFboNeo.width[0] || this.sceneState.drawingBufferHeight[0] !== this.depthFboNeo.height[0])
		{
			// move this to onResize.***
			this.depthFboNeo.deleteObjects(gl);
			this.depthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
			this.sceneState.camera.frustum.dirty = true;
		}
	
		if (this.myCameraSCX === undefined) 
		{ this.myCameraSCX = new Camera(); }
		
		if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
		{
			////this.upDateSceneStateMatrices(this.sceneState);
			this.upDateCamera(this.myCameraSCX);
			this.doMultiFrustumCullingSmartTiles(this.myCameraSCX);
		}
		
		gl.clearStencil(0); // provisionally here.***
		gl.clear(gl.STENCIL_BUFFER_BIT);
	}

	var cameraPosition = this.sceneState.camera.position;
	
	// Take the current frustumVolumenObject.***
	var frustumVolumenObject = this.frustumVolumeControl.getFrustumVolumeCulling(frustumIdx); 
	this.myCameraSCX.setCurrentFrustum(frustumIdx);
	var visibleNodes = frustumVolumenObject.visibleNodes;
	
	if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
	{
		if (this.frustumVolumeControl === undefined)
		{ return; }
		
		//var frustumVolume = this.myCameraSCX.frustum;
		var frustumVolume = this.myCameraSCX.bigFrustum;
		var doFrustumCullingToBuildings = false;
		this.tilesMultiFrustumCullingFinished(frustumVolumenObject.fullyIntersectedLowestTilesArray, visibleNodes, cameraPosition, frustumVolume, doFrustumCullingToBuildings);
		doFrustumCullingToBuildings = true;
		this.tilesMultiFrustumCullingFinished(frustumVolumenObject.partiallyIntersectedLowestTilesArray, visibleNodes, cameraPosition, frustumVolume, doFrustumCullingToBuildings);
		this.prepareNeoBuildingsAsimetricVersion(gl, visibleNodes); 
	}
	
	var currentShader = undefined;
	this.visibleObjControlerNodes = visibleNodes; // set the current visible nodes.***
	
	
	
	// prepare data if camera is no moving.***
	if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
	{
		// 1) LOD 0.***********************************************************************************
		this.visibleObjControlerOctrees.initArrays(); // init.******

		var neoBuilding;
		var node;
		var octree;
		// lod 0 & lod 1.
		this.checkPropertyFilters(this.visibleObjControlerNodes.currentVisibles0);
		this.checkPropertyFilters(this.visibleObjControlerNodes.currentVisibles2);
		var nodesCount = this.visibleObjControlerNodes.currentVisibles0.length;
		for (var i=0; i<nodesCount; i++) 
		{
			node = this.visibleObjControlerNodes.currentVisibles0[i];
			if (!this.getRenderablesDetailedNeoBuildingAsimetricVersion(gl, node, this.visibleObjControlerOctrees, 0))
			{
				// any octree is visible.
				this.visibleObjControlerNodes.currentVisibles0.splice(i, 1);
				i--;
				nodesCount = this.visibleObjControlerNodes.currentVisibles0.length;
			}
		}
		var fileRequestExtraCount = 1;
		
		this.prepareVisibleOctreesSortedByDistance(gl, this.visibleObjControlerOctrees, fileRequestExtraCount); 

		this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles0, fileRequestExtraCount); 
		this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles1, fileRequestExtraCount); 
		this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles2, fileRequestExtraCount); 
		
		//fileRequestExtraCount = 2;
		fileRequestExtraCount = this.visibleObjControlerOctrees.currentVisibles0.length;
		if (fileRequestExtraCount > 2)
		{ fileRequestExtraCount = 2; }
		
		// lod 2.
		nodesCount = this.visibleObjControlerNodes.currentVisibles2.length;
		for (var i=0; i<nodesCount; i++) 
		{
			node = this.visibleObjControlerNodes.currentVisibles2[i];
			if (!this.getRenderablesDetailedNeoBuildingAsimetricVersion(gl, node, this.visibleObjControlerOctrees, 2))
			{
				// any octree is visible.
				this.visibleObjControlerNodes.currentVisibles2.splice(i, 1);
				i--;
				nodesCount = this.visibleObjControlerNodes.currentVisibles2.length;
			}
		}
		fileRequestExtraCount = 2;
		this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles2, fileRequestExtraCount); 
		
		// in this point, put octrees of lod2 to the deletingQueue to delete the lod0 data.
		nodesCount = this.visibleObjControlerNodes.currentVisibles2.length;
		for (var i=nodesCount-1; i>=0; i--) 
		{
			// inversed "for" because delete 1rst farest.***
			node = this.visibleObjControlerNodes.currentVisibles2[i];
			this.processQueue.putNodeToDeleteModelReferences(node, 0);
		}
		
		// in this point, put nodes to delete lod LOWER THAN lod3 (delete lod0, lod1, lod2).***
		/*
		//if(this.currentFrustumIdx === 0)
		{
			nodesCount = this.visibleObjControlerNodes.currentVisibles3.length;
			var nodesPutted = 0;
			for (var i=nodesCount-1; i>=0; i--) 
			{
				// inverse "for" because delete 1rst farest.***
				node = this.visibleObjControlerNodes.currentVisibles3[i];
				neoBuilding = node.data.neoBuilding;
				if (neoBuilding === undefined)
				{ continue; }
				
				var key = neoBuilding.buildingId;
				
				if(neoBuilding.currentLod === 3)
				{
					this.processQueue.eraseNodeToDeleteLessThanLod4(node);
					if (!this.processQueue.nodesToDeleteLessThanLod3Map.hasOwnProperty(key))
					{
						this.processQueue.putNodeToDeleteLessThanLod3(node, 0);
						nodesPutted++;
					}
				}
				else if(neoBuilding.currentLod === 4)
				{
					this.processQueue.eraseNodeToDeleteLessThanLod5(node);
					if (!this.processQueue.nodesToDeleteLessThanLod4Map.hasOwnProperty(key))
					{
						this.processQueue.putNodeToDeleteLessThanLod4(node, 0);
						nodesPutted++;
					}
				}
				else{
					if (!this.processQueue.nodesToDeleteLessThanLod5Map.hasOwnProperty(key))
					{
						this.processQueue.putNodeToDeleteLessThanLod5(node, 0);
						nodesPutted++;
					}
				}
				
					
				if (nodesPutted > 5)
				{ break; }
			}
		}
		*/
		// lod3, lod4, lod5.***
		this.prepareVisibleLowLodNodes(this.visibleObjControlerNodes.currentVisibles3);
		
		// provisionally prepare pointsCloud datas.******************************************************
		if (this.visibleObjControlerOctreesAux === undefined)
		{ this.visibleObjControlerOctreesAux = new VisibleObjectsController(); }
		
		this.visibleObjControlerOctreesAux.initArrays(); // init.******
		var nodesCount = this.visibleObjControlerNodes.currentVisiblesAux.length;
		for (var i=0; i<nodesCount; i++) 
		{
			node = this.visibleObjControlerNodes.currentVisiblesAux[i];
				
			if (!this.getRenderablesDetailedNeoBuildingAsimetricVersion(gl, node, this.visibleObjControlerOctreesAux, 0))
			{
				// any octree is visible.
				this.visibleObjControlerNodes.currentVisiblesAux.splice(i, 1);
				i--;
				nodesCount = this.visibleObjControlerNodes.currentVisiblesAux.length;
			}
		}
		fileRequestExtraCount = 2;
		this.prepareVisibleOctreesSortedByDistancePointsCloudType(gl, this.visibleObjControlerOctreesAux, fileRequestExtraCount);
		
		
		// TinTerrain.***
		// TinTerrain.*******************************************************************************************************************************
		if (this.isFarestFrustum())
		{
			this.prepareVisibleTinTerrains(this.tinTerrainManager);
		}
		//if(this.isFarestFrustum())
		this.manageQueue();
		
		if (this.currentFrustumIdx === 0)
		{
			
			this.loadQueue.manageQueue();
			//this.loadQueue.resetQueue();
		}
	}
	
	if (this.bPicking === true && isLastFrustum)
	{
		var pixelPos;
		
		if (this.magoPolicy.issueInsertEnable === true)
		{
			if (this.objMarkerSC === undefined)
			{ this.objMarkerSC = new ObjectMarker(); }
			
			pixelPos = new Point3D();
			pixelPos = this.calculatePixelPositionWorldCoord(gl, this.mouse_x, this.mouse_y, pixelPos);
			var objMarker = this.objMarkerManager.newObjectMarker();
			//ManagerUtils.calculateGeoLocationDataByAbsolutePoint(pixelPos.x, pixelPos.y, pixelPos.z, this.objMarkerSC.geoLocationData, this);
			ManagerUtils.calculateGeoLocationDataByAbsolutePoint(pixelPos.x, pixelPos.y, pixelPos.z, objMarker.geoLocationData, this);
		}
		
		if (this.magoPolicy.objectInfoViewEnable === true)
		{
			if (this.objMarkerSC === undefined)
			{ this.objMarkerSC = new ObjectMarker(); }
			
			if (pixelPos === undefined)
			{
				pixelPos = new Point3D();
				pixelPos = this.calculatePixelPositionWorldCoord(gl, this.mouse_x, this.mouse_y, pixelPos);
			}
			
			ManagerUtils.calculateGeoLocationDataByAbsolutePoint(pixelPos.x, pixelPos.y, pixelPos.z, this.objMarkerSC.geoLocationData, this);
			//var objMarker = this.objMarkerManager.newObjectMarker();
			//ManagerUtils.calculateGeoLocationDataByAbsolutePoint(pixelPos.x, pixelPos.y, pixelPos.z, objMarker.geoLocationData, this);
		}
	}

	if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
	{
		if (this.selectionFbo === undefined) 
		{ this.selectionFbo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
	
		if (this.isCameraMoved || this.bPicking)
		{
			this.selectionFbo.bind(); // framebuffer for color selection.***
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl.LEQUAL);
			gl.depthRange(0, 1);
			gl.disable(gl.CULL_FACE);
			if (this.isLastFrustum)
			{
				// this is the farest frustum, so init selection process.***
				gl.clearColor(1, 1, 1, 1); // white background.***
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // clear buffer.***
				this.selectionCandidates.clearCandidates();
			}
			
			this.renderGeometryColorCoding(gl, this.visibleObjControlerNodes);
			this.swapRenderingFase();
			
			if (this.currentFrustumIdx === 0)
			{
				this.isCameraMoved = false;
			}
		}

		if (this.currentFrustumIdx === 0)
		{
			if ( this.bPicking === true)
			{
				// this is the closest frustum.***
				this.bPicking = false;
				this.arrayAuxSC.length = 0;
				this.objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
				this.buildingSelected = this.arrayAuxSC[0];
				this.octreeSelected = this.arrayAuxSC[1];
				this.nodeSelected = this.arrayAuxSC[3];
				if (this.nodeSelected)
				{ this.rootNodeSelected = this.nodeSelected.getRoot(); }
				else
				{ this.rootNodeSelected = undefined; }
					
					
				this.arrayAuxSC.length = 0;
				if (this.buildingSelected !== undefined) 
				{
					this.displayLocationAndRotation(this.buildingSelected);
					this.selectedObjectNotice(this.buildingSelected);
				}
				if (this.objectSelected !== undefined) 
				{
					//this.displayLocationAndRotation(currentSelectedBuilding);
					//this.selectedObjectNotice(currentSelectedBuilding);
					//console.log("objectId = " + selectedObject.objectId);
				}
			}
			
			this.selectionColor.init(); // selection colors manager.***
		}
		this.selectionFbo.unbind();
		gl.enable(gl.CULL_FACE);
	}
	
	// lightDepthRender: TODO.***
	
			
	// 1) The depth render.**********************************************************************************************************************
	var ssao_idx = 0; // 0= depth. 1= ssao.***
	var renderTexture = false;
	this.depthFboNeo.bind(); 
	gl.clearColor(1, 1, 1, 1);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.viewport(0, 0, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
	this.renderGeometry(gl, cameraPosition, currentShader, renderTexture, ssao_idx, this.visibleObjControlerNodes);
	// test mago geometries.***********************************************************************************************************
	//this.renderMagoGeometries(ssao_idx); //TEST
	//this.renderFakeEarth(ssao_idx); // test.***
	this.depthFboNeo.unbind();
	this.swapRenderingFase();
	
	// 2) ssao render.************************************************************************************************************
	if (this.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		;//
	}
	else if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		scene._context._currentFramebuffer._bind();
	}

	ssao_idx = 1;
	this.renderGeometry(gl, cameraPosition, currentShader, renderTexture, ssao_idx, this.visibleObjControlerNodes);
	this.swapRenderingFase();
	
	// 3) test mago geometries.***********************************************************************************************************
	//this.renderMagoGeometries(ssao_idx); //TEST
	//this.renderFakeEarth(ssao_idx); // test.***
	
	// test. Draw the buildingNames.***
	if (this.magoPolicy.getShowLabelInfo())
	{
		this.drawBuildingNames(this.visibleObjControlerNodes) ;
	}

	if (this.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		gl.activeTexture(gl.TEXTURE0);
		this.wwd.drawContext.redrawRequested = true;
	}
	
	//this.renderInvertedBox(gl);
};

/**
 * Prepare tinTerrains.***
 */
MagoManager.prototype.prepareVisibleTinTerrains = function(tinTerrainManager) 
{
	var maxIterations = 10;
	var currIteration = 0;
	
	var terrName_geoCoords_map = tinTerrainManager.currentVisibles_terrName_geoCoords_map;
	var terrName_tinTerrain_map = tinTerrainManager.currentTerrainsMap;
	var tinTerrain;
	var tinTerrainToDelete;
	var gl = this.sceneState.gl;
	
	// 1) 1rst, for all current visibles terrNames, make tinTerrain if no exist.***
	var stringAux = "11\\3491\\597";
	for (var key in terrName_geoCoords_map)
	{
		tinTerrain = terrName_tinTerrain_map[key];
		if (tinTerrain === undefined)
		{
			tinTerrain = new TinTerrain();
			tinTerrain.pathName = key;
			terrName_tinTerrain_map[key] = tinTerrain;
			currIteration++;
			
			// provisionally put the "level" inside of terrain.***
			var splittedString = key.split('\\');
			tinTerrain.depth = splittedString[0];
		}
		else
		{
			// try to erase from procesQueue_deleting if exist.***
			this.processQueue.eraseTinTerrainToDelete(tinTerrain);
			
			if (tinTerrain.fileLoadState === CODE.fileLoadState.READY)
			{
				var fileName = "CesiumTerrain/" + tinTerrain.pathName + ".terrain";
				this.readerWriter.loadTINTerrain(gl, fileName, tinTerrain, this);
			}
			else if (tinTerrain.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
			{
				// put the terrain into parseQueue.***
				this.parseQueue.putTinTerrainToParse(tinTerrain, 0);
			}
			else if (tinTerrain.fileLoadState === CODE.fileLoadState.PARSE_FINISHED && tinTerrain.vboKeyContainer === undefined)
			{
				var geographicExtent = tinTerrainManager.currentVisibles_terrName_geoCoords_map[tinTerrain.pathName];
				if (geographicExtent !== undefined)
				{
					tinTerrain.geographicExtent = geographicExtent;
					tinTerrain.decodeData();
					tinTerrain.makeVbo();
				}
			}
		}
		
		//if(currIteration > maxIterations)
		//	break;
	}
	
	// 2) 2nd, for all terrains that exist, if there are not in the visiblesMap, then delete its.***
	for (var key in terrName_tinTerrain_map)
	{
		tinTerrain = terrName_geoCoords_map[key];
		if (tinTerrain === undefined)
		{
			tinTerrainToDelete = terrName_tinTerrain_map[key];
			this.processQueue.putTinTerrainToDelete(tinTerrainToDelete, 0);
		}
	}
	
};

/**
 * Prepare current visibles low LOD nodes.***
 */
MagoManager.prototype.prepareVisibleLowLodNodes = function(lowLodNodesArray) 
{
	var lowLodDataInQueueCount = Object.keys(this.loadQueue.lowLodSkinDataMap).length;
	if (lowLodDataInQueueCount > 1)
	{ return; }
	
	var lowLodTexturesInQueueCount = Object.keys(this.loadQueue.lowLodSkinTextureMap).length;
	if (lowLodTexturesInQueueCount > 1)
	{ return; }
	
	// Prepare lod3, lod4 and lod5 meshes.***
	// check "this.visibleObjControlerNodes.currentVisibles3".***
	var lowLodMesh;
	var lod;
	var node;
	var neoBuilding;
	var projectFolderName;
	var buildingFolderName;
	var extraCount = 5;
	var gl = this.sceneState.gl;
	var geometryDataPath = this.readerWriter.geometryDataPath;
	
	var lowLodNodesCount = lowLodNodesArray.length;
	for (var i=0; i<lowLodNodesCount; i++) 
	{
		if (Object.keys(this.loadQueue.lowLodSkinDataMap).length > 1)
		{ return; }
		
		if (Object.keys(this.loadQueue.lowLodSkinTextureMap).length > 1)
		{ return; }

		node = lowLodNodesArray[i];
		neoBuilding = node.data.neoBuilding;

		var headerVersion = neoBuilding.getHeaderVersion();
		if (headerVersion === undefined)
		{ continue; }
		
		if (headerVersion[0] !== "0")
		{
			continue;
		}
	
		if (neoBuilding.lodMeshesMap === undefined)
		{ neoBuilding.lodMeshesMap = {}; } 
		
		projectFolderName = neoBuilding.projectFolderName;
		buildingFolderName = neoBuilding.buildingFileName;
		
		// recalculate the distToCam with octrees.***
		//var cameraPosition = this.sceneState.camera.position;
		//neoBuilding.distToCam = neoBuilding.octree.getMinDistToCamera(cameraPosition);
		var textureFileName;
		var lodString;
		var lodIdx = neoBuilding.currentLod; 
		
		// must check if the desirable lodMesh is available.***
		var lodBuildingData = neoBuilding.getLodBuildingData(neoBuilding.currentLod);
		if (lodBuildingData === undefined)
		{ continue; }
	
		if (lodBuildingData.isModelRef)
		{ continue; }
		
		textureFileName = lodBuildingData.textureFileName;
		lodString = lodBuildingData.geometryFileName;
		
		///lowLodMesh = neoBuilding.lodMeshesMap.get(lodString); // code if "lodMeshesMap" is a map.***
		lowLodMesh = neoBuilding.lodMeshesMap[lodString];
		if (lowLodMesh === undefined)
		{
			lowLodMesh = new Lego();
			lowLodMesh.fileLoadState = CODE.fileLoadState.READY;
			lowLodMesh.textureName = textureFileName;
			lowLodMesh.legoKey = neoBuilding.buildingId + "_" + lodString;
			neoBuilding.lodMeshesMap[lodString] = lowLodMesh;
		}
		
		if (lowLodMesh.fileLoadState === -1)
		{
			// if a lodObject has "fileLoadState" = -1 means that there are no file in server.***
			continue;
		}
		
		if (lowLodMesh.fileLoadState === CODE.fileLoadState.READY) 
		{
			// put it into fileLoadQueue.***
			var lodMeshFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + lodString;
			this.loadQueue.putLowLodSkinData(lowLodMesh, lodMeshFilePath, 0);
			
			if (lowLodMesh.vbo_vicks_container.vboCacheKeysArray === undefined)
			{ lowLodMesh.vbo_vicks_container.vboCacheKeysArray = []; }
			
		}
		
		if (lowLodMesh.vbo_vicks_container.vboCacheKeysArray[0] && lowLodMesh.vbo_vicks_container.vboCacheKeysArray[0].meshTexcoordsCacheKey)
		{
			// this is the new version.***
			if (lowLodMesh.texture === undefined)
			{
				lowLodMesh.texture = new Texture();
				var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + textureFileName;
				//this.readerWriter.readLegoSimpleBuildingTexture(gl, filePath_inServer, lowLodMesh.texture, this); // old.***
				this.loadQueue.putLowLodSkinTexture(filePath_inServer, lowLodMesh.texture, 0);
			}
		}

		if (this.fileRequestControler.isFullPlusLowLodData(extraCount))	
		{ return; }
	}
};

/**
 * Mago geometries generation test.***
 */
MagoManager.prototype.renderMagoGeometries = function(ssao_idx) 
{
	// 1rst, make the test object if no exist.***
	//return;
	
	if (this.nativeProjectsArray === undefined)
	{
		this.nativeProjectsArray = [];
		var natProject = new MagoNativeProject();
		this.nativeProjectsArray.push(natProject);
		
		var pMesh = natProject.newParametricMesh();
		
		pMesh.profile = new Profile(); // provisional.***
		var profileAux = pMesh.profile; // provisional.***
		
		profileAux.TEST__setFigureHole_2();
		//profileAux.TEST__setFigure_1();
		
		if (pMesh.vboKeyContainer === undefined)
		{ pMesh.vboKeyContainer = new VBOVertexIdxCacheKeysContainer(); }
		
		if (pMesh.vboKeyContainerEdges === undefined)
		{ pMesh.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }
		
		var bIncludeBottomCap, bIncludeTopCap;
		var extrusionVector, extrusionDist, extrudeSegmentsCount;
		/*
		extrudeSegmentsCount = 120;
		extrusionDist = 15.0;
		pMesh.extrude(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector);
		*/
		
		var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
		revolveAngDeg = 90.0;
		revolveSegment2d = new Segment2D();
		var strPoint2d = new Point2D(20, -10);
		var endPoint2d = new Point2D(20, 10);
		revolveSegment2d.setPoints(strPoint2d, endPoint2d);
		revolveSegmentsCount = 24;
		pMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
		
		bIncludeBottomCap = true;
		bIncludeTopCap = true;
		var mesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
		mesh.setColor(0.1, 0.5, 0.5, 1.0);

		mesh.getVbo(pMesh.vboKeyContainer);
		mesh.getVboEdges(pMesh.vboKeyContainerEdges);
		
		// Now, provisionally make a geoLocationData for the nativeProject.*************************************
		if (natProject.geoLocDataManager === undefined)
		{
			natProject.geoLocDataManager = new GeoLocationDataManager();
			var geoLoc = natProject.geoLocDataManager.newGeoLocationData("deploymentLoc"); 
			
			var longitude = 126.61120237344926;
			var latitude = 37.577213509597016;
			var altitude = 50;
			var heading = 0.0;
			var pitch = 0.0;
			var roll = 0.0;

			ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, heading, pitch, roll, geoLoc, this);
		}
		
	}
	//---------------------------------------------------------------------------------------------------------------
	
	var gl = this.sceneState.gl;
	var color;
	var node;
	var currentShader;
	if (ssao_idx === 0)
	{
		currentShader = this.postFxShadersManager.getTriPolyhedronDepthShader(); // triPolyhedron ssao.***
		gl.disable(gl.BLEND);
	}
	if (ssao_idx === 1)
	{
		currentShader = this.postFxShadersManager.getTriPolyhedronShader(); // triPolyhedron ssao.***
		gl.enable(gl.BLEND);
	}
	
	var shaderProgram = currentShader.program;
	
	gl.frontFace(gl.CCW);
	gl.useProgram(shaderProgram);
	gl.enableVertexAttribArray(currentShader.position3_loc);
	
	gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
	
	
	gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
	gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);

	gl.uniform1f(currentShader.near_loc, this.sceneState.camera.frustum.near);
	gl.uniform1f(currentShader.far_loc, this.sceneState.camera.frustum.far);
	
	gl.uniform1i(currentShader.bApplySsao_loc, false);

	gl.uniformMatrix4fv(currentShader.normalMatrix4_loc, false, this.sceneState.normalMatrix4._floatArrays);
	//-----------------------------------------------------------------------------------------------------------
		
	if (ssao_idx === 1)
	{
		// provisionally render all native projects.***
		gl.enableVertexAttribArray(currentShader.normal3_loc);
		gl.enableVertexAttribArray(currentShader.color4_loc);

		gl.uniform1i(currentShader.bUse1Color_loc, false);
		if (color)
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, 1.0]); //.***
		}
		else 
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.***
		}
		
		gl.uniform1i(currentShader.bUseNormal_loc, true);
		
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, this.sceneState.modelViewMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, this.sceneState.projectionMatrix._floatArrays);

		gl.uniform1i(currentShader.depthTex_loc, 0);
		gl.uniform1i(currentShader.noiseTex_loc, 1);
		gl.uniform1i(currentShader.diffuseTex_loc, 2); // no used.***
		gl.uniform1f(currentShader.fov_loc, this.sceneState.camera.frustum.fovyRad);	// "frustum._fov" is in radians.***
		gl.uniform1f(currentShader.aspectRatio_loc, this.sceneState.camera.frustum.aspectRatio);
		gl.uniform1f(currentShader.screenWidth_loc, this.sceneState.drawingBufferWidth);	
		gl.uniform1f(currentShader.screenHeight_loc, this.sceneState.drawingBufferHeight);


		gl.uniform2fv(currentShader.noiseScale2_loc, [this.depthFboNeo.width/this.noiseTexture.width, this.depthFboNeo.height/this.noiseTexture.height]);
		gl.uniform3fv(currentShader.kernel16_loc, this.kernel);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
	}
	
	var neoBuilding;
	var natProject, mesh;
	var geoLocDataManager;
	var buildingGeoLocation;
	var nativeProjectsCount = this.nativeProjectsArray.length;
	for (var i=0; i<nativeProjectsCount; i++)
	{
		natProject = this.nativeProjectsArray[i];
		geoLocDataManager = natProject.geoLocDataManager;
		
		gl.uniform3fv(currentShader.scale_loc, [1, 1, 1]); //.***
		buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		
		// test code.*********************************
		
		buildingGeoLocation.positionHIGH[0] = 0;
		buildingGeoLocation.positionHIGH[1] = 0;
		buildingGeoLocation.positionHIGH[2] = 0;
		
		buildingGeoLocation.positionLOW[0] = 0;
		buildingGeoLocation.positionLOW[1] = 0;
		buildingGeoLocation.positionLOW[2] = 0;
		
		//---------------------------------------------
		
		gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
		gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
		var meshesCount = natProject.getMeshesCount();
		for (var j=0; j<meshesCount; j++)
		{
			mesh = natProject.getMesh(j);
			
			this.renderer.renderObject(gl, mesh, this, currentShader, ssao_idx);
		}
	}
	
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
	
};

/**
 * Draw building names on scene.
 */
MagoManager.prototype.drawBuildingNames = function(visibleObjControlerNodes) 
{
	var canvas = document.getElementById("objectLabel");
	if (canvas === undefined)
	{ return; }
	
	canvas.style.opacity = 1.0;
	canvas.width = this.sceneState.drawingBufferWidth;
	canvas.height = this.sceneState.drawingBufferHeight;
	var ctx = canvas.getContext("2d");
	//ctx.strokeStyle = 'SlateGrey';
	//ctx.strokeStyle = 'MidnightBlue';
	ctx.strokeStyle = 'DarkSlateGray'; 
	//ctx.fillStyle= "white";
	ctx.fillStyle= "PapayaWhip";
	ctx.lineWidth = 4;
	ctx.font = "20px Arial";
	ctx.textAlign = 'center';
	//ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.save();
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	var lineHeight = ctx.measureText("M").width * 1.1;

	// lod2.
	var gl = this.sceneState.gl;
	var node;
	var nodeRoot;
	var geoLocDataManager;
	var geoLoc;
	var neoBuilding;
	var worldPosition;
	var screenCoord;
	
	// 1rst, collect rootNodes.
	var rootNodesMap = {};
	var currentVisiblesArray = visibleObjControlerNodes.currentVisibles2.concat(visibleObjControlerNodes.currentVisibles3);
	var nodesCount = currentVisiblesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = currentVisiblesArray[i];
		nodeRoot = node.getRoot();
		if (node.data === undefined || node.data.neoBuilding === undefined)
		{ continue; }
		
		var key = node.data.neoBuilding.buildingId;
		///rootNodesMap.set(nodeRoot, nodeRoot);
		rootNodesMap[key] = nodeRoot;
	}
	
	//var rootNodesArray = Object.values(rootNodesMap);
	//var rootNodesKeysArray = Object.keys(rootNodesMap);
	//var nodesCount = rootNodesKeysArray.length;
	//for (var i=0; i<nodesCount; i++)
	for (var key in rootNodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(rootNodesMap, key))
		{
			//nodeRoot = rootNodesArray[i];
			nodeRoot = rootNodesMap[key];
			geoLocDataManager = nodeRoot.data.geoLocDataManager;
			geoLoc = geoLocDataManager.getCurrentGeoLocationData();
			//neoBuilding = node.data.neoBuilding;
			worldPosition = nodeRoot.getBBoxCenterPositionWorldCoord(geoLoc);
			screenCoord = this.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord);
			//screenCoord.x += 250;
			//screenCoord.y += 150;
			
			if (screenCoord.x >= 0 && screenCoord.y >= 0)
			{
				ctx.font = "13px Arial";
				//ctx.strokeText(nodeRoot.data.nodeId, screenCoord.x, screenCoord.y);
				//ctx.fillText(nodeRoot.data.nodeId, screenCoord.x, screenCoord.y);
				ctx.strokeText(nodeRoot.data.data_name, screenCoord.x, screenCoord.y);
				ctx.fillText(nodeRoot.data.data_name, screenCoord.x, screenCoord.y);
			}
		}
	}
	
	rootNodesMap = {};

	ctx.restore();
};

/**
 * The camera was moved.
 */
MagoManager.prototype.cameraMoved = function() 
{
	this.sceneState.camera.setDirty(true);
	
	if (this.selectionFbo === undefined) 
	{ this.selectionFbo = new FBO(this.sceneState.gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }

	this.selectionFbo.dirty = true;
};

/**
 * @param {Object} node
 * @returns {Object}
 */
MagoManager.prototype.getNodeGeoLocDataManager = function(node) 
{
	if (node === undefined)
	{ return undefined; }
	
	// provisionally take the geoLocDatamanager from the rootNode.
	//var rootNode = node.getRoot();
	
	var closestRootNode = node.getClosestParentWithData("geoLocDataManager");
	
	if (closestRootNode === undefined)
	{ return undefined; }

	if (closestRootNode.data === undefined)
	{ return undefined; }
	
	var rootNodeGeoLocDataManager = closestRootNode.data.geoLocDataManager;
	return rootNodeGeoLocDataManager;
};

/**
 * Renders the current frustumVolumen with colorCoding for selection.
 * @param {GL} gl.
 * @param {VisibleObjectsControler} visibleObjControlerBuildings Contains the current visible objects clasified by LOD.
 * @returns {Array} resultSelectedArray 
 */
MagoManager.prototype.renderGeometryColorCoding = function(gl, visibleObjControlerNodes) 
{
	//if (this.selectionFbo.dirty) // todo.
	{
		// set byteColor codes for references objects.***
		var node;
		var rootNode;
		var neoBuilding;
		var currentVisibleOctreesControler;
		var currentVisibleLowestOctCount;
		var lowestOctree;
		
		var isInterior = false;
		var ssao_idx = -1;
		var minSize = 0.0;
		var refTMatrixIdxKey = 0;
		var glPrimitive = gl.TRIANGLES;

		// Set uniforms.***************
		var currentShader = this.postFxShadersManager.pFx_shaders_array[5]; // color selection shader.***
		

		var shaderProgram = currentShader.program;
		gl.useProgram(shaderProgram);
		gl.enableVertexAttribArray(currentShader.position3_loc);

		gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
		gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
		gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);
		
		// do the colorCoding render.***
		var idxKey;
		var nodesLOD0Count = visibleObjControlerNodes.currentVisibles0.length;
		for (var i=0; i<nodesLOD0Count; i++)
		{
			node = visibleObjControlerNodes.currentVisibles0[i];
			neoBuilding = node.data.neoBuilding;
			var buildingGeoLocation = this.getNodeGeoLocDataManager(node).getCurrentGeoLocationData();
			gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
			gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
			gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
			
			currentVisibleOctreesControler = neoBuilding.currentVisibleOctreesControler;
			if (currentVisibleOctreesControler === undefined)
			{ continue; }
			
			// LOD0.***
			currentVisibleLowestOctCount = currentVisibleOctreesControler.currentVisibles0.length;
			for (var j=0; j<currentVisibleLowestOctCount; j++)
			{
				lowestOctree = currentVisibleOctreesControler.currentVisibles0[j];
				minSize = 0.0;
				this.renderer.renderNeoRefListsAsimetricVersionColorSelection(gl, lowestOctree, node, this, isInterior, currentShader, minSize, refTMatrixIdxKey, glPrimitive);
			}
			
			// LOD1.***
			currentVisibleLowestOctCount = currentVisibleOctreesControler.currentVisibles1.length;
			for (var j=0; j<currentVisibleLowestOctCount; j++)
			{
				lowestOctree = currentVisibleOctreesControler.currentVisibles1[j];
				minSize = 0.0;
				this.renderer.renderNeoRefListsAsimetricVersionColorSelection(gl, lowestOctree, node, this, isInterior, currentShader, minSize, refTMatrixIdxKey, glPrimitive);
			}
			
			// LOD2.***
			if (this.colorAux === undefined)
			{ this.colorAux = new Color(); }
			
			gl.uniformMatrix4fv(currentShader.refMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
			currentVisibleLowestOctCount = currentVisibleOctreesControler.currentVisibles2.length;
			for (var j=0; j<currentVisibleLowestOctCount; j++)
			{
				lowestOctree = currentVisibleOctreesControler.currentVisibles2[j];

				if (lowestOctree.lego === undefined) 
				{ continue; }

				if (lowestOctree.lego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED) 
				{ continue; }
					
				this.colorAux = this.selectionColor.getAvailableColor(this.colorAux);
				idxKey = this.selectionColor.decodeColor3(this.colorAux.r, this.colorAux.g, this.colorAux.b);
				this.selectionCandidates.setCandidates(idxKey, undefined, lowestOctree, neoBuilding, node);
				
				gl.uniform1i(currentShader.hasTexture_loc, false); //.***
				gl.uniform4fv(currentShader.color4Aux_loc, [this.colorAux.r/255.0, this.colorAux.g/255.0, this.colorAux.b/255.0, 1.0]);

				gl.uniform1i(currentShader.hasAditionalMov_loc, false);
				gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***

				this.renderer.renderLodBuildingColorSelection(gl, lowestOctree.lego, this, currentShader);
			}
		}
		
		var nodesLOD2Count = visibleObjControlerNodes.currentVisibles2.length;
		for (var i=0; i<nodesLOD2Count; i++)
		{
			node = visibleObjControlerNodes.currentVisibles2[i];
			neoBuilding = node.data.neoBuilding;
			var buildingGeoLocation = this.getNodeGeoLocDataManager(node).getCurrentGeoLocationData();
			gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
			gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
			gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
			
			currentVisibleOctreesControler = neoBuilding.currentVisibleOctreesControler;
			if (currentVisibleOctreesControler)
			{

				// LOD2.***
				gl.uniformMatrix4fv(currentShader.refMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
				currentVisibleLowestOctCount = currentVisibleOctreesControler.currentVisibles2.length;
				for (var j=0; j<currentVisibleLowestOctCount; j++)
				{
					lowestOctree = currentVisibleOctreesControler.currentVisibles2[j];

					if (lowestOctree.lego === undefined) 
					{ continue; }

					if (lowestOctree.lego.fileLoadState === CODE.fileLoadState.READY) 
					{ continue; }

					if (lowestOctree.lego.fileLoadState === 2) 
					{ continue; }

					this.colorAux = this.selectionColor.getAvailableColor(this.colorAux);
					idxKey = this.selectionColor.decodeColor3(this.colorAux.r, this.colorAux.g, this.colorAux.b);
					this.selectionCandidates.setCandidates(idxKey, undefined, lowestOctree, neoBuilding, node);
				
					gl.uniform1i(currentShader.hasTexture_loc, false); //.***
					gl.uniform4fv(currentShader.color4Aux_loc, [this.colorAux.r/255.0, this.colorAux.g/255.0, this.colorAux.b/255.0, 1.0]);

					gl.uniform1i(currentShader.hasAditionalMov_loc, false);
					gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***

					this.renderer.renderLodBuildingColorSelection(gl, lowestOctree.lego, this, currentShader);
				}
			}
		}
		
		// now, lod3, lod4 & lod5.***
		var nodesLODXCount = visibleObjControlerNodes.currentVisibles3.length;
		gl.uniform1i(currentShader.refMatrixType_loc, 0); // 0 = identity matrix.***
		for (var i=0; i<nodesLODXCount; i++)
		{
			node = visibleObjControlerNodes.currentVisibles3[i];
			neoBuilding = node.data.neoBuilding;
			
			var buildingGeoLocation = this.getNodeGeoLocDataManager(node).getCurrentGeoLocationData();
			gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
			gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
			gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
			var currentLod = neoBuilding.currentLod;
			
			gl.uniformMatrix4fv(currentShader.refMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
			var skinLod = neoBuilding.getCurrentSkin();
			if (skinLod === undefined)
			{ continue; }
		
			if (skinLod.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED) 
			{ continue; }
				
			this.colorAux = this.selectionColor.getAvailableColor(this.colorAux);
			idxKey = this.selectionColor.decodeColor3(this.colorAux.r, this.colorAux.g, this.colorAux.b);
			this.selectionCandidates.setCandidates(idxKey, undefined, undefined, neoBuilding, node);
			
			gl.uniform1i(currentShader.hasTexture_loc, false); //.***
			gl.uniform4fv(currentShader.color4Aux_loc, [this.colorAux.r/255.0, this.colorAux.g/255.0, this.colorAux.b/255.0, 1.0]);

			gl.uniform1i(currentShader.hasAditionalMov_loc, false);
			gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***

			this.renderer.renderLodBuildingColorSelection(gl, skinLod, this, currentShader);
		}

		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		gl.disableVertexAttribArray(currentShader.position3_loc);
	}
};

/**
 * Selects an object of the current visible objects that's under mouse.
 * @param {GL} gl.
 * @param {int} mouseX Screen x position of the mouse.
 * @param {int} mouseY Screen y position of the mouse.
 * @param {VisibleObjectsControler} visibleObjControlerBuildings Contains the current visible objects clasified by LOD.
 * @returns {Array} resultSelectedArray 
 */
MagoManager.prototype.getSelectedObjects = function(gl, mouseX, mouseY, resultSelectedArray) 
{
	// Read the picked pixel and find the object.*********************************************************
	var pixels = new Uint8Array(4 * 1 * 1); // 4 x 1x1 pixel.***
	gl.readPixels(mouseX, this.sceneState.drawingBufferHeight - mouseY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null); // unbind framebuffer.***

	// now, select the object.***
	var idx = 64516*pixels[0] + 254*pixels[1] + pixels[2];
	this.selectionCandidates.selectObjects(idx);
	
	var selectedObject = this.selectionCandidates.currentReferenceSelected;

	resultSelectedArray[0] = this.selectionCandidates.currentBuildingSelected;
	resultSelectedArray[1] = this.selectionCandidates.currentOctreeSelected;
	resultSelectedArray[2] = this.selectionCandidates.currentReferenceSelected;
	resultSelectedArray[3] = this.selectionCandidates.currentNodeSelected;
	
	return selectedObject;
};


/**
 * Calculates the direction vector of a ray that starts in the camera position and
 * continues to the pixel position in world space.
 * @param {GL} gl 변수
 * @param {int} pixelX Screen x position of the pixel.
 * @param {int} pixelY Screen y position of the pixel.
 * @returns {Line} resultRay
 */
MagoManager.prototype.getRayWorldSpace = function(gl, pixelX, pixelY, resultRay) 
{
	// in this function the "ray" is a line.***
	if (resultRay === undefined) 
	{ resultRay = new Line(); }
	
	// world ray = camPos + lambda*camDir.
	var camPos = this.sceneState.camera.position;
	var rayCamSpace = new Float32Array(3);
	rayCamSpace = this.getRayCamSpace(pixelX, pixelY, rayCamSpace);
	
	if (this.pointSC === undefined)
	{ this.pointSC = new Point3D(); }
	
	this.pointSC.set(rayCamSpace[0], rayCamSpace[1], rayCamSpace[2]);

	// now, must transform this posCamCoord to world coord.***
	this.pointSC2 = this.sceneState.modelViewMatrixInv.rotatePoint3D(this.pointSC, this.pointSC2); // rayWorldSpace.***
	this.pointSC2.unitary(); // rayWorldSpace.***
	resultRay.setPointAndDir(camPos.x, camPos.y, camPos.z,       this.pointSC2.x, this.pointSC2.y, this.pointSC2.z);// original.***

	return resultRay;
};

/**
 * Calculates the direction vector of a ray that starts in the camera position and
 * continues to the pixel position in camera space.
 * @param {GL} gl 변수
 * @param {int} pixelX Screen x position of the pixel.
 * @param {int} pixelY Screen y position of the pixel.
 * @returns {Float32Array(3)} resultRay Result of the calculation.
 */
MagoManager.prototype.getRayCamSpace = function(pixelX, pixelY, resultRay) 
{
	// in this function "ray" is a vector.***
	var frustum_far = 1.0; // unitary frustum far.***
	var fov = this.sceneState.camera.frustum.fovyRad;
	var aspectRatio = this.sceneState.camera.frustum.aspectRatio;

	var hfar = 2.0 * Math.tan(fov/2.0) * frustum_far;
	var wfar = hfar * aspectRatio;
	var mouseX = pixelX;
	var mouseY = this.sceneState.drawingBufferHeight - pixelY;
	if (resultRay === undefined) 
	{ resultRay = new Float32Array(3); }
	resultRay[0] = wfar*((mouseX/this.sceneState.drawingBufferWidth) - 0.5);
	resultRay[1] = hfar*((mouseY/this.sceneState.drawingBufferHeight) - 0.5);
	resultRay[2] = - frustum_far;
	return resultRay;
};

/**
 * Calculates the plane on move an object.
 * @param {GL} gl 변수
 * @param {int} pixelX Screen x position of the pixel.
 * @param {int} pixelY Screen y position of the pixel.
 * @return {Plane} resultSelObjMovePlane Calculated plane.
 */
MagoManager.prototype.calculateSelObjMovePlaneAsimetricMode = function(gl, pixelX, pixelY, resultSelObjMovePlane) 
{
	if (this.pointSC === undefined)
	{ this.pointSC = new Point3D(); }
	
	if (this.pointSC2 === undefined)
	{ this.pointSC2 = new Point3D(); }
	
	var geoLocDataManager = this.getNodeGeoLocDataManager(this.nodeSelected);
	
	this.calculatePixelPositionWorldCoord(gl, pixelX, pixelY, this.pointSC2);
	var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
	this.pointSC = buildingGeoLocation.tMatrixInv.transformPoint3D(this.pointSC2, this.pointSC); // buildingSpacePoint.***

	if (resultSelObjMovePlane === undefined)
	{ resultSelObjMovePlane = new Plane(); }
	// the plane is in world coord.***
	resultSelObjMovePlane.setPointAndNormal(this.pointSC.x, this.pointSC.y, this.pointSC.z, 0.0, 0.0, 1.0);
	return resultSelObjMovePlane;
};

/**
 * Calculates the pixel position in camera coordinates.
 * @param {GL} gl 변수
 * @param {int} pixelX Screen x position of the pixel.
 * @param {int} pixelY Screen y position of the pixel.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @return {Point3D} resultPixelPos The result of the calculation.
 */
MagoManager.prototype.calculatePixelPositionCamCoord = function(gl, pixelX, pixelY, resultPixelPos) 
{
	// depth render.
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.depthRange(0, 1);
	gl.frontFace(gl.CCW);

	var current_frustum_far = this.sceneState.camera.frustum.far;
	//var frustum = this.myCameraSCX.getFrustum(0);
	//var current_frustum_far = frustum.far;
	
	if (this.depthFboNeo) 
	{
		this.depthFboNeo.bind(); // bind the existent last depthFramebuffer.
	}
	else 
	{
		// never enter here.
		if (this.depthFboNeo === undefined) 
		{ this.depthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
		this.depthFboNeo.bind(); 

		gl.clearColor(1, 1, 1, 1); // white background.***
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // clear buffer.***
		gl.disable(gl.BLEND);
		var ssao_idx = 0;
		this.depthRenderLowestOctreeAsimetricVersion(gl, ssao_idx, this.visibleObjControlerNodes);
	}

	// Now, read the pixel and find the pixel position.
	var depthPixels = new Uint8Array(4 * 1 * 1); // 4 x 1x1 pixel.***
	gl.readPixels(pixelX, this.sceneState.drawingBufferHeight - pixelY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, depthPixels);
	var zDepth = depthPixels[0]/(256.0*256.0*256.0) + depthPixels[1]/(256.0*256.0) + depthPixels[2]/256.0 + depthPixels[3]; // 0 to 256 range depth.***
	zDepth /= 256.0; // convert to 0 to 1.0 range depth.***
	var realZDepth = zDepth*current_frustum_far;

	// now, find the 3d position of the pixel in camCoord.****
	this.resultRaySC = this.getRayCamSpace(pixelX, pixelY, this.resultRaySC);
	if (resultPixelPos === undefined)
	{ resultPixelPos = new Point3D(); }

	this.depthFboNeo.unbind();
	
	resultPixelPos.set(this.resultRaySC[0] * realZDepth, this.resultRaySC[1] * realZDepth, this.resultRaySC[2] * realZDepth);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	return resultPixelPos;
};

/**
 * Calculates the pixel position in world coordinates.
 * @param {GL} gl 변수
 * @param {int} pixelX Screen x position of the pixel.
 * @param {int} pixelY Screen y position of the pixel.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @return {Point3D} resultPixelPos The result of the calculation.
 */
MagoManager.prototype.calculatePixelPositionWorldCoord = function(gl, pixelX, pixelY, resultPixelPos) 
{
	var pixelPosCamCoord = new Point3D();
	pixelPosCamCoord = this.calculatePixelPositionCamCoord(gl, pixelX, pixelY, pixelPosCamCoord);

	if (resultPixelPos === undefined)
	{ var resultPixelPos = new Point3D(); }

	resultPixelPos = this.cameraCoordPositionToWorldCoord(pixelPosCamCoord, resultPixelPos);
	return resultPixelPos;
};

/**
 * Calculates the cameraCoord position in world coordinates.
 * @param {Point3D} cameraCoord position.
 * @return {Point3D} resultPixelPos The result of the calculation.
 */
MagoManager.prototype.cameraCoordPositionToWorldCoord = function(camCoordPos, resultWorldPos) 
{
	// now, must transform this pixelCamCoord to world coord.***
	var mv_inv = this.sceneState.modelViewMatrixInv;
	if (resultWorldPos === undefined)
	{ var resultWorldPos = new Point3D(); }
	resultWorldPos = mv_inv.transformPoint3D(camCoordPos, resultWorldPos);
	return resultWorldPos;
};

/**
 * Calculates the pixel position in world coordinates.
 * @param {GL} gl 변수
 * @param {int} pixelX Screen x position of the pixel.
 * @param {int} pixelY Screen y position of the pixel.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @return {Point3D} resultPixelPos The result of the calculation.
 */
MagoManager.prototype.calculateWorldPositionToScreenCoord = function(gl, worldCoordX, worldCoordY, worldCoordZ, resultScreenCoord)
{
	if (resultScreenCoord === undefined)
	{ resultScreenCoord = new Point3D(); }
	
	if (this.pointSC === undefined)
	{ this.pointSC = new Point3D(); }
	
	if (this.pointSC2 === undefined)
	{ this.pointSC2 = new Point3D(); }
	
	this.pointSC.set(worldCoordX, worldCoordY, worldCoordZ);
	
	// calculate the position in camera coords.
	this.pointSC2 = this.sceneState.modelViewMatrix.transformPoint3D(this.pointSC, this.pointSC2);
	
	// now calculate the position in screen coords.
	var zDist = this.pointSC2.z;
	if (zDist > 0)
	{
		// the worldPoint is rear the camera.
		resultScreenCoord.set(-1, -1, 0);
		return resultScreenCoord;
	}
	
	// now calculate the width and height of the plane in zDist.
	//var fovyRad = this.sceneState.camera.frustum.fovyRad;
	
	var planeHeight = this.sceneState.camera.frustum.tangentOfHalfFovy*zDist*2;
	var planeWidth = planeHeight * this.sceneState.camera.frustum.aspectRatio; // aspectRatio(w/h).
	
	var pixelX = -this.pointSC2.x * this.sceneState.drawingBufferWidth / planeWidth;
	var pixelY = -(this.pointSC2.y) * this.sceneState.drawingBufferHeight / planeHeight;

	pixelX += this.sceneState.drawingBufferWidth / 2;
	pixelY += this.sceneState.drawingBufferHeight / 2;
	
	pixelY = this.sceneState.drawingBufferHeight - pixelY;
	
	resultScreenCoord.set(pixelX, pixelY, 0);
	
	return resultScreenCoord;
};

/**
 * 드래그 여부 판단
 * 
 * @returns {Boolean} 드래그 여부
 */
MagoManager.prototype.isDragging = function() 
{
	// test function.***
	var gl = this.sceneState.gl;

	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL)	// Moving all
	{
		this.arrayAuxSC.length = 0;
		this.selectionFbo.bind();
		var current_objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
		var currentBuildingSelected = this.arrayAuxSC[0];
		var currentNodeSelected = this.arrayAuxSC[3];
		var currentRootNodeSelected;
		if (currentNodeSelected)
		{
			currentRootNodeSelected = currentNodeSelected.getRoot();
		}
		this.arrayAuxSC.length = 0;

		if (currentRootNodeSelected === this.rootNodeSelected) 
		{
			return true;
		}
		else 
		{
			return false;
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // Moving object
	{
		this.arrayAuxSC.length = 0;
		this.selectionFbo.bind();
		var current_objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
		this.arrayAuxSC.length = 0;

		if (current_objectSelected === this.objectSelected) 
		{
			return true;
		}
		else 
		{
			return false;
		}
	}
	else
	{
		return false;
	}

};

/**
 * 카메라 motion 활성 또는 비활성
 * 
 * @param {Boolean} state 카메라 모션 활성화 여부
 */
MagoManager.prototype.setCameraMotion = function(state)
{
	if (this.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		this.wwd.navigator.panRecognizer.enabled = state;
		this.wwd.navigator.primaryDragRecognizer.enabled = state;
	}
	else if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		this.scene.screenSpaceCameraController.enableRotate = state;
		this.scene.screenSpaceCameraController.enableZoom = state;
		this.scene.screenSpaceCameraController.enableLook = state;
		this.scene.screenSpaceCameraController.enableTilt = state;
		this.scene.screenSpaceCameraController.enableTranslate = state;
	}
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftDown = function(mouseX, mouseY) 
{
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseLeftDown = true;
	//this.isCameraMoving = true;
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.saveHistoryObjectMovement = function(refObject, node) 
{
	var changeHistory = new ChangeHistory();
	var refMove = changeHistory.getReferenceObjectAditionalMovement();
	var refMoveRelToBuilding = changeHistory.getReferenceObjectAditionalMovementRelToBuilding();
	
	if (refObject.moveVector === undefined)
	{ refObject.moveVector = new Point3D(); }
	
	if (refObject.moveVectorRelToBuilding === undefined)
	{ refObject.moveVectorRelToBuilding = new Point3D(); }
	
	refMove.set(refObject.moveVector.x, refObject.moveVector.y, refObject.moveVector.z);
	refMoveRelToBuilding.set(refObject.moveVectorRelToBuilding.x, refObject.moveVectorRelToBuilding.y, refObject.moveVectorRelToBuilding.z);
	if (node === undefined)
	{ return; }

	var projectId = node.data.projectId;
	var dataKey = node.data.nodeId;
	var objectIndex = refObject._id;
	
	changeHistory.setProjectId(projectId);
	changeHistory.setDataKey(dataKey);
	changeHistory.setObjectIndexOrder(objectIndex);
	MagoConfig.saveMovingHistory(projectId, dataKey, objectIndex, changeHistory);
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftUp = function(mouseX, mouseY) 
{
	if (this.objectMoved)
	{
		this.objectMoved = false;
		var nodeSelected = this.selectionCandidates.currentNodeSelected;
		if (nodeSelected === undefined)
		{ return; }
		
		this.saveHistoryObjectMovement(this.objectSelected, nodeSelected);
	}
	
	this.isCameraMoving = false;
	this.mouseLeftDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane = undefined;
	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;

	this.dateSC = new Date();
	this.currentTimeSC = this.dateSC.getTime();
	var miliSecondsUsed = this.currentTimeSC - this.startTimeSC;
	if (miliSecondsUsed < 1500) 
	{
		if (this.mouse_x === mouseX && this.mouse_y === mouseY) 
		{
			this.bPicking = true;
		}
	}
	
	this.setCameraMotion(true);
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionMiddleDown = function(mouseX, mouseY) 
{
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseMiddleDown = true;
	this.isCameraMoving = true;
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionMiddleUp = function(mouseX, mouseY) 
{
	this.isCameraMoving = false;
	this.mouseMiddleDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane = undefined;
	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;
	this.setCameraMotion(false);
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionRightDown = function(mouseX, mouseY) 
{
	/*
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseRightDown = true;
	this.isCameraMoving = true;
	*/
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionRightUp = function(mouseX, mouseY) 
{
	/*
	this.isCameraMoving = false;
	this.setCameraMotion(false);
	*/
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionMove = function(mouseX, mouseY) 
{
	if (this.mouseLeftDown) 
	{
		this.manageMouseDragging(mouseX, mouseY);
	}
	else if (this.mouseMiddleDown) 
	{
		this.sceneState.camera.setDirty(true);
	}
	else if (this.mouseRightDown) 
	{
		this.sceneState.camera.setDirty(true);
	}
	else
	{
		this.mouseDragging = false;
		this.setCameraMotion(false);
		if (this.mouseMiddleDown)
		{
			this.isCameraMoving = true;
		}
	}
};


/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 * @param renderables_neoRefLists_array 변수
 */
MagoManager.prototype.manageMouseDragging = function(mouseX, mouseY) 
{
	this.sceneState.camera.setDirty(true);
	
	// distinguish 2 modes.******************************************************
	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL) // blocks move.***
	{
		if (this.buildingSelected !== undefined) 
		{
			// move the selected object.***
			this.mouse_x = mouseX;
			this.mouse_y = mouseY;

			// 1rst, check if there are objects to move.***
			if (this.mustCheckIfDragging) 
			{
				if (this.isDragging()) 
				{
					this.mouseDragging = true;
					this.setCameraMotion(false);
				}
				this.mustCheckIfDragging = false;
			}
			// Display geoLocationData while moving building.***
			var nodeOwner = this.buildingSelected.nodeOwner;
			if (nodeOwner === undefined)
			{ return; }

			var geoLocDataManager = nodeOwner.data.geoLocDataManager;
			if (geoLocDataManager === undefined)
			{ return; }

			var geoLocation = geoLocDataManager.getGeoLocationData(0);
			if (geoLocation === undefined)
			{ return; }

			var geographicCoords = geoLocation.geographicCoord;
			if (geographicCoords === undefined)
			{ return; }
			
			movedDataCallback(	MagoConfig.getPolicy().geo_callback_moveddata,
				nodeOwner.data.projectId,
                				nodeOwner.data.nodeId,
				null,
				geographicCoords.latitude,
				geographicCoords.longitude,
				geographicCoords.altitude,
				geoLocation.heading,
				geoLocation.pitch,
				geoLocation.roll);
								
		}
		else 
		{
			this.isCameraMoving = true; // if no object is selected.***
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // objects move.***
	{
		if (this.objectSelected !== undefined) 
		{
			// move the selected object.***
			this.mouse_x = mouseX;
			this.mouse_y = mouseY;

			// 1rst, check if there are objects to move.***
			if (this.mustCheckIfDragging) 
			{
				if (this.isDragging()) 
				{
					this.mouseDragging = true;
					this.setCameraMotion(false);
				}
				this.mustCheckIfDragging = false;
			}
		}
		else 
		{
			this.isCameraMoving = true; // if no object is selected.***
		}
	}
	//---------------------------------------------------------------------------------
	this.isCameraMoving = true; // test.***
	if (this.mouseDragging) 
	{
		this.moveSelectedObjectAsimetricMode(this.sceneState.gl);
	}
};


/**
 * Moves an object.
 * @param {GL} gl 변수
 */
MagoManager.prototype.moveSelectedObjectAsimetricMode = function(gl) 
{
	//var cameraPosition = this.sceneState.camera.position;
	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL) // buildings move.***
	{
		if (this.selectionCandidates.currentNodeSelected === undefined)
		{ return; }
		
		var geoLocDataManager = this.getNodeGeoLocDataManager(this.selectionCandidates.currentNodeSelected);
		var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
	
		// create a XY_plane in the selected_pixel_position.***
		if (this.selObjMovePlane === undefined) 
		{
			this.selObjMovePlane = new Plane();
			// create a local XY plane.
			// find the pixel position relative to building.
			var pixelPosWorldCoord = new Point3D();
			pixelPosWorldCoord = this.calculatePixelPositionWorldCoord(gl, this.mouse_x, this.mouse_y, pixelPosWorldCoord);
			var pixelPosBuildingCoord = geoLocationData.tMatrixInv.transformPoint3D(pixelPosWorldCoord, pixelPosBuildingCoord);
			
			this.selObjMovePlane.setPointAndNormal(pixelPosBuildingCoord.x, pixelPosBuildingCoord.y, pixelPosBuildingCoord.z,    0.0, 0.0, 1.0); 
		}

		if (this.lineSC === undefined)
		{ this.lineSC = new Line(); }
		
		this.lineSC = this.getRayWorldSpace(gl, this.mouse_x, this.mouse_y, this.lineSC); // rayWorldSpace.***

		// transform world_ray to building_ray.***
		var camPosBuilding = new Point3D();
		var camDirBuilding = new Point3D();

		camPosBuilding = geoLocationData.geoLocMatrixInv.transformPoint3D(this.lineSC.point, camPosBuilding);
		this.pointSC = geoLocationData.geoLocMatrixInv.rotatePoint3D(this.lineSC.direction, this.pointSC);
		camDirBuilding.x = this.pointSC.x;
		camDirBuilding.y = this.pointSC.y;
		camDirBuilding.z = this.pointSC.z;

		// now, intersect building_ray with the selObjMovePlane.***
		var line = new Line();
		line.setPointAndDir(camPosBuilding.x, camPosBuilding.y, camPosBuilding.z,       camDirBuilding.x, camDirBuilding.y, camDirBuilding.z);

		var intersectionPoint = new Point3D();
		intersectionPoint = this.selObjMovePlane.intersectionLine(line, intersectionPoint);
		intersectionPoint.set(-intersectionPoint.x, -intersectionPoint.y, -intersectionPoint.z);
		
		if (this.pointSC === undefined)
		{ this.pointSC = new Point3D(); }
		this.pointSC = geoLocationData.geoLocMatrix.transformPoint3D(intersectionPoint, this.pointSC);
		intersectionPoint.set(this.pointSC.x, this.pointSC.y, this.pointSC.z);

		// register the movement.***
		if (!this.thereAreStartMovePoint) 
		{
			var cartographic = ManagerUtils.pointToGeographicCoord(intersectionPoint, cartographic, this);
			this.startMovPoint.x = cartographic.longitude;
			this.startMovPoint.y = cartographic.latitude;
			this.thereAreStartMovePoint = true;
		}
		else 
		{
			var cartographic = ManagerUtils.pointToGeographicCoord(intersectionPoint, cartographic, this);
			this.pointSC.x = cartographic.longitude;
			this.pointSC.y = cartographic.latitude;
			var difX = this.pointSC.x - this.startMovPoint.x;
			var difY = this.pointSC.y - this.startMovPoint.y;

			var newLongitude = geoLocationData.geographicCoord.longitude - difX;
			var newlatitude = geoLocationData.geographicCoord.latitude - difY;
			//var newHeight = cartographic.altitude;

			this.changeLocationAndRotationNode(this.selectionCandidates.currentNodeSelected, newlatitude, newLongitude, undefined, undefined, undefined, undefined);
			this.displayLocationAndRotation(this.buildingSelected);
			
			this.startMovPoint.x -= difX;
			this.startMovPoint.y -= difY;
		}
		
		//this.buildingSelected.calculateBBoxCenterPositionWorldCoord(geoLocationData);
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // objects move.***
	{
		if (this.objectSelected === undefined)
		{ return; }

		// create a XY_plane in the selected_pixel_position.***
		if (this.selObjMovePlane === undefined) 
		{
			this.selObjMovePlane = this.calculateSelObjMovePlaneAsimetricMode(gl, this.mouse_x, this.mouse_y, this.selObjMovePlane);
		}
		
		var geoLocDataManager = this.getNodeGeoLocDataManager(this.selectionCandidates.currentNodeSelected);

		// world ray = camPos + lambda*camDir.***
		if (this.lineSC === undefined)
		{ this.lineSC = new Line(); }
		
		this.getRayWorldSpace(gl, this.mouse_x, this.mouse_y, this.lineSC); // rayWorldSpace.***
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		var camPosBuilding = new Point3D();
		var camDirBuilding = new Point3D();
		camPosBuilding = buildingGeoLocation.tMatrixInv.transformPoint3D(this.lineSC.point, camPosBuilding);
		camDirBuilding = buildingGeoLocation.tMatrixInv.rotatePoint3D(this.lineSC.direction, camDirBuilding);
	
		// now, intersect building_ray with the selObjMovePlane.***
		var line = new Line();
		line.setPointAndDir(camPosBuilding.x, camPosBuilding.y, camPosBuilding.z,       camDirBuilding.x, camDirBuilding.y, camDirBuilding.z);// original.***

		var intersectionPoint = new Point3D();
		intersectionPoint = this.selObjMovePlane.intersectionLine(line, intersectionPoint);

		//the movement of an object must multiply by buildingRotMatrix.***
		if (this.objectSelected.moveVectorRelToBuilding === undefined)
		{ this.objectSelected.moveVectorRelToBuilding = new Point3D(); }
	
		// move vector rel to building.
		if (!this.thereAreStartMovePoint) 
		{
			this.startMovPoint = intersectionPoint;
			this.startMovPoint.add(-this.objectSelected.moveVectorRelToBuilding.x, -this.objectSelected.moveVectorRelToBuilding.y, -this.objectSelected.moveVectorRelToBuilding.z);
			this.thereAreStartMovePoint = true;
		}
		else 
		{
			var difX = intersectionPoint.x - this.startMovPoint.x;
			var difY = intersectionPoint.y - this.startMovPoint.y;
			var difZ = intersectionPoint.z - this.startMovPoint.z;

			this.objectSelected.moveVectorRelToBuilding.set(difX, difY, difZ);
			this.objectSelected.moveVector = buildingGeoLocation.tMatrix.rotatePoint3D(this.objectSelected.moveVectorRelToBuilding, this.objectSelected.moveVector); 
		}
		
		var projectId = this.selectionCandidates.currentNodeSelected.data.projectId;
		var data_key = this.selectionCandidates.currentNodeSelected.data.nodeId;
		var objectIndexOrder = this.objectSelected._id;
		
		MagoConfig.deleteMovingHistoryObject(projectId, data_key, objectIndexOrder);
		this.objectMoved = true; // this provoques that on leftMouseUp -> saveHistoryObjectMovement
		
	}
};


/**
 * Frustum 안의 VisibleOctree 를 검색하여 currentVisibleOctreesControler 를 준비
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 * @param {VisibleObjectsController} visibleObjControlerOctrees 
 * @param {any} lod 
 */
MagoManager.prototype.getRenderablesDetailedNeoBuildingAsimetricVersion = function(gl, node, visibleObjControlerOctrees, lod) 
{
	var neoBuilding = node.data.neoBuilding;
	
	// chaek if the neoBuilding has availableLod_0.***
	if (neoBuilding === undefined || neoBuilding.octree === undefined) { return; }

	var rootGeoLocDataManager = this.getNodeGeoLocDataManager(node);
	var rootGeoLoc = rootGeoLocDataManager.getCurrentGeoLocationData();
	
	//var nodeGeoLocation = geoLocDataManager.getCurrentGeoLocationData(); // original.***
	var nodeGeoLocation = rootGeoLocDataManager.getCurrentGeoLocationData();
	if (nodeGeoLocation === undefined)
	{ return false; }

	if (neoBuilding.currentVisibleOctreesControler === undefined)
	{ neoBuilding.currentVisibleOctreesControler = new VisibleObjectsController(); }	

	var distLod0 = this.magoPolicy.getLod0DistInMeters();
	var distLod1 = this.magoPolicy.getLod1DistInMeters();
	var distLod2 = this.magoPolicy.getLod2DistInMeters();
	var distLod3 = this.magoPolicy.getLod3DistInMeters();
	var distLod4 = this.magoPolicy.getLod4DistInMeters();
	var distLod5 = this.magoPolicy.getLod5DistInMeters();

	var find = false;
	if (this.myCameraRelative === undefined)
	{ this.myCameraRelative = new Camera(); }
	
	this.myCameraRelative.frustum.copyParametersFrom(this.myCameraSCX.bigFrustum);
	this.myCameraRelative = nodeGeoLocation.getTransformedRelativeCamera(this.sceneState.camera, this.myCameraRelative);
	//var isCameraInsideOfBuilding = neoBuilding.isCameraInsideOfBuilding(this.myCameraRelative.position.x, this.myCameraRelative.position.y, this.myCameraRelative.position.z); // old.***
	
	neoBuilding.currentVisibleOctreesControler.clear();
	
	if (lod === 2)
	{
		// in this case is not necessary calculate the frustum planes.
		neoBuilding.octree.extractLowestOctreesByLOD(neoBuilding.currentVisibleOctreesControler, visibleObjControlerOctrees, this.boundingSphere_Aux,
			this.myCameraRelative.position, distLod0, distLod1, distLod5);
		find = true;
	}
	else 
	{
		// must calculate the frustum planes.
		this.myCameraRelative.calculateFrustumsPlanes();
		
		// 1rst, check if there are octrees very close.
		var frustum0 = this.myCameraRelative.bigFrustum;
		find = neoBuilding.octree.getFrustumVisibleLowestOctreesByLOD(	frustum0, neoBuilding.currentVisibleOctreesControler, visibleObjControlerOctrees, this.boundingSphere_Aux,
			this.myCameraRelative.position, distLod0, distLod1, distLod2*100);
	}

	if (!find) 
	{
		// if the building is far to camera, then delete it.
		if (neoBuilding.distToCam > 10) // default: 60.***
		{ this.processQueue.putNodeToDeleteModelReferences(node, 1); }
		return false;
	}
	else 
	{
		this.processQueue.eraseNodeToDeleteModelReferences(node);
	}
	
	// LOD0 & LOD1
	// Check if the lod0lowestOctrees, lod1lowestOctrees must load and parse data
	var lowestOctree;
	var currentVisibleOctrees = [].concat(neoBuilding.currentVisibleOctreesControler.currentVisibles0, neoBuilding.currentVisibleOctreesControler.currentVisibles1);
	var applyOcclusionCulling = neoBuilding.getRenderSettingApplyOcclusionCulling();
	
	// if there are no lod0 & lod1 then put the neobuilding to delete model-references data.
	if (currentVisibleOctrees.length === 0)
	{
		this.processQueue.putNodeToDeleteModelReferences(node, 0);
	}
	else 
	{
		this.processQueue.eraseNodeToDeleteModelReferences(node);
	}
	
	var putLowestOctreeToLod2 = false;
	for (var i=0, length = currentVisibleOctrees.length; i<length; i++) 
	{
		putLowestOctreeToLod2 = false;
		lowestOctree = currentVisibleOctrees[i];
		if (lowestOctree.triPolyhedronsCount === 0) 
		{ continue; }

		if (lowestOctree.neoReferencesMotherAndIndices === undefined)
		{
			lowestOctree.neoReferencesMotherAndIndices = new NeoReferencesMotherAndIndices();
			lowestOctree.neoReferencesMotherAndIndices.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
			// if the octree has no neoReferencesMotherAndIndices ready, then render the lego.
			putLowestOctreeToLod2 = true;
		}
		else
		{
			lowestOctree.neoReferencesMotherAndIndices.updateCurrentVisibleIndices(this.myCameraRelative.position.x, this.myCameraRelative.position.y, this.myCameraRelative.position.z, applyOcclusionCulling);
		}
		
		// if the octree has no blocks list ready, then render the lego.
		var myBlocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
		if (myBlocksList === undefined || myBlocksList.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
		{
			// if the octree has no blocks list ready, then render the lego.
			putLowestOctreeToLod2 = true;
		}
		
		if (putLowestOctreeToLod2)
		{
			neoBuilding.currentVisibleOctreesControler.currentVisibles2.push(lowestOctree);
		}
	}
	currentVisibleOctrees.length = 0;
	
	// check if all lod2-octrees is ready to render. 
	// If lod2-octrees is no ready to render, then render lod3.***
	var allLod2OctreesIsReady = true;
	var octree;
	var visibleOctreesCount = neoBuilding.currentVisibleOctreesControler.currentVisibles2.length;
	if (visibleOctreesCount > 6)
	{ visibleOctreesCount = 6; }
	for (var j=0; j<visibleOctreesCount; j++)
	{
		octree = neoBuilding.currentVisibleOctreesControler.currentVisibles2[j];
		if (octree.lego === undefined || octree.lego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
		{
			allLod2OctreesIsReady = false;
			break;
		}
	}
	
	if (!allLod2OctreesIsReady)
	{
		// must render lod3.***
		neoBuilding.currentLod = 3;
		this.visibleObjControlerNodes.putNodeToArraySortedByDist(this.visibleObjControlerNodes.currentVisibles3, node);
	}
				
	return true;
};


/**
 * LOD0, LOD1 에 대한 F4D ModelData, ReferenceData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.manageQueue = function() 
{
	// first, delete buildings.
	var gl = this.sceneState.gl;
	var maxDeleteNodesCount = 8;
	var nodesToDeleteCount = Object.keys(this.processQueue.nodesToDeleteMap).length;
	if (nodesToDeleteCount < maxDeleteNodesCount)
	{ maxDeleteNodesCount = nodesToDeleteCount; }
	
	var neoBuilding;
	var node;
	var rootNode;
	
	// incompatibility gulp.
	//for (var key of this.processQueue.buildingsToDeleteMap.keys())
	//{
	//	this.deleteNeoBuilding(gl, key);
	//	this.processQueue.buildingsToDeleteMap.delete(key);
	//	deletedCount += 1;
	//	if (deletedCount > maxDeleteBuildingsCount)
	//	{ break; }
	//}
	
	//if(this.isFarestFrustum())
	{
		for (var key in this.processQueue.nodesToDeleteMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.processQueue.nodesToDeleteMap, key))
			{
				//node = nodesToDeleteArray[i];
				node = this.processQueue.nodesToDeleteMap[key];
				
				if (node === undefined)
				{ continue; }

				neoBuilding = node.data.neoBuilding;
				this.processQueue.eraseNodeToDelete(node);
				
				if (neoBuilding === undefined)
				{ continue; }
			
				var deleteMetaData = true;
				if (key == 1)
				{ deleteMetaData = false; }
				this.deleteNeoBuilding(gl, neoBuilding, deleteMetaData);
			}
		}
		
		// now delete modelReferences of lod2Octrees.
		var modelRefsDeletedCount = 0;
		for (var key in this.processQueue.nodesToDeleteModelReferencesMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.processQueue.nodesToDeleteModelReferencesMap, key))
			{
				//node = nodesToDeleteModelReferencesArray[i];
				node = this.processQueue.nodesToDeleteModelReferencesMap[key];
				
				if (node.data === undefined)
				{ continue; }
			
				neoBuilding = node.data.neoBuilding;
				this.processQueue.eraseNodeToDeleteModelReferences(neoBuilding);
				if (neoBuilding === undefined)
				{ continue; }

				if (neoBuilding.octree)
				{
					neoBuilding.octree.deleteObjectsModelReferences(gl, this.vboMemoryManager);
				}
				if (neoBuilding.motherBlocksArray.length > 0 || neoBuilding.motherNeoReferencesArray.length > 0)
				{
					modelRefsDeletedCount ++;
				}
				neoBuilding.deleteObjectsModelReferences(gl, this.vboMemoryManager);
				
				if (modelRefsDeletedCount > 10)
				{ break; }
			}
		}
	}
	
	var deletedCount = 0;
	for (var key in this.processQueue.nodesToDeleteLessThanLod3Map)
	{
		node = this.processQueue.nodesToDeleteLessThanLod3Map[key];
		//node = nodesToDeleteLod2Lod4Lod5Array[i];
		if (node.data === undefined)
		{ continue; }
	
		if (this.processQueue.eraseNodeToDeleteLessThanLod3(node))
		{
			neoBuilding = node.data.neoBuilding;
			if (neoBuilding === undefined)
			{ continue; }
			
			if (neoBuilding.octree)
			{
				neoBuilding.octree.deleteObjectsModelReferences(gl, this.vboMemoryManager);
			}
			if (neoBuilding.motherBlocksArray.length > 0 || neoBuilding.motherNeoReferencesArray.length > 0)
			{
				modelRefsDeletedCount ++;
			}
				
			neoBuilding.deleteObjectsModelReferences(gl, this.vboMemoryManager);
			neoBuilding.deleteObjectsLod2(gl, this.vboMemoryManager);
			deletedCount++;
			
			if (deletedCount > 10)
			{ break; }
		}
	}
	
	deletedCount = 0;
	for (var key in this.processQueue.nodesToDeleteLessThanLod4Map)
	{
		node = this.processQueue.nodesToDeleteLessThanLod4Map[key];
		if (node.data === undefined)
		{ continue; }
	
		if (this.processQueue.eraseNodeToDeleteLessThanLod4(node))
		{
			neoBuilding = node.data.neoBuilding;
			if (neoBuilding === undefined)
			{ continue; }
		
			neoBuilding.deleteObjectsModelReferences(gl, this.vboMemoryManager);
			neoBuilding.deleteObjectsLod2(gl, this.vboMemoryManager);
			neoBuilding.deleteObjectsLodMesh(gl, this.vboMemoryManager, "lod3");
			deletedCount++;
			
			if (deletedCount > 10)
			{ break; }
		}
	}
	
	deletedCount = 0;
	for (var key in this.processQueue.nodesToDeleteLessThanLod5Map)
	{
		node = this.processQueue.nodesToDeleteLessThanLod5Map[key];
		if (node.data === undefined)
		{ continue; }
	
		if (this.processQueue.eraseNodeToDeleteLessThanLod5(node))
		{
			neoBuilding = node.data.neoBuilding;
			if (neoBuilding === undefined)
			{ continue; }
		
			neoBuilding.deleteObjectsModelReferences(gl, this.vboMemoryManager);
			neoBuilding.deleteObjectsLod2(gl, this.vboMemoryManager);
			neoBuilding.deleteObjectsLodMesh(gl, this.vboMemoryManager, "lod3");
			neoBuilding.deleteObjectsLodMesh(gl, this.vboMemoryManager, "lod4");
			deletedCount++;
			
			if (deletedCount > 10)
			{ break; }
		}
	}
	
	
	// now, delete lod0, lod1, lod2.***
	var deletedCount = 0;
	
	// parse pendent data.**********************************************************************************
	var maxParsesCount = 1;
	
	// parse references lod0 & lod 1.
	var lowestOctree;
	var neoBuilding;
	var headerVersion;
	var geoLocDataManager;
	var octreesParsedCount = 0;
	
	if (this.matrix4SC === undefined)
	{ this.matrix4SC = new Matrix4(); }

	// is desirable to parse octrees references ordered by the current eye distance.
	// in the "visibleObjControlerOctrees" there are the octrees sorted by distance, so must use it.
	// parse octrees lod1 references.
	octreesParsedCount = 0;
	maxParsesCount = 1;
	
	if (this.parseQueue.parseOctreesLod0References(gl, this.visibleObjControlerOctrees, this, maxParsesCount))
	{
		if (this.selectionFbo)
		{ this.selectionFbo.dirty = true; }
	}
	
	// parse octrees lod1 references.
	octreesParsedCount = 0;
	maxParsesCount = 1;
	if (Object.keys(this.parseQueue.octreesLod0ReferencesToParseMap).length > 0)
	{
		// 1rst parse the currently closest lowestOctrees to camera.
		var octreesLod0Count = this.visibleObjControlerOctrees.currentVisibles1.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = this.visibleObjControlerOctrees.currentVisibles1[i];
			if (this.parseQueue.parseOctreesLod0References(gl, lowestOctree, this))
			{
				octreesParsedCount++;
			}

			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			for (var key in this.parseQueue.octreesLod0ReferencesToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.parseQueue.octreesLod0ReferencesToParseMap, key))
				{
					var lowestOctree = this.parseQueue.octreesLod0ReferencesToParseMap[key];
					//lowestOctree = octreesArray[i];
					this.parseQueue.parseOctreesLod0References(gl, lowestOctree, this);
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }
				}
			}
		}
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}
	
	// parse octrees lod0 models.
	octreesParsedCount = 0;
	maxParsesCount = 1;
	if (Object.keys(this.parseQueue.octreesLod0ModelsToParseMap).length > 0)
	{
		// 1rst parse the currently closest lowestOctrees to camera.
		var octreesLod0Count = this.visibleObjControlerOctrees.currentVisibles0.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = this.visibleObjControlerOctrees.currentVisibles0[i];
			
			if (this.parseQueue.octreesLod0ModelsToParseMap.hasOwnProperty(lowestOctree.octreeKey))
			{
				delete this.parseQueue.octreesLod0ModelsToParseMap[lowestOctree.octreeKey];
				if (lowestOctree.neoReferencesMotherAndIndices === undefined)
				{ continue; }
				
				var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
				if (blocksList === undefined)
				{ continue; }
				
				if (blocksList.dataArraybuffer === undefined)
				{ continue; }
			
				if (blocksList.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
				{ continue; }
				
				neoBuilding = lowestOctree.neoBuildingOwner;
				headerVersion = neoBuilding.getHeaderVersion();
				
				if (headerVersion[0] === "v")
				{
					// parse the beta version.
					blocksList.parseBlocksList(blocksList.dataArraybuffer, this.readerWriter, neoBuilding.motherBlocksArray, this);
				}
				else 
				{
					// parse versioned.
					blocksList.parseBlocksListVersioned(blocksList.dataArraybuffer, this.readerWriter, neoBuilding.motherBlocksArray, this);
				}
				blocksList.dataArraybuffer = undefined;
				
				octreesParsedCount++;
			}

			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			//var octreesArray = Array.from(this.parseQueue.octreesLod0ModelsToParseMap.keys());
			//for (var i=0; i<octreesArray.length; i++)
			for (var key in this.parseQueue.octreesLod0ModelsToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.parseQueue.octreesLod0ModelsToParseMap, key))
				{
					var lowestOctree = this.parseQueue.octreesLod0ModelsToParseMap[key];
					delete this.parseQueue.octreesLod0ModelsToParseMap[key];
					if (lowestOctree.neoReferencesMotherAndIndices === undefined)
					{ continue; }
					
					var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
					if (blocksList === undefined)
					{ continue; }
					
					if (blocksList.dataArraybuffer === undefined)
					{ continue; }
				
					if (blocksList.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
					{ continue; }
					
					neoBuilding = lowestOctree.neoBuildingOwner;
					headerVersion = neoBuilding.getHeaderVersion();
				
					if (headerVersion[0] === "v")
					{
						// parse the beta version.
						blocksList.parseBlocksList(blocksList.dataArraybuffer, this.readerWriter, neoBuilding.motherBlocksArray, this);
					}
					else 
					{
						// parse versioned.
						blocksList.parseBlocksListVersioned(blocksList.dataArraybuffer, this.readerWriter, neoBuilding.motherBlocksArray, this);
					}
					blocksList.dataArraybuffer = undefined;
					
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}
	
	// parse octrees lod1 models.
	octreesParsedCount = 0;
	maxParsesCount = 1;
	if (Object.keys(this.parseQueue.octreesLod0ModelsToParseMap).length > 0)
	{
		// 1rst parse the currently closest lowestOctrees to camera.
		var octreesLod0Count = this.visibleObjControlerOctrees.currentVisibles1.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = this.visibleObjControlerOctrees.currentVisibles1[i];

			if (this.parseQueue.octreesLod0ModelsToParseMap.hasOwnProperty(lowestOctree.octreeKey))
			{
				delete this.parseQueue.octreesLod0ModelsToParseMap[lowestOctree.octreeKey];
				if (lowestOctree.neoReferencesMotherAndIndices === undefined)
				{ continue; }
				
				var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
				if (blocksList === undefined)
				{ continue; }
				
				if (blocksList.dataArraybuffer === undefined)
				{ continue; }
			
				if (blocksList.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
				{ continue; }
				
				neoBuilding = lowestOctree.neoBuildingOwner;
				headerVersion = neoBuilding.getHeaderVersion();
				if (headerVersion[0] === "v")
				{
					// parse the beta version.
					blocksList.parseBlocksList(blocksList.dataArraybuffer, this.readerWriter, neoBuilding.motherBlocksArray, this);
				}
				else 
				{
					// parse versioned.
					blocksList.parseBlocksListVersioned(blocksList.dataArraybuffer, this.readerWriter, neoBuilding.motherBlocksArray, this);
				}
				blocksList.dataArraybuffer = undefined;
				
				octreesParsedCount++;
			}

			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		
		if (octreesParsedCount === 0)
		{
			for (var key in this.parseQueue.octreesLod0ModelsToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.parseQueue.octreesLod0ModelsToParseMap, key))
				{
					var lowestOctree = this.parseQueue.octreesLod0ModelsToParseMap[key];
					delete this.parseQueue.octreesLod0ModelsToParseMap[key];
					if (lowestOctree.neoReferencesMotherAndIndices === undefined)
					{ continue; }
					
					var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
					if (blocksList === undefined)
					{ continue; }
					
					if (blocksList.dataArraybuffer === undefined)
					{ continue; }
				
					if (blocksList.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
					{ continue; }
					
					neoBuilding = lowestOctree.neoBuildingOwner;
					headerVersion = neoBuilding.getHeaderVersion();
					if (headerVersion[0] === "v")
					{
						// parse the beta version.
						blocksList.parseBlocksList(blocksList.dataArraybuffer, this.readerWriter, neoBuilding.motherBlocksArray, this);
					}
					else 
					{
						// parse versioned.
						blocksList.parseBlocksListVersioned(blocksList.dataArraybuffer, this.readerWriter, neoBuilding.motherBlocksArray, this);
					}
					blocksList.dataArraybuffer = undefined;
					
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}

	
	// parse octrees lod2 (lego).
	octreesParsedCount = 0;
	maxParsesCount = 1;
	if (Object.keys(this.parseQueue.octreesLod2LegosToParseMap).length > 0)
	{
		var octreesLod0Count = this.visibleObjControlerOctrees.currentVisibles2.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = this.visibleObjControlerOctrees.currentVisibles2[i];
			if (this.parseQueue.octreesLod2LegosToParseMap.hasOwnProperty(lowestOctree.octreeKey))
			{
				delete this.parseQueue.octreesLod2LegosToParseMap[lowestOctree.octreeKey];
				//this.parseQueue.eraseOctreeLod2LegosToParse(lowestOctree);
				if (lowestOctree.lego === undefined)
				{ continue; }
				
				lowestOctree.lego.parseArrayBuffer(gl, lowestOctree.lego.dataArrayBuffer, this);
				lowestOctree.lego.dataArrayBuffer = undefined;
				
				octreesParsedCount++;
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			//var octreesArray = Array.from(this.parseQueue.octreesLod2LegosToParseMap.keys());
			//for (var i=0; i<octreesArray.length; i++)
			for (var key in this.parseQueue.octreesLod2LegosToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.parseQueue.octreesLod2LegosToParseMap, key))
				{
					var lowestOctree = this.parseQueue.octreesLod2LegosToParseMap[key];
					if (this.parseQueue.octreesLod2LegosToParseMap.hasOwnProperty(key))
					{
						delete this.parseQueue.octreesLod2LegosToParseMap[key];
						//this.parseQueue.eraseOctreeLod2LegosToParse(lowestOctree);
						if (lowestOctree.lego === undefined)
						{ continue; }
						
						lowestOctree.lego.parseArrayBuffer(gl, lowestOctree.lego.dataArrayBuffer, this);
						lowestOctree.lego.dataArrayBuffer = undefined;
						
						octreesParsedCount++;
					}
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}
	
	// PCloud octree.****************************************************************************
	// PCloud octree.****************************************************************************
	octreesParsedCount = 0;
	maxParsesCount = 1;
	if (Object.keys(this.parseQueue.octreesPCloudToParseMap).length > 0)
	{
		var octreesLod0Count = this.visibleObjControlerOctrees.currentVisiblesAux.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = this.visibleObjControlerOctrees.currentVisiblesAux[i];
			if (this.parseQueue.eraseOctreePCloudToParse(lowestOctree))
			{
				if (lowestOctree.lego === undefined)
				{ continue; }
				
				//lowestOctree.lego.parseArrayBuffer(gl, lowestOctree.lego.dataArrayBuffer, this);
				lowestOctree.lego.parsePointsCloudData(gl, lowestOctree.lego.dataArrayBuffer, this);
				lowestOctree.lego.dataArrayBuffer = undefined;
				
				octreesParsedCount++;
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			for (var key in this.parseQueue.octreesPCloudToParseMap)
			{
				//if (Object.prototype.hasOwnProperty.call(this.parseQueue.octreesPCloudToParseMap, key))
				{
					var lowestOctree = this.parseQueue.octreesPCloudToParseMap[key];
					if (this.parseQueue.eraseOctreePCloudToParse(lowestOctree))
					{
						if (lowestOctree.lego === undefined)
						{ continue; }
						
						//lowestOctree.lego.parseArrayBuffer(gl, lowestOctree.lego.dataArrayBuffer, this);
						lowestOctree.lego.parsePointsCloudData(lowestOctree.lego.dataArrayBuffer, gl, this);
						lowestOctree.lego.dataArrayBuffer = undefined;
						
						octreesParsedCount++;
					}
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}
	
	// skin-lego.********************************************************************************
	// skin-lego.********************************************************************************
	octreesParsedCount = 0;
	maxParsesCount = 1;
	if (Object.keys(this.parseQueue.skinLegosToParseMap).length > 0)
	{
		var node;
		var skinLego;
		var neoBuilding;
		var lod3buildingsCount = this.visibleObjControlerNodes.currentVisibles3.length;
		for (var i=0; i<lod3buildingsCount; i++)
		{
			node = this.visibleObjControlerNodes.currentVisibles3[i];
			neoBuilding = node.data.neoBuilding;
			
			if (neoBuilding === undefined || neoBuilding.lodMeshesMap === undefined)
			{ continue; }
		
		    // check the current lod of the building.***
			var currentBuildingLod = neoBuilding.currentLod;
			var lodIdx = currentBuildingLod;
			
			if (lodIdx < 0)
			{ continue; }// old.***
		
			var lodString = undefined;
			if (currentBuildingLod === 0)
			{ lodString = "lod0"; }
			else if (currentBuildingLod === 1)
			{ lodString = "lod1"; }
			else if (currentBuildingLod === 2)
			{ lodString = "lod2"; }
			else if (currentBuildingLod === 3)
			{ lodString = "lod3"; }
			else if (currentBuildingLod === 4)
			{ lodString = "lod4"; }
			else if (currentBuildingLod === 5)
			{ lodString = "lod5"; }

			if (lodString === undefined)
			{ continue; }
			
			///skinLego = neoBuilding.lodMeshesMap.get(lodString);
			skinLego = neoBuilding.lodMeshesMap[lodString];
			
			if (skinLego === undefined)
			{ continue; }
			
			if (this.parseQueue.skinLegosToParseMap.hasOwnProperty(skinLego.legoKey))
			{
	
				delete this.parseQueue.skinLegosToParseMap[skinLego.legoKey];
				skinLego.parseArrayBuffer(gl, skinLego.dataArrayBuffer, this);
				skinLego.dataArrayBuffer = undefined;
				
				octreesParsedCount++;
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			for (var key in this.parseQueue.skinLegosToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.parseQueue.skinLegosToParseMap, key)) 
				{
					var node = this.parseQueue.skinLegosToParseMap[key];
				
					if (node.data === undefined)
					{ continue; }
					
					neoBuilding = node.data.neoBuilding;
				
					if (neoBuilding === undefined)
					{ continue; }
				
					// check the current lod of the building.***
					var currentBuildingLod = neoBuilding.currentLod;
					var lodIdx = currentBuildingLod - 3;
					
					if (lodIdx < 0)
					{ continue; }
					
					skinLego = neoBuilding.lodMeshesArray[lodIdx];
					if (skinLego === undefined)
					{ continue; }
					if (this.parseQueue.skinLegosToParseMap.hasOwnProperty(skinLego.legoKey))
					{
						delete this.parseQueue.skinLegosToParseMap[skinLego.legoKey];
						skinLego.parseArrayBuffer(gl, skinLego.dataArrayBuffer, this);
						skinLego.dataArrayBuffer = undefined;
						
						octreesParsedCount++;
					}
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		
		
	}
	
	// TinTerrain.***********************************************************************************************
	// TinTerrain.***********************************************************************************************
	
	var tinTerrain;
	var terrName_geoCoords_map = this.tinTerrainManager.currentVisibles_terrName_geoCoords_map;
	for (var key in terrName_geoCoords_map)// for all current visible tinTerrains:
	{
		tinTerrain = this.tinTerrainManager.currentTerrainsMap[key]; // check if exist the tinTerrain.***
		if (tinTerrain !== undefined)
		{
			if (this.parseQueue.eraseTinTerrainToParse(tinTerrain)) // check if is inside of the que to parse.***
			{
				tinTerrain.parseData(tinTerrain.dataArrayBuffer);
			}
		}
	}
	
};

/**
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistancePointsCloudType = function(gl, globalVisibleObjControlerOctrees, fileRequestExtraCount) 
{
	var lod2DataInQueueCount = Object.keys(this.loadQueue.lod2PCloudDataMap).length;
	if (lod2DataInQueueCount > 5)
	{ return; }
	
	var extraCount = fileRequestExtraCount;
	
	var currentVisibles = [].concat(globalVisibleObjControlerOctrees.currentVisibles0, globalVisibleObjControlerOctrees.currentVisibles1,
		globalVisibleObjControlerOctrees.currentVisibles2, globalVisibleObjControlerOctrees.currentVisibles3);
	//var currentVisibles = globalVisibleObjControlerOctrees.currentVisiblesAux;

	if (currentVisibles === undefined)
	{ return; }

	var geometryDataPath = this.readerWriter.geometryDataPath;
	var projectFolderName;
	var neoBuilding;
	var buildingFolderName;

	// LOD2
	// Check if the lod2lowestOctrees must load and parse data
	var lowestOctree;
	for (var i=0, length = currentVisibles.length; i<length; i++) 
	{	
		if (this.fileRequestControler.isFullPlus(extraCount))	
		{ return; }
		
		lowestOctree = currentVisibles[i];
		
		if (lowestOctree.octree_number_name === undefined)
		{ continue; }
		
		if (lowestOctree.lego === undefined) 
		{
			lowestOctree.lego = new Lego();
			lowestOctree.lego.fileLoadState = CODE.fileLoadState.READY;
			lowestOctree.lego.legoKey = lowestOctree.octreeKey + "_lego";
		}
	
		neoBuilding = lowestOctree.neoBuildingOwner;
		if (neoBuilding === undefined)
		{ continue; }

		projectFolderName = neoBuilding.projectFolderName;
		buildingFolderName = neoBuilding.buildingFileName;

		if (lowestOctree.lego.fileLoadState === CODE.fileLoadState.READY)
		{
			var subOctreeNumberName = lowestOctree.octree_number_name.toString();
			var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
			var filePathInServer = references_folderPath + "/" + subOctreeNumberName + "_Ref";
			this.loadQueue.putLod2PCloudData(lowestOctree, filePathInServer, undefined, undefined, 0);
			/*
			// must load the legoStructure of the lowestOctree.***
			var subOctreeNumberName = lowestOctree.octree_number_name.toString();
			var bricks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Bricks";
			var filePathInServer = bricks_folderPath + "/" + subOctreeNumberName + "_Brick";

			// finally check if there are legoSimpleBuildingTexture.***
			// this is the new version.***
			if (neoBuilding.simpleBuilding3x3Texture === undefined)
			{
				neoBuilding.simpleBuilding3x3Texture = new Texture();
				
				var imageFilaName = neoBuilding.getImageFileNameForLOD(2);
				var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + imageFilaName;

				this.loadQueue.putLod2SkinData(lowestOctree, filePathInServer, neoBuilding.simpleBuilding3x3Texture, texFilePath, 0);
				//return;
			}
			else 
			{
				// check texture fileLoadState.***
				
				if ( neoBuilding.simpleBuilding3x3Texture.fileLoadState === CODE.fileLoadState.READY)
				{
					var imageFilaName = neoBuilding.getImageFileNameForLOD(2);
					var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + imageFilaName;
					this.loadQueue.putLod2SkinData(lowestOctree, filePathInServer, neoBuilding.simpleBuilding3x3Texture, texFilePath, 0);
				}
				else if (neoBuilding.simpleBuilding3x3Texture.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
					
				{ this.loadQueue.putLod2SkinData(lowestOctree, filePathInServer, undefined, undefined, 0); }
			}
			*/
		}
		
		if (Object.keys(this.loadQueue.lod2PCloudDataMap).length > 5)
		{ return; }
	} 
};

/**
 * LOD0, LOD1 에 대한 F4D ModelData, ReferenceData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistance = function(gl, globalVisibleObjControlerOctrees, fileRequestExtraCount) 
{
	if (this.fileRequestControler.isFullPlusModelReferences(fileRequestExtraCount))	
	{ return; }

	var geometryDataPath = this.readerWriter.geometryDataPath;
	var buildingFolderName;
	var projectFolderName;
	var neoBuilding;
	var metaData;

	// LOD0 & LOD1
	// Check if the lod0lowestOctrees, lod1lowestOctrees must load and parse data
	var currentVisibleOctrees = [].concat(globalVisibleObjControlerOctrees.currentVisibles0, globalVisibleObjControlerOctrees.currentVisibles1);
	var lowestOctree;
	this.thereAreUrgentOctrees = false;

	// now, prepare the ocree normally.
	var maxFilesLoad = 2;
	var filesLoadCounter = 0;
	/*
	for (var i=0, length = currentVisibleOctrees.length; i<length; i++) 
	{
		lowestOctree = currentVisibleOctrees[i];
		// if the lowest octree is not ready to render, then:
		if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED )
		{
			var insert_idx = lowestOctree.getIndexToInsertBySquaredDistToEye(globalVisibleObjControlerOctrees.currentVisibles2, lowestOctree);
			globalVisibleObjControlerOctrees.currentVisibles2.splice(insert_idx, 0, lowestOctree);
			break;
		}
	}
	*/
	
	for (var i=0, length = currentVisibleOctrees.length; i<length; i++) 
	{
		if (this.fileRequestControler.isFullPlusModelReferences(fileRequestExtraCount))	
		{ return; } 
	
		lowestOctree = currentVisibleOctrees[i];
		neoBuilding = lowestOctree.neoBuildingOwner;
		
		if (neoBuilding === undefined)
		{ continue; }
		
		if (lowestOctree.triPolyhedronsCount === 0) 
		{ continue; }
		
		if (lowestOctree.octree_number_name === undefined)
		{ continue; }
	
		metaData = neoBuilding.metaData;
		
		// Check project's dataType.***
		var projectDataType = metaData.projectDataType;

	
		buildingFolderName = neoBuilding.buildingFileName;
		projectFolderName = neoBuilding.projectFolderName;
		
		if (lowestOctree.neoReferencesMotherAndIndices === undefined)
		{
			lowestOctree.neoReferencesMotherAndIndices = new NeoReferencesMotherAndIndices();
			lowestOctree.neoReferencesMotherAndIndices.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
		}
		
		if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.READY)
		{
			if (lowestOctree.neoReferencesMotherAndIndices.blocksList === undefined)
			{ lowestOctree.neoReferencesMotherAndIndices.blocksList = new BlocksList(); }

			var subOctreeNumberName = lowestOctree.octree_number_name.toString();
			var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
			var intRef_filePath = references_folderPath + "/" + subOctreeNumberName + "_Ref";
			this.readerWriter.getNeoReferencesArraybuffer(intRef_filePath, lowestOctree, this);
			filesLoadCounter++;
		}
		
		// 4 = parsed.***
		// now, check if the blocksList is loaded & parsed.***
		var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
		if (blocksList === undefined)
		{ continue; }
		if (blocksList.fileLoadState === CODE.fileLoadState.READY) 
		{
			// must read blocksList.***
			var subOctreeNumberName = lowestOctree.octree_number_name.toString();
			var blocks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Models";
			var filePathInServer = blocks_folderPath + "/" + subOctreeNumberName + "_Model";
			this.readerWriter.getNeoBlocksArraybuffer(filePathInServer, lowestOctree, this);
			filesLoadCounter++;
		}
		
		if (filesLoadCounter > maxFilesLoad)
		{ return; }
	}
};

/**
 * LOD2 에 대한 F4D LegoData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistanceLOD2 = function(gl, currentVisibles, fileRequestExtraCount) 
{
	var lod2DataInQueueCount = Object.keys(this.loadQueue.lod2SkinDataMap).length;
	if (lod2DataInQueueCount > 5)
	{ return; }
	
	var extraCount = fileRequestExtraCount;

	if (currentVisibles === undefined)
	{ return; }

	var geometryDataPath = this.readerWriter.geometryDataPath;
	var projectFolderName;
	var neoBuilding;
	var buildingFolderName;

	// LOD2
	// Check if the lod2lowestOctrees must load and parse data
	var lowestOctree;
	//var counter = 0;
	for (var i=0, length = currentVisibles.length; i<length; i++) 
	{	
		if (this.fileRequestControler.isFullPlus(extraCount))	
		{ return; }
		
		lowestOctree = currentVisibles[i];
		
		if (lowestOctree.octree_number_name === undefined)
		{ continue; }
		
		if (lowestOctree.lego === undefined) 
		{
			lowestOctree.lego = new Lego();
			lowestOctree.lego.fileLoadState = CODE.fileLoadState.READY;
			lowestOctree.lego.legoKey = lowestOctree.octreeKey + "_lego";
		}
	
		neoBuilding = lowestOctree.neoBuildingOwner;
		if (neoBuilding === undefined)
		{ continue; }

		projectFolderName = neoBuilding.projectFolderName;
		buildingFolderName = neoBuilding.buildingFileName;
		
		var headerVersion = neoBuilding.getHeaderVersion();

		if (lowestOctree.lego.fileLoadState === CODE.fileLoadState.READY)
		{
			// must load the legoStructure of the lowestOctree.***
			var subOctreeNumberName = lowestOctree.octree_number_name.toString();
			var bricks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Bricks";
			var filePathInServer = bricks_folderPath + "/" + subOctreeNumberName + "_Brick";

			// finally check if there are legoSimpleBuildingTexture.***
			if (headerVersion[0] === "v")
			{
				if (lowestOctree.lego.vbo_vicks_container.vboCacheKeysArray[0] && lowestOctree.lego.vbo_vicks_container.vboCacheKeysArray[0].meshTexcoordsCacheKey)
				{
					// this is the old version.***
					if (neoBuilding.simpleBuilding3x3Texture === undefined)
					{
						neoBuilding.simpleBuilding3x3Texture = new Texture();
						var buildingFolderName = neoBuilding.buildingFileName;
						var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/SimpleBuildingTexture3x3.png";
						this.loadQueue.putLod2SkinData(lowestOctree, filePathInServer, neoBuilding.simpleBuilding3x3Texture, texFilePath, 0);
					}
				}
				else 
				{
					// there are no texture in this project.***
					this.loadQueue.putLod2SkinData(lowestOctree, filePathInServer, undefined, undefined, 0);
				}
			}
			else 
			{
				// this is the new version.***
				if (neoBuilding.simpleBuilding3x3Texture === undefined)
				{
					neoBuilding.simpleBuilding3x3Texture = new Texture();
					
					var imageFilaName = neoBuilding.getImageFileNameForLOD(2);
					var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + imageFilaName;

					this.loadQueue.putLod2SkinData(lowestOctree, filePathInServer, neoBuilding.simpleBuilding3x3Texture, texFilePath, 0);
					//return;
				}
				else 
				{
					// check texture fileLoadState.***
					
					if ( neoBuilding.simpleBuilding3x3Texture.fileLoadState === CODE.fileLoadState.READY)
					{
						var imageFilaName = neoBuilding.getImageFileNameForLOD(2);
						var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + imageFilaName;
						this.loadQueue.putLod2SkinData(lowestOctree, filePathInServer, neoBuilding.simpleBuilding3x3Texture, texFilePath, 0);
					}
					else if (neoBuilding.simpleBuilding3x3Texture.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
						
					{ this.loadQueue.putLod2SkinData(lowestOctree, filePathInServer, undefined, undefined, 0); }
				}
			}
		}
		
		if (Object.keys(this.loadQueue.lod2SkinDataMap).length > 5)
		{ return; }
	} 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.checkChangesHistoryMovements = function(nodesArray) 
{
	var nodesCount = nodesArray.length;
	var node;
	var rootNode;	
	var projectId;
	var dataKey;
	var moveHistoryMap;
	var colorChangedHistoryMap;
	var objectIndexOrder;
	var neoBuilding;
	var refObject;
	var moveVector;
	var moveVectorRelToBuilding;
	var geoLocdataManager;
	var geoLoc;
	
	// check movement of objects.
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		rootNode = node.getRoot();
		if (rootNode === undefined)
		{ continue; }
		
		geoLocdataManager = this.getNodeGeoLocDataManager(rootNode);
		geoLoc = geoLocdataManager.getCurrentGeoLocationData();
		projectId = node.data.projectId;
		dataKey = node.data.nodeId;
		
		// objects movement.
		moveHistoryMap = MagoConfig.getMovingHistoryObjects(projectId, dataKey);
		if (moveHistoryMap)
		{
			neoBuilding = node.data.neoBuilding;
			///for (var changeHistory of moveHistoryMap.values()) 
			for (var key in moveHistoryMap)
			{
				if (Object.prototype.hasOwnProperty.call(moveHistoryMap, key)) 
				{
					var changeHistory = moveHistoryMap[key];
					objectIndexOrder = changeHistory.getObjectIndexOrder();
					refObject = neoBuilding.getReferenceObject(objectIndexOrder);
					if (refObject === undefined)
					{ continue; }
					
					if (refObject.moveVector === undefined)
					{ refObject.moveVector = new Point3D(); }
					
					if (refObject.moveVectorRelToBuilding === undefined)
					{ refObject.moveVectorRelToBuilding = new Point3D(); }
					
					moveVector = changeHistory.getReferenceObjectAditionalMovement();
					moveVectorRelToBuilding = changeHistory.getReferenceObjectAditionalMovementRelToBuilding();
					refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);
					refObject.moveVector.set(moveVector.x, moveVector.y, moveVector.z);
					
					// now check if the building was rotated.
					// if was rotated then recalculate the move vector.
					refObject.moveVector = geoLoc.tMatrix.rotatePoint3D(refObject.moveVectorRelToBuilding, refObject.moveVector); 
					
					// if was no rotated, then set the moveVector of the changeHistory.
					//refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);	
				}
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */

MagoManager.prototype.checkPropertyFilters = function(nodesArray) 
{
	if (this.propertyFilterSC === undefined)
	{ return; }
	
	var nodesCount = nodesArray.length;
	var node;	
	var projectId;
	var propertyKey = this.propertyFilterSC.propertyKey;
	var propertyValue = this.propertyFilterSC.propertyValue;
	var visible = this.propertyFilterSC.visible;
	
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		projectId = node.data.projectId;
		if (projectId === this.propertyFilterSC.projectId)
		{
			if (node.data.attributes)
			{
				if (node.data.attributes[propertyKey] !== undefined && node.data.attributes[propertyKey].toString() === propertyValue)
				{
					if (visible === "true")
					{
						// do nothing.
					}
					else
					{
						nodesArray.splice(i, 1);
						i--;
						nodesCount = nodesArray.length;
					}
				}
				else
				{
					if (visible === "true")
					{
						nodesArray.splice(i, 1);
						i--;
						nodesCount = nodesArray.length;
					}
					else 
					{
						// do nothing.
					}
				}
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */

MagoManager.prototype.checkChangesHistoryColors = function(nodesArray) 
{
	var nodesCount = nodesArray.length;
	var node;
	var rootNode;	
	var projectId;
	var dataKey;
	var moveHistoryMap;
	var colorChangedHistoryMap;
	var objectIndexOrder;
	var neoBuilding;
	var refObject;
	
	// check movement of objects.
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		rootNode = node.getRoot();
		if (rootNode === undefined)
		{ continue; }
		
		projectId = node.data.projectId;
		dataKey = node.data.nodeId;

		colorChangedHistoryMap = MagoConfig.getColorHistorys(projectId, dataKey);
		if (colorChangedHistoryMap)
		{
			neoBuilding = node.data.neoBuilding;
			//for (var changeHistory of colorChangedHistoryMap.values()) 
			for (var key in colorChangedHistoryMap)
			{
				if (Object.prototype.hasOwnProperty.call(colorChangedHistoryMap, key)) 
				{
					var changeHistory = colorChangedHistoryMap[key];
					if (changeHistory.objectId === null || changeHistory.objectId === undefined || changeHistory.objectId === "" )
					{
						if (changeHistory.property === null || changeHistory.property === undefined || changeHistory.property === "" )
						{
							// change color for all node.
							neoBuilding.isColorChanged = true;
							if (neoBuilding.aditionalColor === undefined)
							{ neoBuilding.aditionalColor = new Color(); }
							
							neoBuilding.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
						}
						else 
						{
							// there are properties.
							var nodesArray = [];
							node.extractNodes(nodesArray);
							var nodesCount = nodesArray.length;
							var aNode;
							for (var i=0; i<nodesCount; i++)
							{
								aNode = nodesArray[i];
								var propertyKey = changeHistory.propertyKey;
								var propertyValue = changeHistory.propertyValue;
								// 1rst, check if this has the same "key" and same "value".
								if (aNode.data.attributes[propertyKey] !== undefined && aNode.data.attributes[propertyKey].toString() === propertyValue)
								{
									neoBuilding.isColorChanged = true;
									if (neoBuilding.aditionalColor === undefined)
									{ neoBuilding.aditionalColor = new Color(); }
									
									neoBuilding.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
								}
							}
						}
					}
					else 
					{
						// change color for an object.
						var objectId = changeHistory.objectId;
						var objectsArray = neoBuilding.getReferenceObjectsArrayByObjectId(objectId);
						if (objectsArray)
						{
							var objectsCount = objectsArray.length;
							for (var j=0; j<objectsCount; j++)
							{
								var object = objectsArray[j];
								if (object.aditionalColor === undefined)
								{ object.aditionalColor = new Color(); }
								
								object.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
							}
						}
					}	
				}
			}
		}
	}
	
	var allColorHistoryMap = MagoConfig.getAllColorHistory();
	if (allColorHistoryMap)
	{
		for (var key in allColorHistoryMap) 
		{
			if (Object.prototype.hasOwnProperty.call(allColorHistoryMap, key))
			{
				var colorChangedHistoryMap = allColorHistoryMap[key];
				//for (var colorChangedHistoryMap of allColorHistoryMap.values()) 
				//{
				// now check nodes that is no physical.
				for (var key2 in colorChangedHistoryMap) 
				{
					if (Object.prototype.hasOwnProperty.call(colorChangedHistoryMap, key2))
					{
						var changeHistoryMap = colorChangedHistoryMap[key2];
						//for (var changeHistoryMap of colorChangedHistoryMap.values()) 
						//{
						for (var key3 in changeHistoryMap) 
						{
							if (Object.prototype.hasOwnProperty.call(changeHistoryMap, key3))
							{
								var changeHistory = changeHistoryMap[key3];
								//for (var changeHistory of changeHistoryMap.values()) 
								//{
								var projectId = changeHistory.projectId;
								var nodesMap = this.hierarchyManager.getNodesMap(projectId);
								var aNode = nodesMap[changeHistory.dataKey];
								if (aNode && aNode.data.attributes.isPhysical !== undefined && aNode.data.attributes.isPhysical === false)
								{
									// must check if there are filters.
									if (changeHistory.property === null || changeHistory.property === undefined || changeHistory.property === "" )
									{
										// this is a no physical node, so must check children.
										var nodesArray = [];
										aNode.extractNodes(nodesArray);
										var nodesCount = nodesArray.length;
										for (var i=0; i<nodesCount; i++)
										{
											var aNode2 = nodesArray[i];
											neoBuilding = aNode2.data.neoBuilding;
											if (neoBuilding)
											{
												neoBuilding.isColorChanged = true;
												if (neoBuilding.aditionalColor === undefined)
												{ neoBuilding.aditionalColor = new Color(); }
												
												neoBuilding.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
											}
										}
									}
									else 
									{
										var propertyKey = changeHistory.propertyKey;
										var propertyValue = changeHistory.propertyValue;
											
										// this is a no physical node, so must check children.
										var nodesArray = [];
										aNode.extractNodes(nodesArray);
										var nodesCount = nodesArray.length;
										for (var i=0; i<nodesCount; i++)
										{
											var aNode2 = nodesArray[i];
											neoBuilding = aNode2.data.neoBuilding;
											if (neoBuilding)
											{
												if (aNode2.data.attributes[propertyKey] !== undefined && aNode2.data.attributes[propertyKey].toString() === propertyValue)
												{
													neoBuilding.isColorChanged = true;
													if (neoBuilding.aditionalColor === undefined)
													{ neoBuilding.aditionalColor = new Color(); }
													
													neoBuilding.aditionalColor.setRGB(changeHistory.rgbColor[0], changeHistory.rgbColor[1], changeHistory.rgbColor[2]);
												}
											}
										}
									}
								}	
							}
						}	
					}
				}	
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수

 */

MagoManager.prototype.renderInvertedBox = function(gl) 
{
	return;
	
	if (this.fakeScreenPlane === undefined)
	{
		this.fakeScreenPlane = {};
		this.fakeScreenPlane.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
		var vboKey = this.fakeScreenPlane.vbo_vicks_container.newVBOVertexIdxCacheKey();
		var posArray = [-1, -1, 0,  1, -1, 0,  -1, 1, 0,  1, -1, 0,  1, 1, 0,  -1, 1, 0];
		//var elems = [0, 1, 2,];
		vboKey.posVboDataArray = Float32Array.from(posArray);
		vboKey.vertexCount = 6;
	}
	
	gl.depthFunc(gl.ALWAYS);
	//gl.depthFunc(gl.NEVER);
	
	// call this in the end of rendering pipeline.***
	var currentShader = this.postFxShadersManager.getInvertedBoxShader();
	var shaderProgram = currentShader.program;
	
	gl.useProgram(shaderProgram);
	
	gl.enableVertexAttribArray(currentShader.position3_loc);
	//gl.disableVertexAttribArray(currentShader.normal3_loc);
	
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, this.sceneState.modelViewMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, this.sceneState.projectionMatrix._floatArrays);
	gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
	gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);
	gl.uniformMatrix4fv(currentShader.normalMatrix4_loc, false, this.sceneState.normalMatrix4._floatArrays);
	gl.uniform1f(currentShader.near_loc, this.sceneState.camera.frustum.near);
	gl.uniform1f(currentShader.far_loc, this.sceneState.camera.frustum.far);

	gl.uniform1f(currentShader.fov_loc, this.sceneState.camera.frustum.fovyRad);	// "frustum._fov" is in radians.***
	gl.uniform1f(currentShader.aspectRatio_loc, this.sceneState.camera.frustum.aspectRatio);
	gl.uniform1f(currentShader.screenWidth_loc, this.sceneState.drawingBufferWidth);	
	gl.uniform1f(currentShader.screenHeight_loc, this.sceneState.drawingBufferHeight);
	gl.uniform1f(currentShader.shininessValue_loc, 40.0);

	gl.uniform1i(currentShader.depthTex_loc, 0);
	gl.uniform1i(currentShader.noiseTex_loc, 1);
	//gl.uniform1i(currentShader.diffuseTex_loc, 2); // no used.***

	gl.uniform2fv(currentShader.noiseScale2_loc, [this.depthFboNeo.width/this.noiseTexture.width, this.depthFboNeo.height/this.noiseTexture.height]);
	gl.uniform3fv(currentShader.kernel16_loc, this.sceneState.ssaoSphereKernel32);
	
	gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis);
	
	// lighting.
	//this.magoPolicy.setSpecularColor(api.getSpecularColor());
	gl.uniform3fv(currentShader.specularColor_loc, [0.7, 0.7, 0.7]);
	gl.uniform1f(currentShader.ssaoRadius_loc, 1.5); 
	gl.uniform1i(currentShader.hasTexture_loc, false);
	gl.uniform4fv(currentShader.color4Aux_loc, [0.5, 0.5, 0.5, 1.0]);

	gl.uniform1f(currentShader.ambientReflectionCoef_loc, this.magoPolicy.getAmbientReflectionCoef());
	gl.uniform1f(currentShader.diffuseReflectionCoef_loc, this.magoPolicy.getDiffuseReflectionCoef());
	gl.uniform1f(currentShader.specularReflectionCoef_loc, this.magoPolicy.getSpecularReflectionCoef());
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
	
	// 1) LOD0 & LOD1.*********************************************************************************************************************
		
	var refTMatrixIdxKey = 0;
	var minSize = 0.0;
	var renderTexture;
	var ssao_idx = 1;
	var bRenderLines = false;
	var primitiveType = undefined;
	
	gl.enable(gl.BLEND);
	gl.uniform1i(currentShader.bUseNormal_loc, true);
	
	if (this.isLastFrustum)
	{
		//this.renderer.renderObject(gl, this.invertedBox, this, currentShader, ssao_idx, bRenderLines, primitiveType);
		//var vbo_vicky = this.invertedBox.vbo_vicks_container.vboCacheKeysArray[0];
		var vbo_vicky = this.fakeScreenPlane.vbo_vicks_container.vboCacheKeysArray[0];
		if (!vbo_vicky.isReadyPositions(gl, this.vboMemoryManager))
		{ return; }
		gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshVertexCacheKey);
		gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
		
		//if (!vbo_vicky.isReadyNormals(gl, this.vboMemoryManager))
		//	return;
		//gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshNormalCacheKey);
		//gl.vertexAttribPointer(currentShader.normal3_loc, 3, gl.BYTE, true, 0, 0);
				
		//if (!vbo_vicky.isReadyFaces(gl, this.vboMemoryManager)) 
		//{ return; }
		//gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vbo_vicky.meshFacesCacheKey);
		//gl.drawElements(gl.TRIANGLES, vbo_vicky.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
		gl.drawArrays(gl.TRIANGLES, 0, this.fakeScreenPlane.vbo_vicks_container.vboCacheKeysArray[0].vertexCount);
	}
	
	gl.disable(gl.BLEND);
	
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.depthFunc(gl.LEQUAL);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.renderDirectionalLight = function(gl, cameraPosition, shader, renderTexture, ssao_idx, visibleObjControlerNodes) 
{
	//this.myCameraSCX;
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.renderGeometry = function(gl, cameraPosition, shader, renderTexture, ssao_idx, visibleObjControlerNodes) 
{
	// ssao_idx = -1 -> pickingMode.***
	// ssao_idx = 0 -> depth.***
	// ssao_idx = 1 -> ssao.***
	gl.frontFace(gl.CCW);
	var near = 0.20;
	var far = 0.25;

	//gl.depthRange(near, far);	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	
	var currentShader;
	var shaderProgram;
	var neoBuilding;
	var node;
	var rootNode;
	var geoLocDataManager;

	renderTexture = false;
	//var lowestOctreeLegosParsingCount = 0;
	
	

	if (ssao_idx === 0) 
	{
		gl.disable(gl.BLEND);
		this.depthRenderLowestOctreeAsimetricVersion(gl, ssao_idx, visibleObjControlerNodes);
		// draw the axis.***
		if (this.magoPolicy.getShowOrigin() && this.nodeSelected !== undefined)
		{
			node = this.nodeSelected;
			var nodes = [node];
			
			this.renderAxisNodes(gl, nodes, true, ssao_idx);
		}
	}
	if (ssao_idx === 1) 
	{
		// ssao render.************************************************************************************************************
		var nodesLOD0Count = visibleObjControlerNodes.currentVisibles0.length;

		if (nodesLOD0Count > 0)
		{
			// check changesHistory.
			this.checkChangesHistoryMovements(visibleObjControlerNodes.currentVisibles0);
			this.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles0);
		
			if (this.noiseTexture === undefined) 
			{ this.noiseTexture = genNoiseTextureRGBA(gl, 4, 4, this.pixels); }
			
			currentShader = this.postFxShadersManager.getShader("modelRefSsao"); 
			shaderProgram = currentShader.program;
			
			gl.useProgram(shaderProgram);
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, true);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			
			currentShader.bindUniformGenerals();
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
			
			// 1) LOD0 & LOD1.*********************************************************************************************************************
			var refTMatrixIdxKey = 0;
			var minSize = 0.0;
			var renderTexture;
			//if (this.isLastFrustum)
			{
				this.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx, minSize, refTMatrixIdxKey);
			}
			
			if (currentShader)
			{
				if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
				if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
				if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
				if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			}
			
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
		
		// 2) LOD 2, 3, 4, 5.************************************************************************************************************************************
		var nodesLOD2Count = visibleObjControlerNodes.currentVisibles2.length;
		var nodesLOD3Count = visibleObjControlerNodes.currentVisibles3.length;
		if (nodesLOD2Count > 0 || nodesLOD0Count > 0 || nodesLOD3Count>0)
		{
			this.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles2);

			// lodBuildingSsaoSimpleCompressed
			currentShader = this.postFxShadersManager.getShader("lodBuildingSsao");

			shaderProgram = currentShader.program;
		
			gl.useProgram(shaderProgram);
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, true);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			gl.enableVertexAttribArray(currentShader.color4_loc);
			
			currentShader.bindUniformGenerals();
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, this.textureAux_1x1);
			
			this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx); // lod 0.***
			this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles2, this, currentShader, renderTexture, ssao_idx); // lod 2.***
			this.renderer.renderNeoBuildingsLowLOD(gl, visibleObjControlerNodes.currentVisibles3, this, currentShader, renderTexture, ssao_idx); // lod 3, 4, 5.***
			
			if (currentShader)
			{
				if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
				if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
				if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
				if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			}
			
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, null);
		}

		// If there are an object selected, then there are a stencilBuffer.******************************************
		if (this.nodeSelected) // if there are an object selected then there are a building selected.***
		{
			if (this.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && this.objectSelected)
			{
				node = this.nodeSelected;
				var geoLocDataManager = this.getNodeGeoLocDataManager(node);
				neoBuilding = this.buildingSelected;
				var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
				var neoReferencesMotherAndIndices = this.octreeSelected.neoReferencesMotherAndIndices;
				var glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				var maxSizeToRender = 0.0;
				var refMatrixIdxKey = 0;
				
				// do as the "getSelectedObjectPicking".**********************************************************
				currentShader = this.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
				var shaderProgram = currentShader.program;
				gl.useProgram(shaderProgram);
				
				gl.enableVertexAttribArray(currentShader.position3_loc);
				
				gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
				gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
				gl.uniformMatrix4fv(currentShader.ModelViewMatrixRelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays);
				gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
				gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);
				
				// do the colorCoding render.***
				// position uniforms.***
				gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
				gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
				
				gl.uniform4fv(currentShader.color4Aux_loc, [0.0, 1.0, 0.0, 1.0]);
				gl.uniform2fv(currentShader.screenSize_loc, [this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight]);
				gl.uniformMatrix4fv(currentShader.ProjectionMatrix_loc, false, this.sceneState.projectionMatrix._floatArrays);
				
				gl.enable(gl.STENCIL_TEST);
				gl.disable(gl.POLYGON_OFFSET_FILL);
				gl.disable(gl.CULL_FACE);
				gl.disable(gl.DEPTH_TEST);
				gl.depthRange(0, 0);
				
				gl.stencilFunc(gl.EQUAL, 0, 1);
				gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
					
				//glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				//gl.polygonMode( gl.FRONT_AND_BACK, gl.LINE );
				
				var offsetSize = 3/1000;
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, offsetSize]);
				this.renderer.renderNeoReferenceAsimetricVersionColorSelection(gl, this.objectSelected, neoReferencesMotherAndIndices, neoBuilding, this, currentShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, offsetSize]);
				this.renderer.renderNeoReferenceAsimetricVersionColorSelection(gl, this.objectSelected, neoReferencesMotherAndIndices, neoBuilding, this, currentShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, -offsetSize]);
				this.renderer.renderNeoReferenceAsimetricVersionColorSelection(gl, this.objectSelected, neoReferencesMotherAndIndices, neoBuilding, this, currentShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, -offsetSize]);
				this.renderer.renderNeoReferenceAsimetricVersionColorSelection(gl, this.objectSelected, neoReferencesMotherAndIndices, neoBuilding, this, currentShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
				gl.enable(gl.DEPTH_TEST);// return to the normal state.***
				gl.disable(gl.STENCIL_TEST);
				gl.depthRange(0, 1);// return to the normal value.***
				gl.disableVertexAttribArray(currentShader.position3_loc);
				
				if (currentShader)
				{
					if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
					if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
					if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
					if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
				}
			}
			
			// render bbox for neoBuildingSelected. // old.***
			/*
			var selectedNodesArray = [];
			selectedNodesArray.push(this.nodeSelected);
			if (this.colorSC === undefined)
			{ this.colorSC = new Color(); }
			this.colorSC.setRGB(0.8, 1.0, 1.0);
			this.renderBoundingBoxesNodes(gl, selectedNodesArray, this.colorSC); // old.
			*/
			
			// new. Render the silhouette by lod3 or lod4 or lod5 mesh***
			if (this.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && this.buildingSelected)
			{
				node = this.nodeSelected;
				var geoLocDataManager = this.getNodeGeoLocDataManager(node);
				neoBuilding = this.buildingSelected;
				var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
				//var neoReferencesMotherAndIndices = this.octreeSelected.neoReferencesMotherAndIndices;
				var glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				var maxSizeToRender = 0.0;
				var refMatrixIdxKey = 0;
				var skinLego = neoBuilding.getCurrentSkin();
				if (skinLego !== undefined)
				{
					// do as the "getSelectedObjectPicking".**********************************************************
					currentShader = this.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
					var shaderProgram = currentShader.program;
					gl.useProgram(shaderProgram);
					
					gl.enableVertexAttribArray(currentShader.position3_loc);
					
					gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
					gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
					gl.uniformMatrix4fv(currentShader.ModelViewMatrixRelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays);
					gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
					gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);
					
					// do the colorCoding render.***
					// position uniforms.***
					gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
					gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
					
					gl.uniform4fv(currentShader.color4Aux_loc, [0.0, 1.0, 0.0, 1.0]);
					gl.uniform2fv(currentShader.screenSize_loc, [this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight]);
					gl.uniformMatrix4fv(currentShader.ProjectionMatrix_loc, false, this.sceneState.projectionMatrix._floatArrays);
					
					gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
					
					gl.enable(gl.STENCIL_TEST);
					gl.disable(gl.POLYGON_OFFSET_FILL);
					gl.disable(gl.CULL_FACE);
					gl.disable(gl.DEPTH_TEST);
					gl.depthRange(0, 0);
					
					gl.stencilFunc(gl.EQUAL, 0, 1);
					//gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
					gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
						
					//glPrimitive = gl.POINTS;
					glPrimitive = gl.TRIANGLES;
					gl.uniform1i(currentShader.refMatrixType_loc, 0); // 0 = identity matrix.***
					//gl.polygonMode( gl.FRONT_AND_BACK, gl.LINE );

					
					var offsetSize = 4/1000;
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, offsetSize]);
					this.renderer.renderLodBuildingColorSelection(gl, skinLego, this, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, offsetSize]);
					this.renderer.renderLodBuildingColorSelection(gl, skinLego, this, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, -offsetSize]);
					this.renderer.renderLodBuildingColorSelection(gl, skinLego, this, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, -offsetSize]);
					this.renderer.renderLodBuildingColorSelection(gl, skinLego, this, currentShader);
					gl.enable(gl.DEPTH_TEST);// return to the normal state.***
					gl.disable(gl.STENCIL_TEST);
					gl.depthRange(0, 1);// return to the normal value.***
					gl.disableVertexAttribArray(currentShader.position3_loc);
					
					if (currentShader)
					{
						if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
						if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
						if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
						if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
					}
				}
				
			}
			
			// draw the axis.***
			if (this.magoPolicy.getShowOrigin())
			{
				node = this.nodeSelected;
				//var geoLocDataManager = this.getNodeGeoLocDataManager(node);
				var nodes = [node];
				
				this.renderAxisNodes(gl, nodes, true, ssao_idx);
			}
		}
		
		// 3) now render bboxes.*******************************************************************************************************************
		if (this.magoPolicy.getShowBoundingBox())
		{
			var bRenderLines = true;
			this.renderBoundingBoxesNodes(gl, this.visibleObjControlerNodes.currentVisibles0, undefined, bRenderLines);
			this.renderBoundingBoxesNodes(gl, this.visibleObjControlerNodes.currentVisibles2, undefined, bRenderLines);
			this.renderBoundingBoxesNodes(gl, this.visibleObjControlerNodes.currentVisibles3, undefined, bRenderLines);
		}
		
		// 4) Render ObjectMarkers.********************************************************************************************************
		// 4) Render ObjectMarkers.********************************************************************************************************
		// 4) Render ObjectMarkers.********************************************************************************************************
		var objectsMarkersCount = this.objMarkerManager.objectMarkerArray.length;
		if (objectsMarkersCount > 0)
		{
			// now repeat the objects markers for png images.***
			// Png for pin image 128x128.********************************************************************
			if (this.pin.positionBuffer === undefined)
			{ this.pin.createPinCenterBottom(gl); }
			
			currentShader = this.postFxShadersManager.pFx_shaders_array[13]; // png image shader.***
			
			shaderProgram = currentShader.program;
			
			gl.useProgram(shaderProgram);
			gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
			gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
			gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);
			gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, this.sceneState.modelViewRelToEyeMatrixInv._floatArrays);
			
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis); 
			// Tell the shader to get the texture from texture unit 0
			gl.uniform1i(currentShader.texture_loc, 0);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.activeTexture(gl.TEXTURE0);
			
			gl.depthRange(0, 0);
			//var context = document.getElementById('canvas2').getContext("2d");
			//var canvas = document.getElementById("magoContainer");
			
			gl.bindBuffer(gl.ARRAY_BUFFER, this.pin.positionBuffer);
			gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, this.pin.texcoordBuffer);
			gl.vertexAttribPointer(currentShader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
			var j=0;
			for (var i=0; i<objectsMarkersCount; i++)
			{
				if (j>= this.pin.texturesArray.length)
				{ j=0; }
				
				var currentTexture = this.pin.texturesArray[j];
				var objMarker = this.objMarkerManager.objectMarkerArray[i];
				var objMarkerGeoLocation = objMarker.geoLocationData;
				gl.bindTexture(gl.TEXTURE_2D, currentTexture.texId);
				gl.uniform3fv(currentShader.buildingPosHIGH_loc, objMarkerGeoLocation.positionHIGH);
				gl.uniform3fv(currentShader.buildingPosLOW_loc, objMarkerGeoLocation.positionLOW);

				gl.drawArrays(gl.TRIANGLES, 0, 6);
				
				j++;
			}
			gl.depthRange(0, 1);
			gl.useProgram(null);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.disableVertexAttribArray(currentShader.texCoord2_loc);
			gl.disableVertexAttribArray(currentShader.position3_loc);
			
		}
		
		// Test TinTerrain.**************************************************************************
		// Test TinTerrain.**************************************************************************
		// render tiles, rendertiles.***
		
		if (this.tinTerrainManager !== undefined)
		{
			currentShader = this.postFxShadersManager.getShader("tinTerrain");
			shaderProgram = currentShader.program;
			
			gl.useProgram(shaderProgram);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			//gl.disableVertexAttribArray(currentShader.normal3_loc);
			//gl.disableVertexAttribArray(currentShader.color4_loc);
			
			currentShader.bindUniformGenerals();

			var tex = this.pin.texturesArray[4];
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, tex.texId);
			
			gl.uniform1i(currentShader.bIsMakingDepth_loc, false); //.***
			gl.uniform1i(currentShader.hasTexture_loc, true); //.***
			gl.uniform4fv(currentShader.oneColor4_loc, [0.5, 0.5, 0.5, 1.0]);
			
			//gl.enable(gl.POLYGON_OFFSET_FILL);
			//gl.polygonOffset(1, 3);
			
			var renderWireframe = false;
			var tinTerrain;
			var currentTerrainsMap = this.tinTerrainManager.currentTerrainsMap;
			var currentVisiblesTerrainsMap = this.tinTerrainManager.currentVisibles_terrName_geoCoords_map;
			for (var key in currentVisiblesTerrainsMap)
			{
				//currentVisiblesTerrainsMap
				tinTerrain = currentTerrainsMap[key];
				if (tinTerrain === undefined)
				{ continue; }
				
				if (tinTerrain.vboKeyContainer === undefined || tinTerrain.vboKeyContainer.vboCacheKeysArray.length === 0)
				{ continue; }
				
				// check the texture of the terrain.***
				if (tinTerrain.texture === undefined)
				{
					tinTerrain.texture = new Texture();
					var imagesDataPath = "\\images\\ko";
					var textureFilePath = imagesDataPath +  "\\funny_" + tinTerrain.depth + ".jpg";
					this.readerWriter.readLegoSimpleBuildingTexture(gl, textureFilePath, tinTerrain.texture, this);
					continue;
				}
				
				gl.bindTexture(gl.TEXTURE_2D, tinTerrain.texture.texId);
				
				gl.uniform3fv(currentShader.buildingPosHIGH_loc, tinTerrain.terrainPositionHIGH);
				gl.uniform3fv(currentShader.buildingPosLOW_loc, tinTerrain.terrainPositionLOW);
				
				//this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx); // lod 0.***
				var vboKey = tinTerrain.vboKeyContainer.vboCacheKeysArray[0];
				if (vboKey.isReadyPositions(gl, this.vboMemoryManager) && vboKey.isReadyTexCoords(gl, this.vboMemoryManager) && vboKey.isReadyFaces(gl, this.vboMemoryManager))
				{ 
					// Positions.***
					gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshVertexCacheKey);
					gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
					
					// TexCoords.***
					gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshTexcoordsCacheKey);
					gl.vertexAttribPointer(currentShader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
					
					var indicesCount = vboKey.indicesCount;

					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboKey.meshFacesCacheKey);
					
					if (renderWireframe)
					{
						var trianglesCount = indicesCount;
						for (var i=0; i<trianglesCount; i++)
						{
							gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i*3); // Fill.***
						}
					}
					else
					{
						gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
						/*
						gl.disableVertexAttribArray(currentShader.texCoord2_loc);
						gl.uniform1i(currentShader.hasTexture_loc, false); //.***
						gl.uniform4fv(currentShader.oneColor4_loc, [0.0, 0.0, 0.0, 1.0]);
						gl.drawElements(gl.LINES, indicesCount, gl.UNSIGNED_SHORT, 0); // Wireframe.***
						
						gl.enableVertexAttribArray(currentShader.texCoord2_loc);
						gl.uniform1i(currentShader.hasTexture_loc, true); //.***
						*/
					}
				}
			}
			
			if (currentShader)
			{
				if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
				if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
				if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
				if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			}
		}
		
		// test renders.***
		// render cctv.***
		var cctvsCount = this.cctvList.getCCTVCount();
		if (cctvsCount > 0)
		{
			currentShader = this.postFxShadersManager.getShader("modelRefSsao"); 
			shaderProgram = currentShader.program;
				
			gl.useProgram(shaderProgram);
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, false);
			gl.disableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
				
			currentShader.bindUniformGenerals();
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, this.textureAux_1x1);
				
			this.renderer.renderTexture = false;
			var currTime = new Date().getTime();
				
			
			for (var i=0; i<cctvsCount; i++)
			{
				var cctv = this.cctvList.getCCTV(i);
				cctv.updateHeading(currTime);
				cctv.render(gl, this, currentShader);
				
			}
			
			if (this.isFarestFrustum())
			{
				this.drawCCTVNames(this.cctvList.camerasList);
			}
		}
		
		// PointsCloud.****************************************************************************************
		// PointsCloud.****************************************************************************************
		var nodesPCloudCount = this.visibleObjControlerNodes.currentVisiblesAux.length;
		if (nodesPCloudCount > 0)
		{
			currentShader = this.postFxShadersManager.getShader("pointsCloud");

			shaderProgram = currentShader.program;
		
			gl.useProgram(shaderProgram);

			gl.enableVertexAttribArray(currentShader.position3_loc);
			//gl.disableVertexAttribArray(currentShader.normal3_loc); // provisionally has no normals.***
			gl.enableVertexAttribArray(currentShader.color4_loc);
			
			currentShader.bindUniformGenerals();
			/*
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, this.textureAux_1x1);
			*/

			this.renderer.renderNeoBuildingsPCloud(gl, this.visibleObjControlerNodes.currentVisiblesAux, this, currentShader, renderTexture, ssao_idx); // lod0.***
			
			if (currentShader)
			{
				if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
				if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
				if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
				if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			}
			/*
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, null);
			*/
		}
	
		
	}
	
	
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}

	gl.depthRange(0.0, 1.0);	
};

/**
 * Draw building names on scene.
 */
MagoManager.prototype.drawCCTVNames = function(cctvArray) 
{
	var canvas = document.getElementById("objectLabel");
	if (canvas === undefined)
	{ return; }
	
	canvas.style.opacity = 1.0;
	canvas.width = this.sceneState.drawingBufferWidth;
	canvas.height = this.sceneState.drawingBufferHeight;
	var ctx = canvas.getContext("2d");
	//ctx.strokeStyle = 'SlateGrey';
	//ctx.strokeStyle = 'MidnightBlue';
	ctx.strokeStyle = 'DarkSlateGray'; 
	//ctx.fillStyle= "white";
	ctx.fillStyle= "PapayaWhip";
	ctx.lineWidth = 4;
	ctx.font = "20px Arial";
	ctx.textAlign = 'center';
	//ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.save();
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	var lineHeight = ctx.measureText("M").width * 1.1;

	// lod2.
	var gl = this.sceneState.gl;
	var node;
	var nodeRoot;
	var geoLocDataManager;
	var geoLoc;
	var neoBuilding;
	var worldPosition;
	var screenCoord;
	var cctv;
	
	var cctvCount = cctvArray.length;
	for (var i=0; i<cctvCount; i++)
	{
		cctv = cctvArray[i];
		geoLoc = cctv.geoLocationData;
		worldPosition = geoLoc.position;
		screenCoord = this.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord);
		//screenCoord.x += 250;
		//screenCoord.y += 150;
		
		if (screenCoord.x >= 0 && screenCoord.y >= 0)
		{
			ctx.font = "13px Arial";
			ctx.strokeText(cctv.name, screenCoord.x, screenCoord.y);
			ctx.fillText(cctv.name, screenCoord.x, screenCoord.y);
		}
		
	}

	ctx.restore();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.renderRenderables = function(gl, cameraPosition, shader, renderTexture, ssao_idx, visibleObjControlerNodes) 
{
	// ssao_idx = -1 -> pickingMode.***
	// ssao_idx = 0 -> depth.***
	// ssao_idx = 1 -> ssao.***
	gl.frontFace(gl.CCW);
	gl.depthRange(0.0, 1.0);	
	gl.enable(gl.DEPTH_TEST);
	
	var currentShader;
	var shaderProgram;
	var neoBuilding;
	var node;
	var rootNode;
	var geoLocDataManager;

	renderTexture = false;
	//var lowestOctreeLegosParsingCount = 0;

	if (ssao_idx === 0) 
	{
		gl.disable(gl.BLEND);
		this.depthRenderLowestOctreeAsimetricVersion(gl, ssao_idx, visibleObjControlerNodes);
		// draw the axis.***
		if (this.magoPolicy.getShowOrigin() && this.nodeSelected !== undefined)
		{
			node = this.nodeSelected;
			var nodes = [node];
			
			this.renderAxisNodes(gl, nodes, true, ssao_idx);
		}
	}
	if (ssao_idx === 1) 
	{
		// ssao render.************************************************************************************************************
		var nodesLOD0Count = visibleObjControlerNodes.currentVisibles0.length;

		if (nodesLOD0Count > 0)
		{
			// check changesHistory.
			this.checkChangesHistoryMovements(visibleObjControlerNodes.currentVisibles0);
			this.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles0);
		
			if (this.noiseTexture === undefined) 
			{ this.noiseTexture = genNoiseTextureRGBA(gl, 4, 4, this.pixels); }
			
			currentShader = this.postFxShadersManager.getShader("modelRefSsao"); 
			shaderProgram = currentShader.program;
			
			gl.useProgram(shaderProgram);
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, false);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			
			currentShader.bindUniformGenerals();
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
			
			// 1) LOD0 & LOD1.*********************************************************************************************************************
			var refTMatrixIdxKey = 0;
			var minSize = 0.0;
			var renderTexture;
			//if (this.isLastFrustum)
			{
				this.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx, minSize, refTMatrixIdxKey);
			}
			
			if (currentShader)
			{
				if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
				if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
				if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
				if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			}
			
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
		
		// 2) LOD 2, 3, 4, 5.************************************************************************************************************************************
		var nodesLOD2Count = visibleObjControlerNodes.currentVisibles2.length;
		var nodesLOD3Count = visibleObjControlerNodes.currentVisibles3.length;
		if (nodesLOD2Count > 0 || nodesLOD0Count > 0 || nodesLOD3Count>0)
		{
			this.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles2);

			// lodBuildingSsaoSimpleCompressed
			currentShader = this.postFxShadersManager.getShader("lodBuildingSsao");

			shaderProgram = currentShader.program;
		
			gl.useProgram(shaderProgram);
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, false);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			gl.enableVertexAttribArray(currentShader.color4_loc);
			
			currentShader.bindUniformGenerals();
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, this.textureAux_1x1);
			
			this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx); // lod 0.***
			this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles2, this, currentShader, renderTexture, ssao_idx); // lod 2.***
			this.renderer.renderNeoBuildingsLowLOD(gl, visibleObjControlerNodes.currentVisibles3, this, currentShader, renderTexture, ssao_idx); // lod 3, 4, 5.***
			
			if (currentShader)
			{
				if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
				if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
				if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
				if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			}
			
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, null);
		}

		// If there are an object selected, then there are a stencilBuffer.******************************************
		if (this.nodeSelected) // if there are an object selected then there are a building selected.***
		{
			if (this.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && this.objectSelected)
			{
				node = this.nodeSelected;
				var geoLocDataManager = this.getNodeGeoLocDataManager(node);
				neoBuilding = this.buildingSelected;
				var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
				var neoReferencesMotherAndIndices = this.octreeSelected.neoReferencesMotherAndIndices;
				var glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				var maxSizeToRender = 0.0;
				var refMatrixIdxKey = 0;
				
				// do as the "getSelectedObjectPicking".**********************************************************
				currentShader = this.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
				var shaderProgram = currentShader.program;
				gl.useProgram(shaderProgram);
				
				gl.enableVertexAttribArray(currentShader.position3_loc);
				
				gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
				gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
				gl.uniformMatrix4fv(currentShader.ModelViewMatrixRelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays);
				gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
				gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);
				
				// do the colorCoding render.***
				// position uniforms.***
				gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
				gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
				
				gl.uniform4fv(currentShader.color4Aux_loc, [0.0, 1.0, 0.0, 1.0]);
				gl.uniform2fv(currentShader.screenSize_loc, [this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight]);
				gl.uniformMatrix4fv(currentShader.ProjectionMatrix_loc, false, this.sceneState.projectionMatrix._floatArrays);
				
				gl.enable(gl.STENCIL_TEST);
				gl.disable(gl.POLYGON_OFFSET_FILL);
				gl.disable(gl.CULL_FACE);
				gl.disable(gl.DEPTH_TEST);
				gl.depthRange(0, 0);
				
				gl.stencilFunc(gl.EQUAL, 0, 1);
				gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
					
				//glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				//gl.polygonMode( gl.FRONT_AND_BACK, gl.LINE );
				
				var offsetSize = 3/1000;
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, offsetSize]);
				this.renderer.renderNeoReferenceAsimetricVersionColorSelection(gl, this.objectSelected, neoReferencesMotherAndIndices, neoBuilding, this, currentShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, offsetSize]);
				this.renderer.renderNeoReferenceAsimetricVersionColorSelection(gl, this.objectSelected, neoReferencesMotherAndIndices, neoBuilding, this, currentShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, -offsetSize]);
				this.renderer.renderNeoReferenceAsimetricVersionColorSelection(gl, this.objectSelected, neoReferencesMotherAndIndices, neoBuilding, this, currentShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
				gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, -offsetSize]);
				this.renderer.renderNeoReferenceAsimetricVersionColorSelection(gl, this.objectSelected, neoReferencesMotherAndIndices, neoBuilding, this, currentShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
				gl.enable(gl.DEPTH_TEST);// return to the normal state.***
				gl.disable(gl.STENCIL_TEST);
				gl.depthRange(0, 1);// return to the normal value.***
				gl.disableVertexAttribArray(currentShader.position3_loc);
				
				if (currentShader)
				{
					if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
					if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
					if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
					if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
				}
			}
			
			// render bbox for neoBuildingSelected. // old.***
			/*
			var selectedNodesArray = [];
			selectedNodesArray.push(this.nodeSelected);
			if (this.colorSC === undefined)
			{ this.colorSC = new Color(); }
			this.colorSC.setRGB(0.8, 1.0, 1.0);
			this.renderBoundingBoxesNodes(gl, selectedNodesArray, this.colorSC); // old.
			*/
			
			// new. Render the silhouette by lod3 or lod4 or lod5 mesh***
			if (this.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && this.buildingSelected)
			{
				node = this.nodeSelected;
				var geoLocDataManager = this.getNodeGeoLocDataManager(node);
				neoBuilding = this.buildingSelected;
				var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
				//var neoReferencesMotherAndIndices = this.octreeSelected.neoReferencesMotherAndIndices;
				var glPrimitive = gl.POINTS;
				glPrimitive = gl.TRIANGLES;
				var maxSizeToRender = 0.0;
				var refMatrixIdxKey = 0;
				var skinLego = neoBuilding.getCurrentSkin();
				if (skinLego !== undefined)
				{
					// do as the "getSelectedObjectPicking".**********************************************************
					currentShader = this.postFxShadersManager.getModelRefSilhouetteShader(); // silhouette shader.***
					var shaderProgram = currentShader.program;
					gl.useProgram(shaderProgram);
					
					gl.enableVertexAttribArray(currentShader.position3_loc);
					
					gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
					gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
					gl.uniformMatrix4fv(currentShader.ModelViewMatrixRelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays);
					gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
					gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);
					
					// do the colorCoding render.***
					// position uniforms.***
					gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
					gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
					
					gl.uniform4fv(currentShader.color4Aux_loc, [0.0, 1.0, 0.0, 1.0]);
					gl.uniform2fv(currentShader.screenSize_loc, [this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight]);
					gl.uniformMatrix4fv(currentShader.ProjectionMatrix_loc, false, this.sceneState.projectionMatrix._floatArrays);
					
					gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
					
					gl.enable(gl.STENCIL_TEST);
					gl.disable(gl.POLYGON_OFFSET_FILL);
					gl.disable(gl.CULL_FACE);
					gl.disable(gl.DEPTH_TEST);
					gl.depthRange(0, 0);
					
					gl.stencilFunc(gl.EQUAL, 0, 1);
					//gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
					gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
						
					//glPrimitive = gl.POINTS;
					glPrimitive = gl.TRIANGLES;
					gl.uniform1i(currentShader.refMatrixType_loc, 0); // 0 = identity matrix.***
					//gl.polygonMode( gl.FRONT_AND_BACK, gl.LINE );

					
					var offsetSize = 4/1000;
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, offsetSize]);
					this.renderer.renderLodBuildingColorSelection(gl, skinLego, this, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, offsetSize]);
					this.renderer.renderLodBuildingColorSelection(gl, skinLego, this, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [offsetSize, -offsetSize]);
					this.renderer.renderLodBuildingColorSelection(gl, skinLego, this, currentShader);
					gl.uniform2fv(currentShader.camSpacePixelTranslation_loc, [-offsetSize, -offsetSize]);
					this.renderer.renderLodBuildingColorSelection(gl, skinLego, this, currentShader);
					gl.enable(gl.DEPTH_TEST);// return to the normal state.***
					gl.disable(gl.STENCIL_TEST);
					gl.depthRange(0, 1);// return to the normal value.***
					gl.disableVertexAttribArray(currentShader.position3_loc);
					
					if (currentShader)
					{
						if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
						if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
						if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
						if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
					}
				}
				
			}
			
			// draw the axis.***
			if (this.magoPolicy.getShowOrigin())
			{
				node = this.nodeSelected;
				//var geoLocDataManager = this.getNodeGeoLocDataManager(node);
				var nodes = [node];
				
				this.renderAxisNodes(gl, nodes, true, ssao_idx);
			}
		}
		
		// 3) now render bboxes.*******************************************************************************************************************
		if (this.magoPolicy.getShowBoundingBox())
		{
			var bRenderLines = true;
			this.renderBoundingBoxesNodes(gl, this.visibleObjControlerNodes.currentVisibles0, undefined, bRenderLines);
			this.renderBoundingBoxesNodes(gl, this.visibleObjControlerNodes.currentVisibles2, undefined, bRenderLines);
		}
		
		// 4) Render ObjectMarkers.********************************************************************************************************
		// 4) Render ObjectMarkers.********************************************************************************************************
		// 4) Render ObjectMarkers.********************************************************************************************************
		var objectsMarkersCount = this.objMarkerManager.objectMarkerArray.length;
		if (objectsMarkersCount > 0)
		{
			// now repeat the objects markers for png images.***
			// Png for pin image 128x128.********************************************************************
			if (this.pin.positionBuffer === undefined)
			{ this.pin.createPinCenterBottom(gl); }
			
			currentShader = this.postFxShadersManager.pFx_shaders_array[13]; // png image shader.***
			
			shaderProgram = currentShader.program;
			
			gl.useProgram(shaderProgram);
			gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
			gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
			gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);
			gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, this.sceneState.modelViewRelToEyeMatrixInv._floatArrays);
			
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis); 
			// Tell the shader to get the texture from texture unit 0
			gl.uniform1i(currentShader.texture_loc, 0);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.activeTexture(gl.TEXTURE0);
			
			gl.depthRange(0, 0);
			//var context = document.getElementById('canvas2').getContext("2d");
			//var canvas = document.getElementById("magoContainer");
			
			gl.bindBuffer(gl.ARRAY_BUFFER, this.pin.positionBuffer);
			gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, this.pin.texcoordBuffer);
			gl.vertexAttribPointer(currentShader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
			var j=0;
			for (var i=0; i<objectsMarkersCount; i++)
			{
				if (j>= this.pin.texturesArray.length)
				{ j=0; }
				
				var currentTexture = this.pin.texturesArray[j];
				var objMarker = this.objMarkerManager.objectMarkerArray[i];
				var objMarkerGeoLocation = objMarker.geoLocationData;
				gl.bindTexture(gl.TEXTURE_2D, currentTexture.texId);
				gl.uniform3fv(currentShader.buildingPosHIGH_loc, objMarkerGeoLocation.positionHIGH);
				gl.uniform3fv(currentShader.buildingPosLOW_loc, objMarkerGeoLocation.positionLOW);

				gl.drawArrays(gl.TRIANGLES, 0, 6);
				
				j++;
			}
			gl.depthRange(0, 1);
			gl.useProgram(null);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.disableVertexAttribArray(currentShader.texCoord2_loc);
			gl.disableVertexAttribArray(currentShader.position3_loc);
			
		}
		
		// Test TinTerrain.**************************************************************************
		// Test TinTerrain.**************************************************************************
		//this.tinTerrainManager
		
		if (this.tinTerrainManager !== undefined)
		{
			
			currentShader = this.postFxShadersManager.getShader("tinTerrain");
			shaderProgram = currentShader.program;
		
			gl.useProgram(shaderProgram);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			//gl.disableVertexAttribArray(currentShader.normal3_loc);
			//gl.disableVertexAttribArray(currentShader.color4_loc);
			
			currentShader.bindUniformGenerals();

			var tex = this.pin.texturesArray[4];
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, tex.texId);
			
			gl.uniform1i(currentShader.hasTexture_loc, true); //.***
			gl.uniform4fv(currentShader.oneColor4_loc, [0.5, 0.5, 0.5, 1.0]);
			
			var renderWireframe = false;
			var tinTerrain;
			var currentTerrainsMap = this.tinTerrainManager.currentTerrainsMap;
			var currentVisiblesTerrainsMap = this.tinTerrainManager.currentVisibles_terrName_geoCoords_map;
			for (var key in currentVisiblesTerrainsMap)
			{
				//currentVisiblesTerrainsMap
				tinTerrain = currentTerrainsMap[key];
				if (tinTerrain === undefined)
				{ continue; }
				
				if (tinTerrain.vboKeyContainer === undefined || tinTerrain.vboKeyContainer.vboCacheKeysArray.length === 0)
				{ continue; }
				
				// check the texture of the terrain.***
				if (tinTerrain.texture === undefined)
				{
					tinTerrain.texture = new Texture();
					var imagesDataPath = "\\images\\ko";
					var textureFilePath = imagesDataPath +  "\\funny_" + tinTerrain.depth + ".jpg";
					this.readerWriter.readLegoSimpleBuildingTexture(gl, textureFilePath, tinTerrain.texture, this);
					continue;
				}
				
				gl.bindTexture(gl.TEXTURE_2D, tinTerrain.texture.texId);
				
				gl.uniform3fv(currentShader.buildingPosHIGH_loc, tinTerrain.terrainPositionHIGH);
				gl.uniform3fv(currentShader.buildingPosLOW_loc, tinTerrain.terrainPositionLOW);
				
				//this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx); // lod 0.***
				var vboKey = tinTerrain.vboKeyContainer.vboCacheKeysArray[0];
				if (vboKey.isReadyPositions(gl, this.vboMemoryManager) && vboKey.isReadyTexCoords(gl, this.vboMemoryManager) && vboKey.isReadyFaces(gl, this.vboMemoryManager))
				{ 
					// Positions.***
					gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshVertexCacheKey);
					gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
					
					// TexCoords.***
					gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshTexcoordsCacheKey);
					gl.vertexAttribPointer(currentShader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
					
					var indicesCount = vboKey.indicesCount;

					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboKey.meshFacesCacheKey);
					
					if (renderWireframe)
					{
						var trianglesCount = indicesCount;
						for (var i=0; i<trianglesCount; i++)
						{
							gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i*3); // Fill.***
						}
					}
					else
					{
						gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
						//gl.drawElements(gl.LINES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
					}
				}
			}
			
			if (currentShader)
			{
				if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
				if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
				if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
				if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			}
		}
		
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}

};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.renderBoundingBoxesNodes = function(gl, nodesArray, color, bRenderLines) 
{
	var node;
	var currentShader = this.postFxShadersManager.getTriPolyhedronShader(); // box ssao.***
	var shaderProgram = currentShader.program;
	gl.enable(gl.BLEND);
	gl.frontFace(gl.CCW);
	gl.useProgram(shaderProgram);
	gl.enableVertexAttribArray(currentShader.position3_loc);
	gl.enableVertexAttribArray(currentShader.normal3_loc);
	gl.disableVertexAttribArray(currentShader.color4_loc);

	gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, this.sceneState.modelViewMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, this.sceneState.projectionMatrix._floatArrays);
	gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
	gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);

	gl.uniform1f(currentShader.near_loc, this.sceneState.camera.frustum.near);
	gl.uniform1f(currentShader.far_loc, this.sceneState.camera.frustum.far);
	
	gl.uniform1i(currentShader.bApplySsao_loc, false);

	gl.uniformMatrix4fv(currentShader.normalMatrix4_loc, false, this.sceneState.normalMatrix4._floatArrays);
	//-----------------------------------------------------------------------------------------------------------

	gl.uniform1i(currentShader.hasAditionalMov_loc, true);
	gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
	gl.uniform1i(currentShader.bScale_loc, true);
	var alfa = 1.0;
	gl.uniform1i(currentShader.bUse1Color_loc, true);
	if (color)
	{
		gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, alfa]); //.***
	}
	else 
	{
		gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.0, 1.0, alfa]); //.***
	}

	gl.uniform1i(currentShader.depthTex_loc, 0);
	gl.uniform1i(currentShader.noiseTex_loc, 1);
	gl.uniform1i(currentShader.diffuseTex_loc, 2); // no used.***
	gl.uniform1f(currentShader.fov_loc, this.sceneState.camera.frustum.fovyRad);	// "frustum._fov" is in radians.***
	gl.uniform1f(currentShader.aspectRatio_loc, this.sceneState.camera.frustum.aspectRatio);
	gl.uniform1f(currentShader.screenWidth_loc, this.sceneState.drawingBufferWidth);	
	gl.uniform1f(currentShader.screenHeight_loc, this.sceneState.drawingBufferHeight);


	gl.uniform2fv(currentShader.noiseScale2_loc, [this.depthFboNeo.width/this.noiseTexture.width, this.depthFboNeo.height/this.noiseTexture.height]);
	gl.uniform3fv(currentShader.kernel16_loc, this.kernel);
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);

	var neoBuilding;
	var ssao_idx = 1;
	var nodesCount = nodesArray.length;
	for (var b=0; b<nodesCount; b++)
	{
		node = nodesArray[b];
		neoBuilding = node.data.neoBuilding;

		gl.uniform3fv(currentShader.scale_loc, [neoBuilding.bbox.getXLength(), neoBuilding.bbox.getYLength(), neoBuilding.bbox.getZLength()]); //.***
		var buildingGeoLocation = this.getNodeGeoLocDataManager(node).getCurrentGeoLocationData();
		gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);

		this.pointSC = neoBuilding.bbox.getCenterPoint(this.pointSC);
		gl.uniform3fv(currentShader.aditionalMov_loc, [this.pointSC.x, this.pointSC.y, this.pointSC.z]); //.***
		//gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		this.renderer.renderObject(gl, this.unitaryBoxSC, this, currentShader, ssao_idx, bRenderLines);
	}
	
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.renderAxisNodes = function(gl, nodesArray, bRenderLines, ssao_idx) 
{
	if (this.axisXYZ.vbo_vicks_container.vboCacheKeysArray.length === 0)
	{ 
		var mesh = this.axisXYZ.makeMesh(30); 
		mesh.getVbo(this.axisXYZ.vbo_vicks_container);
	}
	
	var gl = this.sceneState.gl;
	var color;
	var node;
	var currentShader;
	if (ssao_idx === 0)
	{
		currentShader = this.postFxShadersManager.getTriPolyhedronDepthShader(); // triPolyhedron ssao.***
		gl.disable(gl.BLEND);
	}
	if (ssao_idx === 1)
	{
		currentShader = this.postFxShadersManager.getTriPolyhedronShader(); // triPolyhedron ssao.***
		gl.enable(gl.BLEND);
	}
	
	var shaderProgram = currentShader.program;
	
	gl.frontFace(gl.CCW);
	gl.useProgram(shaderProgram);
	gl.enableVertexAttribArray(currentShader.position3_loc);
	
	gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
	
	gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
	gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);

	gl.uniform1f(currentShader.near_loc, this.sceneState.camera.frustum.near);
	gl.uniform1f(currentShader.far_loc, this.sceneState.camera.frustum.far);
	
	gl.uniform1i(currentShader.bApplySsao_loc, true);

	gl.uniformMatrix4fv(currentShader.normalMatrix4_loc, false, this.sceneState.normalMatrix4._floatArrays);
	//-----------------------------------------------------------------------------------------------------------
		
	if (ssao_idx === 1)
	{
		// provisionally render all native projects.***
		gl.enableVertexAttribArray(currentShader.normal3_loc);
		gl.enableVertexAttribArray(currentShader.color4_loc);

		gl.uniform1i(currentShader.bUse1Color_loc, false);
		if (color)
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, 1.0]); //.***
		}
		else 
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.***
		}
		
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, this.sceneState.modelViewMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, this.sceneState.projectionMatrix._floatArrays);

		gl.uniform1i(currentShader.depthTex_loc, 0);
		gl.uniform1i(currentShader.noiseTex_loc, 1);
		gl.uniform1i(currentShader.diffuseTex_loc, 2); // no used.***
		gl.uniform1f(currentShader.fov_loc, this.sceneState.camera.frustum.fovyRad);	// "frustum._fov" is in radians.***
		gl.uniform1f(currentShader.aspectRatio_loc, this.sceneState.camera.frustum.aspectRatio);
		gl.uniform1f(currentShader.screenWidth_loc, this.sceneState.drawingBufferWidth);	
		gl.uniform1f(currentShader.screenHeight_loc, this.sceneState.drawingBufferHeight);


		gl.uniform2fv(currentShader.noiseScale2_loc, [this.depthFboNeo.width/this.noiseTexture.width, this.depthFboNeo.height/this.noiseTexture.height]);
		gl.uniform3fv(currentShader.kernel16_loc, this.kernel);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
	}
	
	var neoBuilding;
	var natProject, mesh;
	var geoLocDataManager;
	var buildingGeoLocation;
	var nodesCount = nodesArray.length;
	for (var b=0; b<nodesCount; b++)
	{
		node = nodesArray[b];
		neoBuilding = node.data.neoBuilding;

		gl.uniform3fv(currentShader.scale_loc, [1, 1, 1]); //.***
		var buildingGeoLocation = this.getNodeGeoLocDataManager(node).getCurrentGeoLocationData();
		//buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		
		gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(currentShader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(currentShader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
		gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
		this.renderer.renderObject(gl, this.axisXYZ, this, currentShader, ssao_idx);
	}
	
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.depthRenderLowestOctreeAsimetricVersion = function(gl, ssao_idx, visibleObjControlerNodes) 
{
	// ssao_idx = -1 -> pickingMode.***
	// ssao_idx = 0 -> depth.***
	// ssao_idx = 1 -> ssao.***
	var currentShader;
	var shaderProgram;
	var renderTexture = false;
	
	var nodesLOD0Count = visibleObjControlerNodes.currentVisibles0.length;
	if (nodesLOD0Count > 0)
	{
		// LOD 0. Render detailed.***
		currentShader = this.postFxShadersManager.pFx_shaders_array[3]; // neo depth.***
		shaderProgram = currentShader.program;

		gl.useProgram(shaderProgram);
		gl.enableVertexAttribArray(currentShader.position3_loc);

		gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, this.sceneState.modelViewMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, this.sceneState.projectionMatrix._floatArrays);
		gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
		gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);

		gl.uniform1f(currentShader.near_loc, this.sceneState.camera.frustum.near);
		gl.uniform1f(currentShader.far_loc, this.sceneState.camera.frustum.far);

		// renderDepth for all buildings.***
		// 1) LOD 0 & LOD1.*********************************************************************************************************************
		var refTMatrixIdxKey = 0;
		var minSize = 0.0;
		//if (this.isLastFrustum)
		{
			this.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx, minSize, 0, refTMatrixIdxKey);
		}
		
		if (currentShader.position3_loc !== -1)
		{ gl.disableVertexAttribArray(currentShader.position3_loc); }
	}
	
	// 2) LOD 2 .************************************************************************************************************************************
	var nodesLOD2Count = visibleObjControlerNodes.currentVisibles2.length;
	if (nodesLOD2Count > 0 || nodesLOD0Count > 0)
	{
		currentShader = this.postFxShadersManager.pFx_shaders_array[7]; // lodBuilding depth.***
		shaderProgram = currentShader.program;
		gl.useProgram(shaderProgram);
		gl.enableVertexAttribArray(currentShader.position3_loc);

		gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, this.sceneState.modelViewMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, this.sceneState.projectionMatrix._floatArrays);
		gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
		gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);

		gl.uniform1f(currentShader.near_loc, this.sceneState.camera.frustum.near);
		gl.uniform1f(currentShader.far_loc, this.sceneState.camera.frustum.far);

		gl.uniform1i(currentShader.hasAditionalMov_loc, true);
		gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
		this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx);
		this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles2, this, currentShader, renderTexture, ssao_idx);

		if (currentShader.position3_loc !== -1)
		{ gl.disableVertexAttribArray(currentShader.position3_loc); }
	}
	
	// 3) LOD3, LOD4, LOD5.*************************************************************************************************************************
	var nodesLOD3Count = visibleObjControlerNodes.currentVisibles3.length;
	if (nodesLOD3Count > 0)
	{
		currentShader = this.postFxShadersManager.pFx_shaders_array[7]; // lodBuilding depth.***
		shaderProgram = currentShader.program;
		gl.useProgram(shaderProgram);
		gl.enableVertexAttribArray(currentShader.position3_loc);

		gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, this.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, this.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
		gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, this.sceneState.modelViewMatrix._floatArrays);
		gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, this.sceneState.projectionMatrix._floatArrays);
		gl.uniform3fv(currentShader.cameraPosHIGH_loc, this.sceneState.encodedCamPosHigh);
		gl.uniform3fv(currentShader.cameraPosLOW_loc, this.sceneState.encodedCamPosLow);

		gl.uniform1f(currentShader.near_loc, this.sceneState.camera.frustum.near);
		gl.uniform1f(currentShader.far_loc, this.sceneState.camera.frustum.far);

		gl.uniform1i(currentShader.hasAditionalMov_loc, true);
		gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
		this.renderer.renderNeoBuildingsLowLOD(gl, visibleObjControlerNodes.currentVisibles3, this, currentShader, renderTexture, ssao_idx);

		if (currentShader.position3_loc !== -1)
		{ gl.disableVertexAttribArray(currentShader.position3_loc); }
	}
	
	// tin terrain.***
	if (this.tinTerrainManager !== undefined)
	{
		currentShader = this.postFxShadersManager.getShader("tinTerrain");
		shaderProgram = currentShader.program;
		
		gl.useProgram(shaderProgram);
		gl.enableVertexAttribArray(currentShader.position3_loc);
		gl.disableVertexAttribArray(currentShader.texCoord2_loc);
		//gl.disableVertexAttribArray(currentShader.normal3_loc);
		//gl.disableVertexAttribArray(currentShader.color4_loc);
		
		currentShader.bindUniformGenerals();

		var tex = this.pin.texturesArray[4];
		gl.activeTexture(gl.TEXTURE2); 
		gl.bindTexture(gl.TEXTURE_2D, tex.texId);
		
		gl.uniform1i(currentShader.bIsMakingDepth_loc, true); //.***
		gl.uniform1i(currentShader.hasTexture_loc, true); //.***
		gl.uniform4fv(currentShader.oneColor4_loc, [0.5, 0.5, 0.5, 1.0]);
		
		//gl.enable(gl.POLYGON_OFFSET_FILL);
		//gl.polygonOffset(1, 3);
		
		var renderWireframe = false;
		var tinTerrain;
		var currentTerrainsMap = this.tinTerrainManager.currentTerrainsMap;
		var currentVisiblesTerrainsMap = this.tinTerrainManager.currentVisibles_terrName_geoCoords_map;
		for (var key in currentVisiblesTerrainsMap)
		{
			//currentVisiblesTerrainsMap
			tinTerrain = currentTerrainsMap[key];
			if (tinTerrain === undefined)
			{ continue; }
			
			if (tinTerrain.vboKeyContainer === undefined || tinTerrain.vboKeyContainer.vboCacheKeysArray.length === 0)
			{ continue; }

			// check the texture of the terrain.***
			//if (tinTerrain.texture === undefined)
			//{
			//	tinTerrain.texture = new Texture();
			//	var imagesDataPath = "\\images\\ko";
			//	var textureFilePath = imagesDataPath +  "\\funny_" + tinTerrain.depth + ".jpg";
			//	this.readerWriter.readLegoSimpleBuildingTexture(gl, textureFilePath, tinTerrain.texture, this);
			//	continue;
			//}
			
			gl.uniform3fv(currentShader.buildingPosHIGH_loc, tinTerrain.terrainPositionHIGH);
			gl.uniform3fv(currentShader.buildingPosLOW_loc, tinTerrain.terrainPositionLOW);
			
			//this.renderer.renderNeoBuildingsLOD2AsimetricVersion(gl, visibleObjControlerNodes.currentVisibles0, this, currentShader, renderTexture, ssao_idx); // lod 0.***
			var vboKey = tinTerrain.vboKeyContainer.vboCacheKeysArray[0];
			if (vboKey.isReadyPositions(gl, this.vboMemoryManager) && vboKey.isReadyTexCoords(gl, this.vboMemoryManager) && vboKey.isReadyFaces(gl, this.vboMemoryManager))
			{ 
				// Positions.***
				gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshVertexCacheKey);
				gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
				
				var indicesCount = vboKey.indicesCount;

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboKey.meshFacesCacheKey);
				
				if (renderWireframe)
				{
					var trianglesCount = indicesCount;
					for (var i=0; i<trianglesCount; i++)
					{
						gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i*3); // Fill.***
					}
				}
				else
				{
					gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
					/*
					gl.disableVertexAttribArray(currentShader.texCoord2_loc);
					gl.uniform1i(currentShader.hasTexture_loc, false); //.***
					gl.uniform4fv(currentShader.oneColor4_loc, [0.0, 0.0, 0.0, 1.0]);
					gl.drawElements(gl.LINES, indicesCount, gl.UNSIGNED_SHORT, 0); // Wireframe.***
					
					gl.enableVertexAttribArray(currentShader.texCoord2_loc);
					gl.uniform1i(currentShader.hasTexture_loc, true); //.***
					*/
				}
			}
		}
		
		if (currentShader)
		{
			if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
			if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
			if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
			if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
		}
	}
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
MagoManager.prototype.createDefaultShaders = function(gl) 
{
	// here creates the necessary shaders for mago3d.***
	// 1) ModelReferences ssaoShader.******************************************************************************
	var shaderName = "modelRefSsao";
	var shader = this.postFxShadersManager.newShader(shaderName);
	var ssao_vs_source = ShaderSource.ModelRefSsaoVS;
	var ssao_fs_source = ShaderSource.ModelRefSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 2) LodBuilding ssaoShader.***********************************************************************************
	shaderName = "lodBuildingSsao";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.LodBuildingSsaoVS;
	ssao_fs_source = ShaderSource.LodBuildingSsaoFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 3) TinTerrain shader.****************************************************************************************
	shaderName = "tinTerrain";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.TinTerrainVS;
	ssao_fs_source = ShaderSource.TinTerrainFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	shader.bIsMakingDepth_loc = gl.getUniformLocation(shader.program, "bIsMakingDepth");
	
	// 4) PointsCloud shader.****************************************************************************************
	shaderName = "pointsCloud";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.PointCloudVS;
	ssao_fs_source = ShaderSource.PointCloudFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// pointsCloud shader locals.***
	shader.bPositionCompressed_loc = gl.getUniformLocation(shader.program, "bPositionCompressed");
	shader.minPosition_loc = gl.getUniformLocation(shader.program, "minPosition");
	shader.bboxSize_loc = gl.getUniformLocation(shader.program, "bboxSize");
	
	/*
	// 4) ModelReferences SimpleSsaoShader.******************************************************************************
	var shaderName = "modelRefSsaoSimple";
	var shader = this.postFxShadersManager.newShader(shaderName);
	var ssao_vs_source = ShaderSource.ModelRefSsaoSimpleVS;
	var ssao_fs_source = ShaderSource.ModelRefSsaoSimpleFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 5) LodBuilding SimpleSsaoShader.***********************************************************************************
	shaderName = "lodBuildingSsaoSimple";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.LodBuildingSsaoVS;
	ssao_fs_source = ShaderSource.LodBuildingSsaoSimpleFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	
	// 6) LodBuilding SimpleSsaoShader.***********************************************************************************
	shaderName = "lodBuildingSsaoSimpleCompressed";
	shader = this.postFxShadersManager.newShader(shaderName);
	ssao_vs_source = ShaderSource.LodBuildingSsaoSimpleCompressVS;
	ssao_fs_source = ShaderSource.LodBuildingSsaoSimpleCompressFS;
	
	shader.program = gl.createProgram();
	shader.shader_vertex = this.postFxShadersManager.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.postFxShadersManager.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, this.sceneState);
	shader.createUniformLocals(gl, shader, this.sceneState);
	*/
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */
MagoManager.prototype.renderLodBuilding = function(gl, cameraPosition, scene, shader, renderTexture, ssao_idx, lodBuilding) 
{
	// file loaded but not parsed.***
	if (lodBuilding.fileLoadState === CODE.fileLoadState.LOADING_FINISHED) 
	{
		lodBuilding.parseArrayBuffer(gl, this.readerWriter);
	}

	this.renderer.renderLodBuilding(gl, lodBuilding, this, shader, ssao_idx);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param scene 변수
 */
MagoManager.prototype.reCalculateModelViewProjectionRelToEyeMatrix = function(scene) 
{
	for (var i=0; i<16; i++) 
	{
		if (scene.context._us._modelView[i] === 0) { return; }
	}

	var modelViewRelToEye = new Cesium.Matrix4();
	modelViewRelToEye = Cesium.Matrix4.clone(scene.context._us._modelView);
	modelViewRelToEye[12] = 0.0;
	modelViewRelToEye[13] = 0.0;
	modelViewRelToEye[14] = 0.0;
	var modelViewProjectionRelToEye = new Cesium.Matrix4();
	Cesium.Matrix4.multiply(scene.context._us._projection, modelViewRelToEye, modelViewProjectionRelToEye);
	Cesium.Matrix4.toArray(modelViewProjectionRelToEye, this.modelViewProjRelToEye_matrix);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param neoVisibleBuildingsArray 변수
 * @param cameraPosition 변수
 * @returns neoVisibleBuildingsArray
 */
MagoManager.prototype.deleteNeoBuilding = function(gl, neoBuilding) 
{
	// check if the neoBuilding id the selected building.***
	var vboMemoryManager = this.vboMemoryManager;
	if (neoBuilding === this.buildingSelected)
	{
		this.buildingSelected = undefined;
		this.octreeSelected = undefined;
		this.objectSelected = undefined;
	}
	
	neoBuilding.deleteObjects(gl, vboMemoryManager);
	
};

/**
 * 카메라 영역에 벗어난 오브젝트의 렌더링은 비 활성화
 * 
 * @param frustumVolume 변수
 * @param cameraPosition 변수
 */
MagoManager.prototype.isFarestFrustum = function() 
{
	if (this.numFrustums - this.currentFrustumIdx - 1 === 0)
	{ return true; }
	else
	{ return false; }
};

/**
 * 카메라 영역에 벗어난 오브젝트의 렌더링은 비 활성화
 * 
 * @param frustumVolume 변수
 * @param cameraPosition 변수
 */
MagoManager.prototype.doMultiFrustumCullingSmartTiles = function(camera) 
{
	// Here uses a frustum that is the sum of all frustums.***
	var frustumVolume = this.myCameraSCX.bigFrustum;
	
	// This makes the visible buildings array.
	var smartTile1 = this.smartTileManager.tilesArray[0]; // America side tile.
	var smartTile2 = this.smartTileManager.tilesArray[1]; // Asia side tile.
	
	if (this.frustumVolumeControl === undefined)
	{ this.frustumVolumeControl = new FrustumVolumeControl(); }
	
	if (this.fullyIntersectedLowestTilesArray === undefined)
	{ this.fullyIntersectedLowestTilesArray = []; }

	if (this.partiallyIntersectedLowestTilesArray === undefined)
	{ this.partiallyIntersectedLowestTilesArray = []; }
	
	if (this.lastIntersectedLowestTilesArray === undefined)
	{ this.lastIntersectedLowestTilesArray = []; }
	
	// save the last frustumCulled lowestTiles to delete if necessary.
	this.lastIntersectedLowestTilesArray.push.apply(this.lastIntersectedLowestTilesArray, this.fullyIntersectedLowestTilesArray);
	this.lastIntersectedLowestTilesArray.push.apply(this.lastIntersectedLowestTilesArray, this.partiallyIntersectedLowestTilesArray);
	
	// mark all last_tiles as "no visible".
	var lastLowestTilesCount = this.lastIntersectedLowestTilesArray.length;
	var lowestTile;
	for (var i=0; i<lastLowestTilesCount; i++)
	{
		lowestTile = this.lastIntersectedLowestTilesArray[i];
		lowestTile.isVisible = false;
	}
	
	// do frustum culling for Asia_side_tile and America_side_tile.
	this.fullyIntersectedLowestTilesArray.length = 0; // init array.
	this.partiallyIntersectedLowestTilesArray.length = 0; // init array.
	smartTile1.getFrustumIntersectedLowestTiles(frustumVolume, this.fullyIntersectedLowestTilesArray, this.partiallyIntersectedLowestTilesArray);
	smartTile2.getFrustumIntersectedLowestTiles(frustumVolume, this.fullyIntersectedLowestTilesArray, this.partiallyIntersectedLowestTilesArray);
	
	// Now, store the culled tiles into corresponding frustums, and mark all current_tiles as "visible".***
	this.frustumVolumeControl.initArrays(); // init.***
	var frustumsCount = this.myCameraSCX.frustumsArray.length;
	var frustum;
	var lowestTile;
	var currentLowestTilesCount = this.fullyIntersectedLowestTilesArray.length;
	for (var i=0; i<currentLowestTilesCount; i++)
	{
		lowestTile = this.fullyIntersectedLowestTilesArray[i];
		if (lowestTile.sphereExtent === undefined)
		{ continue; }
		
		lowestTile.isVisible = true;
		for (var j=frustumsCount-1; j>= 0 ; j--)
		{
			frustum = this.myCameraSCX.frustumsArray[j];
			if (frustum.intersectionNearFarSphere(lowestTile.sphereExtent) !== Constant.INTERSECTION_OUTSIDE)
			{
				var frustumVolumeControlObject = this.frustumVolumeControl.getFrustumVolumeCulling(j); 
				frustumVolumeControlObject.fullyIntersectedLowestTilesArray.push(lowestTile);
				//break;
			}
		}
	}
	
	currentLowestTilesCount = this.partiallyIntersectedLowestTilesArray.length;
	for (var i=0; i<currentLowestTilesCount; i++)
	{
		lowestTile = this.partiallyIntersectedLowestTilesArray[i];
		if (lowestTile.sphereExtent === undefined)
		{ continue; }
		
		lowestTile.isVisible = true;
		for (var j=frustumsCount-1; j>= 0 ; j--)
		{
			frustum = this.myCameraSCX.frustumsArray[j];
			if (frustum.intersectionNearFarSphere(lowestTile.sphereExtent) !== Constant.INTERSECTION_OUTSIDE)
			{
				var frustumVolumeControlObject = this.frustumVolumeControl.getFrustumVolumeCulling(j); 
				frustumVolumeControlObject.partiallyIntersectedLowestTilesArray.push(lowestTile);
				//break;
			}
		}
	}
	
	// Now, delete all tiles that is no visible in the all frustumVolumes.***
	// Put to deleting queue.***
	var lastLowestTilesCount = this.lastIntersectedLowestTilesArray.length;
	var lowestTile;
	for (var i=0; i<lastLowestTilesCount; i++)
	{
		lowestTile = this.lastIntersectedLowestTilesArray[i];
		if (!lowestTile.isVisible)
		{
			this.processQueue.putNodesArrayToDelete(lowestTile.nodesArray);
			lowestTile.clearNodesArray();
		}
	}
	
	this.lastIntersectedLowestTilesArray.length = 0;
	
	
	// Test.*** Test.*** Test.*** Test.*** Test.*** Test.*** Test.*** Test.*** Test.*** Test.*** Test.*** Test.***
	/*
	var maxDepth = 15;
	delete this.tinTerrainManager.currentVisibles_terrName_geoCoords_map; // init map.***
	this.tinTerrainManager.currentVisibles_terrName_geoCoords_map = {}; // init map.***
	SmartTile.getFrustumIntersectedTilesNames(frustumVolume, maxDepth, camera.position, this, this.tinTerrainManager.currentVisibles_terrName_geoCoords_map);
	*/
};

/**
 * dataKey 이용해서 data 검색
 * @param dataKey
 */
MagoManager.prototype.tilesMultiFrustumCullingFinished = function(intersectedLowestTilesArray, visibleNodes, cameraPosition, frustumVolume, doFrustumCullingToBuildings) 
{
	var tilesCount = intersectedLowestTilesArray.length;
	
	if (tilesCount === 0)
	{ return; }
	
	var distToCamera;
	
	var lod0_minDist = this.magoPolicy.getLod1DistInMeters();
	var lod1_minDist = 1;
	var lod2_minDist = this.magoPolicy.getLod2DistInMeters();
	var lod5_minDist = this.magoPolicy.getLod5DistInMeters();
	var lod3_minDist;
	
	// get lodDistances for determine the real lod of the building.***
	var lod0Dist = this.magoPolicy.getLod0DistInMeters();
	var lod1Dist = this.magoPolicy.getLod1DistInMeters();
	var lod2Dist = this.magoPolicy.getLod2DistInMeters();
	var lod3Dist = this.magoPolicy.getLod3DistInMeters();
	var lod4Dist = this.magoPolicy.getLod4DistInMeters();
	var lod5Dist = this.magoPolicy.getLod5DistInMeters();

	var maxNumberOfCalculatingPositions = 100;
	var currentCalculatingPositionsCount = 0;
	
	var lowestTile;
	var buildingSeedsCount;
	var buildingSeed;
	var neoBuilding;
	var node;
	var nodeRoot;
	var nodeBbox;
	var geoLoc;
	var geoLocDataManager;
	var realBuildingPos;
	var longitude, latitude, altitude, heading, pitch, roll;

	for (var i=0; i<tilesCount; i++)
	{
		lowestTile = intersectedLowestTilesArray[i];
		if (lowestTile.sphereExtent === undefined)
		{ continue; }
	
		distToCamera = cameraPosition.distToSphere(lowestTile.sphereExtent);
		if (distToCamera > Number(lod5_minDist))
		{ continue; }

		if (lowestTile.nodesArray && lowestTile.nodesArray.length > 0)
		{
			// the neoBuildings is made.
			var nodesCount = lowestTile.nodesArray.length;
			for (var j=0; j<nodesCount; j++)
			{
				// determine LOD for each building.
				node = lowestTile.nodesArray[j];
				nodeRoot = node.getRoot();
				
				// now, create a geoLocDataManager for node if no exist.
				if (nodeRoot.data.geoLocDataManager === undefined)
				{
					geoLoc = this.calculate_geoLocDataOfNode(node);
					continue;
				}
				geoLocDataManager = nodeRoot.data.geoLocDataManager;
				geoLoc = geoLocDataManager.getCurrentGeoLocationData();
				realBuildingPos = node.getBBoxCenterPositionWorldCoord(geoLoc);
				neoBuilding = node.data.neoBuilding;
		
				this.radiusAprox_aux = neoBuilding.bbox.getRadiusAprox();
				if (this.boundingSphere_Aux === undefined)
				{ this.boundingSphere_Aux = new Sphere(); }
				
				this.boundingSphere_Aux.setCenterPoint(realBuildingPos.x, realBuildingPos.y, realBuildingPos.z);
				this.boundingSphere_Aux.setRadius(this.radiusAprox_aux);
					
				distToCamera = cameraPosition.distToSphere(this.boundingSphere_Aux);
				neoBuilding.distToCam = distToCamera;
				if (neoBuilding.distToCam < lod0Dist)
				{ neoBuilding.currentLod = 0; }
				else if (neoBuilding.distToCam < lod1Dist)
				{ neoBuilding.currentLod = 1; }
				else if (neoBuilding.distToCam < lod2Dist)
				{ neoBuilding.currentLod = 2; }
				else if (neoBuilding.distToCam < lod3Dist)
				{ neoBuilding.currentLod = 3; }
				else if (neoBuilding.distToCam < lod4Dist)
				{ neoBuilding.currentLod = 4; }
				else if (neoBuilding.distToCam < lod5Dist)
				{ neoBuilding.currentLod = 5; }
				
				var frustumFar = this.magoPolicy.getFrustumFarDistance();
				if (distToCamera > frustumFar)
				{ 
					// put this node to delete into queue.***
					this.processQueue.putNodeToDelete(node, 0);
					continue; 
				}
				
				// If necessary do frustum culling.*************************************************************************
				if (doFrustumCullingToBuildings)
				{
					var frustumCull = frustumVolume.intersectionSphere(this.boundingSphere_Aux); // cesium.***
					// intersect with Frustum
					if (frustumCull === Constant.INTERSECTION_OUTSIDE) 
					{
						// put this node to delete into queue.***
						//this.processQueue.putNodeToDeleteModelReferences(node, 0);
						this.processQueue.putNodeToDeleteLessThanLod3(node, 0);
						continue;
					}
				}
				//-------------------------------------------------------------------------------------------
				
				// provisionally fork versions.***
				var version = neoBuilding.getHeaderVersion();
				if (version === undefined)
				{ continue; }
				
				if (version[0] === 'v')
				{
					if (distToCamera < lod0_minDist) 
					{
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles0, node);
					}
					else if (distToCamera < lod1_minDist) 
					{
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles1, node);
					}
					else if (distToCamera < lod2_minDist) 
					{
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles2, node);
					}
					else if (distToCamera < lod5_minDist) 
					{
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
					}
				}
				else 
				{
					// provisional test for pointsCloud data.************
					var metaData = neoBuilding.metaData;
					var projectsType = metaData.projectDataType;
					if (projectsType && projectsType === 4)
					{
						// Project_data_type (new in version 002).***
						// 1 = 3d model data type (normal 3d with interior & exterior data).***
						// 2 = single building skin data type (as vWorld or googleEarth data).***
						// 3 = multi building skin data type (as Shibuya & Odaiba data).***
						// 4 = pointsCloud data type.***
						visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisiblesAux, node);
					}
					// end provisional test.-----------------------------
					else
					{
						if (distToCamera < lod0_minDist) 
						{
							// check if the lod0, lod1, lod2 are modelReference type.***
							var lodBuildingData = neoBuilding.getLodBuildingData(0);
							if (lodBuildingData && lodBuildingData.isModelRef)
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles0, node);
							}
							else
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
							}
						}
						else if (distToCamera < lod1_minDist) 
						{
							var lodBuildingData = neoBuilding.getLodBuildingData(1);
							if (lodBuildingData && lodBuildingData.isModelRef)
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles1, node);
							}
							else
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
							}
						}
						else if (distToCamera < lod2_minDist) 
						{
							var lodBuildingData = neoBuilding.getLodBuildingData(2);
							if (lodBuildingData && lodBuildingData.isModelRef)
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles2, node);
							}
							else
							{ 
								visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
							}
						}
						else if (distToCamera < lod5_minDist) 
						{
							visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisibles3, node);
						}
					}
				}
			}
			
			if (lowestTile.nodesArray.length !== lowestTile.nodeSeedsArray.length)
			{
				// create the buildings by buildingSeeds.
				this.createBuildingsByBuildingSeedsOnLowestTile(lowestTile);
			}
		}
		else
		{
			// create the buildings by buildingSeeds.
			this.createBuildingsByBuildingSeedsOnLowestTile(lowestTile);
		}
	}
};

/**
 * dataKey 이용해서 data 검색
 * @param dataKey
 */
MagoManager.prototype.testAproxDist3D = function()
{
	// test: AproxDistance:
	var distCalculationTimeAmount = 0;
	var aproxDistCalculationTimeAmount = 0;
	var squaredDistCalculationTimeAmount = 0;
	
	var pointA = new Point3D();
	var pointB = new Point3D();
	
	var difX, difY, difZ;
	
	
	
	var aproxDist, realDist, squaredDist, startTime, endTime;
	startTime = new Date().getTime();
	for (var k=0; k<1000000; k++)
	{
		pointA.set(Math.random()*1000.0, Math.random()*1000.0, Math.random()*1000.0);
		pointB.set(Math.random()*1000.0, Math.random()*1000.0, Math.random()*1000.0);
		squaredDist = pointA.squareDistToPoint(pointB);
		//difX = pointA.x - pointB.x;
		//difY = pointA.y - pointB.y;
		//difZ = pointA.z - pointB.z;
		//realDist = difX*difX + difY*difY + difZ*difZ;
	}
	endTime = new Date().getTime();
	squaredDistCalculationTimeAmount += (endTime - startTime)/1000;
	
	
	startTime = new Date().getTime();
	for (var k=0; k<1000000; k++)
	{
		pointA.set(Math.random()*1000.0, Math.random()*1000.0, Math.random()*1000.0);
		pointB.set(Math.random()*1000.0, Math.random()*1000.0, Math.random()*1000.0);
		//aproxDist = this.calculateAproxDist3D(pointA, pointB);
		aproxDist = pointA.aproxDistTo(pointB, this.sqrtTable);
		//aproxDist = this.managerUtil.calculateAproxDist3D(pointA, pointB);
		//aproxDist = ManagerUtils.calculateAproxDist3D(pointA, pointB);
	}
	endTime = new Date().getTime();
	aproxDistCalculationTimeAmount += (endTime - startTime)/1000;
	
	
	startTime = new Date().getTime();
	for (var k=0; k<1000000; k++)
	{
		pointA.set(Math.random()*1000.0, Math.random()*1000.0, Math.random()*1000.0);
		pointB.set(Math.random()*1000.0, Math.random()*1000.0, Math.random()*1000.0);
		realDist = pointA.distToPoint(pointB);
		//difX = pointA.x - pointB.x;
		//difY = pointA.y - pointB.y;
		//difZ = pointA.z - pointB.z;
		//realDist = Math.sqrt(difX*difX + difY*difY + difZ*difZ );
	}
	endTime = new Date().getTime();
	distCalculationTimeAmount += (endTime - startTime)/1000;
	
	// test. check the calculation time difference.
	distCalculationTimeAmount;
	aproxDistCalculationTimeAmount;
	squaredDistCalculationTimeAmount;
	
	var ratio = aproxDistCalculationTimeAmount/distCalculationTimeAmount *100;
	var error = (aproxDist - realDist)/realDist * 100;
	
};

/**
 * dataKey 이용해서 data 검색
 * @param dataKey
 */
MagoManager.prototype.calculateAproxDist3D = function(pointA, pointB)
{
	// test function.
	var difX = Math.abs(pointA.x - pointB.x);
	var difY = Math.abs(pointA.y - pointB.y);
	var difZ = Math.abs(pointA.z - pointB.z);

	
	// find the big value.
	var maxValue, value1, value2;
	var value1Idx, value2Idx;
	var aproxDist;
	var tableValuesCount = 10;

	if (difX > difY)
	{
		if (difX > difZ)
		{
			maxValue = difX;
			value1 = difY/maxValue;
			//value1Idx = Math.floor(value1*100);
			value1Idx = ~~(value1*tableValuesCount);
			var middleDist = maxValue * this.sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			//value2Idx = Math.floor(value2*100);
			value2Idx = ~~(value2*tableValuesCount);
			return (middleDist * this.sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			//value1Idx = Math.floor(value1*100);
			value1Idx = ~~(value1*tableValuesCount);
			var middleDist = maxValue * this.sqrtTable[value1Idx];
			value2 = difY/middleDist;
			//value2Idx = Math.floor(value2*100);
			value2Idx = ~~(value2*tableValuesCount);
			return (middleDist * this.sqrtTable[value2Idx]);
		}
	}
	else 
	{
		if (difY > difZ)
		{
			maxValue = difY;
			value1 = difX/maxValue;
			//value1Idx = Math.floor(value1*100);
			value1Idx = ~~(value1*tableValuesCount);
			var middleDist = maxValue * this.sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			//value2Idx = Math.floor(value2*100);
			value2Idx = ~~(value2*tableValuesCount);
			return (middleDist * this.sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			//value1Idx = Math.floor(value1*100);
			value1Idx = ~~(value1*tableValuesCount);
			var middleDist = maxValue * this.sqrtTable[value1Idx];
			value2 = difY/middleDist;
			//value2Idx = Math.floor(value2*100);
			value2Idx = ~~(value2*tableValuesCount);
			return (middleDist * this.sqrtTable[value2Idx]);
		}
	}
	
};

/**
 * dataKey 이용해서 data 검색
 * @param dataKey
 */
MagoManager.prototype.createBuildingsByBuildingSeedsOnLowestTile = function(lowestTile) 
{
	// create the buildings by buildingSeeds.
	var node;
	var neoBuilding;
	var nodeBbox;
	var buildingSeed;
	var startIndex = 0;
	
	// if exist nodesArray (there are buildings) and add a nodeSeed, we must make nodes of the added nodeSeeds.***
	if (lowestTile.nodesArray)
	{ startIndex = lowestTile.nodesArray.length; }
	
	var nodeSeedsCount = lowestTile.nodeSeedsArray.length;
	for (var j=startIndex; j<nodeSeedsCount; j++)
	{
		node = lowestTile.nodeSeedsArray[j];
		neoBuilding = new NeoBuilding();
		neoBuilding.nodeOwner = node;
		node.data.neoBuilding = neoBuilding;
		nodeBbox = new BoundingBox();
		node.data.bbox = nodeBbox;
		buildingSeed = node.data.buildingSeed;
	
		if (lowestTile.nodesArray === undefined)
		{ lowestTile.nodesArray = []; }
		
		lowestTile.nodesArray.push(node);
		
		if (neoBuilding.metaData === undefined) 
		{ neoBuilding.metaData = new MetaData(); }

		if (neoBuilding.metaData.geographicCoord === undefined)
		{ neoBuilding.metaData.geographicCoord = new GeographicCoord(); }

		if (neoBuilding.metaData.bbox === undefined) 
		{ neoBuilding.metaData.bbox = new BoundingBox(); }

		// create a building and set the location.***
		neoBuilding.name = buildingSeed.name;
		neoBuilding.buildingId = buildingSeed.buildingId;
	
		neoBuilding.buildingType = "basicBuilding";
		neoBuilding.buildingFileName = buildingSeed.buildingFileName;
		neoBuilding.metaData.geographicCoord.setLonLatAlt(buildingSeed.geographicCoord.longitude, buildingSeed.geographicCoord.latitude, buildingSeed.geographicCoord.altitude);
		neoBuilding.metaData.bbox.copyFrom(buildingSeed.bBox);
		nodeBbox.copyFrom(buildingSeed.bBox); // initially copy from building.
		if (neoBuilding.bbox === undefined)
		{ neoBuilding.bbox = new BoundingBox(); }
		neoBuilding.bbox.copyFrom(buildingSeed.bBox);
		neoBuilding.metaData.heading = buildingSeed.rotationsDegree.z;
		neoBuilding.metaData.pitch = buildingSeed.rotationsDegree.x;
		neoBuilding.metaData.roll = buildingSeed.rotationsDegree.y;
		neoBuilding.projectFolderName = node.data.projectFolderName;
	}
};

/**
 * dataKey 이용해서 data 검색
 * @param dataKey
 */
MagoManager.prototype.calculate_geoLocDataOfNode = function(node) 
{
	// this function creates the geoLocationData of "node".***
	var nodeRoot = node.getRoot();

	if (nodeRoot.data.geoLocDataManager === undefined)
	{ nodeRoot.data.geoLocDataManager = new GeoLocationDataManager(); }
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		
	if (geoLoc === undefined || geoLoc.pivotPoint === undefined)
	{ 
		geoLoc = geoLocDataManager.newGeoLocationData("deploymentLoc"); 
		var geographicCoord;
		var rotationsDegree;
		
		if (node.data.geographicCoord === undefined)
		{
			var buildingSeed = node.data.buildingSeed;
			geographicCoord = buildingSeed.geographicCoord;
			rotationsDegree = buildingSeed.rotationsDegree;
		}
		else 
		{
			geographicCoord = node.data.geographicCoord;
			rotationsDegree = node.data.rotationsDegree;
		}
		
		var longitude = geographicCoord.longitude;
		var latitude = geographicCoord.latitude;
		var altitude = geographicCoord.altitude;
		var heading = rotationsDegree.z;
		var pitch = rotationsDegree.x;
		var roll = rotationsDegree.y;
		ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, heading, pitch, roll, geoLoc, this);
		this.pointSC = node.data.bbox.getCenterPoint(this.pointSC);

		// check if use "centerOfBoundingBoxAsOrigin".***
		if (node.data.mapping_type !== undefined && node.data.mapping_type.toLowerCase() === "boundingboxcenter")
		{
			var rootNode = node.getRoot();
			if (rootNode)
			{
				// now, calculate the root center of bbox.
				var buildingSeed = node.data.buildingSeed;
				var buildingSeedBBox = buildingSeed.bBox;
				this.pointSC = buildingSeedBBox.getCenterPoint(this.pointSC);
				ManagerUtils.translatePivotPointGeoLocationData(geoLoc, this.pointSC );
			}
		}
	}
	
	return geoLoc;
};



/**
 * dataKey 이용해서 data 검색
 * @param apiName api 이름
 * @param projectId project id
 * @param dataKey
 */
MagoManager.prototype.flyTo = function(longitude, latitude, altitude, duration) 
{
	if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM) 
	{
		this.scene.camera.flyTo({
			destination: Cesium.Cartesian3.fromDegrees(parseFloat(longitude),
				parseFloat(latitude),
				parseFloat(altitude) + 10),
			duration: parseInt(duration)
		});
	}
	else if (MagoConfig.getPolicy().geo_view_library === Constant.WORLDWIND)
	{
		this.wwd.goToAnimator.travelTime = duration * 1000;
		this.wwd.goTo(new WorldWind.Position(parseFloat(latitude), parseFloat(longitude), parseFloat(altitude) + 50));
	}
	else if (MagoConfig.getPolicy().geo_view_library === Constant.MAGOWORLD)
	{
		this.magoWorld.goto(parseFloat(longitude),
			parseFloat(latitude),
			parseFloat(altitude) + 10);
	}

};

/**
 * dataKey 이용해서 data 검색
 * @param apiName api 이름
 * @param projectId project id
 * @param dataKey
 */
MagoManager.prototype.flyToBuilding = function(apiName, projectId, dataKey) 
{
	var node = this.hierarchyManager.getNodeByDataName(projectId, "nodeId", dataKey);
	if (node === undefined)
	{ 
		apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
		return; 
	}
	
	var nodeRoot = node.getRoot();
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc;
	if (geoLocDataManager === undefined)
	{ 
		geoLoc = this.calculate_geoLocDataOfNode(node);
		if (geoLoc === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return; 
		}
	}
	geoLocDataManager = nodeRoot.data.geoLocDataManager;
	geoLoc = geoLocDataManager.getCurrentGeoLocationData();
	var realBuildingPos = node.getBBoxCenterPositionWorldCoord(geoLoc);

	if (realBuildingPos === undefined)
	{ return; }

	this.radiusAprox_aux = nodeRoot.data.bbox.getRadiusAprox();

	if (this.boundingSphere_Aux === undefined)
	{ this.boundingSphere_Aux = new Sphere(); }
	
	this.boundingSphere_Aux.radius = this.radiusAprox_aux;

	if (this.configInformation.geo_view_library === Constant.CESIUM)
	{
		this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(realBuildingPos);
		var seconds = 3;
		this.scene.camera.flyToBoundingSphere(this.boundingSphere_Aux, seconds);
	}
	else if (this.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		var geographicCoord = buildingSeed.geographicCoordOfBBox;
		this.wwd.goToAnimator.travelTime = 3000;
		this.wwd.goTo(new WorldWind.Position(geographicCoord.latitude, geographicCoord.longitude, geographicCoord.altitude + 1000));
	}
};


/**
 * 어떤 일을 하고 있습니까?
 */
MagoManager.prototype.getNeoBuildingById = function(buildingType, buildingId) 
{
	var resultNeoBuilding = this.smartTileManager.getNeoBuildingById(buildingType, buildingId);
	return resultNeoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 */
MagoManager.prototype.getBuildingSeedById = function(buildingType, buildingId) 
{
	var resultNeoBuildingSeed = this.smartTileManager.getBuildingSeedById(buildingType, buildingId);
	return resultNeoBuildingSeed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param frustumVolume 변수
 * @param visibleBuildings_array 변수
 * @param cameraPosition 변수
 * @returns visibleBuildings_array
 */
MagoManager.prototype.doFrustumCullingTerranTileServiceFormat = function(gl, frustumVolume, visibleBuildings_array, cameraPosition) 
{
	// This makes the visible buildings array.***
	// This has Cesium dependency because uses the frustumVolume and the boundingSphere of cesium.***
	//---------------------------------------------------------------------------------------------------------
	// Note: in this function, we do frustum culling and determine the detailedBuilding in same time.***

	// Init the visible buildings array.***************************
	//visibleBuildings_array.length = 0; // Init.***
	//this.currentVisibleBuildings_LOD0_array.length = 0; // Init.***
	//this.detailed_building;

	var squaredDistToCamera;
	//	var squaredDistToCamera_candidate;
	var last_squared_dist;
	var buildings_count;
	//	var nearestTile;
	//	var nearestTile_candidate;

	this.filteredVisibleTiles_array.length = 0;
	this.detailedVisibleTiles_array.length = 0;
	this.LOD0VisibleTiles_array.length = 0;

	var BR_Project;

	var max_tileFilesReading = 10;

	this.currentVisible_terranTiles_array.length = 0;// Init.***
	this.terranTile.getIntersectedSmallestTiles(frustumVolume, this.currentVisible_terranTiles_array, this.boundingSphere_Aux);

	// Find the nearest tile to camera.***
	var visibleTiles_count = this.currentVisible_terranTiles_array.length;
	if (visibleTiles_count === 0) { return; }

	for (var i=0; i<visibleTiles_count; i++) 
	{
		this.terranTileSC = this.currentVisible_terranTiles_array[i];
		squaredDistToCamera = Cesium.Cartesian3.distanceSquared(cameraPosition, this.terranTileSC.position);

		if (squaredDistToCamera > this.min_squaredDist_to_see) { continue; }

		if (squaredDistToCamera < this.min_squaredDist_to_see_detailed * 1.2) 
		{
			this.detailedVisibleTiles_array.push(this.terranTileSC);
		}
		else if (squaredDistToCamera <  this.min_squaredDist_to_see_LOD0 * 1.2) 
		{
			this.LOD0VisibleTiles_array.push(this.terranTileSC);
		}
		else 
		{
			this.filteredVisibleTiles_array.push(this.terranTileSC); // Original.***
			//this.LOD0VisibleTiles_array.push(this.terranTileSC); // Test.***
		}
	}

	// Make the visible buildings list.******************************************************************************
	this.boundingSphere_Aux.radius = 50.0;
	var need_frustumCulling = false;
	var filePath_scratch;
	var tileNumberNameString;

	var detailedVisibleTiles_count = this.detailedVisibleTiles_array.length;
	for (var i=0; i<detailedVisibleTiles_count; i++) 
	{
		this.terranTileSC = this.detailedVisibleTiles_array[i];

		if (!this.terranTileSC.fileReading_started) 
		{
			if (this.backGround_fileReadings_count < max_tileFilesReading) 
			{
				tileNumberNameString = this.terranTileSC._numberName.toString();
				filePath_scratch = this.readerWriter.getCurrentDataPath() + Constant.RESULT_XDO2F4D_TERRAINTILES + tileNumberNameString + ".til";
				this.readerWriter.getTileArrayBuffer(gl, filePath_scratch, this.terranTileSC, this.readerWriter, this);
				this.backGround_fileReadings_count ++;
			}

			continue;
		}

		if (this.terranTileSC.fileReading_finished && !this.terranTileSC.fileParsingFinished) 
		{
			//this.terranTileSC.parseFileOneBuilding(gl, this);
			this.terranTileSC.parseFileAllBuildings(this);
			//continue;
		}

		need_frustumCulling = false;
		if (this.terranTileSC.visibilityType === Cesium.Intersect.INTERSECTING) { need_frustumCulling = true; }

		buildings_count = this.terranTileSC._BR_buildingsArray.length;
		for (var j=0; j<buildings_count; j++) 
		{
			BR_Project = this.detailedVisibleTiles_array[i]._BR_buildingsArray[j];
			if (BR_Project.buildingPosition === undefined) 
			{
				this.currentVisibleBuildings_LOD0_array.push(BR_Project);
				continue;
			}

			squaredDistToCamera = Cesium.Cartesian3.distanceSquared(cameraPosition, BR_Project.buildingPosition);
			if (squaredDistToCamera < this.min_squaredDist_to_see_detailed) 
			{

				// Activate this in the future, when all f4d_projects unified.***
				if (BR_Project._compRefList_Container.compRefsListArray.length > 0) 
				{
					if (BR_Project._header._f4d_version === 1) 
					{
						if (last_squared_dist) 
						{
							if (squaredDistToCamera < last_squared_dist) 
							{
								last_squared_dist = squaredDistToCamera;
								this.currentVisibleBuildings_LOD0_array.push(this.detailed_building);
								this.detailed_building = BR_Project;
							}
							else 
							{
								this.currentVisibleBuildings_LOD0_array.push(BR_Project);
							}
						}
						else 
						{
							last_squared_dist = squaredDistToCamera;
							this.detailed_building = BR_Project;
						}
					}
				}
				else 
				{
					if (BR_Project._header.isSmall) { visibleBuildings_array.push(BR_Project); }
					else { this.currentVisibleBuildings_LOD0_array.push(BR_Project); }
				}
			}
			else if (squaredDistToCamera < this.min_squaredDist_to_see_LOD0) 
			{
				if (need_frustumCulling) 
				{
					this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(BR_Project.buildingPosition);
					if (need_frustumCulling && frustumVolume.computeVisibility(this.boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE) 
					{
						this.currentVisibleBuildings_LOD0_array.push(BR_Project);
					}
				}
				else { this.currentVisibleBuildings_LOD0_array.push(BR_Project); }
			}
			else 
			{
				if (need_frustumCulling) 
				{
					this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(BR_Project.buildingPosition);
					if (need_frustumCulling && frustumVolume.computeVisibility(this.boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE) 
					{
						visibleBuildings_array.push(BR_Project);
					}
				}
				else { visibleBuildings_array.push(BR_Project); }
			}
		}
	}

	var LOD0VisiblesTiles_count = this.LOD0VisibleTiles_array.length;
	for (var i=0; i<LOD0VisiblesTiles_count; i++) 
	{
		this.terranTileSC = this.LOD0VisibleTiles_array[i];

		if (!this.terranTileSC.fileReading_started) 
		{
			if (this.backGround_fileReadings_count < max_tileFilesReading) 
			{
				tileNumberNameString = this.terranTileSC._numberName.toString();
				filePath_scratch = this.readerWriter.getCurrentDataPath() + Constant.RESULT_XDO2F4D_TERRAINTILES + tileNumberNameString + ".til";
				this.readerWriter.getTileArrayBuffer(gl, filePath_scratch, this.terranTileSC, this.readerWriter, this);
				this.backGround_fileReadings_count ++;
			}
			continue;
		}

		if (this.terranTileSC.fileReading_finished && !this.terranTileSC.fileParsingFinished) 
		{
			//this.terranTileSC.parseFileOneBuilding(gl, this);
			this.terranTileSC.parseFileAllBuildings(this);
			//continue;
		}

		need_frustumCulling = false;
		if (this.terranTileSC.visibilityType === Cesium.Intersect.INTERSECTING) { need_frustumCulling = true; }

		buildings_count = this.terranTileSC._BR_buildingsArray.length;
		for (var j=0; j<buildings_count; j++) 
		{
			BR_Project = this.LOD0VisibleTiles_array[i]._BR_buildingsArray[j];
			if (BR_Project.buildingPosition === undefined) 
			{
				visibleBuildings_array.push(BR_Project);
				continue;
			}

			squaredDistToCamera = Cesium.Cartesian3.distanceSquared(cameraPosition, BR_Project.buildingPosition);
			if (squaredDistToCamera < this.min_squaredDist_to_see_LOD0) 
			{
				if (need_frustumCulling) 
				{
					this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(BR_Project.buildingPosition);
					if (frustumVolume.computeVisibility(this.boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE) 
					{
						this.currentVisibleBuildings_LOD0_array.push(BR_Project);
					}
				}
				else { this.currentVisibleBuildings_LOD0_array.push(BR_Project); }
			}
			else 
			{
				if (need_frustumCulling) 
				{
					this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(BR_Project.buildingPosition);
					if (frustumVolume.computeVisibility(this.boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE) 
					{
						visibleBuildings_array.push(BR_Project);
					}
				}
				else { visibleBuildings_array.push(BR_Project); }
			}
		}
	}

	var filteredVisibleTiles_count = this.filteredVisibleTiles_array.length;
	for (var i=0; i<filteredVisibleTiles_count; i++) 
	{
		this.terranTileSC = this.filteredVisibleTiles_array[i];
		if (!this.terranTileSC.fileReading_started) 
		{
			if (this.backGround_fileReadings_count < max_tileFilesReading) 
			{
				tileNumberNameString = this.terranTileSC._numberName.toString();
				filePath_scratch = this.readerWriter.getCurrentDataPath() + Constant.RESULT_XDO2F4D_TERRAINTILES + tileNumberNameString + ".til";
				this.readerWriter.getTileArrayBuffer(gl, filePath_scratch, this.terranTileSC, this.readerWriter, this);
				this.backGround_fileReadings_count ++;
			}
			continue;
		}

		if (this.terranTileSC.fileReading_finished && !this.terranTileSC.fileParsingFinished) 
		{
			//this.terranTileSC.parseFileOneBuilding(gl, this);
			this.terranTileSC.parseFileAllBuildings(this);
			//continue;
		}

		need_frustumCulling = false;
		if (this.terranTileSC.visibilityType === Cesium.Intersect.INTERSECTING) { need_frustumCulling = true; }

		buildings_count = this.terranTileSC._BR_buildingsArray.length;
		for (var j=0; j<buildings_count; j++) 
		{
			BR_Project = this.filteredVisibleTiles_array[i]._BR_buildingsArray[j];
			if (BR_Project.buildingPosition === undefined) 
			{
				visibleBuildings_array.push(BR_Project);
				continue;
			}
			else 
			{
				squaredDistToCamera = Cesium.Cartesian3.distanceSquared(cameraPosition, BR_Project.buildingPosition);
				if (BR_Project._header.isSmall) 
				{
					if (squaredDistToCamera < this.min_squaredDist_to_see_smallBuildings) 
					{
						if (need_frustumCulling) 
						{
							this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(BR_Project.buildingPosition);
							if (frustumVolume.computeVisibility(this.boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
							{ visibleBuildings_array.push(BR_Project); }
						}
						else { visibleBuildings_array.push(BR_Project); }
					}
				}
				else 
				{
					// Provisionally check for LODzero distance.***
					if (squaredDistToCamera < this.min_squaredDist_to_see_LOD0) 
					{
						if (need_frustumCulling) 
						{
							this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(BR_Project.buildingPosition);
							if (frustumVolume.computeVisibility(this.boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE) 
							{
								this.currentVisibleBuildings_LOD0_array.push(BR_Project);
							}
						}
						else { this.currentVisibleBuildings_LOD0_array.push(BR_Project); }
					}
					else 
					{
						if (need_frustumCulling) 
						{
							this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(BR_Project.buildingPosition);
							if (frustumVolume.computeVisibility(this.boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
							{ visibleBuildings_array.push(BR_Project); }
						}
						else { visibleBuildings_array.push(BR_Project); }
					}
				}
			}
		}
	}

	return visibleBuildings_array;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param visibleBuildings_array 변수
 * @param cameraPosition 변수
 * @returns visibleBuildings_array
 */
MagoManager.prototype.doFrustumCullingClouds = function(frustumVolume, visibleBuildings_array)
{
	// This makes the visible buildings array.***
	// This has Cesium dependency because uses the frustumVolume and the boundingSphere of cesium.***
	//---------------------------------------------------------------------------------------------------------
	// Note: in this function, we do frustum culling and determine the detailedBuilding in same time.***

	// Init the visible buildings array.***

	this.currentVisibleClouds_array.length = 0; // Init.***

	//	var min_squaredDist_to_see_detailed = 40000; // 200m.***
	//	var min_squaredDist_to_see_LOD0 = 250000; // 600m.***
	//	var min_squaredDist_to_see = 10000000;
	//	var min_squaredDist_to_see_smallBuildings = 700000;
	//
	//	var squaredDistToCamera;
	//	var last_squared_dist;

	var clouds_count = this.atmosphere.cloudsManager.circularCloudsArray.length;
	for (var p_counter = 0; p_counter<clouds_count; p_counter++) 
	{
		var cloud = this.atmosphere.cloudsManager.circularCloudsArray[p_counter];

		if (cloud.cullingPosition === undefined) 
		{
			continue;
		}

		/*
		squaredDistToCamera = Cesium.Cartesian3.distanceSquared(cameraPosition, cloud.cullingPosition);
		if(squaredDistToCamera > min_squaredDist_to_see)
			continue;

		if(BR_Project._header.isSmall && squaredDistToCamera>min_squaredDist_to_see_smallBuildings)
			continue;
		*/

		this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(cloud.cullingPosition);
		this.radiusAprox_aux = cloud.cullingRadius;

		if (this.radiusAprox_aux) 
		{
			this.boundingSphere_Aux.radius = this.radiusAprox_aux;
		}
		else 
		{
			this.boundingSphere_Aux.radius = 50.0; // 50m. Provisional.***
		}

		var frustumCull = frustumVolume.computeVisibility(this.boundingSphere_Aux);
		if (frustumCull !== Cesium.Intersect.OUTSIDE) 
		{
			this.currentVisibleClouds_array.push(cloud);
		}
	}

	return visibleBuildings_array;
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.renderModeChanged = function()
{
	if (this.renderModeTemp === 0)
	{
		;//
	}
	else if (this.renderModeTemp === 1)
	{
		;//
	}
	else if (this.renderModeTemp === 2)
	{
		;//
	}

};

MagoManager.prototype.displayLocationAndRotation = function(neoBuilding) 
{
	//var node = this.hierarchyManager.getNodeByDataName(projectId, dataName, dataNameValue); // original.***
	var node = neoBuilding.nodeOwner;
	var geoLocDatamanager = this.getNodeGeoLocDataManager(node);
	if (geoLocDatamanager === undefined)
	{ return; }
	var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
	var latitude = geoLocationData.geographicCoord.latitude;
	var longitude = geoLocationData.geographicCoord.longitude;
	var altitude = geoLocationData.geographicCoord.altitude;
	var heading = geoLocationData.heading;
	var pitch = geoLocationData.pitch;
	var roll = geoLocationData.roll;
	var dividedName = neoBuilding.buildingId.split("_");
};

/**
 * 변환 행렬
 */
MagoManager.prototype.selectedObjectNotice = function(neoBuilding) 
{
	var node = neoBuilding.nodeOwner;
	var geoLocDatamanager = this.getNodeGeoLocDataManager(node);
	if (geoLocDatamanager === undefined)
	{ return; }
	var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
	var dataKey = node.data.nodeId;
	var projectId = node.data.projectId;

	if (MagoConfig.getPolicy().geo_callback_enable === "true") 
	{
		//if (this.objMarkerSC === undefined) { return; }
		var objectId = null;
		if (this.objectSelected !== undefined) { objectId = this.objectSelected.objectId; }
		
		// click object 정보를 표시
		if (this.magoPolicy.getObjectInfoViewEnable()) 
		{
			selectedObjectCallback(		MagoConfig.getPolicy().geo_callback_selectedobject,
				projectId,
				dataKey,
				objectId,
				geoLocationData.geographicCoord.latitude,
				geoLocationData.geographicCoord.longitude,
				geoLocationData.geographicCoord.altitude,
				geoLocationData.heading,
				geoLocationData.pitch,
				geoLocationData.roll);
		}
			
		// 이슈 등록 창 오픈
		if (this.magoPolicy.getIssueInsertEnable()) 
		{
			if (this.objMarkerSC === undefined) { return; }
			
			insertIssueCallback(	MagoConfig.getPolicy().geo_callback_insertissue,
				projectId,
				dataKey,
				objectId,
				geoLocationData.geographicCoord.latitude,
				geoLocationData.geographicCoord.longitude,
				(parseFloat(geoLocationData.geographicCoord.altitude)));
		}
	}
	
	
};

/**
 * 변환 행렬
 */
MagoManager.prototype.changeLocationAndRotation = function(projectId, dataKey, latitude, longitude, elevation, heading, pitch, roll) 
{
	var nodesMap = this.hierarchyManager.getNodesMap(projectId);
	if (nodesMap)
	{
		var node = nodesMap[dataKey];
		if (node === undefined)
		{ return; }
		this.changeLocationAndRotationNode(node, latitude, longitude, elevation, heading, pitch, roll);
	}
};

/**
 * 변환 행렬
 */
MagoManager.prototype.changeLocationAndRotationNode = function(node, latitude, longitude, elevation, heading, pitch, roll) 
{
	if (node === undefined)
	{ return; }

	// 1rst, find the rootNode.
	var nodeRoot;
	//nodeRoot = node.getRoot(); // original.***
	nodeRoot = node.getClosestParentWithData("geoLocDataManager");
	
	if (nodeRoot === undefined)
	{ return; }
	
	// now, extract all buildings of the nodeRoot.
	var nodesArray = [];
	nodeRoot.extractNodesByDataName(nodesArray, "neoBuilding");
	
	var aNode;
	var nodesCount = nodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		aNode = nodesArray[i];
		var geoLocDatamanager = this.getNodeGeoLocDataManager(aNode);
		var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
		geoLocationData = ManagerUtils.calculateGeoLocationData(longitude, latitude, elevation, heading, pitch, roll, geoLocationData, this);
		if (geoLocationData === undefined)
		{ continue; }

		// now, must change the keyMatrix of the references of the octrees of all buildings of this node.***
		var neoBuilding = aNode.data.neoBuilding;
		if (neoBuilding.octree)
		{
			neoBuilding.octree.multiplyKeyTransformMatrix(0, geoLocationData.rotMatrix);
		}
		neoBuilding.calculateBBoxCenterPositionWorldCoord(geoLocationData);
		nodeRoot.bboxAbsoluteCenterPos = undefined; // provisional.***
		nodeRoot.calculateBBoxCenterPositionWorldCoord(geoLocationData); // provisional.***
		
		aNode.bboxAbsoluteCenterPos = undefined; // provisional.***
		aNode.calculateBBoxCenterPositionWorldCoord(geoLocationData); // provisional.***
	}
	
	this.selectedObjectNotice(this.buildingSelected);
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.getObjectIndexFile = function(projectId, projectDataFolder) 
{
	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}
	
	this.buildingSeedList = new BuildingSeedList();
	var fileName;
	var geometrySubDataPath = projectDataFolder;
	fileName = this.readerWriter.geometryDataPath + "/" + geometrySubDataPath + Constant.OBJECT_INDEX_FILE + Constant.CACHE_VERSION + MagoConfig.getPolicy().content_cache_version;
	this.readerWriter.getObjectIndexFileForSmartTile(fileName, this, this.buildingSeedList, projectId);
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.getObjectIndexFile_xxxx = function() 
{
	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}

	this.buildingSeedList = new BuildingSeedList();
	this.readerWriter.getObjectIndexFileForSmartTile(
		this.readerWriter.getCurrentDataPath() + Constant.OBJECT_INDEX_FILE + Constant.CACHE_VERSION + MagoConfig.getPolicy().content_cache_version, this, this.buildingSeedList);
		
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.makeNode = function(jasonObject, resultPhysicalNodesArray, buildingSeedMap, projectFolderName, projectId) 
{
	var attributes = undefined;
	var children = undefined;
	var data_group_id = undefined;
	var data_group_name = undefined;
	var data_id = undefined;
	var data_key = undefined;
	var data_name = undefined;
	var heading = undefined;
	var height = undefined;
	var latitude = undefined;
	var longitude = undefined;
	var pitch = undefined;
	var roll = undefined;
	var mapping_type = undefined;
	
	if (jasonObject !== undefined)
	{
		attributes = jasonObject.attributes;
		children = jasonObject.children;
		data_group_id = jasonObject.data_group_id;
		data_group_name = jasonObject.data_group_name;
		data_id = jasonObject.data_id;
		data_key = jasonObject.data_key;
		data_name = jasonObject.data_name;
		heading = jasonObject.heading;
		height = jasonObject.height;
		latitude = jasonObject.latitude;
		longitude = jasonObject.longitude;
		pitch = jasonObject.pitch;
		roll = jasonObject.roll;
		mapping_type = jasonObject.mapping_type;
	}
	
	// now make the node.
	var buildingId;
	var buildingSeed;
	var node;
	var bbox;
	var childJason;
	var childNode;
	var childrenCount;
	if (attributes !== undefined)
	{
		buildingId = data_key;
		node = this.hierarchyManager.newNode(buildingId, projectId, attributes);
		// set main data of the node.
		node.data.projectFolderName = projectFolderName;
		node.data.projectId = projectId;
		node.data.data_name = data_name;
		node.data.attributes = attributes;
		node.data.mapping_type = mapping_type;
		var tMatrix;
		
		if (attributes.isPhysical)
		{
			// find the buildingSeed.
			buildingSeed = buildingSeedMap[buildingId];
			if (buildingSeed)
			{
				node.data.buildingSeed = buildingSeed;
				resultPhysicalNodesArray.push(node);
			}
		}

		if (longitude && latitude)
		{
			// this is root node.
			if (height === undefined)
			{ height = 0; }
			
			node.data.geographicCoord = new GeographicCoord();
			node.data.geographicCoord.setLonLatAlt(longitude, latitude, height);
			
			if (node.data.rotationsDegree === undefined)
			{ node.data.rotationsDegree = new Point3D(); }
			node.data.rotationsDegree.set(pitch, roll, heading);
			
			
			if (buildingSeed !== undefined)
			{
				if (buildingSeed.geographicCoord === undefined)
				{ buildingSeed.geographicCoord = new GeographicCoord(); }
			
				if (buildingSeed.rotationsDegree === undefined)
				{ buildingSeed.rotationsDegree = new Point3D(); }
		
				buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, height);
				buildingSeed.rotationsDegree.set(pitch, roll, heading);
				
				// now calculate the geographic coord of the center of the bbox.
				if (buildingSeed.geographicCoordOfBBox === undefined) 
				{ buildingSeed.geographicCoordOfBBox = new GeographicCoord(); }
			
				// calculate the transformation matrix at (longitude, latitude, height).
				var worldCoordPosition = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, height, worldCoordPosition, this);
				tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(worldCoordPosition, heading, pitch, roll, undefined, tMatrix, this);
				
				// now calculate the geographicCoord of the center of the bBox.
				var bboxCenterPoint;
				//if(node.data.mapping_type !== undefined && node.data.mapping_type.toLowerCase() === "boundingboxcenter")
				//	bboxCenterPoint = new Point3D(0,0,0);

				bboxCenterPoint = buildingSeed.bBox.getCenterPoint(bboxCenterPoint);
				var bboxCenterPointWorldCoord = tMatrix.transformPoint3D(bboxCenterPoint, bboxCenterPointWorldCoord);
				buildingSeed.geographicCoordOfBBox = ManagerUtils.pointToGeographicCoord(bboxCenterPointWorldCoord, buildingSeed.geographicCoordOfBBox, this); // original.
			}
		}

		// now, calculate the bbox.***
		node.data.bbox = new BoundingBox();
		
		if (node.data.buildingSeed && node.data.buildingSeed.bBox)
		{ node.data.bbox.copyFrom(buildingSeed.bBox); }
		
		if (node.data.mapping_type && node.data.mapping_type.toLowerCase() === "boundingboxcenter")
		{
			node.data.bbox.translateToOrigin();
		}
		
		// calculate the geographicCoordOfTheBBox.***
		if (tMatrix !== undefined)
		{
			bboxCenterPoint = node.data.bbox.getCenterPoint(bboxCenterPoint);
			var bboxCenterPointWorldCoord = tMatrix.transformPoint3D(bboxCenterPoint, bboxCenterPointWorldCoord);
			node.data.bbox.geographicCoord = ManagerUtils.pointToGeographicCoord(bboxCenterPointWorldCoord, node.data.bbox.geographicCoord, this);
		}

		bbox = node.data.bbox;

		if (children !== undefined)
		{
			childrenCount = children.length;
			for (var i=0; i<childrenCount; i++)
			{
				childJason = children[i];
				childNode = this.makeNode(childJason, resultPhysicalNodesArray, buildingSeedMap, projectFolderName, projectId);
				
				// if childNode has "geographicCoord" then the childNode is in reality a root.
				if (childNode.data.geographicCoord === undefined)
				{
					node.addChildren(childNode);
				}
			}
		}
	}
	return node;
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.calculateBoundingBoxesNodes = function() 
{
	var node;
	var nodeRoot;
	var buildingSeed;
	var longitude, latitude, height;
	var heading, pitch, roll;
	
	// 1rst, calculate boundingBoxes of buildingSeeds of nodes.
	var nodesCount = this.hierarchyManager.nodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = this.hierarchyManager.nodesArray[i];
		buildingSeed = node.data.buildingSeed;
		if (buildingSeed)
		{
			//nodeRoot = node.getRoot(); // old.***
			nodeRoot = node.getClosestParentWithData("geographicCoord");
			
			longitude = nodeRoot.data.geographicCoord.longitude; 
			latitude = nodeRoot.data.geographicCoord.latitude; 
			height = nodeRoot.data.geographicCoord.altitude;
			
			heading = nodeRoot.data.rotationsDegree.z;
			pitch = nodeRoot.data.rotationsDegree.x;
			roll = nodeRoot.data.rotationsDegree.y;
			
			//node.data.geographicCoord = nodeRoot.data.geographicCoord;
			if (buildingSeed.geographicCoord === undefined)
			{ buildingSeed.geographicCoord = new GeographicCoord(); }
		
			if (buildingSeed.rotationsDegree === undefined)
			{ buildingSeed.rotationsDegree = new Point3D(); }

			buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, height);
			buildingSeed.rotationsDegree.set(pitch, roll, heading);
			
			// now calculate the geographic coord of the center of the bbox.
			if (buildingSeed.geographicCoordOfBBox === undefined) 
			{ buildingSeed.geographicCoordOfBBox = new GeographicCoord(); }
		
			// calculate the transformation matrix at (longitude, latitude, height).
			var worldCoordPosition = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, height, worldCoordPosition, this);
			var tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(worldCoordPosition, heading, pitch, roll, undefined, tMatrix, this);
			
			// now calculate the geographicCoord of the center of the bBox.
			if (node.data.attributes.mapping_type && node.data.attributes.mapping_type === "boundingboxcenter")
			{
				var bboxCenterPoint = buildingSeed.bBox.getCenterPoint(bboxCenterPoint);
				var bboxCenterPointWorldCoord = tMatrix.transformPoint3D(bboxCenterPoint, bboxCenterPointWorldCoord);
				buildingSeed.geographicCoordOfBBox = ManagerUtils.pointToGeographicCoord(bboxCenterPointWorldCoord, buildingSeed.geographicCoordOfBBox, this); // original.
			}
			else 
			{
				buildingSeed.geographicCoordOfBBox.setLonLatAlt(longitude, latitude, height);
			}
		}
	}
	
	// now, must calculate the bbox of the root nodes.
	var rootNodesArray = [];
	var nodesArray = [];
	this.hierarchyManager.getRootNodes(rootNodesArray); // original.***
	var bboxStarted = false;
	
	var rootNodesCount = rootNodesArray.length;
	for (var i=0; i<rootNodesCount; i++)
	{
		nodeRoot = rootNodesArray[i];
		
		nodesArray.length = 0; // init.***
		nodeRoot.extractNodesByDataName(nodesArray, "buildingSeed");
		// now, take nodes that is "isMain" = true.
		bboxStarted = false;
		nodesCount =  nodesArray.length;
		for (var j=0; j<nodesCount; j++)
		{
			node = nodesArray[j];
			var nodeBBox = node.data.bbox;
			
			if (nodeBBox)
			{
				if (node.data.attributes)
				{
					if (node.data.attributes.isMain)
					{
						//buildingSeed = node.data.buildingSeed;
						if (bboxStarted === false)
						{
							nodeRoot.data.bbox.copyFrom(nodeBBox);
							bboxStarted = true;
						}
						else 
						{
							nodeRoot.data.bbox.addBox(nodeBBox);
						}
					}
					else 
					{
						if (bboxStarted === false)
						{
							nodeRoot.data.bbox.copyFrom(nodeBBox);
							bboxStarted = true;
						}
						else 
						{
							nodeRoot.data.bbox.addBox(nodeBBox);
						}
					}
				}
				else 
				{
					if (bboxStarted === false)
					{
						nodeRoot.data.bbox.copyFrom(nodeBBox);
						bboxStarted = true;
					}
					else 
					{
						nodeRoot.data.bbox.addBox(nodeBBox);
					}
				}
			}
		}
	}
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.makeSmartTile = function(buildingSeedList, projectId) 
{
	//var realTimeLocBlocksList = MagoConfig.getData().alldata; // original.***
	// "projectId" = json file name.
	var realTimeLocBlocksList = MagoConfig.getData(CODE.PROJECT_ID_PREFIX + projectId);
	var buildingSeedsCount;
	var buildingSeed;
	var buildingId;
	var newLocation;

	// now, read all hierarchyJason and make the hierarchy tree.
	var physicalNodesArray = []; // put here the nodes that has geometry data.
	// make a buildingSeedMap.
	var buildingSeedMap = {};
	var buildingSeedsCount = buildingSeedList.buildingSeedArray.length;
	for (var i=0; i<buildingSeedsCount; i++)
	{
		buildingSeed = buildingSeedList.buildingSeedArray[i];
		buildingId = buildingSeed.buildingId;
		buildingSeedMap[buildingId] = buildingSeed;
	}
	var projectFolderName = realTimeLocBlocksList.data_key;
	this.makeNode(realTimeLocBlocksList, physicalNodesArray, buildingSeedMap, projectFolderName, projectId);
	this.calculateBoundingBoxesNodes();
	
	// now, make smartTiles.
	// there are 2 general smartTiles: AsiaSide & AmericaSide.
	var smartTilesCount = this.smartTileManager.tilesArray.length; // In this point, "smartTilesCount" = 2 always.
	for (var a=0; a<smartTilesCount; a++)
	{
		var smartTile = this.smartTileManager.tilesArray[a];
		if (smartTile.nodeSeedsArray === undefined)
		{ smartTile.nodeSeedsArray = []; }
		
		smartTile.nodeSeedsArray = physicalNodesArray;
		smartTile.makeTreeByDepth(17, this); // depth = 17.
	}
	this.buildingSeedList.buildingSeedArray.length = 0; // init.

};

MagoManager.prototype.getNeoBuildingByTypeId = function(buildingType, buildingId)
{
	return this.smartTileManager.getNeoBuildingById(buildingType, buildingId);
};

/**
 * api gateway
 */
MagoManager.prototype.callAPI = function(api) 
{
	var apiName = api.getAPIName();
	if (apiName === "changeMagoState") 
	{
		this.magoPolicy.setMagoEnable(api.getMagoEnable());
	}
	else if (apiName === "searchData") 
	{
		return this.flyToBuilding(apiName, api.getProjectId(), api.getDataKey());
	}
	else if (apiName === "changeColor") 
	{
		ColorAPI.changeColor(api, this);
	}
	else if (apiName === "show") 
	{
		this.magoPolicy.setHideBuildings.length = 0;
	}
	else if (apiName === "hide") 
	{
		this.magoPolicy.setHideBuildings(api.gethideBuilds());
	}
	else if (apiName === "changeOutFitting") 
	{
		this.magoPolicy.setShowOutFitting(api.getShowOutFitting());
	} 
	else if (apiName === "changeLabel") 
	{
		this.magoPolicy.setShowLabelInfo(api.getShowLabelInfo());
		
		// clear the text canvas.
		var canvas = document.getElementById("objectLabel");
		var ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	}
	else if (apiName === "changeOrigin")
	{
		this.magoPolicy.setShowOrigin(api.getShowOrigin());
	}
	else if (apiName === "changeBoundingBox") 
	{
		this.magoPolicy.setShowBoundingBox(api.getShowBoundingBox());
	}
	else if (apiName === "changeShadow") 
	{
		this.magoPolicy.setShowShadow(api.getShowShadow());
		
	}
	else if (apiName === "changefrustumFarDistance") 
	{
		// frustum culling 가시 거리
		this.magoPolicy.setFrustumFarSquaredDistance(api.getFrustumFarDistance() * api.getFrustumFarDistance());
	}
	else if (apiName === "changeLocationAndRotation") 
	{
		LocationAndRotationAPI.changeLocationAndRotation(api, this);
	}
	else if (apiName === "changeObjectMove") 
	{
		this.magoPolicy.setObjectMoveMode(api.getObjectMoveMode());
	}
	else if (apiName === "saveObjectMove") 
	{
	//		var changeHistory = new ChangeHistory();
	//		changeHistory.setObjectMoveMode(api.getObjectMoveMode());
	//		MagoConfig.saveMovingHistory(api.getProjectId(), api.getDataKey(), api.getObjectIndexOrder(), changeHistory);
	}
	else if (apiName === "deleteAllObjectMove") 
	{
		// delete "aditionalMove" of the objects.***
		var moveHistoryMap = MagoConfig.getAllMovingHistory(); // get colorHistoryMap.***
		if (moveHistoryMap === undefined)
		{
			MagoConfig.clearMovingHistory();
			return;
		}
		
		for (var key_projectId in moveHistoryMap)
		{
			if (Object.prototype.hasOwnProperty.call(moveHistoryMap, key_projectId))
			{
				var projectId = key_projectId;
				var buildingsMap = moveHistoryMap[projectId];
				if (buildingsMap === undefined)
				{ continue; }
				
				for (var key_dataKey in buildingsMap)
				{
					if (Object.prototype.hasOwnProperty.call(buildingsMap, key_dataKey))
					{
						var dataKey = key_dataKey;
						var dataValue = buildingsMap[key_dataKey];
						
						if (dataValue === undefined)
						{ continue; }
						
						for (var objectIdx in dataValue)
						{
							if (Object.prototype.hasOwnProperty.call(dataValue, objectIdx))
							{
								var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
								if (node === undefined || node.data === undefined)
								{ continue; }
								
								var neoBuilding = node.data.neoBuilding;
								if (neoBuilding === undefined)
								{ continue; }
								
								var refObject = neoBuilding.getReferenceObject(objectIdx);
								if (refObject)
								{
									refObject.moveVector = undefined;
									refObject.moveVectorRelToBuilding = undefined;
								}	
							}
						}	
					}
				}	
			}
		}
		
		MagoConfig.clearMovingHistory();
	}
	else if (apiName === "deleteAllChangeColor") 
	{
		// 1rst, must delete the aditionalColors of objects.***
		var colorHistoryMap = MagoConfig.getAllColorHistory(); // get colorHistoryMap.***
		
		if (colorHistoryMap === undefined)
		{
			MagoConfig.clearColorHistory();
			return;
		}
		
		for (var key_projectId in colorHistoryMap)
		{
			if (Object.prototype.hasOwnProperty.call(colorHistoryMap, key_projectId))
			{
				var projectId = key_projectId;
				var buildingsMap = colorHistoryMap[projectId];
				if (buildingsMap === undefined)
				{ continue; }
				
				for (var key_dataKey in buildingsMap)
				{
					if (Object.prototype.hasOwnProperty.call(buildingsMap, key_dataKey))
					{
						var dataKey = key_dataKey;
						var dataValue = buildingsMap[key_dataKey];
						if (dataValue === undefined)
						{ continue; }
						
						for (var objectId in dataValue)
						{
							if (Object.prototype.hasOwnProperty.call(dataValue, objectId))
							{
								var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
								if (node === undefined || node.data === undefined)
								{ continue; }
								
								var neoBuilding = node.data.neoBuilding;
								if (neoBuilding === undefined)
								{ continue; }
								
								var refObjectArray = neoBuilding.getReferenceObjectsArrayByObjectId(objectId);
								if (refObjectArray === undefined)
								{ continue; }
								
								var refObjectsCount = refObjectArray.length;
								for (var i=0; i<refObjectsCount; i++)
								{
									var refObject = refObjectArray[i];
									if (refObject)
									{
										refObject.aditionalColor = undefined;
									}
								}	
							}
						}	
					}
				}	
			}
		}
		
		MagoConfig.clearColorHistory();
	}
	else if (apiName === "changeInsertIssueMode") 
	{
		this.magoPolicy.setIssueInsertEnable(api.getIssueInsertEnable());
		//selectedObjectCallback(이걸 해 주면 될거 같음)
	}
	else if (apiName === "changeObjectInfoViewMode") 
	{
		// object info 표시
		this.magoPolicy.setObjectInfoViewEnable(api.getObjectInfoViewEnable());
	}
	else if (apiName === "changeNearGeoIssueListViewMode") 
	{
		// issue list 표시
		this.magoPolicy.setNearGeoIssueListEnable(api.getNearGeoIssueListEnable());
		if (!api.getNearGeoIssueListEnable()) 
		{
			// clear objMarkerManager objectmakersarrays 사이즈를 0 으로 하면... .됨
			this.objMarkerManager.objectMarkerArray = [];
		}
	}
	else if (apiName === "changeOcclusionCulling") 
	{
		// OcclusionCulling 적용 유무
		this.magoPolicy.setOcclusionCullingEnable(api.getOcclusionCullingEnable());
		var neoBuilding = this.selectionCandidates.currentBuildingSelected;
		if (neoBuilding)
		{ neoBuilding.setRenderSettingApplyOcclusionCulling(this.magoPolicy.getOcclusionCullingEnable()); }
		// dataKey 는 api.getDataKey();
	}
	else if (apiName === "drawInsertIssueImage") 
	{
		DrawAPI.drawInsertIssueImage(api, this);
	}
	else if (apiName === "changeInsertIssueState")
	{
		this.sceneState.insertIssueState = 0;
	}
	else if (apiName === "changeLod")
	{
		LodAPI.changeLod(api, this);
	}
	else if (apiName === "changeLighting")
	{
		this.magoPolicy.setAmbientReflectionCoef(api.getAmbientReflectionCoef());
		this.magoPolicy.setDiffuseReflectionCoef(api.getDiffuseReflectionCoef());
		this.magoPolicy.setSpecularReflectionCoef(api.getSpecularReflectionCoef());
		this.magoPolicy.setSpecularColor(api.getSpecularColor());
	}
	else if (apiName === "changeSsaoRadius")
	{
		this.magoPolicy.setSsaoRadius(api.getSsaoRadius());
	}	
	else if (apiName === "changeFPVMode")
	{
		if (api.getFPVMode())
		{
			if (this.cameraFPV._camera !== undefined)	{ return; }

			this.cameraFPV.init();

			if (this.configInformation.geo_view_library === Constant.WORLDWIND)
			{
				;
			}
			else if (this.configInformation.geo_view_library === Constant.CESIUM)
			{
				var scratchLookAtMatrix4 = new Cesium.Matrix4();
				var scratchFlyToBoundingSphereCart4 = new Cesium.Cartesian4();
				var camera = this.scene._camera;

				this.cameraFPV._camera = camera;
				this.cameraFPV._cameraBAK = Cesium.Camera.clone(camera, this.cameraFPV._cameraBAK);
	
				var position = new Cesium.Cartesian3();
				var direction = new Cesium.Cartesian3();
				var up = new Cesium.Cartesian3();
	
				var cameraCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(camera.position);
				cameraCartographic.height = this.scene.globe.getHeight(cameraCartographic) + 1.5;
	
				this.scene.globe.ellipsoid.cartographicToCartesian(cameraCartographic, position);
				var transform = Cesium.Transforms.eastNorthUpToFixedFrame(position, Cesium.Ellipsoid.WGS84, scratchLookAtMatrix4);
				Cesium.Cartesian3.fromCartesian4(Cesium.Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4), direction);
				Cesium.Cartesian3.fromCartesian4(Cesium.Matrix4.getColumn(transform, 2, scratchFlyToBoundingSphereCart4), up);
	
				camera.flyTo({
					destination : position,
					orientation : {
						direction : direction,
						up        : up
					},
					duration: 1
				});
			}
		}
		else 
		{
			if (this.cameraFPV._cameraBAK === undefined)	{ return; }
			if (this.configInformation.geo_view_library === Constant.WORLDWIND)
			{
				;
			}
			else if (this.configInformation.geo_view_library === Constant.CESIUM)
			{
				this.scene._camera = Cesium.Camera.clone(this.cameraFPV._cameraBAK, this.scene._camera);
			}
			this.cameraFPV.release();
		}
	}
	else if (apiName === "changePropertyRendering") 
	{
		var visible = api.getShowShadow();
		var projectId = api.getProjectId();
		var property = api.getProperty();
		var splittedWords = property.split("=");
		var propertyKey = splittedWords[0];
		var propertyValue = splittedWords[1];
		
		if (this.propertyFilterSC === undefined)
		{ this.propertyFilterSC = {}; }
		
		this.propertyFilterSC.visible = visible;
		this.propertyFilterSC.projectId = projectId;
		this.propertyFilterSC.propertyKey = propertyKey;
		this.propertyFilterSC.propertyValue = propertyValue;

	}	
	else if (apiName === "drawAppendData")
	{
		DrawAPI.drawAppendData(api, this);
	}
	else if (apiName === "drawDeleteData")
	{
		this.deleteAll();
	}
	else if (apiName === "clearAllData")
	{
		this.deleteAll();
	}
	else if (apiName === "getDataInfoByDataKey")
	{
		var projectId = api.getProjectId(); // for example : 3ds, collada, ifc, etc.***
		var dataKey = api.getDataKey();
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var dataName = node.data.data_name;
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (dataName === undefined || geoLocDataManager === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		
		if (geoLocdata === undefined || geoLocdata.geographicCoord === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var projectId = node.data.projectId;
		var latitude = geoLocdata.geographicCoord.latitude;
		var longitude = geoLocdata.geographicCoord.longitude;
		var altitude = geoLocdata.geographicCoord.altitude;
		var heading = geoLocdata.heading;
		var pitch = geoLocdata.pitch;
		var roll = geoLocdata.roll;
		
		dataInfoCallback(		MagoConfig.getPolicy().geo_callback_dataInfo,
			projectId,
			dataKey,
			dataName,
			latitude,
			longitude,
			altitude,
			heading,
			pitch,
			roll);
	}
	else if (apiName === "gotoProject")
	{
		var projectId = api.getProjectId();
		//if (!this.hierarchyManager.existProject(projectId))
		//{
		//	var projectDataFolder = api.getProjectDataFolder();
		//	this.getObjectIndexFile(projectId, projectDataFolder);
		//}
		
		var nodeMap = this.hierarchyManager.getNodesMap(projectId);
		if (Object.keys(nodeMap).length === 0)
		{
			var projectDataFolder = api.getProjectDataFolder();
			this.getObjectIndexFile(projectId, projectDataFolder);
		}
		
		
		this.flyTo(api.getLongitude(), api.getLatitude(), api.getElevation(), api.getDuration());
	}
	else if (apiName === "gotoIssue")
	{
		var projectId = api.getProjectId();
		if (!this.hierarchyManager.existProject(projectId))
		{
			var projectDataFolder = api.getProjectDataFolder();
			this.getObjectIndexFile(projectId, projectDataFolder);
		}
		
		this.flyTo(api.getLongitude(), api.getLatitude(), api.getElevation(), api.getDuration());
		
		// pin을 그림
		if (api.getIssueId() !== null && api.getIssueType() !== undefined) 
		{
			DrawAPI.drawInsertIssueImage(api, this);
		}
	}
	else if (apiName === "getCoordinateRelativeToBuilding") 
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		var worldPoint = api.getInputPoint();
		var resultPoint = api.getResultPoint();
		
		if (projectId === undefined || dataKey === undefined || worldPoint === undefined)
		{ return undefined; }
		
		if (resultPoint === undefined)
		{ resultPoint = new Point3D(); }
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{ return undefined; }
		
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (geoLocDataManager === undefined)
		{ return undefined; }
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		resultPoint = geoLocdata.worldCoordToLocalCoord(worldPoint, resultPoint);
		return resultPoint;
	}
	else if (apiName === "getAbsoluteCoodinateOfBuildingPoint") 
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		var localPoint = api.getInputPoint();
		var resultPoint = api.getResultPoint();
		
		if (projectId === undefined || dataKey === undefined || localPoint === undefined)
		{ return undefined; }
		
		if (resultPoint === undefined)
		{ resultPoint = new Point3D(); }
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{ return undefined; }
		
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (geoLocDataManager === undefined)
		{ return undefined; }
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		resultPoint = geoLocdata.localCoordToWorldCoord(localPoint, resultPoint);
		return resultPoint;
	}
};

MagoManager.prototype.deleteAll = function ()
{
	// deselect.
	this.selectionCandidates.clearCandidates();
	this.selectionCandidates.clearCurrents();
	this.objectSelected = undefined;
	this.octreeSelected = undefined;
	this.buildingSelected = undefined;
	this.nodeSelected = undefined;
	
	// erase from processQueue and parseQueue. 
	this.parseQueue.clearAll();
	this.processQueue.clearAll();
	
	// clear current visibles.
	if (this.visibleObjControlerBuildings)
	{ this.visibleObjControlerBuildings.clear(); }
	if (this.visibleObjControlerNodes)
	{ this.visibleObjControlerNodes.clear(); }
	if (this.visibleObjControlerOctrees)
	{ this.visibleObjControlerOctrees.clear(); }
	
	// reset tiles.
	this.smartTileManager.resetTiles();
	
	// finally delete nodes.
	this.hierarchyManager.deleteNodes(this.sceneState.gl, this.vboMemoryManager);
};

MagoManager.prototype.checkCollision = function (position, direction)
{
	var gl = this.sceneState.gl;
	if (gl === undefined)	{ return; }

	var posX = this.sceneState.drawingBufferWidth * 0.5;
	var posY = this.sceneState.drawingBufferHeight * 0.5;
	
	var objects = this.getSelectedObjects(gl, posX, posY, this.arrayAuxSC);
	if (objects === undefined)	{ return; }

	var current_building = this.buildingSelected;
	this.buildingSelected = this.arrayAuxSC[0];

	var collisionPosition = new Point3D();
	var bottomPosition = new Point3D();

	this.calculatePixelPositionWorldCoord(gl, posX, posY, collisionPosition);
	this.swapRenderingFase();
	this.calculatePixelPositionWorldCoord(gl, posX, this.sceneState.drawingBufferHeight, bottomPosition);

	this.buildingSelected = current_building;
	var distance = collisionPosition.squareDistTo(position.x, position.y, position.z);
	this.swapRenderingFase();

	if (distance > 3.5)
	{
		var bottomPositionCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(bottomPosition);
		var currentPositionCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(position);
		var currentHeight = currentPositionCartographic.height;
		var bottomHeight = bottomPositionCartographic.height + 1.5;
	
		if ( bottomHeight < currentHeight )
		{
			currentHeight -= 0.2;
		}
	
		if ( bottomHeight > currentHeight || 
			(bottomHeight < currentHeight && currentHeight - bottomHeight > 1.5))
		{
			currentHeight = bottomHeight;
		}
		var tmpLat = Cesium.Math.toDegrees(currentPositionCartographic.latitude);
		var tmpLon = Cesium.Math.toDegrees(currentPositionCartographic.longitude);
		
		this.cameraFPV.camera.position = Cesium.Cartesian3.fromDegrees(tmpLon, tmpLat, currentHeight);

		return false; 
	}

	return true;
};;

'use strict';

/**
 * Factory method 패턴을 사용해서 cesium, worldwind 등을 wrapping 해 주는 클래스
 * @class ManagerFactory
 *
 * @param viewer 타 시스템과의 연동의 경우 view 객체가 생성되어서 넘어 오는 경우가 있음
 * @param containerId 뷰에서 표시할 위치 id
 * @param serverPolicy policy json object
 * @param projectIdArray json object map에 저장하기 위한 key
 * @param projectDataArray data json object
 * @param projectDataFolderArray f4d data folder path
 * @param imagePath 이미지 경로
 * @return api
 */
var ManagerFactory = function(viewer, containerId, serverPolicy, projectIdArray, projectDataArray, projectDataFolderArray, imagePath) 
{
	if (!(this instanceof ManagerFactory)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	var magoManager = null;
	var scene = null;
	var magoManagerState = CODE.magoManagerState.INIT;
	
	//var startMousePosition = null;
	//var nowMousePosition = null;

	// 환경 설정
	MagoConfig.init(serverPolicy, projectIdArray, projectDataArray);
	
	// 카메라 행동 설정
	function disableCameraMotion(state)
	{
		viewer.scene.screenSpaceCameraController.enableRotate = state;
		viewer.scene.screenSpaceCameraController.enableZoom = state;
		viewer.scene.screenSpaceCameraController.enableLook = state;
		viewer.scene.screenSpaceCameraController.enableTilt = state;
		viewer.scene.screenSpaceCameraController.enableTranslate = state;
	}
	
	// 이벤트 확장
	function addMouseAction() 
	{
		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionLeftDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionMiddleDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
		
		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionRightDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.RIGHT_DOWN);

		//var mousePosition;
		magoManager.handler.setInputAction(function(movement) 
		{
			//magoManager.mouseActionMove(movement.endPosition.x, movement.endPosition.y);
			//mousePosition = movement.endPosition;
			if (magoManager.mouseLeftDown) 
			{
				if (movement.startPosition.x !== movement.endPosition.x || movement.startPosition.y !== movement.endPosition.y) 
				{
					magoManager.manageMouseDragging(movement.startPosition.x, movement.startPosition.y);
					magoManager.cameraMoved();
				}
			}
			else
			{
				magoManager.mouseDragging = false;
				disableCameraMotion(true);
				if (magoManager.mouseMiddleDown || magoManager.mouseRightDown)
				{
					magoManager.isCameraMoving = true;
					magoManager.cameraMoved();
				}
			}
			
		}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
		/*
		// disable wheel for cesium.
		var handler = magoManager.scene.screenSpaceCameraController._aggregator._eventHandler;
        handler.removeInputAction(Cesium.ScreenSpaceEventType.WHEEL);
        for ( var modifierName in Cesium.KeyboardEventModifier) 
        {
            if (Cesium.KeyboardEventModifier.hasOwnProperty(modifierName)) 
            {
                var modifier = Cesium.KeyboardEventModifier[modifierName];
                if (modifier !== undefined) 
                {
                    handler.removeInputAction(Cesium.ScreenSpaceEventType.WHEEL, modifier);
                }
            }
        }
		
		// make mago wheel.
		magoManager.handler.setInputAction(function (wheelZoomAmount) {
			var cameraHeight, directionToZoom, zoomAmount;
			if (mousePosition) {
				cameraHeight = viewer.scene.globe.ellipsoid.cartesianToCartographic(viewer.camera.position).height || Number.MAX_VALUE;
				directionToZoom = viewer.camera.getPickRay(mousePosition).direction;
				zoomAmount = wheelZoomAmount * cameraHeight / 1000;
				
				if(wheelZoomAmount > magoManager.TEST_maxWheelZoomAmount)
					magoManager.TEST_maxWheelZoomAmount = wheelZoomAmount;
				
				if(zoomAmount > magoManager.TEST_maxZoomAmount)
					magoManager.TEST_maxZoomAmount = zoomAmount;
				
				if(cameraHeight < 1000)
				{
					if(wheelZoomAmount > 100)
						wheelZoomAmount = 100;
					
					if(zoomAmount > 80)
						zoomAmount = 80;
				}
				if(directionToZoom.x > 1 || directionToZoom.y > 1 || directionToZoom.z > 1 )
					var hola =0;
				
				viewer.camera.position.x = viewer.camera.position.x + directionToZoom.x * zoomAmount;
				viewer.camera.position.y = viewer.camera.position.y + directionToZoom.y * zoomAmount;
				viewer.camera.position.z = viewer.camera.position.z + directionToZoom.z * zoomAmount;
				//viewer.camera.move(directionToZoom, zoomAmount);
			}
		}, Cesium.ScreenSpaceEventType.WHEEL);
		*/
		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionLeftUp(movement.position.x, movement.position.y);
			// display current mouse position
			var pickPosition = {lat: null, lon: null, alt: null};
			var position = magoManager.scene.camera.pickEllipsoid(movement.position);
			if (position)
			{
				var cartographicPosition = Cesium.Cartographic.fromCartesian(position);
				pickPosition.lat = Cesium.Math.toDegrees(cartographicPosition.latitude);
				pickPosition.lon = Cesium.Math.toDegrees(cartographicPosition.longitude);
				pickPosition.alt = cartographicPosition.height;
			}
			if (MagoConfig.getPolicy().geo_callback_enable === "true") 
			{
				if (serverPolicy.geo_callback_clickposition !== '') 
				{
					clickPositionCallback(serverPolicy.geo_callback_clickposition, pickPosition);
				}
			}
	    }, Cesium.ScreenSpaceEventType.LEFT_UP);

		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionMiddleUp(movement.position.x, movement.position.y);
	    }, Cesium.ScreenSpaceEventType.MIDDLE_UP);
		
		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionRightUp(movement.position.x, movement.position.y);
	    }, Cesium.ScreenSpaceEventType.RIGHT_UP);
	}

	// cesium을 구현체로서 이용
	function initWwwMago(manager, gl) 
	{
		//var viewport = manager.wwd.viewport;
		//manager.selection.init(gl, viewport.width, viewport.height);
		manager.shadersManager.createDefaultShader(gl);
		manager.postFxShadersManager.gl = gl;
		manager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
		manager.createDefaultShaders(gl);// A1-Use this.***

		// object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
		//manager.getObjectIndexFile(); // old.***
		//viewer.scene.magoManager.getObjectIndexFile();
		if (projectIdArray !== null && projectIdArray.length > 0) 
		{
			for (var i=0; i<projectIdArray.length; i++) 
			{
				manager.getObjectIndexFile(projectIdArray[i], projectDataFolderArray[i]);
			}
		}
	}

	// cesium을 구현체로서 이용
	function drawCesium() 
	{
		var gl = viewer.scene.context._gl;
		//viewer.scene.magoManager.selection.init(gl, viewer.scene.drawingBufferWidth, viewer.scene.drawingBufferHeight);
		viewer.scene.magoManager.shadersManager.createDefaultShader(gl);
		viewer.scene.magoManager.postFxShadersManager.gl = gl;
		viewer.scene.magoManager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
		viewer.scene.magoManager.createDefaultShaders(gl);// A1-Use this.***
		viewer.scene.magoManager.scene = viewer.scene;

		// Start postRender version.***********************************************
		magoManager = viewer.scene.magoManager;
		scene = viewer.scene;
		//scene.copyGlobeDepth = true;
		viewer.scene.globe.depthTestAgainstTerrain = true;

		// object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
		//viewer.scene.magoManager.getObjectIndexFile();
		if (projectIdArray !== null && projectIdArray.length > 0) 
		{
			for (var i=0; i<projectIdArray.length; i++) 
			{
				viewer.scene.magoManager.getObjectIndexFile(projectIdArray[i], projectDataFolderArray[i]);
			}
		}
		viewer.scene.magoManager.handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
		addMouseAction();
		viewer.clock.onTick.addEventListener(function(clock) 
		{
			magoManager.cameraFPV.update(magoManager);
		});
	}
	
	// magoworld을 구현체로서 이용
	function drawMagoWorld() 
	{
		var gl = viewer.magoManager.sceneState.gl;
		var manager = viewer.magoManager;
		manager.shadersManager.createDefaultShader(gl);
		manager.postFxShadersManager.gl = gl;
		manager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
		manager.createDefaultShaders(gl);// A1-Use this.***
		//viewer.renderTest();
	};

	// 실제 화면에 object를 rendering 하는 메인 메서드
	function draw() 
	{
		if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM) 
		{
			drawCesium();
		}
		else if (MagoConfig.getPolicy().geo_view_library === Constant.WORLDWIND) 
		{
			//initWwwMago();
		}
		else if (MagoConfig.getPolicy().geo_view_library === Constant.MAGOWORLD) 
		{
			drawMagoWorld();
		}
	}

	/**
	 * add Layers
	 */
	function addImageryLayers() 
	{
		var provider = new Cesium.WebMapServiceImageryProvider({
			url        : MagoConfig.getPolicy().geo_server_add_url,
			layers     : MagoConfig.getPolicy().geo_server_add_layers,
			parameters : {
				service     : MagoConfig.getPolicy().geo_server_add_parameters_service,
				version     : MagoConfig.getPolicy().geo_server_add_parameters_version,
				request     : MagoConfig.getPolicy().geo_server_add_parameters_request,
				transparent : MagoConfig.getPolicy().geo_server_add_parameters_transparent,
				//tiled : MagoConfig.getPolicy().backgroundProvider.parameters.tiled,
				format      : MagoConfig.getPolicy().geo_server_add_parameters_format
				//				time : MagoConfig.getPolicy().backgroundProvider.parameters.time,
				//		    	rand : MagoConfig.getPolicy().backgroundProvider.parameters.rand,
				//		    	asdf : MagoConfig.getPolicy().backgroundProvider.parameters.asdf
			}
			//,proxy: new Cesium.DefaultProxy('/proxy/')
		});

		//		if(index) viewer.imageryLayers.addImageryProvider(provider, index);
		viewer.imageryLayers.addImageryProvider(provider);
	}

	/**
	 * zoomTo 할 Entity
	 * @returns entities
	 */
	function initEntity() 
	{
		return viewer.entities.add({
			name     : "mago3D",
			position : Cesium.Cartesian3.fromDegrees(37.521168, 126.924185, 3000.0),
			box      : {
				dimensions : new Cesium.Cartesian3(300000.0*1000.0, 300000.0*1000.0, 300000.0*1000.0), // dimensions : new Cesium.Cartesian3(400000.0, 300000.0, 500000.0),
				fill       : true,
				material   : Cesium.Color.BLUE,
				outline    : false
			}
		});
	}

	// terrain 적용 유무를 설정
	function initTerrain() 
	{
		/*		if(MagoConfig.getPolicy().geoConfig.initTerrain.enable) {
			var terrainProvider = new Cesium.CesiumTerrainProvider({
				url : MagoConfig.getPolicy().geoConfig.initTerrain.url,
				requestWaterMask: MagoConfig.getPolicy().geoConfig.initTerrain.requestWaterMask,
				requestVertexNormals: MagoConfig.getPolicy().geoConfig.initTerrain.requestVertexNormals
			});
			viewer.terrainProvider = terrainProvider;
		}*/
	}

	// 최초 로딩시 이동할 카메라 위치
	function initCamera() 
	{
		viewer.camera.flyTo({
			destination: Cesium.Cartesian3.fromDegrees(parseFloat(MagoConfig.getPolicy().geo_init_longitude),
				parseFloat(MagoConfig.getPolicy().geo_init_latitude),
				parseFloat(MagoConfig.getPolicy().geo_init_height)),
			duration: parseInt(MagoConfig.getPolicy().geo_init_duration)
		});
	}

	// deploy 타입 적용
	function initRenderMode() 
	{
		var api = new API("renderMode");
		magoManager.callAPI(api);

		if (MagoConfig.getPolicy().geo_time_line_enable === "false") 
		{
			// visible <---> hidden
			$(viewer._animation.container).css("visibility", "hidden");
			$(viewer._timeline.container).css("visibility", "hidden");
			viewer.forceResize();
		}
	}
	
	var DEFALUT_IMAGE = "ESRI World Imagery";
	var DEFALUT_TERRAIN = "WGS84 Ellipsoid";
	
	// pick baseLayer
	function setDefaultDataset() 
	{
		// WGS84 Ellipsoide
		if (MagoConfig.getPolicy().geo_init_default_terrain !== null && MagoConfig.getPolicy().geo_init_default_terrain !== "") 
		{
			DEFALUT_TERRAIN = MagoConfig.getPolicy().geo_init_default_terrain;
		}
		
		// search default imageryProvider from baseLayerPicker
		var imageryProvider = null;
		var imageryProviderViewModels = viewer.baseLayerPicker.viewModel.imageryProviderViewModels; 
		for (var i in imageryProviderViewModels) 
		{
			if (!imageryProviderViewModels.hasOwnProperty(i))	{ continue; }

			var provider = imageryProviderViewModels[i];
			if (provider.name === DEFALUT_IMAGE) 
			{
				imageryProvider = provider;
				break;
			}
		}
		if (imageryProvider) { viewer.baseLayerPicker.viewModel.selectedImagery = imageryProvider; }
	  
		// search default terrainProvider from baseLayerPicker
		var terrainProvider = null;
		var terrainProviderViewModels = viewer.baseLayerPicker.viewModel.terrainProviderViewModels;
		for (var i in terrainProviderViewModels) 
		{
			if (!terrainProviderViewModels.hasOwnProperty(i))	{ continue; }
			var provider = terrainProviderViewModels[i];
			if (provider.name === DEFALUT_TERRAIN) 
			{
				terrainProvider = provider;
				break;
			}
		}
		if (terrainProvider) { viewer.baseLayerPicker.viewModel.selectedTerrain = terrainProvider; }
	}

	if (serverPolicy.geo_view_library === null ||
		serverPolicy.geo_view_library === '' ||
		serverPolicy.geo_view_library === Constant.CESIUM) 
	{
		// webgl lost events.******************************************
		var canvas = document.getElementById(containerId);
		canvas.addEventListener('webglcontextlost', function(e) 
		{
			console.log(e);
		}, false);
		
		canvas.addEventListener('webglcontextrestored', function(e) 
		{
		  console.log(e); 
		}, false);
		//-------------------------------------------------------------

		if (serverPolicy.geo_server_enable === "true" && serverPolicy.geo_server_url !== null && serverPolicy.geo_server_url !== '') 
		{
			var imageryProvider = new Cesium.WebMapServiceImageryProvider({
				url        : serverPolicy.geo_server_url,
				layers     : serverPolicy.geo_server_layers,
				parameters : {
					service     : serverPolicy.geo_server_parameters_service,
					version     : serverPolicy.geo_server_parameters_version,
					request     : serverPolicy.geo_server_parameters_request,
					transparent : serverPolicy.geo_server_parameters_transparent,
					format      : serverPolicy.geo_server_parameters_format
				}//,
				//proxy: new Cesium.DefaultProxy('/proxy/')
			});
			var options = {imageryProvider: imageryProvider, baseLayerPicker: false};
			if (viewer === null) { viewer = new Cesium.Viewer(containerId, options); }
		}
		else 
		{
			if (serverPolicy.geo_cesium_ion_token !== null && serverPolicy.geo_cesium_ion_token !== "") 
			{
				Cesium.Ion.defaultAccessToken = serverPolicy.geo_cesium_ion_token;
				DEFALUT_TERRAIN = "Cesium World Terrain";
			}
			if (viewer === null) { viewer = new Cesium.Viewer(containerId); }
			// 기본 지도 설정
			setDefaultDataset();
		}
			
		viewer.scene.magoManager = new MagoManager();
		viewer.scene.magoManager.sceneState.textureFlipYAxis = false;
		viewer.camera.frustum.fov = Cesium.Math.PI_OVER_THREE*1.8;
		//viewer.camera.frustum.near = 0.1;
		if (MagoConfig.getPolicy().geo_init_default_fov > 0) 
		{
			viewer.camera.frustum.fov = Cesium.Math.PI_OVER_THREE * MagoConfig.getPolicy().geo_init_default_fov;
		}

		// Layers 추가 적용
		if (serverPolicy.geo_server_enable === "true" && serverPolicy.geo_server_add_url !== null && serverPolicy.geo_server_add_url !== '') 
		{ 
			addImageryLayers(); 
		}
			
		draw();
		// build을 rendering 할 위치
		initEntity();
		// terrain 적용 여부
		/*if() {
				initTerrain();
			}*/
		// 최초 로딩시 카메라 이동 여부
		if (serverPolicy.geo_init_camera_enable === "true") { initCamera(); }
		// render Mode 적용
		initRenderMode();
	}
	else if (serverPolicy.geo_view_library === Constant.WORLDWIND) 
	{
			
		// Tell World Wind to log only warnings and errors.
		WorldWind.Logger.setLoggingLevel(WorldWind.Logger.LEVEL_WARNING);

		// set to canvas the current gl.***
		var canvas = document.getElementById(containerId);
			
		var wwd;
		if (serverPolicy.geo_server_enable === "true" && serverPolicy.geo_server_url !== null && serverPolicy.geo_server_url !== '') 
		{
			wwd = new WorldWind.WorldWindow(containerId, new WorldWind.ZeroElevationModel());
				
			// Web Map Service information
			var serviceAddress = serverPolicy.geo_server_url + "?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0";

			// Named layer displaying Average Temperature data
			var layerName = "mago3d";

			// Called asynchronously to parse and create the WMS layer
			var createLayer = function (xmlDom) 
			{
				// Create a WmsCapabilities object from the XML DOM
				var wms = new WorldWind.WmsCapabilities(xmlDom);
				// Retrieve a WmsLayerCapabilities object by the desired layer name
				var wmsLayerCapabilities = wms.getNamedLayer(layerName);
				// Form a configuration object from the WmsLayerCapability object
				var wmsConfig = WorldWind.WmsLayer.formLayerConfiguration(wmsLayerCapabilities);
				// Modify the configuration objects title property to a more user friendly title
				wmsConfig.title = "imageProvider";
				// Create the WMS Layer from the configuration object
				var wmsLayer = new WorldWind.WmsLayer(wmsConfig);

				// Add the layers to WorldWind and update the layer manager
				wwd.addLayer(wmsLayer);
			};

				// Called if an error occurs during WMS Capabilities document retrieval
			var logError = function (jqXhr, text, exception) 
			{
				console.log("There was a failure retrieving the capabilities document: " + text + " exception: " + exception);
			};

			$.get(serviceAddress).done(createLayer).fail(logError);
		}
		else 
		{
			// Create the World Window.
			wwd = new WorldWind.WorldWindow(containerId);
			//wwd.depthBits = 32;
				
			var layers = [
				{layer: new WorldWind.BMNGLayer(), enabled: true},
				{layer: new WorldWind.BMNGLandsatLayer(), enabled: false},
				{layer: new WorldWind.BingAerialWithLabelsLayer(null), enabled: true},
				{layer: new WorldWind.OpenStreetMapImageLayer(null), enabled: false},
				{layer: new WorldWind.CompassLayer(), enabled: false},
				{layer: new WorldWind.CoordinatesDisplayLayer(wwd), enabled: true},
				{layer: new WorldWind.ViewControlsLayer(wwd), enabled: true}
			];

			for (var l = 0; l < layers.length; l++) 
			{
				layers[l].layer.enabled = layers[l].enabled;
				wwd.addLayer(layers[l].layer);
			}
		}

		// Now set up to handle highlighting.
		//var highlightController = new WorldWind.HighlightController(wwd);

		magoManager = new MagoManager();
		magoManager.wwd = wwd;
		magoManager.sceneState.textureFlipYAxis = true;
			
		var newRenderableLayer = new WorldWind.RenderableLayer();
		newRenderableLayer.displayName = "F4D tiles";
		newRenderableLayer.inCurrentFrame = true; // Test.***
		wwd.addLayer(newRenderableLayer);
			
		//newRenderableLayer.addRenderable(f4d_wwwLayer);// old.***
		newRenderableLayer.addRenderable(magoManager);
		// End Create a layer to hold the f4dBuildings.-------------------------------------------------------

		var gl = wwd.drawContext.currentGlContext;
		initWwwMago(magoManager, gl);

		// Click event. 
		// The common gesture-handling function.
		var handleClick = function (recognizer) 
		{
			// Obtain the event location.
			//magoManager.mouse_x = event.layerX,
			//magoManager.mouse_y = event.layerY;
			//magoManager.bPicking = true;
				
			// Perform the pick. Must first convert from window coordinates to canvas coordinates, which are
			// relative to the upper left corner of the canvas rather than the upper left corner of the page.
			//var pickList = wwd.pick(wwd.canvasCoordinates(x, y));

			// If only one thing is picked and it is the terrain, use a go-to animator to go to the picked location.
			/*
				if (pickList.objects.length === 1 && pickList.objects[0].isTerrain) {
					var position = pickList.objects[0].position;
					//wwd.goTo(new WorldWind.Location(position.latitude, position.longitude));
					//wwd.goTo(new WorldWind.Position(37.48666, 127.05618, 500));
					wwd.goToOriented(new WorldWind.Position(37.48666, 127.05618, 500.0), 120.0, 80.0);
				}
				*/
		};

			// Listen for mouse clicks.
		var clickRecognizer = new WorldWind.ClickRecognizer(wwd, handleClick);
		clickRecognizer.button = 0;  //left mouse button
			
		var mouseDownEvent = function(event) 
		{
			if (event.button === 0) 
			{ 
				magoManager.mouseActionLeftDown(event.layerX, event.layerY); 
			}
			else if (event.button === 1) 
			{ 
				magoManager.mouseActionMiddleDown(event.layerX, event.layerY); 
			}
			else if (event.button === 2) 
			{ 
				magoManager.mouseActionRightDown(event.layerX, event.layerY); 
			}
		};
		wwd.addEventListener("mousedown", mouseDownEvent, false);
			
		var mouseUpEvent = function(event) 
		{
			if (event.button === 0) 
			{ 
				magoManager.mouseActionLeftUp(event.layerX, event.layerY);
			}
			else if (event.button === 1) 
			{ 
				magoManager.mouseActionMiddleUp(event.layerX, event.layerY);
			}
			else if (event.button === 2) 
			{ 
				magoManager.mouseActionRightUp(event.layerX, event.layerY);
			}

			// display current mouse position
				
			var terrainObject;
			var pickPosition = {lat: null, lon: null, alt: null};
			var pickPoint = wwd.canvasCoordinates(event.layerX, event.layerY);
			if (pickPoint[0] >= 0 && pickPoint[0] < wwd.canvas.width &&
					pickPoint[1] >= 0 && pickPoint[1] < wwd.canvas.height)
			{
				terrainObject = wwd.pickTerrain(pickPoint).terrainObject();
				var terrainPosition = terrainObject ? terrainObject.position : null;
				if (terrainPosition !== null)
				{
					pickPosition.lat = terrainPosition.latitude;
					pickPosition.lon = terrainPosition.longitude;
					pickPosition.alt = terrainPosition.altitude;	
				}
			}
			if (MagoConfig.getPolicy().geo_callback_enable === "true") 
			{
				if (serverPolicy.geo_callback_clickposition !== '') 
				{
					clickPositionCallback(serverPolicy.geo_callback_clickposition, pickPosition);
				}
			}
		};
		wwd.addEventListener("mouseup", mouseUpEvent, false);
			
		var mouseMoveEvent = function(event) 
		{
			magoManager.mouse_x = event.layerX,
			magoManager.mouse_y = event.layerY;
			if (magoManager.mouseLeftDown) 
			{ 
				magoManager.manageMouseDragging(event.layerX, event.layerY); 
				magoManager.cameraMoved();
			}
			else if (magoManager.mouseMiddleDown || magoManager.mouseRightDown) 
			{ 
				magoManager.cameraMoved();
			}
				
		};
		wwd.addEventListener("mousemove", mouseMoveEvent, false);
		
		wwd.goToAnimator.travelTime = MagoConfig.getPolicy().geo_init_duration * 1000;
		wwd.goTo(new WorldWind.Position(MagoConfig.getPolicy().geo_init_latitude, MagoConfig.getPolicy().geo_init_longitude, MagoConfig.getPolicy().geo_init_height));
	}
	if (serverPolicy.geo_view_library === Constant.MAGOWORLD) 
	{
		var canvas = document.getElementById(containerId);
		var glAttrs = {antialias: false, stencil: true};
		var gl = canvas.getContext("webgl", glAttrs);
		if (!gl)
		{ gl = canvas.getContext("experimental-webgl", glAttrs); }
		
		// Problem: canvas-width initially is 300 and canvas-height = 150.***
		canvas.width = canvas.clientWidth;
		canvas.height = canvas.clientHeight;
		
		magoManager = new MagoManager();
		var sceneState = magoManager.sceneState;
		sceneState.textureFlipYAxis = true;
		sceneState.gl = gl;
		sceneState.drawingBufferWidth[0] = canvas.clientWidth;
		sceneState.drawingBufferHeight[0] = canvas.clientHeight;
		sceneState.camera.frustum.aspectRatio = canvas.clientWidth/canvas.clientHeight;
		sceneState.camera.frustum.fovRad[0] = Math.PI/3*1.8;
		sceneState.camera.frustum.fovyRad[0] = sceneState.camera.frustum.fovRad[0]/sceneState.camera.frustum.aspectRatio;
		sceneState.camera.frustum.tangentOfHalfFovy[0] = Math.tan(sceneState.camera.frustum.fovyRad[0]/2);
		
		
		// initial camera position.***
		sceneState.camera.position.set(0.0, 0.0, 10000000.0);
		sceneState.camera.direction.set(0.0, 0.0, -1.0);
		sceneState.camera.up.set(0.0, 1.0, 0.0);
		
		// test init camera position.***
		//sphere.r = 6378137.0;
		sceneState.encodedCamPosHigh[0] = 0;
		sceneState.encodedCamPosHigh[1] = 0;
		sceneState.encodedCamPosHigh[2] = 10000000.0;
		
		sceneState.encodedCamPosLow[0] = 0;
		sceneState.encodedCamPosLow[1] = 0;
		sceneState.encodedCamPosLow[2] = 0;

		
		viewer = new MagoWorld(magoManager);
		magoManager.magoWorld = viewer;
		magoManager.globe = new Globe();
		// init matrices.***
		viewer.updateModelViewMatrixByCamera(sceneState.camera);
		//magoManager.upDateSceneStateMatrices(sceneState);
		
		// event listener.***
		canvas.addEventListener('mousedown', function(event)
		{
			viewer.mousedown(event);			
		}, false);
		
		canvas.addEventListener('mouseup', function(event)
		{
			viewer.mouseup(event);			
		}, false);
		
		canvas.addEventListener('mousewheel', function(event)
		{
			viewer.mousewheel(event); 
		}, false);
		
		canvas.addEventListener('mousemove', function(event)
		{
			viewer.mousemove(event);
		}, false);
		
		canvas.addEventListener('resize', function(event)
		{
			var hola = 0; // no works.***
		}, false);
		
		canvas.addEventListener('keydown', function(event) // no works.***
		{
			viewer.keydown(event); // no works.***
		}, false);

		
		draw();
	}

	// 이미지 경로
	magoManager.magoPolicy.imagePath = imagePath;
	magoManagerState = CODE.magoManagerState.READY;

	// KeyPressEvents.**************************************
	document.addEventListener('keydown', function(event) 
	{
		// get current building selected
		if (magoManager.magoPolicy.issueInsertEnable)	{ return; }

		var selectedBuilding = magoManager.buildingSelected;	
		if (selectedBuilding === undefined) 	{ return; }

		var nodeSelected = magoManager.selectionCandidates.currentNodeSelected;
		if (nodeSelected === undefined)
		{ return; }
		var rootNodeSelected = nodeSelected.getRoot();
		var geoLocationData = rootNodeSelected.data.geoLocDataManager.getCurrentGeoLocationData();
		if (geoLocationData === undefined)		{ return; }

		var increDeg = 3.0;
		var currentHeading = geoLocationData.heading || 0;
		var currentPitch = geoLocationData.pitch || 0;
		var currentRoll = geoLocationData.roll || 0;
		
		var increDist = 0.2;
		var currentAlt = geoLocationData.geographicCoord.altitude || 0;
		var displayData = false;
		
		// For Heading
		if (event.keyCode === 'Q'.charCodeAt(0))
		{
			currentHeading += increDeg;
			displayData = true;
		}
		else if (event.keyCode === 'A'.charCodeAt(0))
		{
			currentHeading -= increDeg;
			displayData = true;
		}
		
		// For Pitch
		if (event.keyCode === 'W'.charCodeAt(0))
		{
			currentPitch += increDeg;
			displayData = true;
		}
		else if (event.keyCode === 'S'.charCodeAt(0))
		{
			currentPitch -= increDeg;
			displayData = true;
		}

		// For Roll
		if (event.keyCode === 'E'.charCodeAt(0))
		{
			currentRoll += increDeg;
			displayData = true;
		}
		else if (event.keyCode === 'D'.charCodeAt(0))
		{
			currentRoll -= increDeg;
			displayData = true;
		}
		
		// For Altitude
		if (event.keyCode === 'Z'.charCodeAt(0))
		{
			currentAlt += increDist;
			displayData = true;
		}
		else if (event.keyCode === 'X'.charCodeAt(0))
		{
			currentAlt -= increDist;
			displayData = true;
		}

		if (displayData)
		{ magoManager.changeLocationAndRotationNode(nodeSelected, geoLocationData.geographicCoord.latitude, geoLocationData.geographicCoord.longitude, currentAlt, currentHeading, currentPitch, currentRoll); }

	}, false);
	
	// TODO API 객체를 생성해서 하나의 parameter로 전달하는 방식이 좀 더 깔끔할거 같지만 성능적인 부분에서 조금은 투박할거 같아서 일단 이렇게 처리
	return {
		// api gateway 역할
		callAPI: function(api) 
		{
		    if (api.getReturnable()) 
			{
		        return magoManager.callAPI(api);
			}
			else 
			{
				magoManager.callAPI(api);
			}
		},
		// flyTo: function(issueId, issueType, longitude, latitude, height, duration)
		// {
		// 	if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM)
		// 	{
		// 		viewer.camera.flyTo({
		// 			destination: Cesium.Cartesian3.fromDegrees(parseFloat(longitude),
		// 				parseFloat(latitude),
		// 				parseFloat(height) + 10),
		// 			duration: parseInt(duration)
		// 		});
		// 	}
		// 	else
		// 	{
		// 		wwd.goToAnimator.travelTime = duration * 1000;
		// 		wwd.goTo(new WorldWind.Position(parseFloat(latitude), parseFloat(longitude), parseFloat(height) + 50));
		// 	}
		// 	// pin을 그림
		// 	if (issueId !== null && issueType !== undefined)
		// 	{
		// 		var api = new API("drawInsertIssueImage");
		// 		api.setDrawType(0);
		// 		api.setIssueId(issueId);
		// 		api.setIssueType(issueType);
		// 		api.setDataKey(null);
		// 		api.setLatitude(latitude);
		// 		api.setLongitude(longitude);
		// 		api.setElevation(height);
		// 		magoManager.callAPI(api);
		// 	}
		// },
		// magoManager 상태
		getViewer: function()
		{
			return viewer;
		},
		getMagoManagerState: function() 
		{
			return magoManagerState;
		}
	};
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Matrix4
 */
var Matrix4 = function() 
{
	if (!(this instanceof Matrix4)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this._floatArrays = [ 	1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	];
};

/**
 * 어떤 일을 하고 있습니까?
 */
Matrix4.prototype.Identity = function() 
{
	this._floatArrays = [ 	1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns rowMajor_matrix
 */
Matrix4.prototype.deleteObjects = function() 
{
	this._floatArrays = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns rowMajor_matrix
 */
Matrix4.prototype.getRowMajorMatrix = function() 
{
	var rowMajor_matrix = new Float32Array(16);

	rowMajor_matrix[0] = this.get(0, 0);
	rowMajor_matrix[1] = this.get(1, 0);
	rowMajor_matrix[2] = this.get(2, 0);
	rowMajor_matrix[3] = this.get(3, 0);

	rowMajor_matrix[4] = this.get(0, 1);
	rowMajor_matrix[5] = this.get(1, 1);
	rowMajor_matrix[6] = this.get(2, 1);
	rowMajor_matrix[7] = this.get(3, 1);

	rowMajor_matrix[8] = this.get(0, 2);
	rowMajor_matrix[9] = this.get(1, 2);
	rowMajor_matrix[10] = this.get(2, 2);
	rowMajor_matrix[11] = this.get(3, 2);

	rowMajor_matrix[12] = this.get(0, 3);
	rowMajor_matrix[13] = this.get(1, 3);
	rowMajor_matrix[14] = this.get(2, 3);
	rowMajor_matrix[15] = this.get(3, 3);

	return rowMajor_matrix;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angRad 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Matrix4.getRotationDegZXYMatrix = function(zRotDeg, xRotDeg, yRotDeg, resultMatrix4) 
{
	// static function.***
	var xRotMatrix = new Matrix4();  // created as identity matrix.
	var yRotMatrix = new Matrix4();  // created as identity matrix.
	var zRotMatrix = new Matrix4();  // created as identity matrix.
	
	if (zRotDeg !== undefined && zRotDeg !== 0)
	{ zRotMatrix.rotationAxisAngDeg(zRotDeg, 0.0, 0.0, 1.0); }

	if (xRotDeg !== undefined && xRotDeg !== 0)
	{ xRotMatrix.rotationAxisAngDeg(xRotDeg, 1.0, 0.0, 0.0); }

	if (yRotDeg !== undefined && yRotDeg !== 0)
	{ yRotMatrix.rotationAxisAngDeg(yRotDeg, 0.0, 1.0, 0.0); }


	if (resultMatrix4 === undefined)
	{ resultMatrix4 = new Matrix4(); }  // created as identity matrix.


	var zRotatedTMatrix;
	var zxRotatedTMatrix;
	var zxyRotatedTMatrix;

	zRotatedTMatrix = zRotMatrix;
	zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
	zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
	
	resultMatrix4 = zxyRotatedTMatrix;
	return resultMatrix4;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angDeg 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Matrix4.prototype.rotationAxisAngDeg = function(angDeg, axis_x, axis_y, axis_z) 
{
	var quaternion = new Quaternion();
	quaternion.rotationAngDeg(angDeg, axis_x, axis_y, axis_z);
	this.rotationByQuaternion(quaternion);
	quaternion = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angRad 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Matrix4.prototype.rotationAxisAngRad = function(angRad, axis_x, axis_y, axis_z) 
{
	var quaternion = new Quaternion();
	quaternion.rotationAngRad(angRad, axis_x, axis_y, axis_z);
	this.rotationByQuaternion(quaternion);
	quaternion = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param quaternion 변수
 */
Matrix4.prototype.rotationByQuaternion = function(quaternion) 
{
	var w = quaternion.w;
	var x = quaternion.x;
	var y = quaternion.y;
	var z = quaternion.z;

	this._floatArrays[this.getIndexOfArray(0, 0)] = 1 - 2*y*y - 2*z*z;
	this._floatArrays[this.getIndexOfArray(0, 1)] = 2*x*y + 2*z*w;
	this._floatArrays[this.getIndexOfArray(0, 2)] = 2*x*z - 2*y*w;
	this._floatArrays[this.getIndexOfArray(0, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(1, 0)] = 2*x*y - 2*z*w;
	this._floatArrays[this.getIndexOfArray(1, 1)] = 1 - 2*x*x - 2*z*z;
	this._floatArrays[this.getIndexOfArray(1, 2)] = 2*y*z + 2*x*w;
	this._floatArrays[this.getIndexOfArray(1, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(2, 0)] = 2*x*z + 2*y*w;
	this._floatArrays[this.getIndexOfArray(2, 1)] = 2*y*z - 2*x*w;
	this._floatArrays[this.getIndexOfArray(2, 2)] = 1 - 2*x*x - 2*y*y;
	this._floatArrays[this.getIndexOfArray(2, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(3, 0)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 1)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 2)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 3)] = 1.0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param float32array 변수
 */
Matrix4.prototype.setByFloat32Array = function(float32array) 
{
	for (var i=0; i<16; i++) 
	{
		this._floatArrays[i] = float32array[i];
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param col 변수
 * @param row 변수
 */
Matrix4.prototype.getIndexOfArray = function(col, row) 
{
	return 4 * col + row;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param col 변수
 * @param row 변수
 */
Matrix4.prototype.get = function(col, row) 
{
	if (this._floatArrays === null)
	{ return null; }
	
	return this._floatArrays[this.getIndexOfArray(col, row)];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param col 변수
 * @param row 변수
 */
Matrix4.prototype.set = function(col, row, value) 
{
	this._floatArrays[this.getIndexOfArray(col, row)] = value;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param point3d 변수
 * @param result_point3d 변수
 * @returns result_point3d
 */
Matrix4.prototype.transformPoint3D = function(point3d, result_point3d) 
{
	if (result_point3d === undefined) { result_point3d = new Point3D(); }

	var x = point3d.x;
	var y = point3d.y;
	var z = point3d.z;

	result_point3d.x = x*this.get(0, 0) + y*this.get(1, 0) + z*this.get(2, 0) + this.get(3, 0);
	result_point3d.y = x*this.get(0, 1) + y*this.get(1, 1) + z*this.get(2, 1) + this.get(3, 1);
	result_point3d.z = x*this.get(0, 2) + y*this.get(1, 2) + z*this.get(2, 2) + this.get(3, 2);

	return result_point3d;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param point3d 변수
 * @param result_point3d 변수
 * @returns result_point3d
 */
Matrix4.prototype.rotatePoint3D = function(point3d, result_point3d) 
{
	if (result_point3d === undefined) { result_point3d = new Point3D(); }

	var x = point3d.x;
	var y = point3d.y;
	var z = point3d.z;

	result_point3d.x = x*this.get(0, 0) + y*this.get(1, 0) + z*this.get(2, 0);
	result_point3d.y = x*this.get(0, 1) + y*this.get(1, 1) + z*this.get(2, 1);
	result_point3d.z = x*this.get(0, 2) + y*this.get(1, 2) + z*this.get(2, 2);

	return result_point3d;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param matrix 변수
 * @param resultMat 변수
 * @returns resultMat
 */
Matrix4.prototype.getMultipliedByMatrix = function(matrix, resultMat) 
{

	if (resultMat === undefined) { resultMat = new Matrix4(); }

	for (var i=0; i<4; i++) 
	{
		for (var j=0; j<4; j++) 
		{
			var idx = this.getIndexOfArray(i, j);
			resultMat._floatArrays[idx] = 0.0;
			for (var k=0; k<4; k++) 
			{
				resultMat._floatArrays[idx] += matrix.get(k, j) * this.get(i, k);
			}
		}
	}
	return resultMat;
};

Matrix4.prototype.setToPerspectiveProjection = function (fovyrad, aspect, near, far) 
{
	var yScale = 1.0 / Math.tan(fovyrad / 2);
	var xScale = yScale / aspect;
	var nearmfar = near - far;
	this.setByFloat32Array([xScale, 0, 0, 0,
		0, yScale, 0, 0,
		0, 0, (far + near) / nearmfar, -1,
		0, 0, 2*far*near / nearmfar, 0 ]);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param matrix 변수
 * @param resultMat 변수
 * @returns resultMat
 */
Matrix4.prototype.copyFromMatrix4 = function(matrix) 
{
	for (var i=0; i<16; i++)
	{
		this._floatArrays[i] = matrix._floatArrays[i];
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param matrix 변수
 * @param resultMat 변수
 * @returns resultMat
 */
Matrix4.prototype.copyFromFloatArray = function(floatArrays) 
{
	for (var i=0; i<16; i++)
	{
		this._floatArrays[i] = floatArrays[i];
	}
};

/**
 * Returns if the value is aproximately equal to the valueToCompare with error.
 * @returns {boolean} are equal.
 */
Matrix4.prototype.computeMatrixType = function() 
{
	// matrixType = 0 -> identity matrix.
	// matrixType = 1 -> translate matrix.
	// matrixType = 2 -> transform matrix.
	
	var error = 10E-8;
	if (this.isRotationIdentity())
	{
		// check if there are translation.
		if (this.aproxEqual(this._floatArrays[3], 0, error))
		{
			if (this.aproxEqual(this._floatArrays[7], 0, error))
			{
				if (this.aproxEqual(this._floatArrays[11], 0, error))
				{
					if (this.aproxEqual(this._floatArrays[12], 0, error))
					{
						if (this.aproxEqual(this._floatArrays[13], 0, error))
						{
							if (this.aproxEqual(this._floatArrays[14], 0, error))
							{
								if (this.aproxEqual(this._floatArrays[15], 1, error))
								{
									return 0;
								}
								else { return 1; }
							}
							else { return 1; }
						}
						else { return 1; }
					}
					else { return 1; }
				}
				else { return 1; }
			}
			else { return 1; }
		}
		else { return 1; }
	}
	else
	{
		return 2;
	}
};

/**
 * Returns if the value is aproximately equal to the valueToCompare with error.
 * @returns {boolean} are equal.
 */
Matrix4.prototype.aproxEqual = function(value, valueToCompare, error) 
{
	if (error === undefined)
	{ error = 10E-8; }
	
	if (value === valueToCompare)
	{
		return true;
	}
	else
	{
		if (value > (valueToCompare - error) && value < (valueToCompare + error))
		{ return true; }
		else
		{ return false; }
	}
};

/**
 * Returns if the arrayA equal to the arrayB.
 * @returns {boolean} are equal.
 */
Matrix4.areEqualArrays = function(arrayA, arrayB) 
{
	var areEqual = true;
	var i=0;
	while (areEqual && i<16)
	{
		if (arrayA[i] !== arrayB[i])
		{
			areEqual = false;
		}
		i++;
	}
	
	return areEqual;
};

/**
 * Returns if the matrix is identity.
 * @returns {boolean} matrixIsIdentity.
 */
Matrix4.prototype.isIdentity = function(error) 
{	
	if (this.isRotationIdentity())
	{
		if (this.aproxEqual(this._floatArrays[3], 0, error))
		{
			if (this.aproxEqual(this._floatArrays[7], 0, error))
			{
				if (this.aproxEqual(this._floatArrays[11], 0, error))
				{
					if (this.aproxEqual(this._floatArrays[12], 0, error))
					{
						if (this.aproxEqual(this._floatArrays[13], 0, error))
						{
							if (this.aproxEqual(this._floatArrays[14], 0, error))
							{
								if (this.aproxEqual(this._floatArrays[15], 1, error))
								{
									return true;
								}
								else { return false; }
							}
							else { return false; }
						}
						else { return false; }
					}
					else { return false; }
				}
				else { return false; }
			}
			else { return false; }
		}
		else { return false; }
	}
	else
	{ return false; }
};

/**
 * Returns if the matrix is identity.
 * @returns {boolean} matrixIsIdentity.
 */
Matrix4.prototype.isRotationIdentity = function(error) 
{
	if (this.aproxEqual(this._floatArrays[0], 1, error))
	{
		if (this.aproxEqual(this._floatArrays[1], 0, error))
		{
			if (this.aproxEqual(this._floatArrays[2], 0, error))
			{
				if (this.aproxEqual(this._floatArrays[4], 0, error))
				{
					if (this.aproxEqual(this._floatArrays[5], 1, error))
					{
						if (this.aproxEqual(this._floatArrays[6], 0, error))
						{
							if (this.aproxEqual(this._floatArrays[8], 0, error))
							{
								if (this.aproxEqual(this._floatArrays[9], 0, error))
								{
									if (this.aproxEqual(this._floatArrays[10], 1, error))
									{
										return true;
									}
									else { return false; }
								}
								else { return false; }
							}
							else { return false; }
						}
						else { return false; }
					}
					else { return false; }
				}
				else { return false; }
			}
			else { return false; }
		}
		else { return false; }
	}
	else { return false; }
};























'use strict';

var Messages = {};

Messages.CONSTRUCT_ERROR = "이 객체는 new를 사용하여 생성해야 합니다.";
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class MouseAction
 */
var MouseAction = function() 
{
	if (!(this instanceof MouseAction)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// current.***
	this.curX;
	this.curY;
	this.curCamCoordPoint;
	this.curWorldPoint;
	this.curWorldPoint2;
	this.curModelViewMatrix = new Matrix4();
	this.curModelViewMatrixInv = new Matrix4();
	
	// start.***
	this.strX;
	this.strY;
	this.strCamCoordPoint;
	this.strWorldPoint;
	
	// cameraStatus.***
	this.curCamera = new Camera();
	this.curCameraTarget = new Float32Array([0.0, 0.0, 0.0]);
	
	// Camera rotation.***
	this.camRotPoint = new Point3D();
	this.camRotAxis = new Point3D();
	
};

MouseAction.prototype.saveCurrentToStart = function()
{
	this.strX = this.curX;
	this.strY = this.curY;
	
	// world point.***
	if (this.strWorldPoint === undefined)
	{ this.strWorldPoint = new Point3D(); }
	
	if (this.curWorldPoint)
	{
		this.strWorldPoint.copyFrom(this.curWorldPoint);
	}
	
	// camCoord point.***
	if (this.strCamCoordPoint === undefined)
	{ this.strCamCoordPoint = new Point3D(); }
	
	if (this.curCamCoordPoint)
	{
		this.strCamCoordPoint.copyFrom(this.curCamCoordPoint);
	}
};







































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarker
 *
 */
var ObjectMarker = function() 
{
	if (!(this instanceof ObjectMarker)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.geoLocationData = new GeoLocationData();
	this.issue_id = null;
	this.issue_type = null;
	//this.latitude = 0;
	//this.longitude = 0;
	//this.height = 0;
};

ObjectMarker.prototype.copyFrom = function(objMarker) 
{
	if (objMarker === undefined) { return; }
		
	if (objMarker.geoLocationData) 
	{
		this.geoLocationData.copyFrom(objMarker.geoLocationData);
	}
	
	this.issue_id = objMarker.issue_id;
	this.issue_type = objMarker.issue_type;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarkerManager
 *
 */
var ObjectMarkerManager = function() 
{
	if (!(this instanceof ObjectMarkerManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.objectMarkerArray = [];

};

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarkerManager
 *
 */
ObjectMarkerManager.prototype.newObjectMarker = function()
{
	var objMarker = new ObjectMarker();
	this.objectMarkerArray.push(objMarker);
	return objMarker;
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class OcclusionCullingOctreeCell
 * @param occlusionCullingOctree_Cell_Owner 변수
 */
var OcclusionCullingOctreeCell = function(occlusionCullingOctree_Cell_Owner) 
{
	if (!(this instanceof OcclusionCullingOctreeCell)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this._ocCulling_Cell_owner = occlusionCullingOctree_Cell_Owner;
	this.minX = 0.0;
	this.maxX = 0.0;
	this.minY = 0.0;
	this.maxY = 0.0;
	this.minZ = 0.0;
	this.maxZ = 0.0;
	this._indicesArray = []; // Visible objects indices.***
	this._subBoxesArray = [];
	this.modelReferencedGroupsList; // undefined initially.
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoRefsIndices 변수
 * @param motherNeoRefsList 변수
 */
OcclusionCullingOctreeCell.prototype.createModelReferencedGroups = function(motherNeoRefsList) 
{
	var subBoxesCount = this._subBoxesArray.length;
	if (subBoxesCount === 0)
	{
		if (this._indicesArray.length === 0)
		{ return; }
		
		if (this.modelReferencedGroupsList === undefined)
		{ this.modelReferencedGroupsList = new ModelReferencedGroupsList(); }
		
		this.modelReferencedGroupsList.createModelReferencedGroups(this._indicesArray, motherNeoRefsList);
	}
	else
	{
		for (var i=0; i<subBoxesCount; i++)
		{
			this._subBoxesArray[i].createModelReferencedGroups(motherNeoRefsList);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns subBox
 */
OcclusionCullingOctreeCell.prototype.newSubBox = function() 
{
	var subBox = new OcclusionCullingOctreeCell(this);
	this._subBoxesArray.push(subBox);
	return subBox;
};

/**
 * 어떤 일을 하고 있습니까?
 */
OcclusionCullingOctreeCell.prototype.create8SubBoxes = function() 
{
	this._subBoxesArray.length = 0;	
	for (var i=0; i<8; i++) 
	{
		this.newSubBox();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param min_x 변수
 * @param max_x 변수
 * @param min_y 변수
 * @param max_y 변수
 * @param min_z 변수
 * @param max_z 변수
 */
OcclusionCullingOctreeCell.prototype.setDimensions = function(min_x, max_x, min_y, max_y, min_z, max_z) 
{
	this.minX = min_x;
	this.maxX = max_x;
	this.minY = min_y;
	this.maxY = max_y;
	this.minZ = min_z;
	this.maxZ = max_z;
};

/**
 * 어떤 일을 하고 있습니까?
 */
OcclusionCullingOctreeCell.prototype.setSizesSubBoxes = function() 
{
	// Bottom                      Top
	// |----------|----------|     |----------|----------|
	// |          |          |     |          |          |       Y
	// |    3     |    2     |	   |    7     |    6     |       ^
	// |          |          |     |          |          |       |
	// |----------|----------|     |----------|----------|       |
	// |          |          |     |          |          |       |
	// |     0    |     1    |     |    4     |    5     |       |
	// |          |          |     |          |          |       -----------------> X
	// |----------|----------|     |----------|----------|  
	
	if (this._subBoxesArray.length > 0) 
	{
		var half_x= (this.maxX + this.minX)/2.0;
		var half_y= (this.maxY + this.minY)/2.0;
		var half_z= (this.maxZ + this.minZ)/2.0;
		
		this._subBoxesArray[0].setDimensions(this.minX, half_x,   this.minY, half_y,   this.minZ, half_z);
		this._subBoxesArray[1].setDimensions(half_x, this.maxX,   this.minY, half_y,   this.minZ, half_z);
		this._subBoxesArray[2].setDimensions(half_x, this.maxX,   half_y, this.maxY,   this.minZ, half_z);
		this._subBoxesArray[3].setDimensions(this.minX, half_x,   half_y, this.maxY,   this.minZ, half_z);

		this._subBoxesArray[4].setDimensions(this.minX, half_x,   this.minY, half_y,   half_z, this.maxZ);
		this._subBoxesArray[5].setDimensions(half_x, this.maxX,   this.minY, half_y,   half_z, this.maxZ);
		this._subBoxesArray[6].setDimensions(half_x, this.maxX,   half_y, this.maxY,   half_z, this.maxZ);
		this._subBoxesArray[7].setDimensions(this.minX, half_x,   half_y, this.maxY,   half_z, this.maxZ);
		
		for (var i=0; i<this._subBoxesArray.length; i++) 
		{
			this._subBoxesArray[i].setSizesSubBoxes();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
OcclusionCullingOctreeCell.prototype.intersectsWithPoint3D = function(x, y, z) 
{
	var intersects = false;
	if (x> this.minX && x<this.maxX) 
	{
		if (y> this.minY && y<this.maxY) 
		{
			if (z> this.minZ && z<this.maxZ) 
			{
				intersects = true;
			}
		}
	}
	
	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersectedSubBox
 */
OcclusionCullingOctreeCell.prototype.getIntersectedSubBoxByPoint3D = function(x, y, z) 
{
	if (this._ocCulling_Cell_owner === undefined) 
	{
		// This is the mother_cell.***
		if (!this.intersectsWithPoint3D(x, y, z)) 
		{
			return undefined;
		}
	}
	
	var intersectedSubBox = undefined;
	var subBoxes_count = this._subBoxesArray.length;
	if (subBoxes_count > 0) 
	{
		var center_x = (this.minX + this.maxX)/2.0;
		var center_y = (this.minY + this.maxY)/2.0;
		var center_z = (this.minZ + this.maxZ)/2.0;
		
		var intersectedSubBox_aux = undefined;
		var intersectedSubBox_idx;
		if (x<center_x) 
		{
			// Here are the boxes number 0, 3, 4, 7.***
			if (y<center_y) 
			{
				// Here are 0, 4.***
				if (z<center_z) { intersectedSubBox_idx = 0; }
				else { intersectedSubBox_idx = 4; }
			}
			else 
			{
				// Here are 3, 7.***
				if (z<center_z) { intersectedSubBox_idx = 3; }
				else { intersectedSubBox_idx = 7; }
			}
		}
		else 
		{
			// Here are the boxes number 1, 2, 5, 6.***
			if (y<center_y) 
			{
				// Here are 1, 5.***
				if (z<center_z) { intersectedSubBox_idx = 1; }
				else { intersectedSubBox_idx = 5; }
			}
			else 
			{
				// Here are 2, 6.***
				if (z<center_z) { intersectedSubBox_idx = 2; }
				else { intersectedSubBox_idx = 6; }
			}
		}
		
		intersectedSubBox_aux = this._subBoxesArray[intersectedSubBox_idx];
		intersectedSubBox = intersectedSubBox_aux.getIntersectedSubBoxByPoint3D(x, y, z);
		
	}
	else 
	{
		intersectedSubBox = this;
	}
	
	return intersectedSubBox;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 * @param result_visibleIndicesArray 변수
 * @returns result_visibleIndicesArray
 */
OcclusionCullingOctreeCell.prototype.getIndicesVisiblesForEye = function(eye_x, eye_y, eye_z, result_visibleIndicesArray, result_modelReferencedGroup) 
{
	var intersectedSubBox = this.getIntersectedSubBoxByPoint3D(eye_x, eye_y, eye_z);
	
	if (intersectedSubBox !== undefined && intersectedSubBox._indicesArray.length > 0) 
	{
		result_visibleIndicesArray = intersectedSubBox._indicesArray;
		if (result_modelReferencedGroup)
		{
			result_modelReferencedGroup = this.modelReferencedGroupsList;
		}
	}
	
	return result_visibleIndicesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param expansionDist 변수
 */
OcclusionCullingOctreeCell.prototype.expandBox = function(expansionDist) 
{
	this.minX -= expansionDist;
	this.maxX += expansionDist;
	this.minY -= expansionDist;
	this.maxY += expansionDist;
	this.minZ -= expansionDist;
	this.maxZ += expansionDist;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param arrayBuffer 변수
 * @param bytes_readed 변수
 * @param f4dReaderWriter 변수
 * @returns bytes_readed
 */
OcclusionCullingOctreeCell.prototype.parseArrayBuffer = function(arrayBuffer, bytes_readed, f4dReaderWriter) 
{
	// Important note: this is the version of neoGeometry.***
	// Important note: this is the version of neoGeometry.***
	// Important note: this is the version of neoGeometry.***
	var is_mother_cell = f4dReaderWriter.readInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
	if (is_mother_cell) 
	{
		// read the mother dimensions.***
		var minX = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxX = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var minY = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxY = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var minZ = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxZ = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		
		this.setDimensions(minX, maxX, minY, maxY, minZ, maxZ);
	}
	
	var subBoxes_count = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	
	if (subBoxes_count === 0) 
	{
		var objects_count = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		for (var i=0; i<objects_count; i++) 
		{
			var objects_idxInList = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			if (objects_idxInList < 0)
			{ var hola = 0; }
			
			this._indicesArray.push(objects_idxInList);
		}
	}
	else 
	{
		for (var i=0; i<subBoxes_count; i++) 
		{
			var subOcclusionBox = this.newSubBox();
			bytes_readed = subOcclusionBox.parseArrayBuffer(arrayBuffer, bytes_readed, f4dReaderWriter);
		}
	}
	
	return bytes_readed;
};
	
/**
 * 어떤 일을 하고 있습니까?
 * @class OcclusionCullingOctree
 */
var OcclusionCullingOctree = function() 
{
	if (!(this instanceof OcclusionCullingOctree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this._ocCulling_box = new OcclusionCullingOctreeCell(null);
	this._infinite_ocCulling_box = new OcclusionCullingOctreeCell(null);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Pin
 *
 */
var Pin = function() 
{
	if (!(this instanceof Pin)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.texture; // default.***
	this.texturesArray = [];
	this.positionBuffer;
	this.texcoordBuffer;
	
};

Pin.prototype.createPin = function(gl)
{
	this.positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);

	// Put a unit quad in the buffer
	var positionsPinQuad = [
		0, 0, 0,
		1, 0, 0,
		0, 1, 0,
		0, 1, 0,
		1, 0, 0,
		1, 1, 0
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionsPinQuad), gl.STATIC_DRAW);

	this.texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
	var texcoordsPinQuad = [
		0, 0,
		1, 0,
		0, 1,
		0, 1,
		1, 0,
		1, 1
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoordsPinQuad), gl.STATIC_DRAW);
	
};

Pin.prototype.createPinCenterBottom = function(gl)
{
	this.positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);

	// Put a unit quad in the buffer
	var positionsPinQuad = [
		-0.5, 0, 0,
		0.5, 0, 0,
		-0.5, 1, 0,
		-0.5, 1, 0,
		0.5, 0, 0,
		0.5, 1, 0
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionsPinQuad), gl.STATIC_DRAW);

	this.texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
	var texcoordsPinQuad = [
		0, 0,
		1, 0,
		0, 1,
		0, 1,
		1, 0,
		1, 1
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoordsPinQuad), gl.STATIC_DRAW);
	
};
'use strict';

/**
 * Plane on 3D space. Plane equation ax+by+cz+d = 0.
 * @class Plane
 */
var Plane = function() 
{
	if (!(this instanceof Plane)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// ax+by+cz+d = 0 plane.***
	this.a = 0.0;
	this.b = 0.0;
	this.c = 0.0;
	this.d = 0.0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @param nx 변수
 * @param ny 변수
 * @param nz 변수p
 */
Plane.prototype.setPointAndNormal = function(px, py, pz, nx, ny, nz) 
{
	this.a = nx;
	this.b = ny;
	this.c = nz;
	this.d = -this.a*px -this.b*py - this.c*pz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @param nx 변수
 * @param ny 변수
 * @param nz 변수p
 */
Plane.prototype.setPoint = function(px, py, pz) 
{
	this.d = -this.a*px -this.b*py - this.c*pz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param dist
 * @param nx 변수
 * @param ny 변수
 * @param nz 변수p
 */
Plane.prototype.setNormalAndDistance = function(nx, ny, nz, dist) 
{
	this.a = nx;
	this.b = ny;
	this.c = nz;
	this.d = dist;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param line 변수
 * @param intersectionPoint 변수
 */
Plane.prototype.intersectionLine = function(line, intersectionPoint) 
{
	
	var r = line.point.x;
	var s = line.point.y;
	var t = line.point.z;
	
	var u = line.direction.x;
	var v = line.direction.y;
	var w = line.direction.z;
	
	var den = this.a*u + this.b*v + this.c*w;
	
	if (Math.abs(den) > 10E-8) 
	{
		var alfa = -((this.a*r + this.b*s + this.c*t + this.d)/(den));
		
		if (intersectionPoint === undefined) { intersectionPoint = new Point3D(); }
		
		intersectionPoint.set(r+alfa*u, s+alfa*v, t+alfa*w);
		return intersectionPoint;
	}
	else { return undefined; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param line 변수
 * @param intersectionPoint 변수
 */
Plane.prototype.intersectionSphere = function(sphere) 
{
	if (sphere === undefined || sphere.centerPoint === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var sphereCenter = sphere.centerPoint;
	
	// calculate the distance by dotProduct.***
	var distance = sphereCenter.x * this.a + sphereCenter.y * this.b + sphereCenter.z * this.c + this.d;

	if (distance < -sphere.r)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	else if (distance < sphere.r)
	{
		return Constant.INTERSECTION_INTERSECT;
	}
	return Constant.INTERSECTION_INSIDE;
};






'use strict';

/**
* 어떤 일을 하고 있습니까?
* @class Quaternion
*/
var Quaternion = function() 
{
	if (!(this instanceof Quaternion)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.x = 0.0;
	this.y = 0.0;
	this.z = 0.0;
	this.w = 1.0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w )
 */
Quaternion.prototype.Modul = function() 
{
	return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w );
};

/**
 * 어떤 일을 하고 있습니까?
 */
Quaternion.prototype.Unitary = function() 
{
	var modul = this.Modul();
	this.x /= modul;
	this.y /= modul;
	this.z /= modul;
	this.w /= modul;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angDeg 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Quaternion.prototype.rotationAngDeg = function(angDeg, axis_x, axis_y, axis_z) 
{
	var angRad = angDeg*Math.PI/180.0;
	this.rotationAngRad(angRad, axis_x, axis_y, axis_z);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angRad 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Quaternion.prototype.rotationAngRad = function(angRad, axis_x, axis_y, axis_z) 
{
	var s = Math.sqrt(axis_x*axis_x + axis_y*axis_y + axis_z*axis_z);
	var error = 10E-13;
	if (!s < error) 
	{
		var c = 1.0/s;
		var omega = 0.5 * angRad;
		s = Math.sin(omega);
		this.x = axis_x * c * s;
		this.y = axis_y * c * s;
		this.z = axis_z * c * s;
		this.w = Math.cos(omega);
		this.Unitary();
	}
	else 
	{
		this.x = 0.0;
		this.y = 0.0;
		this.z = 0.0;
		this.w = 1.0;
	}
};

'use strict';

/**
 * Quadtree based tile with thickness.
 * @class SmartTile
 */
var SmartTile = function(smartTileName) 
{
	//       +-----+-----+
	//       |  3  |  2  |
	//       +-----+-----+
	//       |  0  |  1  |
	//       +-----+-----+
	
	if (!(this instanceof SmartTile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.name;
	if (smartTileName)
	{ this.name = smartTileName; }
	this.depth; // mother tile depth = 0.
	this.minGeographicCoord; // longitude, latitude, altitude.
	this.maxGeographicCoord; // longitude, latitude, altitude.
	this.sphereExtent; // cartesian position sphere in worldCoord.
	this.subTiles; // array.
	
	this.nodeSeedsArray;
	this.nodesArray; // nodes with geometry data only (lowest nodes).
	
	this.isVisible; // var to manage the frustumCulling and delete buildings if necessary.
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.deleteObjects = function() 
{
	this.name = undefined;
	this.depth = undefined;
	if (this.minGeographicCoord)
	{ this.minGeographicCoord.deleteObjects(); } 
		
	if (this.maxGeographicCoord)
	{ this.maxGeographicCoord.deleteObjects(); } 
	
	this.minGeographicCoord = undefined; 
	this.maxGeographicCoord = undefined; 
	if (this.sphereExtent)
	{ this.sphereExtent.deleteObjects(); }
	
	this.sphereExtent = undefined;
	
	// now, erase nodeSeeds.
	if (this.nodeSeedsArray)
	{
		var nodeSeedsCount = this.nodeSeedsArray.length;
		for (var i=0; i<nodeSeedsCount; i++)
		{
			// no delete the nodeObjects. nodeObjects must be deleted by hierarchyManager.
			this.nodeSeedsArray[i] = undefined;
		}
		this.nodeSeedsArray = undefined;
	}
	
	// now, erase nodes.
	if (this.nodesArray)
	{
		var nodesCount = this.nodesArray.length;
		for (var i=0; i<nodesCount; i++)
		{
			// no delete the nodeObjects. nodeObjects must be deleted by hierarchyManager.
			this.nodesArray[i] = undefined;
		}
		this.nodesArray = undefined;
	}
	
	this.isVisible = undefined;
	
	// delete children.
	if (this.subTiles)
	{
		var subTilesCount = this.subTiles.length;
		for (var i=0; i<subTilesCount; i++)
		{
			this.subTiles[i].deleteObjects();
			this.subTiles[i] = undefined;
		}
		this.subTiles = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.newSubTile = function(parentTile) 
{
	if (this.subTiles === undefined)
	{ this.subTiles = []; }
	
	var subTile = new SmartTile();
	subTile.depth = parentTile.depth + 1;
	this.subTiles.push(subTile);
	return subTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.clearNodesArray = function() 
{
	if (this.nodesArray === undefined)
	{ return; }
	
	for (var i=0; i<this.nodesArray.length; i++)
	{
		this.nodesArray[i] = undefined;
	}
	this.nodesArray = undefined;
};


/**
 * 어떤 일을 하고 있습니까?
 */
/*
SmartTile.prototype.getNodeByBuildingId = function(buildingType, buildingId) 
{
	var resultNode;
	var neoBuilding;
	var node;
	var hasSubTiles = true;
	if (this.subTiles === undefined)
	{ hasSubTiles = false; }
	
	if (this.subTiles && this.subTiles.length === 0)
	{ hasSubTiles = false; }
		
	if (!hasSubTiles)
	{
		if (this.nodesArray)
		{
			var nodesCount = this.nodesArray.length;
			var find = false;
			var i=0;
			while (!find && i<nodesCount) 
			{
				node = this.nodesArray[i];
				neoBuilding = node.data.neoBuilding;
				if (buildingType)
				{
					if (neoBuilding.buildingId === buildingId && neoBuilding.buildingType === buildingType) 
					{
						find = true;
						resultNode = node;
						return resultNode;
					}
				}
				else 
				{
					if (neoBuilding.buildingId === buildingId) 
					{
						find = true;
						resultNode = node;
						return resultNode;
					}
				}
				i++;
			}
		}	
	}
	else 
	{
		for (var i=0; i<this.subTiles.length; i++)
		{
			resultNode = this.subTiles[i].getNodeByBuildingId(buildingType, buildingId);
			if (resultNode)
			{ return resultNode; }
		}
	}
	
	return resultNode;
};
*/

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.getNeoBuildingById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var node = this.getNodeByBuildingId(buildingType, buildingId);
	if (node !== undefined)
	{ resultNeoBuilding = node.data.neoBuilding; }

	return resultNeoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.getBuildingSeedById = function(buildingType, buildingId) 
{
	var resultNeoBuildingSeed;
	var hasSubTiles = true;
	if (this.subTiles === undefined)
	{ hasSubTiles = false; }
	
	if (this.subTiles && this.subTiles.length === 0)
	{ hasSubTiles = false; }
		
	if (!hasSubTiles)
	{
		if (this.nodeSeedsArray)
		{
			var buildingCount = this.nodeSeedsArray.length;
			var find = false;
			var i=0;
			var buildingSeed, node;
			while (!find && i<buildingCount) 
			{
				node = this.nodeSeedsArray[i];
				buildingSeed = node.data.buildingSeed;
				if (buildingType)
				{
					if (buildingSeed.buildingId === buildingId && buildingSeed.buildingType === buildingType) 
					{
						find = true;
						resultNeoBuildingSeed = buildingSeed;
						return resultNeoBuildingSeed;
					}
				}
				else 
				{
					if (buildingSeed.buildingId === buildingId) 
					{
						find = true;
						resultNeoBuildingSeed = buildingSeed;
						return resultNeoBuildingSeed;
					}
				}
				i++;
			}
		}	
	}
	else 
	{
		for (var i=0; i<this.subTiles.length; i++)
		{
			resultNeoBuildingSeed = this.subTiles[i].getBuildingSeedById(buildingType, buildingId);
			if (resultNeoBuildingSeed)
			{ return resultNeoBuildingSeed; }
		}
	}
	
	return resultNeoBuildingSeed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.TEST__hasLowestTiles_nodesArray = function() 
{
	
	var lowestTilesArray = [];
	this.extractLowestTiles(lowestTilesArray);
	var subTilesCount = lowestTilesArray.length;
	var find = false;
	var i=0;
	while (!find && i<subTilesCount)
	{
		if (lowestTilesArray[i].nodesArray && lowestTilesArray[i].nodesArray.length > 0)
		{
			return true;
		}
		i++;
	}
	
	return find;
	
};


/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.makeSphereExtent = function(magoManager) 
{
	this.sphereExtent = SmartTile.computeSphereExtent(magoManager, this.minGeographicCoord, this.maxGeographicCoord, this.sphereExtent);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.computeSphereExtent = function(magoManager, minGeographicCoord, maxGeographicCoord, resultSphereExtent) 
{
	if (resultSphereExtent === undefined)
	{ resultSphereExtent = new Sphere(); }
	
	// calculate worldCoord center position.
	var midLongitude = (maxGeographicCoord.longitude + minGeographicCoord.longitude)/2;
	var midLatitude = (maxGeographicCoord.latitude + minGeographicCoord.latitude)/2;
	var midAltitude = (maxGeographicCoord.altitude + minGeographicCoord.altitude)/2;
	
	resultSphereExtent.centerPoint = ManagerUtils.geographicCoordToWorldPoint(midLongitude, midLatitude, midAltitude, resultSphereExtent.centerPoint, magoManager);
	
	// calculate an aproximate radius.
	var cornerPoint;
	cornerPoint = ManagerUtils.geographicCoordToWorldPoint(minGeographicCoord.longitude, minGeographicCoord.latitude, minGeographicCoord.altitude, cornerPoint, magoManager);

	resultSphereExtent.r = resultSphereExtent.centerPoint.distTo(cornerPoint.x, cornerPoint.y, cornerPoint.z) * 1.2;
	return resultSphereExtent;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.makeTreeByDepth = function(targetDepth, magoManager) 
{
	if (this.nodeSeedsArray === undefined || this.nodeSeedsArray.length === 0)
	{ return; }
	
	// if this has "nodeSeedsArray" then make sphereExtent.
	this.makeSphereExtent(magoManager);
	
	// now, if the current depth < targetDepth, then descend.
	if (this.depth < targetDepth)
	{
		// create 4 child smartTiles.
		if (this.subTiles === undefined || this.subTiles.length === 0)
		{
			for (var i=0; i<4; i++)
			{ this.newSubTile(this); }
		}
		
		// set the sizes to subTiles (The minLongitude, MaxLongitude, etc. is constant, but the minAlt & maxAlt can will be modified every time that insert new buildingSeeds).
		this.setSizesToSubTiles();

		// intercept buildingSeeds for each subTiles.
		for (var i=0; i<4; i++)
		{
			this.subTiles[i].takeIntersectedBuildingSeeds(this.nodeSeedsArray, magoManager);
		}
		
		// for each subTile that has intercepted buildingSeeds -> makeTree.
		for (var i=0; i<4; i++)
		{
			this.subTiles[i].makeTreeByDepth(targetDepth, magoManager);
		}
		
	}
	//else
	//	var hola = 0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
/*
SmartTile.prototype.getLowestTileWithNodeInside = function(node) 
{
	// this function returns the lowestTile with "node" if exist.
	if (this.subTiles === undefined)
	{
		var nodesCount = this.nodesArray.length;
		var i=0;
		while (i<nodesCount)
		{
			if (node == this.nodesArray[i])
			{
				return this;
			}
			i++;
		}
		return undefined;
	}
	else 
	{	
		var subTilesCount = this.subTiles.length;
		var lowestTile;
		for (var i=0; i<subTilesCount; i++)
		{
			lowestTile = this.subTiles[i].getLowestTileWithNodeInside(node);
			if (lowestTile)
			{ return lowestTile; }
		}
		
		return undefined;
	}
};
*/

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.takeIntersectedBuildingSeeds = function(nodeSeedsArray) 
{
	// this function intersects the buildingSeeds with this tile.
	// this function is used only one time when load a initial buildings distributions on the globe.
	var buildingSeed;
	var node, rootNode;
	var buildingSeedsCount = nodeSeedsArray.length;
	for (var i=0; i<buildingSeedsCount; i++)
	{
		node = nodeSeedsArray[i];
		buildingSeed = node.data.buildingSeed;
		
		rootNode = node.getRoot();
		
		var longitude, latitude;
		if (rootNode.data.bbox.geographicCoord === undefined)
		{
			// in this case take the data from buildingSeed.***
			longitude = buildingSeed.geographicCoordOfBBox.longitude;
			latitude = buildingSeed.geographicCoordOfBBox.latitude;
		}
		else 
		{
			longitude = rootNode.data.bbox.geographicCoord.longitude;
			latitude = rootNode.data.bbox.geographicCoord.latitude;
		}
		
		if (this.intersectPoint(longitude, latitude))
		{
			nodeSeedsArray.splice(i, 1);
			i--;
			buildingSeedsCount = nodeSeedsArray.length;
			
			if (this.nodeSeedsArray === undefined)
			{ this.nodeSeedsArray = []; }
			
			this.nodeSeedsArray.push(node);
			
			// now, redefine the altitude limits of this tile.
			var altitude = buildingSeed.geographicCoordOfBBox.altitude;
			var bboxRadius = buildingSeed.bBox.getRadiusAprox();
			if (altitude-bboxRadius < this.minGeographicCoord.altitude)
			{
				this.minGeographicCoord.altitude = altitude-bboxRadius;
			}
			if (altitude+bboxRadius > this.maxGeographicCoord.altitude)
			{
				this.maxGeographicCoord.altitude = altitude+bboxRadius;
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
/*
SmartTile.prototype.calculateAltitudeLimits = function() 
{
	// this function calculates the minAltitude and maxAltitude of the tile.
	// init the altitudes.
	this.minGeographicCoord.altitude = 0;
	this.maxGeographicCoord.altitude = 0;
	
	var buildingSeed;
	var buildingSeedsCount = this.buildingSeedsArray.length;
	for (var i=0; i<buildingSeedsCount; i++)
	{
		buildingSeed = this.buildingSeedsArray[i];

		var altitude = buildingSeed.geographicCoordOfBBox.altitude;
		var bboxRadius = buildingSeed.bBox.getRadiusAprox();
		if (altitude-bboxRadius < this.minGeographicCoord.altitude)
		{
			this.minGeographicCoord.altitude = altitude-bboxRadius;
		}
		if (altitude+bboxRadius > this.maxGeographicCoord.altitude)
		{
			this.maxGeographicCoord.altitude = altitude+bboxRadius;
		}
	}
};
*/

/**
 * 어떤 일을 하고 있습니까?
 * @param geographicCoord 변수
 */
SmartTile.prototype.intersectPoint = function(longitude, latitude) 
{
	if (longitude < this.minGeographicCoord.longitude || longitude > this.maxGeographicCoord.longitude)
	{ return false; }
	
	if (latitude < this.minGeographicCoord.latitude || latitude > this.maxGeographicCoord.latitude)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.extractLowestTiles = function(resultLowestTilesArray) 
{
	if (this.subTiles === undefined)
	{
		if (this.nodeSeedsArray && this.nodeSeedsArray.length > 0)
		{
			resultLowestTilesArray.push(this);
		}
		return;
	}
		
	var subTilesCount = this.subTiles.length;
	for (var i=0; i<subTilesCount; i++)
	{
		this.subTiles[i].extractLowestTiles(resultLowestTilesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.getFrustumIntersectedLowestTiles = function(frustum, resultFullyIntersectedTilesArray, resultPartiallyIntersectedTilesArray) 
{
	var fullyIntersectedTiles = [];
	this.getFrustumIntersectedTiles(frustum, fullyIntersectedTiles, resultPartiallyIntersectedTilesArray);
	
	var intersectedTilesCount = fullyIntersectedTiles.length;
	for (var i=0; i<intersectedTilesCount; i++)
	{
		fullyIntersectedTiles[i].extractLowestTiles(resultFullyIntersectedTilesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.getFrustumIntersectedTiles = function(frustum, resultFullyIntersectedTilesArray, resultPartiallyIntersectedTilesArray) 
{
	if (this.sphereExtent === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var intersectionType = frustum.intersectionSphere(this.sphereExtent);
	
	if (intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ return; }
	else if (intersectionType === Constant.INTERSECTION_INSIDE)
	{
		resultFullyIntersectedTilesArray.push(this);
		return;
	}
	else if (intersectionType === Constant.INTERSECTION_INTERSECT)
	{
		if (this.subTiles && this.subTiles.length > 0)
		{
			for (var i=0; i<this.subTiles.length; i++)
			{
				if (this.subTiles[i].sphereExtent)
				{ this.subTiles[i].getFrustumIntersectedTiles(frustum, resultFullyIntersectedTilesArray, resultPartiallyIntersectedTilesArray); }
			}
		}
		else
		{ 
			if (this.nodeSeedsArray &&  this.nodeSeedsArray.length > 0)
			{ resultPartiallyIntersectedTilesArray.push(this); } 
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.selectTileAngleRangeByDepth = function(depth) 
{
	if (depth === undefined || depth < 0 || depth > 15)
	{ return undefined; }
	
	if (depth === 0)
	{ return 180; }
	if (depth === 1)
	{ return 90; }
	if (depth === 2)
	{ return 45; }
	if (depth === 3)
	{ return 22.5; }
	if (depth === 4)
	{ return 11.25; }
	if (depth === 5)
	{ return 5.625; }
	if (depth === 6)
	{ return 2.8125; }
	if (depth === 7)
	{ return 1.40625; }
	if (depth === 8)
	{ return 0.703125; }
	if (depth === 9)
	{ return 0.3515625; }
	if (depth === 10)
	{ return 0.17578125; }
	if (depth === 11)
	{ return 0.087890625; }
	if (depth === 12)
	{ return 0.043945313; }
	if (depth === 13)
	{ return 0.021972656; }
	if (depth === 14)
	{ return 0.010986328; }
	if (depth === 15)
	{ return 0.010986328/2.0; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.selectTileName = function(depth, longitude, latitude, resultTileName) 
{
	var xMin = -180.0;
	var yMin = 90.0;
	var angRange = SmartTile.selectTileAngleRangeByDepth(depth) ;
	
	var xIndex = Math.floor((longitude - xMin)/angRange);
	// with yMin = -90.0;
	//var yIndex = Math.floor((latitude - yMin)/angRange);
	var yIndex = Math.floor((yMin - latitude)/angRange);
	resultTileName = depth.toString() + "\\" + xIndex.toString() + "\\" + yIndex.toString();
	return resultTileName;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
 
SmartTile.getFrustumIntersectedTilesNames = function(frustum, maxDepth, camPos, magoManager, resultFullyIntersectedTilesNamesMap) 
{
	var currMinGeographicCoords = new GeographicCoord();
	var currMaxGeographicCoords = new GeographicCoord();
	var currDepth = 0;
	
	// America side.
	currMinGeographicCoords.setLonLatAlt(-180, -90, 0);
	currMaxGeographicCoords.setLonLatAlt(0, 90, 0);
	currDepth = 0;
	SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, magoManager.boundingSphere_Aux, 
		resultFullyIntersectedTilesNamesMap);
	
	// Asia side.
	currMinGeographicCoords.setLonLatAlt(0, -90, 0);
	currMaxGeographicCoords.setLonLatAlt(180, 90, 0);
	currDepth = 0;
	SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, magoManager.boundingSphere_Aux, 
		resultFullyIntersectedTilesNamesMap);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
 
SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent = function(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap) 
{
	// STATIC FUNCTION.***
	// 1rst, make a sphereExtent.***
	
	sphereExtentAux = SmartTile.computeSphereExtent(magoManager, currMinGeographicCoords, currMaxGeographicCoords, sphereExtentAux);

	var intersectionType = frustum.intersectionSphere(sphereExtentAux);
	
	if (intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ return; }
	else if (intersectionType === Constant.INTERSECTION_INSIDE)
	{
		var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
		var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
		var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
		var geographicExtent = new GeographicExtent();
		geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
		geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
		resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
		return;
	}
	else if (intersectionType === Constant.INTERSECTION_INTERSECT)
	{
		// check distance to camera.***
		var distToCam = camPos.distToSphere(sphereExtentAux);
		if (distToCam > 2000)
		{
			var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
			var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
			var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
			var geographicExtent = new GeographicExtent();
			geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
			geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
			resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
			return;
		}
		
		if (currDepth < maxDepth)
		{
			// must descend.***
			currDepth += 1;
			var minLon = currMinGeographicCoords.longitude;
			var minLat = currMinGeographicCoords.latitude;
			var minAlt = currMinGeographicCoords.altitude;
			var maxLon = currMaxGeographicCoords.longitude;
			var maxLat = currMaxGeographicCoords.latitude;
			var maxAlt = currMaxGeographicCoords.altitude;
			var midLon = (minLon + maxLon)/ 2;
			var midLat = (minLat + maxLat)/ 2;
			
			// subTile 1.***
			currMaxGeographicCoords.setLonLatAlt(midLon, midLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 2.***
			currMinGeographicCoords.setLonLatAlt(midLon, minLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(maxLon, midLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 3.***
			currMinGeographicCoords.setLonLatAlt(midLon, midLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(maxLon, maxLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 4.***
			currMinGeographicCoords.setLonLatAlt(minLon, midLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(midLon, maxLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
		}
		else 
		{
			var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
			var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
			var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
			var geographicExtent = new GeographicExtent();
			geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
			geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
			resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
			return;
		}
	}
	
};


/**
 * 어떤 일을 하고 있습니까?
 * Extent(범위)
 * @param frustum 변수
 */
SmartTile.prototype.getSphereExtent = function() 
{
	return this.sphereExtent;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.setSize = function(minLon, minLat, minAlt, maxLon, maxLat, maxAlt) 
{
	if (this.minGeographicCoord === undefined)
	{ this.minGeographicCoord = new GeographicCoord(); }
	if (this.maxGeographicCoord === undefined)	
	{ this.maxGeographicCoord = new GeographicCoord(); }
		
	this.minGeographicCoord.setLonLatAlt(minLon, minLat, minAlt);	
	this.maxGeographicCoord.setLonLatAlt(maxLon, maxLat, maxAlt);	
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.setSizesToSubTiles = function() 
{
	//       +-----+-----+
	//       |  3  |  2  |
	//       +-----+-----+
	//       |  0  |  1  |
	//       +-----+-----+
	
	var minLon = this.minGeographicCoord.longitude;
	var maxLon = this.maxGeographicCoord.longitude;
	var minLat = this.minGeographicCoord.latitude;
	var maxLat = this.maxGeographicCoord.latitude;
	var minAlt = this.minGeographicCoord.altitude;
	var maxAlt = this.maxGeographicCoord.altitude;
	
	var midLon = (maxLon + minLon)/2;
	var midLat = (maxLat + minLat)/2;
	
	var subTile = this.subTiles[0];
	subTile.setSize(minLon, minLat, minAlt,     midLon, midLat, maxAlt);
	
	subTile = this.subTiles[1];
	subTile.setSize(midLon, minLat, minAlt,     maxLon, midLat, maxAlt);
	
	subTile = this.subTiles[2];
	subTile.setSize(midLon, midLat, minAlt,     maxLon, maxLat, maxAlt);
	
	subTile = this.subTiles[3];
	subTile.setSize(minLon, midLat, minAlt,     midLon, maxLat, maxAlt);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.getLongitudeRangeDegree = function() 
{
	return this.maxGeographicCoord.longitude - this.minGeographicCoord.longitude;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.getLatitudeRangeDegree = function() 
{
	return this.maxGeographicCoord.latitude - this.minGeographicCoord.latitude;
};


/**
 * Quadtree based tile with thickness.
 * @class SmartTileManager
 */
var SmartTileManager = function() 
{
	if (!(this instanceof SmartTileManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.tilesArray = []; // has 2 tiles (Asia side and America side).
	this.createMainTiles();
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
SmartTileManager.prototype.createMainTiles = function() 
{
	// tile 1 : longitude {-180, 0}, latitude {-90, 90}
	// tile 2 : longitude {0, 180},  latitude {-90, 90}
	
	// America side.
	var tile1 = this.newSmartTile("AmericaSide");
	if (tile1.minGeographicCoord === undefined)
	{ tile1.minGeographicCoord = new GeographicCoord(); }
	if (tile1.maxGeographicCoord === undefined)
	{ tile1.maxGeographicCoord = new GeographicCoord(); }
	
	tile1.depth = 0; // mother tile.
	tile1.minGeographicCoord.setLonLatAlt(-180, -90, 0);
	tile1.maxGeographicCoord.setLonLatAlt(0, 90, 0);
	
	// Asia side.
	var tile2 = this.newSmartTile("AsiaSide");
	if (tile2.minGeographicCoord === undefined)
	{ tile2.minGeographicCoord = new GeographicCoord(); }
	if (tile2.maxGeographicCoord === undefined)
	{ tile2.maxGeographicCoord = new GeographicCoord(); }
	
	tile2.depth = 0; // mother tile.
	tile2.minGeographicCoord.setLonLatAlt(0, -90, 0);
	tile2.maxGeographicCoord.setLonLatAlt(180, 90, 0);
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
SmartTileManager.prototype.deleteTiles = function() 
{
	// this function deletes all children tiles.
	if (this.tilesArray)
	{
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		for (var i=0; i<tilesCount; i++)
		{
			this.tilesArray[i].deleteObjects();
			this.tilesArray[i] = undefined;
		}
		this.tilesArray.length = 0;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
SmartTileManager.prototype.resetTiles = function() 
{
	this.deleteTiles();
	
	// now create the main tiles.
	this.createMainTiles();
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
SmartTileManager.prototype.newSmartTile = function(smartTileName) 
{
	if (this.tilesArray === undefined)
	{ this.tilesArray = []; }
	
	var smartTile = new SmartTile(smartTileName);
	this.tilesArray.push(smartTile);
	return smartTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.getNeoBuildingById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var i = 0;
	var smartTilesCount = this.tilesArray.length;
	while (resultNeoBuilding === undefined && i<smartTilesCount)
	{
		resultNeoBuilding = this.tilesArray[i].getNeoBuildingById(buildingType, buildingId); 
		i++;
	}
	
	return resultNeoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.getBuildingSeedById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var i = 0;
	var smartTilesCount = this.tilesArray.length;
	while (resultNeoBuilding === undefined && i<smartTilesCount)
	{
		resultNeoBuilding = this.tilesArray[i].getBuildingSeedById(buildingType, buildingId);
		i++;
	}
	
	return resultNeoBuilding;
};













'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Sphere
 */
var Sphere = function() 
{
	if (!(this instanceof Sphere)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.r = 0.0;
	this.centerPoint = new Point3D();
	
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.***
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.setCenterPoint = function(x, y, z) 
{
	this.centerPoint.set(x, y, z);
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.setRadius = function(radius) 
{
	this.r = radius;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.deleteObjects = function() 
{
	this.r = undefined;
	this.centerPoint.deleteObjects();
	this.centerPoint = undefined;
};

/**
 */
Sphere.prototype.getVbo = function(resultVboContainer)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	var mesh;
	
	
	// make vbo.***
	mesh = this.makeMesh(mesh);
	var bIncludeBottomCap = false;
	var bIncludeTopCap = false;
	
	// now rotate in X axis.***
	/*
	var rotMatAux = new Matrix4();
	var frustum = this.camera.bigFrustum;
	var halfFovyRad = frustum.fovyRad / 2.0;
	rotMatAux.rotationAxisAngDeg(-90.0 - (halfFovyRad/2) * 180.0 / Math.PI, 1.0, 0.0, 0.0);
	*/
	var surfIndepMesh = mesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	
	// now rotate in X axis.***
	var rotMatAux = new Matrix4();
	rotMatAux.rotationAxisAngDeg(90.0, 1.0, 0.0, 0.0);
	surfIndepMesh.transformByMatrix4(rotMatAux);
	
	surfIndepMesh.setColor(0.0, 0.5, 0.9, 0.3);
	surfIndepMesh.calculateVerticesNormals();
	surfIndepMesh.getVbo(resultVboContainer);
	
	return resultVboContainer;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.makeMesh = function(resultMesh) 
{
	if (resultMesh === undefined)
	{ resultMesh = new ParametricMesh(); }

	resultMesh.profile = new Profile(); 
	var profileAux = resultMesh.profile; 
	
	// Outer ring.**************************************
	var outerRing = profileAux.newOuterRing();
	var polyLine, point3d, arc;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-this.r*0.01, -this.r); // 0
	point3d = polyLine.newPoint2d(-this.r*0.01, this.r); // 1
	
	var startAngDeg = 95.0;
	var endAngDeg = 265.0;
	arc = outerRing.newElement("ARC");
	this.sweepSense = 1;
	arc.setCenterPosition(0.0, 0.0);
	arc.setRadius(this.r);
	arc.setStartAngleDegree(startAngDeg);
	arc.setSweepAngleDegree(endAngDeg - startAngDeg);
	arc.numPointsFor360Deg = 48;
	
	// now revolve.***
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = 360;
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(0, -1);
	var endPoint2d = new Point2D(0, 1);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 48;
	resultMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	/*
	var extrusionVector
	var extrudeSegmentsCount = 2;
	var extrusionDist = 15.0;
		resultMesh.extrude(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector);
	*/
	
	return resultMesh;
};











































'use strict';

/**
 * ??
 * @class SceneState
 */

var SplitValue = function()
{
	this.high = undefined;
	this.low = undefined;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class TerranTile
 */
var TerranTile = function() 
{
	if (!(this instanceof TerranTile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	//           +-----+-----+
	//           |  3  |  2  |
	//           +-----+-----+
	//           |  0  |  1  |
	//           +-----+-----+

	this._depth = 0; // qudtree depth. 0 => mother_quadtree.***
	this._numberName = 1; // mother quadtree.***
	this._terranTile_owner;
	//------------------------------------------------------------
	this.projectsArray = [];
	
	this._BR_buildingsArray = []; // Old.***
	this._boundingBox; // dont use this.***
	this._pCloudMesh_array = []; // 1rst aproximation to the pointCloud data. Test.***

	this.position; // absolute position, for do frustum culling.***
	this.radius; // aprox radius for this tile.***

	this.leftDown_position;
	this.rightDown_position;
	this.rightUp_position;
	this.leftUp_position;
	this.visibilityType;

	this.subTiles_array = [];
	this.terranIndexFile_readed = false;
	this.empty_tile = false;

	// File.***************************************************
	this.fileReading_started = false;
	this.fileReading_finished = false;
	this.fileArrayBuffer;
	this.fileBytesReaded = 0;
	this.fileParsingFinished = false;
	this.projectsParsed_count = 0;

	this.current_BRProject_parsing;
	this.current_BRProject_parsing_state = 0;

	this.readWriter;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns br_buildingProject
 */
TerranTile.prototype.newBRProject = function() 
{
	// Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.***
	// dont use this. delete this.***
	var br_buildingProject = new BRBuildingProject();
	this._BR_buildingsArray.push(br_buildingProject);
	return br_buildingProject;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns subTile
 */
TerranTile.prototype.newSubTerranTile = function() 
{
	var subTiles_count = this.subTiles_array.length;
	var subTile = new TerranTile();
	subTile._depth = this._depth + 1;
	subTile._numberName = this._numberName*10 + subTiles_count + 1;
	this.subTiles_array.push(subTile);
	return subTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.make4subTiles = function() 
{
	for (var i = 0; i < 4; i++) 
	{
		this.newSubTerranTile();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param lonMin 변수
 * @param lonMax 변수
 * @param latMin 변수
 * @param latMax 변수
 */
TerranTile.prototype.setDimensions = function(lonMin, lonMax, latMin, latMax) 
{
	this.longitudeMin = lonMin;
	this.longitudeMax = lonMax;
	this.latitudeMin = latMin;
	this.latitudeMax = latMax;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param maxDepth 변수
 */
TerranTile.prototype.makeTree = function(maxDepth) 
{
	if (this._depth < maxDepth)
	{
		var subTileAux;
		for (var i = 0; i < 4; i++)
		{
			subTileAux = this.newSubTerranTile();
			subTileAux.makeTree(maxDepth);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.calculatePositionByLonLat = function() 
{
	var lon_mid = (this.longitudeMax + this.longitudeMin)/2.0;
	var lat_mid = (this.latitudeMax + this.latitudeMin)/2.0;

	this.position = Cesium.Cartesian3.fromDegrees(lon_mid, lat_mid, 0.0);

	this.leftDown_position = Cesium.Cartesian3.fromDegrees(this.longitudeMin, this.latitudeMin, 0.0);
	this.rightDown_position = Cesium.Cartesian3.fromDegrees(this.longitudeMax, this.latitudeMin, 0.0);
	this.rightUp_position = Cesium.Cartesian3.fromDegrees(this.longitudeMax, this.latitudeMax, 0.0);
	this.leftUp_position = Cesium.Cartesian3.fromDegrees(this.longitudeMin, this.latitudeMax, 0.0);

	this.radius = Cesium.Cartesian3.distance(this.leftDown_position, this.rightUp_position)/2.0 * 0.9;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.calculatePositionByLonLatSubTiles = function() 
{
	this.calculatePositionByLonLat();

	var subTile;
	var subTiles_count = this.subTiles_array.length; // subTiles_count must be 4.***

	for (var i=0; i<subTiles_count; i++)
	{
		this.subTiles_array[i].calculatePositionByLonLatSubTiles();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 */
TerranTile.prototype.parseFileHeader = function(BR_Project) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{ return; }

	var version_string_length = 5;
	var intAux_scratch = 0;
	//var auxScratch;
	var header = BR_Project._header;
	var arrayBuffer = this.fileArrayBuffer;
	var bytes_readed = this.fileBytesReaded;

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	// 1) Version(5 chars).***********
	for (var j=0; j<version_string_length; j++)
	{
		header._version += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
	}

	header._f4d_version = 2;

	// 3) Global unique ID.*********************
	intAux_scratch = this.readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var j=0; j<intAux_scratch; j++)
	{
		header._global_unique_id += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
	}

	// 4) Location.*************************
	header._longitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	header._latitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	header._elevation = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;

	//header._elevation += 70.0; // delete this. TEST.!!!

	// 6) BoundingBox.************************
	header._boundingBox.minX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.minY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.minZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;

	var semiHeight = (header._boundingBox.maxZ - header._boundingBox.minZ )/2.0;
	header._elevation = 45.0 + semiHeight-0.5;

	var isLarge = false;
	if (header._boundingBox.maxX - header._boundingBox.minX > 40.0 || header._boundingBox.maxY - header._boundingBox.minY > 40.0)
	{
		isLarge = true;
	}

	if (!isLarge && header._boundingBox.maxZ - header._boundingBox.minZ < 30.0)
	{
		header.isSmall = true;
	}

	var imageLODs_count = this.readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

	// Now, must calculate some params of the project.**********************************************
	// 0) PositionMatrix.************************************************************************
	// Determine the elevation of the position.***********************************************************
	var position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, header._elevation);
	var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------

	//var position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, header._elevation);  // Original.***
	position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, height);

	BR_Project.buildingPosition = position;

	// High and Low values of the position.****************************************************
	var splitValue = Cesium.EncodedCartesian3.encode(position);
	var splitVelue_X  = Cesium.EncodedCartesian3.encode(position.x);
	var splitVelue_Y  = Cesium.EncodedCartesian3.encode(position.y);
	var splitVelue_Z  = Cesium.EncodedCartesian3.encode(position.z);

	BR_Project.buildingPositionHIGH = new Float32Array(3);
	BR_Project.buildingPositionHIGH[0] = splitVelue_X.high;
	BR_Project.buildingPositionHIGH[1] = splitVelue_Y.high;
	BR_Project.buildingPositionHIGH[2] = splitVelue_Z.high;

	BR_Project.buildingPositionLOW = new Float32Array(3);
	BR_Project.buildingPositionLOW[0] = splitVelue_X.low;
	BR_Project.buildingPositionLOW[1] = splitVelue_Y.low;
	BR_Project.buildingPositionLOW[2] = splitVelue_Z.low;

	this.fileBytesReaded = bytes_readed;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 */
TerranTile.prototype.parseFileSimpleBuilding = function(BR_Project) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{ return; }

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var bytes_readed = this.fileBytesReaded;
	var startBuff;
	var endBuff;
	var arrayBuffer = this.fileArrayBuffer;

	if (BR_Project._simpleBuilding_v1 === undefined)
	{ BR_Project._simpleBuilding_v1 = new SimpleBuildingV1(); }

	var simpBuildingV1 = BR_Project._simpleBuilding_v1;
	var vbo_objects_count = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // Almost allways is 1.***

	// single interleaved buffer mode.*********************************************************************************
	for (var i=0; i<vbo_objects_count; i++) // Almost allways is 1.***
	{
		var simpObj = simpBuildingV1.newSimpleObject();
		var vt_cacheKey = simpObj._vtCacheKeys_container.newVertexTexcoordsArraysCacheKey();

		var iDatas_count = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		startBuff = bytes_readed;
		endBuff = bytes_readed + (4*3+2*2+1*4)*iDatas_count; // fPos_usTex_bNor.****
		vt_cacheKey.verticesArrayBuffer = arrayBuffer.slice(startBuff, endBuff);

		bytes_readed = bytes_readed + (4*3+2*2+1*4)*iDatas_count; // updating data.***

		vt_cacheKey._vertices_count = iDatas_count;

	}

	// Finally read the 4byte color.***
	var color_4byte_temp = this.readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

	//var b = color_4byte_temp & 0xFF;
	//var g = (color_4byte_temp & 0xFF00) >>> 8;
	//var r = (color_4byte_temp & 0xFF0000) >>> 16;
	//var a = ( (color_4byte_temp & 0xFF000000) >>> 24 ) / 255 ;

	this.fileBytesReaded = bytes_readed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileNailImage = function(BR_Project, magoManager) 
{
	//BR_Project._f4d_nailImage_readed = true;

	if (BR_Project._simpleBuilding_v1 === undefined)
	{ BR_Project._simpleBuilding_v1 = new SimpleBuildingV1(); }

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var simpBuildingV1 = BR_Project._simpleBuilding_v1;

	// Read the image.**********************************************************************************
	var bytes_readed = this.fileBytesReaded;
	var arrayBuffer = this.fileArrayBuffer;

	var nailImageSize = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	var startBuff = bytes_readed;
	var endBuff = bytes_readed + nailImageSize;
	simpBuildingV1.textureArrayBuffer = new Uint8Array(arrayBuffer.slice(startBuff, endBuff));

	bytes_readed += nailImageSize;

	this.fileBytesReaded = bytes_readed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileAllBuildings = function(magoManager) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{
		this.fileParsingFinished = true;
		return;
	}

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var arrayBuffer = this.fileArrayBuffer;
	var projects_count = this.readWriter.readInt32(arrayBuffer, 0, 4); this.fileBytesReaded += 4;

	if (projects_count === 0)
	{ this.empty_tile = true; }

	for (var i=0; i<projects_count; i++)
	{
		/*
		// 1rst, read the relative rawFile_path.***
		var rawFileNamePath_length = this.readWriter.readInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;// only debug test.***
		var rawFileNamePath = "";

		for(var j=0; j<rawFileNamePath_length; j++){
			rawFileNamePath += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
		}
		*/
		var bytes_readed = this.fileBytesReaded;
		this.fileBytesReaded = bytes_readed;

		this.current_BRProject_parsing = this.newBRProject();
		//this.current_BRProject_parsing._f4d_rawPathName = rawFileNamePath;

		this.parseFileHeader(this.current_BRProject_parsing);
		this.parseFileSimpleBuilding(this.current_BRProject_parsing);
		this.parseFileNailImage(this.current_BRProject_parsing, magoManager);
	}
	this.fileParsingFinished = true;
	this.fileArrayBuffer = null;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileOneBuilding = function(gl, magoManager) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{
		this.fileParsingFinished = true;
		return;
	}

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var projects_count = this.readWriter.readInt32(this.fileArrayBuffer, 0, 4); // only debug test.***

	if (this.projectsParsed_count >= projects_count)
	{
		this.fileParsingFinished = true;
		this.fileBytesReaded = null;
		return;
	}

	if (this.current_BRProject_parsing_state === 0)
	{
		if (this.projectsParsed_count === 0)
		{ this.fileBytesReaded = 4; }

		this.current_BRProject_parsing = this.newBRProject();
	}

	var BR_Project = this.current_BRProject_parsing;

	// Read header, simpleBuilding, and the nailImage.***
	if (this.current_BRProject_parsing_state === 0) 
	{
		this.parseFileHeader(BR_Project);
		this.current_BRProject_parsing_state=1;
	}
	else if (this.current_BRProject_parsing_state === 1) 
	{
		if (magoManager.backGround_imageReadings_count < 1) 
		{
			this.parseFile_simpleBuilding_old(gl, BR_Project);
			this.current_BRProject_parsing_state=2;
		}
	}
	else if (this.current_BRProject_parsing_state === 2) 
	{
		if (magoManager.backGround_imageReadings_count < 1) 
		{
			this.parseFile_nailImage_old(gl, BR_Project, magoManager);
			this.current_BRProject_parsing_state=0;
			this.projectsParsed_count++;
			magoManager.backGround_imageReadings_count ++;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.setDimensionsSubTiles = function() 
{
	var subTile;
	var subTiles_count = this.subTiles_array.length; // subTiles_count must be 4.***
	if (subTiles_count === 4) 
	{
		var lon_mid = (this.longitudeMax + this.longitudeMin)/2.0;
		var lat_mid = (this.latitudeMax + this.latitudeMin)/2.0;

		subTile = this.subTiles_array[0];
		subTile.setDimensions(this.longitudeMin, lon_mid, this.latitudeMin, lat_mid);

		subTile = this.subTiles_array[1];
		subTile.setDimensions(lon_mid, this.longitudeMax, this.latitudeMin, lat_mid);

		subTile = this.subTiles_array[2];
		subTile.setDimensions(lon_mid, this.longitudeMax, lat_mid, this.latitudeMax);

		subTile = this.subTiles_array[3];
		subTile.setDimensions(this.longitudeMin, lon_mid, lat_mid, this.latitudeMax);

		for (var i=0; i<subTiles_count; i++) 
		{
			this.subTiles_array[i].setDimensionsSubTiles();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param smallefstTiles_array 변수
 */
TerranTile.prototype.getSmallestTiles = function(smallestTiles_array) 
{
	// this returns smallestTiles, if the smallestTile has buildingd inside.***
	if (this.subTiles_array.length > 0) 
	{
		for (var i=0; i<this.subTiles_array.length; i++) 
		{
			this.subTiles_array[i].visibilityType = this.visibilityType;
			this.subTiles_array[i].getSmallestTiles(smallestTiles_array);
		}
	}
	else 
	{
		if (!this.empty_tile.length) { smallestTiles_array.push(this); }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param intersectedSmallestTiles_array 변수
 * @param boundingSphere_Aux 변수
 */
TerranTile.prototype.getIntersectedSmallestTiles = function(frustumVolume, intersectedSmallestTiles_array, boundingSphere_Aux) 
{
	var intersectedTiles_array = [];
	this.getIntersectedTiles(frustumVolume, intersectedTiles_array, boundingSphere_Aux);

	var intersectedTiles_count = intersectedTiles_array.length;
	for (var i=0; i<intersectedTiles_count; i++) 
	{
		intersectedTiles_array[i].getSmallestTiles(intersectedSmallestTiles_array);
	}
	intersectedTiles_array.length = 0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param intersectedTiles_array 변수
 * @param boundingSphere_Aux 변수
 */
TerranTile.prototype.getIntersectedTiles = function(frustumVolume, intersectedTiles_array, boundingSphere_Aux) 
{
	// Cesium dependency.***
	if (this.position === undefined) { return; }

	if (boundingSphere_Aux === undefined) { boundingSphere_Aux = new Cesium.BoundingSphere(); }

	//var intersectedPoints_count = 0;
	boundingSphere_Aux.radius = this.radius;
	boundingSphere_Aux.center.x = this.position.x;
	boundingSphere_Aux.center.y = this.position.y;
	boundingSphere_Aux.center.z = this.position.z;
	this.visibilityType = frustumVolume.computeVisibility(boundingSphere_Aux); // old. change for intersectionSphere.
	/*
	boundingSphere_Aux.center = this.leftDown_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.rightDown_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.rightUp_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.leftUp_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;
	*/

	if (this.visibilityType === Cesium.Intersect.OUTSIDE) 
	{
		// OUTSIDE.***
		// do nothing.***
	}
	else if (this.visibilityType === Cesium.Intersect.INSIDE) 
	{
		// INSIDE.***
		intersectedTiles_array.push(this);
	}
	else 
	{
		// INTERSECTED.***
		if (this.subTiles_array.length > 0) 
		{
			for (var i=0; i<this.subTiles_array.length; i++) 
			{
				this.subTiles_array[i].getIntersectedTiles(frustumVolume, intersectedTiles_array);
			}
		}
		else 
		{
			intersectedTiles_array.push(this);
		}
	}
};

'use strict';


/**
 * 맵 이미지. 머티리얼에는 텍스처에 대한 참조가 포함될 수 있으므로 머티리얼의 셰이더는 객체의 표면색을 계산하는 동안 텍스처를 사용할 수 있습니다.
 * 오브제의 표면의 기본 색상 (알베도) 외에도 텍스쳐는 반사율이나 거칠기와 같은 재질 표면의 많은 다른면을 나타낼 수 있습니다.
 * @class Texture
 */
var Texture = function() 
{
	if (!(this instanceof Texture)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.textureTypeName = "";
	this.textureImageFileName = "";
	this.texId;
	this.fileLoadState = CODE.fileLoadState.READY;
};

Texture.prototype.deleteObjects = function(gl)
{
	this.textureTypeName = undefined;
	this.textureImageFileName = undefined;
	if (this.texId)
	{
		gl.deleteTexture(this.texId);
	}
	this.texId = undefined;
	this.fileLoadState = undefined;
};

'use strict';

/**
 * 영역 박스
 * @class TriPolyhedron
 */
var TriPolyhedron = function() 
{
	if (!(this instanceof TriPolyhedron)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.vertexMatrix = new VertexMatrix();
	this.vertexList = this.vertexMatrix.newVertexList();
	this.triSurfacesArray = [];
};

TriPolyhedron.prototype.newTriSurface = function() 
{
	var triSurface = new TriSurface();
	this.triSurfacesArray.push(triSurface);
	return triSurface;
};

TriPolyhedron.prototype.invertTrianglesSenses = function() 
{
	var triSurfacesCount = this.triSurfacesArray.length;
	for (var i=0; i<triSurfacesCount; i++)
	{
		this.triSurfacesArray[i].invertTrianglesSenses();
	}
};

TriPolyhedron.prototype.getVBOArrayModePosNorCol = function(resultVBOVertexIdxCacheKey) 
{
	// there are "arrayMode" and the "elementMode". "elementMode" uses indices.***
	if (resultVBOVertexIdxCacheKey === undefined)
	{ resultVBOVertexIdxCacheKey = new VBOVertexIdxCacheKey(); }

	if (resultVBOVertexIdxCacheKey.posVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.posVboDataArray = []; }

	if (resultVBOVertexIdxCacheKey.norVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.norVboDataArray = []; }

	if (resultVBOVertexIdxCacheKey.colVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.colVboDataArray = []; }

	var positionArray = [];
	var normalsArray = [];
	var colorsArray = [];


	resultVBOVertexIdxCacheKey.vertexCount = 0;

	var vertex0, vertex1, vertex2;
	var triangle;
	var trianglesCount;
	var triSurface;
	var triSurfacesCount = this.triSurfacesArray.length;
	for (var i = 0; i < triSurfacesCount; i++) 
	{
		triSurface = this.triSurfacesArray[i];
		trianglesCount = triSurface.trianglesArray.length;
		for (var j = 0; j < trianglesCount; j++) 
		{
			triangle = triSurface.trianglesArray[j];
			if (triangle.normal === undefined)
			{ triangle.calculatePlaneNormal(); }

			// position.***
			vertex0 = triangle.vertex0;
			vertex1 = triangle.vertex1;
			vertex2 = triangle.vertex2;

			positionArray.push(vertex0.point3d.x);
			positionArray.push(vertex0.point3d.y);
			positionArray.push(vertex0.point3d.z);

			positionArray.push(vertex1.point3d.x);
			positionArray.push(vertex1.point3d.y);
			positionArray.push(vertex1.point3d.z);

			positionArray.push(vertex2.point3d.x);
			positionArray.push(vertex2.point3d.y);
			positionArray.push(vertex2.point3d.z);

			// normal (use planeNormal).***
			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			// colors.***
			if (vertex0.color4 === undefined) 
			{
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);

				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);

				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
			}
			else 
			{
				colorsArray.push(vertex0.color4.r);
				colorsArray.push(vertex0.color4.g);
				colorsArray.push(vertex0.color4.b);
				colorsArray.push(vertex0.color4.a);

				colorsArray.push(vertex1.color4.r);
				colorsArray.push(vertex1.color4.g);
				colorsArray.push(vertex1.color4.b);
				colorsArray.push(vertex1.color4.a);

				colorsArray.push(vertex2.color4.r);
				colorsArray.push(vertex2.color4.g);
				colorsArray.push(vertex2.color4.b);
				colorsArray.push(vertex2.color4.a);
			}

			resultVBOVertexIdxCacheKey.vertexCount += 3;
		}
	}

	var vertexCount = resultVBOVertexIdxCacheKey.vertexCount;
	resultVBOVertexIdxCacheKey.norVboDataArray = new Int8Array(vertexCount*3);
	resultVBOVertexIdxCacheKey.colVboDataArray = new Uint8Array(vertexCount*4);
	resultVBOVertexIdxCacheKey.posVboDataArray = new Float32Array(vertexCount*3);
	
	for (var i = 0; i < vertexCount * 3; i++) 
	{
		resultVBOVertexIdxCacheKey.posVboDataArray[i] = positionArray[i];
		resultVBOVertexIdxCacheKey.norVboDataArray[i] = normalsArray[i];
	}
	
	for (var i = 0; i < vertexCount * 4; i++) 
	{
		resultVBOVertexIdxCacheKey.colVboDataArray[i] = colorsArray[i];
	}

	positionArray = undefined;
	normalsArray = undefined;
	colorsArray = undefined;

	return resultVBOVertexIdxCacheKey;
};

'use strict';

/**
 * 영역 박스
 * @class TriSurface
 */
var TriSurface = function() 
{
	if (!(this instanceof TriSurface)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertexList;
	this.trianglesArray;
	this.trianglesList;
};

TriSurface.prototype.newTriangle = function() 
{
	if (this.trianglesArray === undefined)
	{ this.trianglesArray = []; }
	
	var triangle = new Triangle();
	this.trianglesArray.push(triangle);
	return triangle;
};

TriSurface.prototype.invertTrianglesSenses = function() 
{
	var trianglesCount = this.trianglesArray.length;
	for (var i=0; i<trianglesCount; i++)
	{
		this.trianglesArray[i].invertSense();
	}
};



'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOManager
 */
var VBOManager = function() 
{
	if (!(this instanceof VBOManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class Buffer
 */
var Buffer = function() 
{
	if (!(this instanceof Buffer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.dataArray;
	this.dataArrayByteLength = 0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOVertexIdxCacheKey
 */
var VBOVertexIdxCacheKey = function() 
{
	if (!(this instanceof VBOVertexIdxCacheKey)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.indicesCount = -1;
	this.vertexCount = -1;
	this.bigTrianglesIndicesCount = -1;

	this.meshVertexCacheKey;
	this.meshFacesCacheKey;
	this.meshNormalCacheKey;
	this.meshColorCacheKey;
	this.meshTexcoordsCacheKey;

	this.posVboDataArray; // to store data here, and when necessary bind to gl and delete it.***
	this.norVboDataArray; // to store data here, and when necessary bind to gl and delete it.***
	this.idxVboDataArray; // to store data here, and when necessary bind to gl and delete it.***
	this.colVboDataArray; // to store data here, and when necessary bind to gl and delete it.***
	this.tcoordVboDataArray; // to store data here, and when necessary bind to gl and delete it.***
	
	this.posArrayByteSize;
	this.norArrayByteSize;
	this.idxArrayByteSize;
	this.colArrayByteSize;
	this.tcoordArrayByteSize;
	
	// byteType: float, short, byte.***
	this.posArrayByteType;
	this.norArrayByteType;
	this.idxArrayByteType;
	this.colArrayByteType;
	this.tcoordArrayByteType;

	this.buffer;// delete this. provisionally put this here.***
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboViCacheKey
 */
VBOVertexIdxCacheKey.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.meshVertexCacheKey) 
	{
		vboMemManager.storeClassifiedBufferKey(gl, this.meshVertexCacheKey, this.posArrayByteSize);
		this.meshVertexCacheKey = undefined;
	}
	this.posVboDataArray = undefined;

	if (this.meshNormalCacheKey) 
	{
		vboMemManager.storeClassifiedBufferKey(gl, this.meshNormalCacheKey, this.norArrayByteSize);
		this.meshNormalCacheKey = undefined;
	}
	this.norVboDataArray = undefined;

	if (this.meshColorCacheKey) 
	{
		vboMemManager.storeClassifiedBufferKey(gl, this.meshColorCacheKey, this.colArrayByteSize);
		this.meshColorCacheKey = undefined;
	}
	this.colVboDataArray = undefined;

	if (this.meshTexcoordsCacheKey) 
	{
		vboMemManager.storeClassifiedBufferKey(gl, this.meshTexcoordsCacheKey, this.tcoordArrayByteSize);
		this.meshTexcoordsCacheKey = undefined;
	}
	this.tcoordVboDataArray = undefined;

	if (this.meshFacesCacheKey) 
	{
		vboMemManager.storeClassifiedElementKey(gl, this.meshFacesCacheKey, this.idxArrayByteSize);
		this.meshFacesCacheKey = undefined;
	}
	this.idxVboDataArray = undefined;
	
	this.posArrayByteSize = undefined;
	this.norArrayByteSize = undefined;
	this.idxArrayByteSize = undefined;
	this.colArrayByteSize = undefined;
	this.tcoordArrayByteSize = undefined;

	this.buffer = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @return boolean
 */
VBOVertexIdxCacheKey.prototype.isReadyPositions = function(gl, vboMemManager) 
{
	if (this.meshVertexCacheKey === undefined) 
	{
		if (this.posVboDataArray === undefined) { return false; }
		
		this.meshVertexCacheKey = vboMemManager.getClassifiedBufferKey(gl, this.posArrayByteSize);
		if (this.meshVertexCacheKey === undefined)
		{ return false; }
		gl.bindBuffer(gl.ARRAY_BUFFER, this.meshVertexCacheKey);
		gl.bufferData(gl.ARRAY_BUFFER, this.posVboDataArray, gl.STATIC_DRAW);
		this.posVboDataArray = undefined;
		return true;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @return boolean
 */
VBOVertexIdxCacheKey.prototype.isReadyNormals = function(gl, vboMemManager) 
{
	if (this.meshNormalCacheKey === undefined) 
	{
		if (this.norVboDataArray === undefined) { return false; }

		this.meshNormalCacheKey = vboMemManager.getClassifiedBufferKey(gl, this.norArrayByteSize);
		if (this.meshNormalCacheKey === undefined)
		{ return false; }
		gl.bindBuffer(gl.ARRAY_BUFFER, this.meshNormalCacheKey);
		gl.bufferData(gl.ARRAY_BUFFER, this.norVboDataArray, gl.STATIC_DRAW);
		this.norVboDataArray = undefined;
		return true;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @return boolean
 */
VBOVertexIdxCacheKey.prototype.isReadyFaces = function(gl, vboMemManager) 
{
	if (this.meshFacesCacheKey === undefined) 
	{
		if (this.idxVboDataArray === undefined) { return false; }

		this.meshFacesCacheKey = vboMemManager.getClassifiedElementKey(gl, this.idxArrayByteSize);
		if (this.meshFacesCacheKey === undefined)
		{ return false; }
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.meshFacesCacheKey);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.idxVboDataArray, gl.STATIC_DRAW);
		this.idxVboDataArray = undefined;
		return true;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @return boolean
 */
VBOVertexIdxCacheKey.prototype.isReadyTexCoords = function(gl, vboMemManager) 
{
	if (this.meshTexcoordsCacheKey === undefined) 
	{
		if (this.tcoordVboDataArray === undefined) { return false; }

		this.meshTexcoordsCacheKey = vboMemManager.getClassifiedBufferKey(gl, this.tcoordArrayByteSize);
		if (this.meshTexcoordsCacheKey === undefined)
		{ return false; }
		gl.bindBuffer(gl.ARRAY_BUFFER, this.meshTexcoordsCacheKey);
		gl.bufferData(gl.ARRAY_BUFFER, this.tcoordVboDataArray, gl.STATIC_DRAW);
		this.tcoordVboDataArray = undefined;

		return true;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @return boolean
 */
VBOVertexIdxCacheKey.prototype.isReadyColors = function(gl, vboMemManager) 
{
	if (this.meshColorCacheKey === undefined) 
	{
		if (this.colVboDataArray === undefined) { return false; }
		
		this.meshColorCacheKey = vboMemManager.getClassifiedBufferKey(gl, this.colArrayByteSize);
		if (this.meshColorCacheKey === undefined)
		{ return false; }
		gl.bindBuffer(gl.ARRAY_BUFFER, this.meshColorCacheKey);
		gl.bufferData(gl.ARRAY_BUFFER, this.colVboDataArray, gl.STATIC_DRAW);
		this.colVboDataArray = undefined;
		
		return true;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOVertexIdxCacheKeysContainer
 */
var VBOVertexIdxCacheKeysContainer = function() 
{
	if (!(this instanceof VBOVertexIdxCacheKeysContainer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vboCacheKeysArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboViCacheKey
 */
VBOVertexIdxCacheKeysContainer.prototype.newVBOVertexIdxCacheKey = function() 
{
	var vboViCacheKey = new VBOVertexIdxCacheKey();
	this.vboCacheKeysArray.push(vboViCacheKey);
	return vboViCacheKey;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboViCacheKey
 */
VBOVertexIdxCacheKeysContainer.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.vboCacheKeysArray === undefined)
	{ return; }
	
	var vboDatasCount = this.vboCacheKeysArray.length;
	for (var j = 0; j < vboDatasCount; j++) 
	{
		this.vboCacheKeysArray[j].deleteGlObjects(gl, vboMemManager);
		this.vboCacheKeysArray[j] = undefined;
	}
	this.vboCacheKeysArray.length = 0;
	this.vboCacheKeysArray = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboViCacheKey
 */
VBOVertexIdxCacheKeysContainer.prototype.getVbosCount = function() 
{
	if (this.vboCacheKeysArray === undefined) { return 0; }
	
	return this.vboCacheKeysArray.length;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOByteColorCacheKey
 */
var VBOByteColorCacheKey = function() 
{
	if (!(this instanceof VBOByteColorCacheKey)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.meshColorsCacheKey = null;
	this.meshTexcoordsCacheKey = null;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOByteColorCacheKeysContainer
 */
var VBOByteColorCacheKeysContainer = function() 
{
	if (!(this instanceof VBOByteColorCacheKeysContainer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vboByteColorsCacheKeysArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @return vboByteColCacheKey
 */
VBOByteColorCacheKeysContainer.prototype.newVBOByteColorsCacheKey = function() 
{
	var vboByteColCacheKey = new VBOByteColorCacheKey();
	this.vboByteColorsCacheKeysArray.push(vboByteColCacheKey);
	return vboByteColCacheKey;
};











'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOKeysStore
 */
var VBOKeysStore = function(bufferSize) 
{
	if (!(this instanceof VBOKeysStore)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.classifiedSize = bufferSize;
	this.vboKeysArray = [];
	this.keysCreated = 0; // total keys created for this size.
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. 
 */
VBOKeysStore.prototype.getBufferKey = function(gl, keyNation, keyWorld, onlyReuse) 
{
	if (this.vboKeysArray.length > 0)
	{
		var vboKey = this.vboKeysArray.pop();
		return vboKey;
	}
	else 
	{
		if (!onlyReuse)
		{
			// there are no free key, so create one.
			var vboKey = gl.createBuffer();
			this.keysCreated += 1; // increment key created counter.
			keyNation.totalBytesUsed += this.classifiedSize;
			keyWorld.totalBytesUsed += this.classifiedSize;
			return vboKey;
		}
		return undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. 
 */
VBOKeysStore.prototype.storeBufferKey = function(bufferKey) 
{
	this.vboKeysArray.push(bufferKey);
};

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOKeysNation
 */
var VBOKeysNation = function(bufferSizes, minSize) 
{
	if (!(this instanceof VBOKeysNation)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// buffer sizes are in bytes.
	this.vboKeysStoreMap = {};
	this.bufferSizes = bufferSizes;
	this.minSize = minSize;
	this.maxSize = bufferSizes[bufferSizes.length-1];
	this.totalBytesUsed = 0;
	
	var vboKeysStore;
	var sizesCount = bufferSizes.length;
	for (var i=0; i<sizesCount; i++)
	{
		vboKeysStore = new VBOKeysStore(bufferSizes[i]);
		this.vboKeysStoreMap[bufferSizes[i]] = vboKeysStore;

		if (bufferSizes[i] > this.maxSize) { this.maxSize = bufferSizes[i]; }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferKey. 
 */
VBOKeysNation.prototype.getClassifiedBufferKey = function(gl, bufferSize, keyWorld, onlyReuse) 
{
	// 1rst find the vboKeyStore for this bufferSize.
	var vboKeyStore = this.vboKeysStoreMap[bufferSize];
	
	if (vboKeyStore)
	{
		return vboKeyStore.getBufferKey(gl, this, keyWorld, onlyReuse);
	}
	else { return -1; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferKey. 
 */
VBOKeysNation.prototype.storeClassifiedBufferKey = function(bufferKey, bufferSize) 
{
	// 1rst find the vboKeyStore for this bufferSize.
	var vboKeyStore = this.vboKeysStoreMap[bufferSize];
	if (vboKeyStore)
	{
		vboKeyStore.storeBufferKey(bufferKey);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. true if the currentBufferSize is in the range of this nation.
 */
VBOKeysNation.prototype.getClosestBufferSize = function(currentBufferSize) 
{
	if (!this.isInsideRange(currentBufferSize))
	{ return -1; }
	
	var sizesCount = this.bufferSizes.length;
	for (var i=0; i<sizesCount; i++)
	{
		if (currentBufferSize <= this.bufferSizes[i])
		{
			return this.bufferSizes[i];
		}
	}
	return -1;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. true if the currentBufferSize is in the range of this nation.
 */
VBOKeysNation.prototype.isInsideRange = function(bufferSize) 
{
	if (bufferSize > this.maxSize || bufferSize < this.minSize)
	{ return false; }

	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
var VBOKeysWorld = function() 
{
	if (!(this instanceof VBOKeysWorld)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.totalBytesUsed = 0;
	this.bytesLimit = 1000;
	
	this.vboKeysNationsArray = [];
	this.vboKeyNation12to128 = new VBOKeysNation(new Uint32Array([12, 16, 32, 48, 64, 76, 92, 128]), 0);
	this.vboKeysNationsArray.push(this.vboKeyNation12to128);
	this.vboKeyNation200to1000 = new VBOKeysNation(new Uint32Array([200, 300, 400, 500, 600, 700, 800, 900, 1000]), 129);
	this.vboKeysNationsArray.push(this.vboKeyNation200to1000);
	this.vboKeyNation1500to6000 = new VBOKeysNation(new Uint32Array([1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500, 6000]), 1001);
	this.vboKeysNationsArray.push(this.vboKeyNation1500to6000);
	this.vboKeyNation7000to16000 = new VBOKeysNation(new Uint32Array([7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]), 6001);
	this.vboKeysNationsArray.push(this.vboKeyNation7000to16000);
	this.vboKeyNation20000to56000 = new VBOKeysNation(new Uint32Array([20000, 24000, 28000, 32000, 36000, 40000, 44000, 48000, 52000, 56000]), 16001);
	this.vboKeysNationsArray.push(this.vboKeyNation20000to56000);
	this.vboKeyNation60000to150000 = new VBOKeysNation(new Uint32Array([60000, 70000, 80000, 90000, 100000, 110000, 120000, 130000, 140000, 150000]), 56001);
	this.vboKeysNationsArray.push(this.vboKeyNation60000to150000);
	this.vboKeyNation200000to1100000 = new VBOKeysNation(new Uint32Array([200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 1100000]), 150001);
	this.vboKeysNationsArray.push(this.vboKeyNation200000to1100000);
	this.vboKeyNation1500000to3000000 = new VBOKeysNation(new Uint32Array([1500000, 2000000, 2500000, 3000000]), 1100001);
	this.vboKeysNationsArray.push(this.vboKeyNation1500000to3000000);
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.getClassifiedBufferKey = function(gl, bufferSize) 
{
	// check gpuMemory limit.
	var onlyReuse = false;
	if (this.totalBytesUsed > this.bytesLimit)
	{
		onlyReuse = true;
	}
	
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(bufferSize);
	var vboBufferKey = undefined;
	if (keyNation)
	{
		vboBufferKey = keyNation.getClassifiedBufferKey(gl, bufferSize, this, onlyReuse);
	}
	return vboBufferKey;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.storeClassifiedBufferKey = function(bufferKey, bufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(bufferSize);
	if (keyNation)
	{ keyNation.storeClassifiedBufferKey(bufferKey, bufferSize); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.getKeyNationBySize = function(bufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var nationsCount = this.vboKeysNationsArray.length;
	var i=0;
	var vboBufferKey = -1;
	while (i<nationsCount)
	{
		if (this.vboKeysNationsArray[i].isInsideRange(bufferSize))
		{
			return this.vboKeysNationsArray[i];
		}
		i++;
	}
	return vboBufferKey;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferStandardSize
 */
VBOKeysWorld.prototype.getClassifiedBufferSize = function(currentBufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(currentBufferSize);
	var classifiedSize = -1;

	if (keyNation !== -1)
	{ classifiedSize = keyNation.getClosestBufferSize(currentBufferSize); }
	return classifiedSize;
};



/**
 * 어떤 일을 하고 있습니까?
 * @class VBOMemoryManager
 */
var VBOMemoryManager = function() 
{
	if (!(this instanceof VBOMemoryManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// if "enableMemoryManagement" == false -> no management of the gpu memory.
	this.enableMemoryManagement = false;
	
	this.buffersKeyWorld = new VBOKeysWorld();
	this.elementKeyWorld = new VBOKeysWorld();
	
	this.buffersKeyWorld.bytesLimit = 800000000;
	this.elementKeyWorld.bytesLimit = 300000000;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.isGpuMemFull = function() 
{
	if (this.buffersKeyWorld.totalBytesUsed > this.buffersKeyWorld.bytesLimit || this.elementKeyWorld.totalBytesUsed > this.elementKeyWorld.bytesLimit)
	{ return true; }
	else { return false; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.getClassifiedBufferKey = function(gl, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ return this.buffersKeyWorld.getClassifiedBufferKey(gl, bufferSize); }
	else
	{ return gl.createBuffer(); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.storeClassifiedBufferKey = function(gl, bufferKey, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ this.buffersKeyWorld.storeClassifiedBufferKey(bufferKey, bufferSize); }
	else
	{ gl.deleteBuffer(bufferKey); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.getClassifiedElementKey = function(gl, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ return this.elementKeyWorld.getClassifiedBufferKey(gl, bufferSize); }
	else
	{ return gl.createBuffer(); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.storeClassifiedElementKey = function(gl, bufferKey, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ this.elementKeyWorld.storeClassifiedBufferKey(bufferKey, bufferSize); }
	else
	{ gl.deleteBuffer(bufferKey); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferStandardSize
 */
VBOMemoryManager.prototype.getClassifiedBufferSize = function(currentBufferSize) 
{
	if (this.enableMemoryManagement)
	{ return this.buffersKeyWorld.getClassifiedBufferSize(currentBufferSize); } 
	else
	{ return currentBufferSize; }
};











'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VisibleObjectsController
 */
var VisibleObjectsController = function() 
{
	if (!(this instanceof VisibleObjectsController)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.currentVisibles0 = [];
	this.currentVisibles1 = [];
	this.currentVisibles2 = [];
	this.currentVisibles3 = [];
	this.currentVisiblesAux = [];
};

VisibleObjectsController.prototype.initArrays = function() 
{
	this.currentVisibles0 = [];
	this.currentVisibles1 = [];
	this.currentVisibles2 = [];
	this.currentVisibles3 = [];
	this.currentVisiblesAux = [];
};

VisibleObjectsController.prototype.clear = function() 
{
	this.currentVisibles0.length = 0;
	this.currentVisibles1.length = 0;
	this.currentVisibles2.length = 0;
	this.currentVisibles3.length = 0;
	this.currentVisiblesAux.length = 0;
};

/**
 */
VisibleObjectsController.prototype.getNodeIdxSortedByDist = function(nodesArray, startIdx, endIdx, node) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	var neoBuilding = node.data.neoBuilding;
	var range = endIdx - startIdx;
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;

		while (!finished && i<=endIdx)
		{
			var aNeoBuilding = nodesArray[i].data.neoBuilding;
			if (neoBuilding.distToCam < aNeoBuilding.distToCam)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{ return idx; }
		else 
		{ return endIdx+1; }
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		var middleNeoBuilding = nodesArray[middleIdx].data.neoBuilding;
		if (middleNeoBuilding.distToCam > neoBuilding.distToCam)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getNodeIdxSortedByDist(nodesArray, newStartIdx, newEndIdx, node);
	}
};

/**
 */
VisibleObjectsController.prototype.putNodeToArraySortedByDist = function(nodesArray, node) 
{
	if (nodesArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = nodesArray.length - 1;
		var idx = this.getNodeIdxSortedByDist(nodesArray, startIdx, endIdx, node);
		
		nodesArray.splice(idx, 0, node);
	}
	else 
	{
		nodesArray.push(node);
	}
};
















/* eslint-env jquery */
'use strict';

/**
 * An API that interacts with the on-screen UI. Class name to be modified by APIGateWay or API class
 * @class MagoFacade
 */
/**
 * mago3d 활성화/비활성화
 * @param {ManagerFactory} managerFactoryInstance 
 * @param {boolean} isShow true = show, false = hide
 */
function changeMagoStateAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeMagoState");
	api.setMagoEnable(isShow);
	managerFactoryInstance.callAPI(api);
};

/**
 * Label show/hide
 * @param {ManagerFactory} managerFactoryInstance 
 * @param {boolean} isShow true = show, false = hide
 */
function changeLabelAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeLabel");
	api.setShowLabelInfo(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * Origin show/hide
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} isShow true = show, false = hide
 */
function changeOriginAPI(managerFactoryInstance, isShow)
{
	if (managerFactoryInstance === null) { return; }

	var api = new API("changeOrigin");
	api.setShowOrigin(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * boundingBox show/hide
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} isShow true = show, false = hide
 */
function changeBoundingBoxAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeBoundingBox");
	api.setShowBoundingBox(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * 속성값에 의한 가시화 유무설정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} isShow true = 표시, false = 비표시
 */
function changePropertyRenderingAPI(managerFactoryInstance, isShow, projectId, property) 
{
	if (managerFactoryInstance === null) { return; } 
		
	var api = new API("changePropertyRendering");
	api.setShowShadow(isShow);
	api.setProjectId(projectId);
	api.setProperty(property);
	managerFactoryInstance.callAPI(api);
}

/**
 * 그림자 표시/비표시
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} isShow true = 활성화, false = 비활성화
 */
function changeShadowAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeShadow");
	api.setShowShadow(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * color 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId 프로젝트 아이디
 * @param {string} dataKey data key
 * @param {string} objectIds object id. 복수개의 경우 , 로 입력
 * @param {string} property 속성값 예)isMain=true
 * @param {string} color R, G, B 색깔을 ',' 로 연결한 string 값을 받음.
 */
function changeColorAPI(managerFactoryInstance, projectId, dataKey, objectIds, property, color) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeColor");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setObjectIds(objectIds);
	api.setProperty(property);
	api.setColor(color);
	managerFactoryInstance.callAPI(api);
}

/**
 * location and rotation 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId
 * @param {string} dataKey
 * @param {string} latitude 위도
 * @param {string} longitude 경도
 * @param {string} height 높이
 * @param {string} heading 좌, 우
 * @param {string} pitch 위, 아래
 * @param {string} roll 좌, 우 기울기
 */
function changeLocationAndRotationAPI(managerFactoryInstance, projectId, dataKey, latitude, longitude, height, heading, pitch, roll) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeLocationAndRotation");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setHeading(heading);
	api.setPitch(pitch);
	api.setRoll(roll);
	managerFactoryInstance.callAPI(api);
}

/**
 * 마우스 클릭 객체 이동 대상 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function changeObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 마우스로 이동한 객체 정보를 브라우저내 저장
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function saveObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("saveObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 브라우저내 모든 마우스 이동 정보를 삭제
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function deleteAllObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("deleteAllObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 브라우저내 모든 색깔 변경 이력을 삭제
 * @param {ManagerFactory} managerFactoryInstance
 */
function deleteAllChangeColorAPI(managerFactoryInstance) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("deleteAllChangeColor");
	managerFactoryInstance.callAPI(api);
}

/**
 * 이슈 등록 활성화 유무
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} flag true = 활성화, false = 비활성화
 */
function changeInsertIssueModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeInsertIssueMode");
	api.setIssueInsertEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * object 정보 표시 활성화 유무
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} flag true = 활성화, false = 비활성화
 */
function changeObjectInfoViewModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeObjectInfoViewMode");
	api.setObjectInfoViewEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * Object Occlusion culling
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} flag true = 활성화, false = 비활성화
 * @param {string} dataKey
 */
function changeOcclusionCullingAPI(managerFactoryInstance, flag, dataKey) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeOcclusionCulling");
	api.setOcclusionCullingEnable(flag);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * 1인칭, 3인칭 모드 개발중...
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} flag true = 활성화, false = 비활성화
 */
function changeFPVModeAPI(managerFactoryInstance, flag)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeFPVMode");
	api.setFPVMode(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * 현재 위치 근처 issue list. false인 경우 clear
 * @param {ManagerFactory} managerFactoryInstance
 * @param {boolean} flag true = 활성화, false = 비활성화
 */
function changeNearGeoIssueListViewModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeNearGeoIssueListViewMode");
	api.setNearGeoIssueListEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * TODO 이건 위에 이슈 등록 활성화, 비활성화 api로 통합이 가능할거 같음
 * issue 등록 geo 정보 관련 상태 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} insertIssueState 이슈 등록 좌표 상태
 */
function changeInsertIssueStateAPI(managerFactoryInstance, insertIssueState) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeInsertIssueState");
	api.setInsertIssueState(insertIssueState);
	managerFactoryInstance.callAPI(api);
}

/**
 * LOD 설정을 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} lod0DistInMeters
 * @param {string} lod1DistInMeters
 * @param {string} lod2DistInMeters
 * @param {string} lod3DistInMeters
 * @param {string} lod4DistInMeters
 * @param {string} lod5DistInMeters
 */
function changeLodAPI(managerFactoryInstance, lod0DistInMeters, lod1DistInMeters, lod2DistInMeters, lod3DistInMeters, lod4DistInMeters, lod5DistInMeters)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeLod");
	api.setLod0DistInMeters(lod0DistInMeters);
	api.setLod1DistInMeters(lod1DistInMeters);
	api.setLod2DistInMeters(lod2DistInMeters);
	api.setLod3DistInMeters(lod3DistInMeters);
	api.setLod4DistInMeters(lod4DistInMeters);
	api.setLod5DistInMeters(lod5DistInMeters);
	managerFactoryInstance.callAPI(api);
}

/**
 * Lighting 설정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} ambientReflectionCoef
 * @param {string} diffuseReflectionCoef
 * @param {string} specularReflectionCoef
 * @param {string} ambientColor
 * @param {string} specularColor
 */
function changeLightingAPI(managerFactoryInstance, ambientReflectionCoef, diffuseReflectionCoef, specularReflectionCoef, ambientColor, specularColor)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeLighting");
	api.setAmbientReflectionCoef(ambientReflectionCoef);
	api.setDiffuseReflectionCoef(diffuseReflectionCoef);
	api.setSpecularReflectionCoef(specularReflectionCoef);
	api.setAmbientColor(ambientColor);
	api.setSpecularColor(specularColor);
	managerFactoryInstance.callAPI(api);
}

/**
 * SSAO Radius 설정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} ssaoRadius
 */
function changeSsaoRadiusAPI(managerFactoryInstance, ssaoRadius)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("changeSsaoRadius");
	api.setSsaoRadius(ssaoRadius);
	managerFactoryInstance.callAPI(api);
}

/**
 * 화면에 있는 모든 데이터를 삭제, 비표시
 * @param {ManagerFactory} managerFactoryInstance
 */
function clearAllDataAPI(managerFactoryInstance)
{	
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("clearAllData");
	MagoConfig.clearAllData();
	managerFactoryInstance.callAPI(api);
}

/**
 * pin image를 그림
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} drawType 이미지를 그리는 유형 0 : DB, 1 : 이슈등록
 * @param {string} issue_id 이슈 고유키
 * @param {string} issue_type 이슈 고유키
 * @param {string} data_key 데이터 고유키
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 */
function drawInsertIssueImageAPI(managerFactoryInstance, drawType, issue_id, issue_type, data_key, latitude, longitude, height) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("drawInsertIssueImage");
	api.setDrawType(drawType);
	api.setIssueId(issue_id);
	api.setIssueId(issue_type);
	api.setDataKey(data_key);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	managerFactoryInstance.callAPI(api);
}

/**
 * 해당 프로젝트를 로딩하고 이동하기
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project id
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 * @param {string} duration 이동하는 시간
 */
function gotoProjectAPI(managerFactoryInstance, projectId, projectData, projectDataFolder, longitude, latitude, height, duration) 
{
	if (managerFactoryInstance === null) { return; } 
	
	MagoConfig.setData(CODE.PROJECT_ID_PREFIX + projectId, projectData);
	MagoConfig.setProjectDataFolder(CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder, projectDataFolder);
	
	var api = new API("gotoProject");
	api.setProjectId(projectId);
	api.setProjectDataFolder(projectDataFolder);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setDuration(duration);
	managerFactoryInstance.callAPI(api);
}

/**
 * 해당 프로젝트를 로딩하고 Issue 등록 지점으로 이동하기
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project id
 * @param {string} issueId issue id
 * @param {string} issueType issue type
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 * @param {string} duration 이동하는 시간
 */
function gotoIssueAPI(managerFactoryInstance, projectId, projectData, projectDataFolder, issueId, issueType, longitude, latitude, height, duration)
{
	if (managerFactoryInstance === null) { return; } 
	
	MagoConfig.setData(CODE.PROJECT_ID_PREFIX + projectId, projectData);
	MagoConfig.setProjectDataFolder(CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder, projectDataFolder);
	
	var api = new API("gotoIssue");
	api.setProjectId(projectId);
	api.setProjectDataFolder(projectDataFolder);
	api.setIssueId(issueId);
	api.setIssueType(issueType);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setDuration(duration);
	managerFactoryInstance.callAPI(api);
}


/**
 * 마우스를 사용할 수 없는 환경에서 버튼 이벤트로 대체
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} eventType 어떤 마우스 동작을 원하는지를 구분
 */
function mouseMoveAPI(managerFactoryInstance, eventType) 
{
	if (managerFactoryInstance === null) { return; } 
	
	managerFactoryInstance.mouseMove(eventType);
}

/**
 * 데이터 검색
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId 데이터 고유키
 * @param {string} dataKey 데이터 고유키
 */
function searchDataAPI(managerFactoryInstance, projectId, dataKey) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new API("searchData");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * 환경 설정 data Object에 key 값의 존재 유무를 판별
 * @param {string} key 검색 키
 * @param 
 */
function isDataExistAPI(key) 
{
	if (MagoConfig.isDataExist(key)) { return true; }
	else { return false; }
}

/**
 * 환경 설정 data map에서 key 값을 취득
 * @param {string} key 검색 키
 * @param 
 */
function getDataAPI(key) 
{
	return MagoConfig.getData(key);
}

/**
 * Data Key 를 이용하여 Geo Spatial Info를 취득
 * @param {ManagerFactory} managerFactoryInstance
 * @param {String} projectId 고유키
 * @param {String} dataKey Data 고유키
 * @param
 */
function getDataInfoByDataKeyAPI(managerFactoryInstance, projectId, dataKey)
{
	if (managerFactoryInstance === null) { return; }

	var api = new API("getDataInfoByDataKey");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * 데이터를 Rendering
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Object[]} projectIdArray 프로젝트 이름들
 * @param {Object[]} projectDataArray 프로젝트 데이터들
 * @param {Object[]} projectDataFolderArray 프로젝트 f4d 파일 경로
 * @param 
 */
function drawAppendDataAPI(managerFactoryInstance, projectIdArray, projectDataArray, projectDataFolderArray) 
{
	if (managerFactoryInstance === null) { return; } 
	
	if (projectIdArray.length <= 0) { return; }
	
	var api = new API("drawAppendData");
	projectIdArray.forEach(function(dataName, index) 
	{
			
		MagoConfig.setData(CODE.PROJECT_ID_PREFIX + dataName, projectDataArray[index]);
		MagoConfig.setProjectDataFolder(CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolderArray[index], projectDataFolderArray[index]);
		
		api.setProjectId(dataName);
		api.setProjectDataFolder(projectDataFolderArray[index]);
		managerFactoryInstance.callAPI(api);
	});
}

/**
 * get coodinate relative to building
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @param {string} inputPoint input x, y, z
 * @param {string} resultPoint return point
 */
function getCoordinateRelativeToBuildingAPI(managerFactoryInstance, projectId, dataKey, inputPoint, resultPoint)
{
	if (managerFactoryInstance === null) { return; }

	var api = new API("getCoordinateRelativeToBuilding");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setInputPoint(inputPoint);
	api.setResultPoint(resultPoint);

	return managerFactoryInstance.callAPI(api);
}

/**
 * get absolte coodinate of building point
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @param {string} inputPoint input x, y, z
 * @param {string} resultPoint return point
 */
function getAbsoluteCoodinateOfBuildingPointAPI(managerFactoryInstance, projectId, dataKey, inputPoint, resultPoint)
{
	if (managerFactoryInstance === null) { return; }

	var api = new API("getAbsoluteCoodinateOfBuildingPoint");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setInputPoint(inputPoint);
	api.setResultPoint(resultPoint);

	return managerFactoryInstance.callAPI(api);
}
'use strict';

/**
 * color 처리 관련 도메인
 * @class ColorAPI
 */
var ColorAPI = {};

ColorAPI.changeColor = function(api, magoManager) 
{
	var projectId = api.getProjectId();
	var dataKey = api.getDataKey();
	var objectIds = api.getObjectIds();
	var property = api.getProperty();
	var propertyKey = null;
	var propertyValue = null;
	if (property !== null && property !== "") 
	{
		var properties = property.split("=");
		propertyKey = properties[0];
		propertyValue = properties[1];
	}
	var color = api.getColor().split(",");
	var rgbColor = [ color[0]/255, color[1]/255, color[2]/255 ] ;
	
	var isExistObjectIds = false;
	if (objectIds !== null && objectIds.length !== 0) 
	{
		isExistObjectIds = true;
	}
	
	var changeHistorys = [];
	if (isExistObjectIds) 
	{
		for (var i=0, objectCount = objectIds.length; i<objectCount; i++) 
		{
			var changeHistory = new ChangeHistory();
			changeHistory.setProjectId(projectId);
			changeHistory.setDataKey(dataKey);
			changeHistory.setObjectId(objectIds[i]);
			changeHistory.setProperty(property);
			changeHistory.setPropertyKey(propertyKey);
			changeHistory.setPropertyValue(propertyValue);
			changeHistory.setRgbColor(rgbColor);
			
			changeHistorys.push(changeHistory);
		}
	}
	else 
	{
		var changeHistory = new ChangeHistory();
		changeHistory.setProjectId(projectId);
		changeHistory.setDataKey(dataKey);
		changeHistory.setObjectId(null);
		changeHistory.setProperty(property);
		changeHistory.setPropertyKey(propertyKey);
		changeHistory.setPropertyValue(propertyValue);
		changeHistory.setRgbColor(rgbColor);
		
		changeHistorys.push(changeHistory);
	}

	var changeHistory;
	var historiesCount = changeHistorys.length;
	for (var i=0; i<historiesCount; i++)
	{
		changeHistory = changeHistorys[i];
		MagoConfig.saveColorHistory(projectId, dataKey, changeHistory.getObjectId(), changeHistory);
	}
};
'use strict';

/**
 * Draw 관련 API를 담당하는 클래스
 * 원래는 이렇게 만들려고 한게 아니지만, legacy 파일이랑 이름, function 등이 중복되서 이렇게 만들었음
 * @class DrawAPI
 */
var DrawAPI = {};

DrawAPI.drawAppendData = function(api, magoManager) 
{
	magoManager.getObjectIndexFile(api.getProjectId(), api.getProjectDataFolder());
};

DrawAPI.drawInsertIssueImage = function(api, magoManager) 
{
	// pin 을 표시
	if (magoManager.objMarkerSC === undefined || api.getDrawType() === 0) 
	{
		magoManager.objMarkerSC = new ObjectMarker();
		magoManager.objMarkerSC.geoLocationData.geographicCoord = new GeographicCoord();
		ManagerUtils.calculateGeoLocationData(parseFloat(api.getLongitude()), parseFloat(api.getLatitude()), parseFloat(api.getElevation()), 
			undefined, undefined, undefined, magoManager.objMarkerSC.geoLocationData, magoManager);
	}
	
	var objMarker = magoManager.objMarkerManager.newObjectMarker();
	
	magoManager.objMarkerSC.issue_id = api.getIssueId();
	magoManager.objMarkerSC.issue_type = api.getIssueType();
	magoManager.objMarkerSC.geoLocationData.geographicCoord.setLonLatAlt(parseFloat(api.getLongitude()), parseFloat(api.getLatitude()), parseFloat(api.getElevation()));
	
	objMarker.copyFrom(magoManager.objMarkerSC);
	magoManager.objMarkerSC = undefined;
};
'use strict';

/**
 * 변환 행렬 API
 * @class LocationAndRotationAPI
 */
var LocationAndRotationAPI = {};

LocationAndRotationAPI.changeLocationAndRotation = function(api, magoManager) 
{
//	var buildingId = api.getDataKey();
//	var buildingType = "structure";
//	var building = this.getNeoBuildingByTypeId(buildingType, buildingId);

	var changeHistory = new ChangeHistory();
	changeHistory.setProjectId(api.getProjectId());
	changeHistory.setDataKey(api.getDataKey());
	changeHistory.setLatitude(parseFloat(api.getLatitude()));
	changeHistory.setLongitude(parseFloat(api.getLongitude()));
	changeHistory.setElevation(parseFloat(api.getElevation()));
	changeHistory.setHeading(parseFloat(api.getHeading()));
	changeHistory.setPitch(parseFloat(api.getPitch()));
	changeHistory.setRoll(parseFloat(api.getRoll()));
	
	magoManager.changeLocationAndRotation(	api.getProjectId(),
		api.getDataKey(),
		parseFloat(api.getLatitude()),
		parseFloat(api.getLongitude()),
		parseFloat(api.getElevation()),
		parseFloat(api.getHeading()),
		parseFloat(api.getPitch()),
		parseFloat(api.getRoll()));
	
	// MagoConfig에 저장......?
};
'use strict';

/**
 * lod 처리 관련 도메인
 * @class LodAPI
 */
var LodAPI = {};

LodAPI.changeLod = function(api, magoManager) 
{
	if (api.getLod0DistInMeters() !== null && api.getLod0DistInMeters() !== "") { magoManager.magoPolicy.setLod0DistInMeters(api.getLod0DistInMeters()); }
	if (api.getLod1DistInMeters() !== null && api.getLod1DistInMeters() !== "") { magoManager.magoPolicy.setLod1DistInMeters(api.getLod1DistInMeters()); }
	if (api.getLod2DistInMeters() !== null && api.getLod2DistInMeters() !== "") { magoManager.magoPolicy.setLod2DistInMeters(api.getLod2DistInMeters()); }
	if (api.getLod3DistInMeters() !== null && api.getLod3DistInMeters() !== "") { magoManager.magoPolicy.setLod3DistInMeters(api.getLod3DistInMeters()); }
	if (api.getLod4DistInMeters() !== null && api.getLod4DistInMeters() !== "") { magoManager.magoPolicy.setLod4DistInMeters(api.getLod4DistInMeters()); }
	if (api.getLod5DistInMeters() !== null && api.getLod5DistInMeters() !== "") { magoManager.magoPolicy.setLod5DistInMeters(api.getLod5DistInMeters()); }
};
'use strict';

/**
 * mago3djs API
 * 
 * @alias API
 * @class API
 * 
 * @param {any} apiName api이름
 */
function API(apiName)
{
	if (!(this instanceof API)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// mago3d 활성화/비활성화 여부
	this.magoEnable = true;
	// return
	this.returnable = false;

	// api 이름
	this.apiName = apiName;
	
	// project id
	this.projectId = null;
	this.projectDataFolder = null;
	// objectIds
	this.objectIds = null;
	// data_key
	this.dataKey = null;
	// issueId
	this.issueId = null;
	// issueType
	this.issueType = null;
	// drawType 이미지를 그리는 유형 0 : DB, 1 : 이슈등록
	this.drawType = 0;

	// 위도
	this.latitude = 0;
	// 경도
	this.longitude = 0;
	// 높이
	this.elevation = 0;
	// heading
	this.heading = 0;
	// pitch
	this.pitch = 0;
	// roll
	this.roll = 0;
	// duration
	this.duration = 0;

	// 속성
	this.property = null;
	// 색깔
	this.color = 0;
	// structs = MSP, outfitting = MOP
	this.blockType = null;
	// outfitting 표시/비표시
	this.showOutFitting = false;
	// label 표시/비표시
	this.showLabelInfo = true;
	// origin 표시/비표시
	this.showOrigin = false;
	// boundingBox 표시/비표시
	this.showBoundingBox = false;
	// 그림자 표시/비표시
	this.showShadow = false;
	// frustum culling 가시 거리(M단위)
	this.frustumFarDistance = 0;
	// move mode 
	this.objectMoveMode = CODE.moveMode.NONE;
	// 이슈 등록 표시
	this.issueInsertEnable = false;
	// object 정보 표시
	this.objectInfoViewEnable = false;
	// 이슈 목록 표시
	this.nearGeoIssueListEnable = false;
	// occlusion culling
	this.occlusionCullingEnable = false;
	//
	this.insertIssueState = 0;
	
	// LOD1
	this.lod0DistInMeters = null;
	this.lod1DistInMeters = null;
	this.lod2DistInMeters = null;
	this.lod3DistInMeters = null;
	this.lod4DistInMeters = null;
	this.lod5DistInMeters = null;
	
	// Lighting
	this.ambientReflectionCoef = null;
	this.diffuseReflectionCoef = null;
	this.specularReflectionCoef = null;
	this.ambientColor = null;
	this.specularColor = null;
	
	this.ssaoRadius = null;
	//
	this.FPVMode = false;

	// input x, y, z
	this.inputPoint = null;
	// result x, y, z
	this.resultPoint = null;
};

API.prototype.getMagoEnable = function() 
{
	return this.magoEnable;
};
API.prototype.setMagoEnable = function(magoEnable) 
{
	this.magoEnable = magoEnable;
};

API.prototype.getReturnable = function()
{
	return this.returnable;
};
API.prototype.setReturnable = function(returnable)
{
	this.returnable = returnable;
};

API.prototype.getAPIName = function() 
{
	return this.apiName;
};

API.prototype.getProjectId = function() 
{
	return this.projectId;
};
API.prototype.setProjectId = function(projectId) 
{
	this.projectId = projectId;
};

API.prototype.getProjectDataFolder = function() 
{
	return this.projectDataFolder;
};
API.prototype.setProjectDataFolder = function(projectDataFolder) 
{
	this.projectDataFolder = projectDataFolder;
};

API.prototype.getObjectIds = function() 
{
	return this.objectIds;
};
API.prototype.setObjectIds = function(objectIds) 
{
	this.objectIds = objectIds;
};

API.prototype.getIssueId = function() 
{
	return this.issueId;
};
API.prototype.setIssueId = function(issueId) 
{
	this.issueId = issueId;
};
API.prototype.getIssueType = function() 
{
	return this.issueType;
};
API.prototype.setIssueType = function(issueType) 
{
	this.issueId = issueType;
};

API.prototype.getDataKey = function() 
{
	return this.dataKey;
};
API.prototype.setDataKey = function(dataKey) 
{
	this.dataKey = dataKey;
};

API.prototype.getLatitude = function() 
{
	return this.latitude;
};
API.prototype.setLatitude = function(latitude) 
{
	this.latitude = latitude;
};

API.prototype.getLongitude = function() 
{
	return this.longitude;
};
API.prototype.setLongitude = function(longitude) 
{
	this.longitude = longitude;
};

API.prototype.getElevation = function() 
{
	return this.elevation;
};
API.prototype.setElevation = function(elevation) 
{
	this.elevation = elevation;
};

API.prototype.getHeading = function() 
{
	return this.heading;
};
API.prototype.setHeading = function(heading) 
{
	this.heading = heading;
};

API.prototype.getPitch = function() 
{
	return this.pitch;
};
API.prototype.setPitch = function(pitch) 
{
	this.pitch = pitch;
};

API.prototype.getRoll = function() 
{
	return this.roll;
};
API.prototype.setRoll = function(roll) 
{
	this.roll = roll;
};

API.prototype.getProperty = function() 
{
	return this.property;
};
API.prototype.setProperty = function(property) 
{
	this.property = property;
};

API.prototype.getColor = function() 
{
	return this.color;
};
API.prototype.setColor = function(color) 
{
	this.color = color;
};

API.prototype.getBlockType = function() 
{
	return this.blockType;
};
API.prototype.setBlockType = function(blockType) 
{
	this.blockType = blockType;
};

API.prototype.getShowOutFitting = function() 
{
	return this.showOutFitting;
};
API.prototype.setShowOutFitting = function(showOutFitting) 
{
	this.showOutFitting = showOutFitting;
};


API.prototype.getShowLabelInfo = function() 
{
	return this.showLabelInfo;
};
API.prototype.setShowLabelInfo = function(showLabelInfo) 
{
	this.showLabelInfo = showLabelInfo;
};

API.prototype.getShowOrigin = function()
{
	return this.showOrigin;
};
API.prototype.setShowOrigin = function(showOrigin)
{
	this.showOrigin = showOrigin;
};

API.prototype.getShowBoundingBox = function() 
{
	return this.showBoundingBox;
};
API.prototype.setShowBoundingBox = function(showBoundingBox) 
{
	this.showBoundingBox = showBoundingBox;
};

API.prototype.getShowShadow = function() 
{
	return this.showShadow;
};
API.prototype.setShowShadow = function(showShadow) 
{
	this.showShadow = showShadow;
};

API.prototype.getFrustumFarDistance = function() 
{
	return this.frustumFarDistance;
};
API.prototype.setFrustumFarDistance = function(frustumFarDistance) 
{
	this.frustumFarDistance = frustumFarDistance;
};

API.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
API.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};

API.prototype.getIssueInsertEnable = function() 
{
	return this.issueInsertEnable;
};
API.prototype.setIssueInsertEnable = function(issueInsertEnable) 
{
	this.issueInsertEnable = issueInsertEnable;
};
API.prototype.getObjectInfoViewEnable = function() 
{
	return this.objectInfoViewEnable;
};
API.prototype.setObjectInfoViewEnable = function(objectInfoViewEnable) 
{
	this.objectInfoViewEnable = objectInfoViewEnable;
};
API.prototype.getOcclusionCullingEnable = function() 
{
	return this.occlusionCullingEnable;
};
API.prototype.setOcclusionCullingEnable = function(occlusionCullingEnable) 
{
	this.occlusionCullingEnable = occlusionCullingEnable;
};
API.prototype.getNearGeoIssueListEnable = function() 
{
	return this.nearGeoIssueListEnable;
};
API.prototype.setNearGeoIssueListEnable = function(nearGeoIssueListEnable) 
{
	this.nearGeoIssueListEnable = nearGeoIssueListEnable;
};

API.prototype.getInsertIssueState = function() 
{
	return this.insertIssueState;
};
API.prototype.setInsertIssueState = function(insertIssueState) 
{
	this.insertIssueState = insertIssueState;
};

API.prototype.getDrawType = function() 
{
	return this.drawType;
};
API.prototype.setDrawType = function(drawType) 
{
	this.drawType = drawType;
};

API.prototype.getLod0DistInMeters = function() 
{
	return this.lod0DistInMeters;
};
API.prototype.setLod0DistInMeters = function(lod0DistInMeters) 
{
	this.lod0DistInMeters = lod0DistInMeters;
};
API.prototype.getLod1DistInMeters = function() 
{
	return this.lod1DistInMeters;
};
API.prototype.setLod1DistInMeters = function(lod1DistInMeters) 
{
	this.lod1DistInMeters = lod1DistInMeters;
};
API.prototype.getLod2DistInMeters = function() 
{
	return this.lod2DistInMeters;
};
API.prototype.setLod2DistInMeters = function(lod2DistInMeters) 
{
	this.lod2DistInMeters = lod2DistInMeters;
};
API.prototype.getLod3DistInMeters = function() 
{
	return this.lod3DistInMeters;
};
API.prototype.setLod3DistInMeters = function(lod3DistInMeters) 
{
	this.lod3DistInMeters = lod3DistInMeters;
};
API.prototype.getLod4DistInMeters = function() 
{
	return this.lod4DistInMeters;
};
API.prototype.setLod4DistInMeters = function(lod4DistInMeters) 
{
	this.lod4DistInMeters = lod4DistInMeters;
};
API.prototype.getLod5DistInMeters = function() 
{
	return this.lod5DistInMeters;
};
API.prototype.setLod5DistInMeters = function(lod5DistInMeters) 
{
	this.lod5DistInMeters = lod5DistInMeters;
};

API.prototype.getAmbientReflectionCoef = function() 
{
	return this.ambientReflectionCoef;
};
API.prototype.setAmbientReflectionCoef = function(ambientReflectionCoef) 
{
	this.ambientReflectionCoef = ambientReflectionCoef;
};
API.prototype.getDiffuseReflectionCoef = function() 
{
	return this.diffuseReflectionCoef;
};
API.prototype.setDiffuseReflectionCoef = function(diffuseReflectionCoef) 
{
	this.diffuseReflectionCoef = diffuseReflectionCoef;
};
API.prototype.getSpecularReflectionCoef = function() 
{
	return this.specularReflectionCoef;
};
API.prototype.setSpecularReflectionCoef = function(specularReflectionCoef) 
{
	this.specularReflectionCoef = specularReflectionCoef;
};
API.prototype.getAmbientColor = function() 
{
	return this.ambientColor;
};
API.prototype.setAmbientColor = function(ambientColor) 
{
	this.ambientColor = ambientColor;
};
API.prototype.getSpecularColor = function() 
{
	return this.specularColor;
};
API.prototype.setSpecularColor = function(specularColor) 
{
	this.specularColor = specularColor;
};
API.prototype.getSsaoRadius = function() 
{
	return this.ssaoRadius;
};
API.prototype.setSsaoRadius = function(ssaoRadius) 
{
	this.ssaoRadius = ssaoRadius;
};
API.prototype.getFPVMode = function()
{
	return this.FPVMode;
};
API.prototype.setFPVMode = function(value)
{
	this.FPVMode = value;
};

API.prototype.getDuration = function()
{
	return this.duration;
};
API.prototype.setDuration = function(duration)
{
	this.duration = duration;
};

API.prototype.getInputPoint = function()
{
	return this.inputPoint;
};
API.prototype.setInputPoint = function(inputPoint)
{
	this.inputPoint = inputPoint;
};

API.prototype.getResultPoint = function()
{
	return this.resultPoint;
};
API.prototype.setResultPoint = function(resultPoint)
{
	this.resultPoint = resultPoint;
};
'use strict';

/**
 * api 처리 결과를 담당하는 callback function
 * @param functionName policy json의 geo_callback_apiresult 속성값
 * @param apiName 호출한 api 이름
 * @param result 결과값
 */
function apiResultCallback(functionName, apiName, result) 
{
	window[functionName](apiName, result);
}

/**
 * 선택한 object 정보를 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function selectedObjectCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * 이동한 data 정보를 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function movedDataCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * Data Key 를 이용하여 Geo Spatial Info를 획득하여 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param dataName
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function dataInfoCallback(functionName, projectId, dataKey, dataName, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, dataName, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * 선택한 object 정보를 화면에 표시
 * @param functionName
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 */
function insertIssueCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation);
}

/**
 * mouse click 위치 정보를 화면에 표시
 * @param functionName
 * @param position
 */
function clickPositionCallback(functionName, position) 
{
	window[functionName](position);
}

'use strict';

/**
 * 사용자가 변경한 moving, color, rotation 등 이력 정보를 위한 domain
 * @class Policy
 */
var ChangeHistory = function() 
{
	if (!(this instanceof ChangeHistory)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.moveHistory = false;
	this.colorHistory = false;
	this.rotationHistory = false;
	
	// move mode. ALL : 0 , OBJECT : 1, NONE : 2
	this.objectMoveMode = null;
	
	// project id
	this.projectId = null;
	// project data folder
	this.projectDataFolder = null;
	// data_key
	this.dataKey = null;	
	// objectId
	this.objectId = null;
	// objectIndexOrder
	this.objectIndexOrder = 0;
	
	// referenceObject aditional movement.
	this.refObjectAditionalMove;
	this.refObjectAditionalMoveRelToBuilding;
	
	// 위도
	this.latitude = 0.0;
	// 경도
	this.longitude = 0.0;
	// 높이
	this.elevation = 0.0;
	// heading
	this.heading = 0.0;
	// pitch
	this.pitch = 0.0;
	// roll
	this.roll = 0.0;
	// duration
	this.duration = 0;
	// 색깔
	this.color = 0;
	// color rgb
	this.rgbColor = [];
	// 속성
	this.property = null;
	this.propertyKey = null;
	this.propertyValue = null;
};

ChangeHistory.prototype.getReferenceObjectAditionalMovement = function() 
{
	if (this.refObjectAditionalMove === undefined)
	{ this.refObjectAditionalMove = new Point3D(); }
	
	return this.refObjectAditionalMove;
};

ChangeHistory.prototype.getReferenceObjectAditionalMovementRelToBuilding = function() 
{
	if (this.refObjectAditionalMoveRelToBuilding === undefined)
	{ this.refObjectAditionalMoveRelToBuilding = new Point3D(); }
	
	return this.refObjectAditionalMoveRelToBuilding;
};

ChangeHistory.prototype.getProjectId = function() 
{
	return this.projectId;
};
ChangeHistory.prototype.setProjectId = function(projectId) 
{
	this.projectId = projectId;
};

ChangeHistory.prototype.getProjectDataFolder = function() 
{
	return this.projectDataFolder;
};
ChangeHistory.prototype.setProjectDataFolder = function(projectDataFolder) 
{
	this.projectDataFolder = projectDataFolder;
};

ChangeHistory.prototype.getDataKey = function() 
{
	return this.dataKey;
};
ChangeHistory.prototype.setDataKey = function(dataKey) 
{
	this.dataKey = dataKey;
};

ChangeHistory.prototype.getObjectId = function() 
{
	return this.objectId;
};
ChangeHistory.prototype.setObjectId = function(objectId) 
{
	this.objectId = objectId;
};

ChangeHistory.prototype.getObjectIndexOrder = function() 
{
	return this.objectIndexOrder;
};
ChangeHistory.prototype.setObjectIndexOrder = function(objectIndexOrder) 
{
	this.objectIndexOrder = objectIndexOrder;
};

ChangeHistory.prototype.getLatitude = function() 
{
	return this.latitude;
};
ChangeHistory.prototype.setLatitude = function(latitude) 
{
	this.latitude = latitude;
};

ChangeHistory.prototype.getLongitude = function() 
{
	return this.longitude;
};
ChangeHistory.prototype.setLongitude = function(longitude) 
{
	this.longitude = longitude;
};

ChangeHistory.prototype.getElevation = function() 
{
	return this.elevation;
};
ChangeHistory.prototype.setElevation = function(elevation) 
{
	this.elevation = elevation;
};

ChangeHistory.prototype.getHeading = function() 
{
	return this.heading;
};
ChangeHistory.prototype.setHeading = function(heading) 
{
	this.heading = heading;
};

ChangeHistory.prototype.getPitch = function() 
{
	return this.pitch;
};
ChangeHistory.prototype.setPitch = function(pitch) 
{
	this.pitch = pitch;
};

ChangeHistory.prototype.getRoll = function() 
{
	return this.roll;
};
ChangeHistory.prototype.setRoll = function(roll) 
{
	this.roll = roll;
};

ChangeHistory.prototype.getColor = function() 
{
	return this.color;
};
ChangeHistory.prototype.setColor = function(color) 
{
	this.color = color;
};
ChangeHistory.prototype.getRgbColor = function() 
{
	return this.rgbColor;
};
ChangeHistory.prototype.setRgbColor = function(rgbColor) 
{
	this.rgbColor = rgbColor;
};

ChangeHistory.prototype.getProperty = function() 
{
	return this.property;
};
ChangeHistory.prototype.setProperty = function(property) 
{
	this.property = property;
};
ChangeHistory.prototype.getPropertyKey = function() 
{
	return this.propertyKey;
};
ChangeHistory.prototype.setPropertyKey = function(propertyKey) 
{
	this.propertyKey = propertyKey;
};
ChangeHistory.prototype.getPropertyValue = function() 
{
	return this.propertyValue;
};
ChangeHistory.prototype.setPropertyValue = function(propertyValue) 
{
	this.propertyValue = propertyValue;
};

ChangeHistory.prototype.getDuration = function()
{
	return this.duration;
};
ChangeHistory.prototype.setDuration = function(duration)
{
	this.duration = duration;
};

ChangeHistory.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
ChangeHistory.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};
"use strict";

var CODE = {};

// magoManager가 다 로딩 되지 않은 상태에서 화면으로 부터 호출 되는 것을 막기 위해
CODE.magoManagerState = {
	"INIT"   	: 0,
	"STARTED"	: 1,
	"READY"   : 2
};

//0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.***
CODE.fileLoadState = {
	"READY"            : 0,
	"LOADING_STARTED"  : 1,
	"LOADING_FINISHED" : 2,
	"PARSE_STARTED"    : 3,
	"PARSE_FINISHED"   : 4,
	"IN_QUEUE"         : 5
};

CODE.moveMode = {
	"ALL"    : "0",
	"OBJECT" : "1",
	"NONE"   : "2"
};

CODE.PROJECT_ID_PREFIX = "projectId_";
CODE.PROJECT_DATA_FOLDER_PREFIX = "projectDataFolder_";

'use strict';

/**
 * 상수 설정
 * @class Constant
 */
var Constant = {};

Constant.CESIUM = "cesium";
Constant.WORLDWIND = "worldwind";
Constant.MAGOWORLD = "magoworld";
Constant.OBJECT_INDEX_FILE = "/objectIndexFile.ihe";
Constant.CACHE_VERSION = "?cache_version=";
Constant.SIMPLE_BUILDING_TEXTURE3x3_BMP = "/SimpleBuildingTexture3x3.bmp";
Constant.RESULT_XDO2F4D = "/Result_xdo2f4d/Images/";
Constant.RESULT_XDO2F4D_TERRAINTILES = "/Result_xdo2f4d/F4D_TerrainTiles/";
Constant.RESULT_XDO2F4D_TERRAINTILEFILE_TXT = "/Result_xdo2f4d/f4dTerranTileFile.txt";

Constant.INTERSECTION_OUTSIDE = 0;
Constant.INTERSECTION_INTERSECT= 1;
Constant.INTERSECTION_INSIDE = 2;
Constant.INTERSECTION_POINT_A = 3;
Constant.INTERSECTION_POINT_B = 4;

'use strict';

/**
 * mago3D 전체 환경 설정을 관리
 * @class MagoConfig
 */
var MagoConfig = {};

MagoConfig.getPolicy = function() 
{
	return this.serverPolicy;
};

MagoConfig.getData = function(key) 
{
	return this.dataObject[key];
};

MagoConfig.isDataExist = function(key) 
{
	return this.dataObject.hasOwnProperty(key);
};

MagoConfig.deleteData = function(key) 
{
	return delete this.dataObject[key];
};

/**
 * data 를 map에 저장
 * @param key map에 저장될 key
 * @param value map에 저장될 value
 */
MagoConfig.setData = function(key, value) 
{
	if (!this.isDataExist(key)) 
	{
		this.dataObject[key] = value;
	}
};

/**
 * F4D Converter 실행 결과물이 저장된 project data folder 명을 획득
 * @param projectDataFolder data folder
 */
MagoConfig.getProjectDataFolder = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return this.dataObject[key];
};

/**
 * project map에 data folder명의 존재 유무를 검사
 * @param projectDataFolder
 */
MagoConfig.isProjectDataFolderExist = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return this.dataObject.hasOwnProperty(key);
};

/**
 * project data folder명을 map에서 삭제
 * @param projectDataFolder
 */
MagoConfig.deleteProjectDataFolder = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return delete this.dataObject[key];
};

/**
 * project data folder명을 Object에서 삭제
 * @param projectDataFolder Object에 저장될 key
 * @param value Object에 저장될 value
 */
MagoConfig.setProjectDataFolder = function(projectDataFolder, value) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	if (!this.isProjectDataFolderExist(key))
	{
		this.dataObject[key] = value;
	}
};

/**
 * 환경설정 초기화
 * @param serverPolicy mago3d policy(json)
 * @param projectIdArray data 정보를 map 저장할 key name
 * @param projectDataArray data 정보(json)
 */
MagoConfig.init = function(serverPolicy, projectIdArray, projectDataArray) 
{
	this.dataObject = {};
	
	this.selectHistoryObject = {};
	this.movingHistoryObject = {};
	this.colorHistoryObject = {};
	this.locationAndRotationHistoryObject = {};
	
	this.serverPolicy = serverPolicy;
	if (projectIdArray !== null && projectIdArray.length > 0) 
	{
		for (var i=0; i<projectIdArray.length; i++) 
		{
			if (!this.isDataExist(CODE.PROJECT_ID_PREFIX + projectIdArray[i])) 
			{
				this.setData(CODE.PROJECT_ID_PREFIX + projectIdArray[i], projectDataArray[i]);
				this.setProjectDataFolder(CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataArray[i].data_key, projectDataArray[i].data_key);
			}
		}
	}
};

/**
 * 모든 데이터를 삭제함
 */
MagoConfig.clearAllData = function() 
{
	this.dataObject = {};
};

/**
 * 모든 선택 히스토리 삭제
 */
MagoConfig.clearSelectHistory = function() 
{
	this.selectHistoryObject = {};
};

/**
 * 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getAllSelectHistory = function()
{
	return this.selectHistoryObject;
};

/**
 * project 별 해당 키에 해당하는 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getSelectHistoryObjects = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * object 선택 내용 이력을 취득
 */
MagoConfig.getSelectHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return dataKeyObject[objectIndexOrder];
};

/**
 * object 선택 내용을 저장
 */
MagoConfig.saveSelectHistory = function(projectId, dataKey, objectIndexOrder, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject.get(projectId);
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.selectHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}
	
	// objectIndexOrder 를 저장
	dataKeyObject[objectIndexOrder] = changeHistory;
};

/**
 * object 선택 내용을 삭제
 */
MagoConfig.deleteSelectHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectIndexOrder];
};

/**
 * 모든 이동 히스토리 삭제
 */
MagoConfig.clearMovingHistory = function() 
{
	this.movingHistoryObject = {};
};

/**
 * 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getAllMovingHistory = function()
{
	return this.movingHistoryObject;
};

/**
 * project별 입력키 값과 일치하는 object 이동 내용 이력을 취득
 */
MagoConfig.getMovingHistoryObjects = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * object 이동 내용 이력을 취득
 */
MagoConfig.getMovingHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return dataKeyObject[objectIndexOrder];
};

/**
 * object 이동 내용을 저장
 */
MagoConfig.saveMovingHistory = function(projectId, dataKey, objectIndexOrder, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.movingHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}
	
	// objectIndexOrder 를 저장
	dataKeyObject[objectIndexOrder] = changeHistory;
};

/**
 * object 이동 내용을 삭제
 */
MagoConfig.deleteMovingHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectIndexOrder];
};

/**
 * 모든 색깔 변경 이력을 획득
 */
MagoConfig.getAllColorHistory = function() 
{
	return this.colorHistoryObject;
};

/**
 * 모든 색깔변경 히스토리 삭제
 */
MagoConfig.clearColorHistory = function() 
{
	this.colorHistoryObject = {};
};

/**
 * project별 키에 해당하는 모든 색깔 변경 이력을 획득
 */
MagoConfig.getColorHistorys = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * 색깝 변경 이력을 획득
 */
MagoConfig.getColorHistory = function(projectId, dataKey, objectId)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectId 를 저장
	return dataKeyObject[objectId];
};

/**
 * 색깝 변경 내용을 저장
 */
MagoConfig.saveColorHistory = function(projectId, dataKey, objectId, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.colorHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}

	if (objectId === null || objectId === "") 
	{
		dataKeyObject[dataKey] = changeHistory;
	}
	else 
	{
		dataKeyObject[objectId] = changeHistory;
	}
};

/**
 * 색깔 변경 이력을 삭제
 */
MagoConfig.deleteColorHistory = function(projectId, dataKey, objectId)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectId];
};

/**
 * 모든 색깔변경 히스토리 삭제
 */
MagoConfig.clearColorHistory = function() 
{
	this.colorHistoryObject = {};
};

/**
 * 모든 location and rotation 변경 이력을 획득
 */
MagoConfig.getAllLocationAndRotationHistory = function() 
{
	return this.locationAndRotationHistoryObject;
};

/**
 * 프로젝트별 해당 키 값을 갖는 모든 location and rotation 이력을 획득
 */
MagoConfig.getLocationAndRotationHistorys = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * location and rotation 이력을 획득
 */
MagoConfig.getLocationAndRotationHistory = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	
	return dataKeyObject;
};

/**
 * location and rotation 내용을 저장
 */
MagoConfig.saveLocationAndRotationHistory = function(projectId, dataKey, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.locationAndRotationHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
	}

	dataKeyObject[dataKey] = changeHistory;
};

/**
 * location and rotation 이력을 삭제
 */
MagoConfig.deleteLocationAndRotationHistory = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = delete projectIdObject[dataKey];
};

/**
 * 모든 location and rotation 히스토리 삭제
 */
MagoConfig.clearLocationAndRotationHistory = function() 
{
	this.locationAndRotationHistoryObject = {};
};
	
/**
 * TODO 이건 나중에 활요. 사용하지 않음
 * check 되지 않은 데이터들을 삭제함
 * @param keyObject 비교할 맵
 */
/*MagoConfig.clearUnSelectedData = function(keyObject)
{
	for (var key of this.dataObject.keys())
	{
		if (!keyObject.hasxxxxx(key))
		{
			// data folder path가 존재하면....
			if (key.indexOf(CODE.PROJECT_DATA_FOLDER_PREFIX) >= 0) 
			{
				// 지우는 처리가 있어야 함
			}
			this.dataObject.delete(key);
		}
	}
};*/

'use strict';

/**
 * Policy
 * @class Policy
 */
var Policy = function() 
{
	if (!(this instanceof Policy)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// mago3d 활성화/비활성화 여부
	this.magoEnable = true;

	// outfitting 표시 여부
	this.showOutFitting = false;
	// label 표시/비표시
	this.showLabelInfo = false;
	// boundingBox 표시/비표시
	this.showBoundingBox = false;
	// 그림자 표시/비표시
	this.showShadow = false;
	// squared far frustum 거리
	this.frustumFarSquaredDistance = 5000000;
	// far frustum
	this.frustumFarDistance = 20000;

	// highlighting
	this.highLightedBuildings = [];
	// color
	this.colorBuildings = [];
	// color
	this.color = [];
	// show/hide
	this.hideBuildings = [];
	// move mode
	this.objectMoveMode = CODE.moveMode.NONE;
	// 이슈 등록 표시
	this.issueInsertEnable = false;
	// object 정보 표시
	this.objectInfoViewEnable = false;
	// 이슈 목록 표시
	this.nearGeoIssueListEnable = false;
	// occlusion culling
	this.occlusionCullingEnable = false;
	// origin axis XYZ
	this.showOrigin = false;
	
	// 이미지 경로
	this.imagePath = "";
	
	// provisional.***
	this.colorChangedObjectId;
	
	// LOD1
	this.lod0DistInMeters = 15;
	this.lod1DistInMeters = 50;
	this.lod2DistInMeters = 90;
	this.lod3DistInMeters = 200;
	this.lod4DistInMeters = 1000;
	this.lod5DistInMeters = 50000;
	
	// Lighting
	this.ambientReflectionCoef = 0.45; // 0.2.
	this.diffuseReflectionCoef = 0.75; // 1.0
	this.specularReflectionCoef = 0.6; // 0.7
	this.ambientColor = null;
	this.specularColor = new Float32Array([0.6, 0.6, 0.6]);
	
	this.ssaoRadius = 0.15;
};
Policy.prototype.getShowOrigin = function() 
{
	return this.showOrigin;
};
Policy.prototype.setShowOrigin = function(showOrigin) 
{
	this.showOrigin = showOrigin;
};

Policy.prototype.getMagoEnable = function() 
{
	return this.magoEnable;
};
Policy.prototype.setMagoEnable = function(magoEnable) 
{
	this.magoEnable = magoEnable;
};

Policy.prototype.getShowOutFitting = function() 
{
	return this.showOutFitting;
};
Policy.prototype.setShowOutFitting = function(showOutFitting) 
{
	this.showOutFitting = showOutFitting;
};
Policy.prototype.getShowLabelInfo = function() 
{
	return this.showLabelInfo;
};
Policy.prototype.setShowLabelInfo = function(showLabelInfo) 
{
	this.showLabelInfo = showLabelInfo;
};
Policy.prototype.getShowBoundingBox = function() 
{
	return this.showBoundingBox;
};
Policy.prototype.setShowBoundingBox = function(showBoundingBox) 
{
	this.showBoundingBox = showBoundingBox;
};

Policy.prototype.getShowShadow = function() 
{
	return this.showShadow;
};
Policy.prototype.setShowShadow = function(showShadow) 
{
	this.showShadow = showShadow;
};

Policy.prototype.getFrustumFarSquaredDistance = function() 
{
	return this.frustumFarSquaredDistance;
};
Policy.prototype.setFrustumFarSquaredDistance = function(frustumFarSquaredDistance) 
{
	this.frustumFarSquaredDistance = frustumFarSquaredDistance;
};

Policy.prototype.getFrustumFarDistance = function() 
{
	return this.frustumFarDistance;
};
Policy.prototype.setFrustumFarDistance = function(frustumFarDistance) 
{
	this.frustumFarDistance = frustumFarDistance;
};

Policy.prototype.getHighLightedBuildings = function() 
{
	return this.highLightedBuildings;
};
Policy.prototype.setHighLightedBuildings = function(highLightedBuildings) 
{
	this.highLightedBuildings = highLightedBuildings;
};

Policy.prototype.getColorBuildings = function() 
{
	return this.colorBuildings;
};
Policy.prototype.setColorBuildings = function(colorBuildings) 
{
	this.colorBuildings = colorBuildings;
};

Policy.prototype.getColor = function() 
{
	return this.color;
};
Policy.prototype.setColor = function(color) 
{
	this.color = color;
};

Policy.prototype.getHideBuildings = function() 
{
	return this.hideBuildings;
};
Policy.prototype.setHideBuildings = function(hideBuildings) 
{
	this.hideBuildings = hideBuildings;
};

Policy.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
Policy.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};

Policy.prototype.getIssueInsertEnable = function() 
{
	return this.issueInsertEnable;
};
Policy.prototype.setIssueInsertEnable = function(issueInsertEnable) 
{
	this.issueInsertEnable = issueInsertEnable;
};
Policy.prototype.getObjectInfoViewEnable = function() 
{
	return this.objectInfoViewEnable;
};
Policy.prototype.setObjectInfoViewEnable = function(objectInfoViewEnable) 
{
	this.objectInfoViewEnable = objectInfoViewEnable;
};
Policy.prototype.getOcclusionCullingEnable = function() 
{
	return this.occlusionCullingEnable;
};
Policy.prototype.setOcclusionCullingEnable = function(occlusionCullingEnable) 
{
	this.occlusionCullingEnable = occlusionCullingEnable;
};
Policy.prototype.getNearGeoIssueListEnable = function() 
{
	return this.nearGeoIssueListEnable;
};
Policy.prototype.setNearGeoIssueListEnable = function(nearGeoIssueListEnable) 
{
	this.nearGeoIssueListEnable = nearGeoIssueListEnable;
};

Policy.prototype.getImagePath = function() 
{
	return this.imagePath;
};
Policy.prototype.setImagePath = function(imagePath) 
{
	this.imagePath = imagePath;
};

Policy.prototype.getLod0DistInMeters = function() 
{
	return this.lod0DistInMeters;
};
Policy.prototype.setLod0DistInMeters = function(lod0DistInMeters) 
{
	this.lod0DistInMeters = lod0DistInMeters;
};
Policy.prototype.getLod1DistInMeters = function() 
{
	return this.lod1DistInMeters;
};
Policy.prototype.setLod1DistInMeters = function(lod1DistInMeters) 
{
	this.lod1DistInMeters = lod1DistInMeters;
};
Policy.prototype.getLod2DistInMeters = function() 
{
	return this.lod2DistInMeters;
};
Policy.prototype.setLod2DistInMeters = function(lod2DistInMeters) 
{
	this.lod2DistInMeters = lod2DistInMeters;
};
Policy.prototype.getLod3DistInMeters = function() 
{
	return this.lod3DistInMeters;
};
Policy.prototype.setLod3DistInMeters = function(lod3DistInMeters) 
{
	this.lod3DistInMeters = lod3DistInMeters;
};
Policy.prototype.getLod4DistInMeters = function() 
{
	return this.lod4DistInMeters;
};
Policy.prototype.setLod4DistInMeters = function(lod4DistInMeters) 
{
	this.lod4DistInMeters = lod4DistInMeters;
};
Policy.prototype.getLod5DistInMeters = function() 
{
	return this.lod5DistInMeters;
};
Policy.prototype.setLod5DistInMeters = function(lod5DistInMeters) 
{
	this.lod5DistInMeters = lod5DistInMeters;
};
Policy.prototype.getAmbientReflectionCoef = function() 
{
	return this.ambientReflectionCoef;
};
Policy.prototype.setAmbientReflectionCoef = function(ambientReflectionCoef) 
{
	this.ambientReflectionCoef = ambientReflectionCoef;
};
Policy.prototype.getDiffuseReflectionCoef = function() 
{
	return this.diffuseReflectionCoef;
};
Policy.prototype.setDiffuseReflectionCoef = function(diffuseReflectionCoef) 
{
	this.diffuseReflectionCoef = diffuseReflectionCoef;
};
Policy.prototype.getSpecularReflectionCoef = function() 
{
	return this.specularReflectionCoef;
};
Policy.prototype.setSpecularReflectionCoef = function(specularReflectionCoef) 
{
	this.specularReflectionCoef = specularReflectionCoef;
};
Policy.prototype.getAmbientColor = function() 
{
	return this.ambientColor;
};
Policy.prototype.setAmbientColor = function(ambientColor) 
{
	this.ambientColor = ambientColor;
};
Policy.prototype.getSpecularColor = function() 
{
	return this.specularColor;
};
Policy.prototype.setSpecularColor = function(specularColor) 
{
	this.specularColor = specularColor;
};
Policy.prototype.getSsaoRadius = function() 
{
	return this.ssaoRadius;
};
Policy.prototype.setSsaoRadius = function(ssaoRadius) 
{
	this.ssaoRadius = ssaoRadius;
};
/**
  DataStream reads scalars, arrays and structs of data from an ArrayBuffer.
  It's like a file-like DataView on steroids.

  @param {ArrayBuffer} arrayBuffer ArrayBuffer to read from.
  @param {?Number} byteOffset Offset from arrayBuffer beginning for the DataStream.
  @param {?Boolean} endianness DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN (the default).
  */
var DataStream = function(arrayBuffer, byteOffset, endianness) {
  this._byteOffset = byteOffset || 0;
  if (arrayBuffer instanceof ArrayBuffer) {
    this.buffer = arrayBuffer;
  } else if (typeof arrayBuffer == "object") {
    this.dataView = arrayBuffer;
    if (byteOffset) {
      this._byteOffset += byteOffset;
    }
  } else {
    this.buffer = new ArrayBuffer(arrayBuffer || 1);
  }
  this.position = 0;
  this.endianness = endianness == null ? DataStream.LITTLE_ENDIAN : endianness;
};
DataStream.prototype = {};

/* Fix for Opera 12 not defining BYTES_PER_ELEMENT in typed array prototypes. */
if (Uint8Array.prototype.BYTES_PER_ELEMENT === undefined) {
    Uint8Array.prototype.BYTES_PER_ELEMENT = Uint8Array.BYTES_PER_ELEMENT; 
    Int8Array.prototype.BYTES_PER_ELEMENT = Int8Array.BYTES_PER_ELEMENT; 
    Uint8ClampedArray.prototype.BYTES_PER_ELEMENT = Uint8ClampedArray.BYTES_PER_ELEMENT; 
    Uint16Array.prototype.BYTES_PER_ELEMENT = Uint16Array.BYTES_PER_ELEMENT; 
    Int16Array.prototype.BYTES_PER_ELEMENT = Int16Array.BYTES_PER_ELEMENT; 
    Uint32Array.prototype.BYTES_PER_ELEMENT = Uint32Array.BYTES_PER_ELEMENT; 
    Int32Array.prototype.BYTES_PER_ELEMENT = Int32Array.BYTES_PER_ELEMENT; 
    Float64Array.prototype.BYTES_PER_ELEMENT = Float64Array.BYTES_PER_ELEMENT; 
}

/**
  Saves the DataStream contents to the given filename.
  Uses Chrome's anchor download property to initiate download.

  @param {string} filename Filename to save as.
  @return {null}
  */
DataStream.prototype.save = function(filename) {
  var blob = new Blob(this.buffer);
  var URL = (window.webkitURL || window.URL);
  if (URL && URL.createObjectURL) {
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.setAttribute('href', url);
      a.setAttribute('download', filename);
      a.click();
      URL.revokeObjectURL(url);
  } else {
      throw("DataStream.save: Can't create object URL.");
  }
};

/**
  Big-endian const to use as default endianness.
  @type {boolean}
  */
DataStream.BIG_ENDIAN = false;

/**
  Little-endian const to use as default endianness.
  @type {boolean}
  */
DataStream.LITTLE_ENDIAN = true;

/**
  Whether to extend DataStream buffer when trying to write beyond its size.
  If set, the buffer is reallocated to twice its current size until the
  requested write fits the buffer.
  @type {boolean}
  */
DataStream.prototype._dynamicSize = true;
Object.defineProperty(DataStream.prototype, 'dynamicSize',
  { get: function() {
      return this._dynamicSize;
    },
    set: function(v) {
      if (!v) {
        this._trimAlloc();
      }
      this._dynamicSize = v;
    } });

/**
  Virtual byte length of the DataStream backing buffer.
  Updated to be max of original buffer size and last written size.
  If dynamicSize is false is set to buffer size.
  @type {number}
  */
DataStream.prototype._byteLength = 0;

/**
  Returns the byte length of the DataStream object.
  @type {number}
  */
Object.defineProperty(DataStream.prototype, 'byteLength',
  { get: function() {
    return this._byteLength - this._byteOffset;
  }});

/**
  Set/get the backing ArrayBuffer of the DataStream object.
  The setter updates the DataView to point to the new buffer.
  @type {Object}
  */
Object.defineProperty(DataStream.prototype, 'buffer',
  { get: function() {
      this._trimAlloc();
      return this._buffer;
    },
    set: function(v) {
      this._buffer = v;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._buffer.byteLength;
    } });

/**
  Set/get the byteOffset of the DataStream object.
  The setter updates the DataView to point to the new byteOffset.
  @type {number}
  */
Object.defineProperty(DataStream.prototype, 'byteOffset',
  { get: function() {
      return this._byteOffset;
    },
    set: function(v) {
      this._byteOffset = v;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._buffer.byteLength;
    } });

/**
  Set/get the backing DataView of the DataStream object.
  The setter updates the buffer and byteOffset to point to the DataView values.
  @type {Object}
  */
Object.defineProperty(DataStream.prototype, 'dataView',
  { get: function() {
      return this._dataView;
    },
    set: function(v) {
      this._byteOffset = v.byteOffset;
      this._buffer = v.buffer;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._byteOffset + v.byteLength;
    } });

/**
  Internal function to resize the DataStream buffer when required.
  @param {number} extra Number of bytes to add to the buffer allocation.
  @return {null}
  */
DataStream.prototype._realloc = function(extra) {
  if (!this._dynamicSize) {
    return;
  }
  var req = this._byteOffset + this.position + extra;
  var blen = this._buffer.byteLength;
  if (req <= blen) {
    if (req > this._byteLength) {
      this._byteLength = req;
    }
    return;
  }
  if (blen < 1) {
    blen = 1;
  }
  while (req > blen) {
    blen *= 2;
  }
  var buf = new ArrayBuffer(blen);
  var src = new Uint8Array(this._buffer);
  var dst = new Uint8Array(buf, 0, src.length);
  dst.set(src);
  this.buffer = buf;
  this._byteLength = req;
};

/**
  Internal function to trim the DataStream buffer when required.
  Used for stripping out the extra bytes from the backing buffer when
  the virtual byteLength is smaller than the buffer byteLength (happens after
  growing the buffer with writes and not filling the extra space completely).

  @return {null}
  */
DataStream.prototype._trimAlloc = function() {
  if (this._byteLength == this._buffer.byteLength) {
    return;
  }
  var buf = new ArrayBuffer(this._byteLength);
  var dst = new Uint8Array(buf);
  var src = new Uint8Array(this._buffer, 0, dst.length);
  dst.set(src);
  this.buffer = buf;
};

/**
  Sets the DataStream read/write position to given position.
  Clamps between 0 and DataStream length.

  @param {number} pos Position to seek to.
  @return {null}
  */
DataStream.prototype.seek = function(pos) {
  var npos = Math.max(0, Math.min(this.byteLength, pos));
  this.position = (isNaN(npos) || !isFinite(npos)) ? 0 : npos;
};

/**
  Returns true if the DataStream seek pointer is at the end of buffer and
  there's no more data to read.

  @return {boolean} True if the seek pointer is at the end of the buffer.
  */
DataStream.prototype.isEof = function() {
  return (this.position >= this.byteLength);
};

/**
  Maps an Int32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Int32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Maps an Int16Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int16Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt16Array = function(length, e) {
  this._realloc(length * 2);
  var arr = new Int16Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 2;
  return arr;
};

/**
  Maps an Int8Array into the DataStream buffer.

  Nice for quickly reading in data.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int8Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt8Array = function(length) {
  this._realloc(length * 1);
  var arr = new Int8Array(this._buffer, this.byteOffset+this.position, length);
  this.position += length * 1;
  return arr;
};

/**
  Maps a Uint32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Uint32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Maps a Uint16Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint16Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint16Array = function(length, e) {
  this._realloc(length * 2);
  var arr = new Uint16Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 2;
  return arr;
};

/**
  Maps a Uint8Array into the DataStream buffer.

  Nice for quickly reading in data.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint8Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint8Array = function(length) {
  this._realloc(length * 1);
  var arr = new Uint8Array(this._buffer, this.byteOffset+this.position, length);
  this.position += length * 1;
  return arr;
};

/**
  Maps a Float64Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Float64Array to the DataStream backing buffer.
  */
DataStream.prototype.mapFloat64Array = function(length, e) {
  this._realloc(length * 8);
  var arr = new Float64Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 8;
  return arr;
};

/**
  Maps a Float32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Float32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapFloat32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Float32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Reads an Int32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int32Array.
 */
DataStream.prototype.readInt32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Int32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads an Int16Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int16Array.
 */
DataStream.prototype.readInt16Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 2) : length;
  var arr = new Int16Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads an Int8Array of desired length from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int8Array.
 */
DataStream.prototype.readInt8Array = function(length) {
  length = length == null ? (this.byteLength-this.position) : length;
  var arr = new Int8Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint32Array.
 */
DataStream.prototype.readUint32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Uint32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint16Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint16Array.
 */
DataStream.prototype.readUint16Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 2) : length;
  var arr = new Uint16Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint8Array of desired length from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint8Array.
 */
DataStream.prototype.readUint8Array = function(length) {
  length = length == null ? (this.byteLength-this.position) : length;
  var arr = new Uint8Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Float64Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Float64Array.
 */
DataStream.prototype.readFloat64Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 8) : length;
  var arr = new Float64Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Float32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Float32Array.
 */
DataStream.prototype.readFloat32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Float32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Writes an Int32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeInt32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Int32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt32(arr[i], e);
    }
  }
};

/**
  Writes an Int16Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeInt16Array = function(arr, e) {
  this._realloc(arr.length * 2);
  if (arr instanceof Int16Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt16Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt16(arr[i], e);
    }
  }
};

/**
  Writes an Int8Array to the DataStream.

  @param {Object} arr The array to write.
 */
DataStream.prototype.writeInt8Array = function(arr) {
  this._realloc(arr.length * 1);
  if (arr instanceof Int8Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt8Array(arr.length);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt8(arr[i]);
    }
  }
};

/**
  Writes a Uint32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeUint32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Uint32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint32(arr[i], e);
    }
  }
};

/**
  Writes a Uint16Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeUint16Array = function(arr, e) {
  this._realloc(arr.length * 2);
  if (arr instanceof Uint16Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint16Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint16(arr[i], e);
    }
  }
};

/**
  Writes a Uint8Array to the DataStream.

  @param {Object} arr The array to write.
 */
DataStream.prototype.writeUint8Array = function(arr) {
  this._realloc(arr.length * 1);
  if (arr instanceof Uint8Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint8Array(arr.length);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint8(arr[i]);
    }
  }
};

/**
  Writes a Float64Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeFloat64Array = function(arr, e) {
  this._realloc(arr.length * 8);
  if (arr instanceof Float64Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapFloat64Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeFloat64(arr[i], e);
    }
  }
};

/**
  Writes a Float32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeFloat32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Float32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapFloat32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeFloat32(arr[i], e);
    }
  }
};


/**
  Reads a 32-bit int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readInt32 = function(e) {
  var v = this._dataView.getInt32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 16-bit int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readInt16 = function(e) {
  var v = this._dataView.getInt16(this.position, e == null ? this.endianness : e);
  this.position += 2;
  return v;
};

/**
  Reads an 8-bit int from the DataStream.

  @return {number} The read number.
 */
DataStream.prototype.readInt8 = function() {
  var v = this._dataView.getInt8(this.position);
  this.position += 1;
  return v;
};

/**
  Reads a 32-bit unsigned int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readUint32 = function(e) {
  var v = this._dataView.getUint32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 16-bit unsigned int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readUint16 = function(e) {
  var v = this._dataView.getUint16(this.position, e == null ? this.endianness : e);
  this.position += 2;
  return v;
};

/**
  Reads an 8-bit unsigned int from the DataStream.

  @return {number} The read number.
 */
DataStream.prototype.readUint8 = function() {
  var v = this._dataView.getUint8(this.position);
  this.position += 1;
  return v;
};

/**
  Reads a 32-bit float from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readFloat32 = function(e) {
  var v = this._dataView.getFloat32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 64-bit float from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readFloat64 = function(e) {
  var v = this._dataView.getFloat64(this.position, e == null ? this.endianness : e);
  this.position += 8;
  return v;
};


/**
  Writes a 32-bit int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeInt32 = function(v, e) {
  this._realloc(4);
  this._dataView.setInt32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 16-bit int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeInt16 = function(v, e) {
  this._realloc(2);
  this._dataView.setInt16(this.position, v, e == null ? this.endianness : e);
  this.position += 2;
};

/**
  Writes an 8-bit int to the DataStream.

  @param {number} v Number to write.
 */
DataStream.prototype.writeInt8 = function(v) {
  this._realloc(1);
  this._dataView.setInt8(this.position, v);
  this.position += 1;
};

/**
  Writes a 32-bit unsigned int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeUint32 = function(v, e) {
  this._realloc(4);
  this._dataView.setUint32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 16-bit unsigned int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeUint16 = function(v, e) {
  this._realloc(2);
  this._dataView.setUint16(this.position, v, e == null ? this.endianness : e);
  this.position += 2;
};

/**
  Writes an 8-bit unsigned  int to the DataStream.

  @param {number} v Number to write.
 */
DataStream.prototype.writeUint8 = function(v) {
  this._realloc(1);
  this._dataView.setUint8(this.position, v);
  this.position += 1;
};

/**
  Writes a 32-bit float to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeFloat32 = function(v, e) {
  this._realloc(4);
  this._dataView.setFloat32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 64-bit float to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeFloat64 = function(v, e) {
  this._realloc(8);
  this._dataView.setFloat64(this.position, v, e == null ? this.endianness : e);
  this.position += 8;
};

/**
  Native endianness. Either DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN
  depending on the platform endianness.

  @type {boolean}
 */
DataStream.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0;

/**
  Copies byteLength bytes from the src buffer at srcOffset to the
  dst buffer at dstOffset.

  @param {Object} dst Destination ArrayBuffer to write to.
  @param {number} dstOffset Offset to the destination ArrayBuffer.
  @param {Object} src Source ArrayBuffer to read from.
  @param {number} srcOffset Offset to the source ArrayBuffer.
  @param {number} byteLength Number of bytes to copy.
 */
DataStream.memcpy = function(dst, dstOffset, src, srcOffset, byteLength) {
  var dstU8 = new Uint8Array(dst, dstOffset, byteLength);
  var srcU8 = new Uint8Array(src, srcOffset, byteLength);
  dstU8.set(srcU8);
};

/**
  Converts array to native endianness in-place.

  @param {Object} array Typed array to convert.
  @param {boolean} arrayIsLittleEndian True if the data in the array is
                                       little-endian. Set false for big-endian.
  @return {Object} The converted typed array.
 */
DataStream.arrayToNative = function(array, arrayIsLittleEndian) {
  if (arrayIsLittleEndian == this.endianness) {
    return array;
  } else {
    return this.flipArrayEndianness(array);
  }
};

/**
  Converts native endianness array to desired endianness in-place.

  @param {Object} array Typed array to convert.
  @param {boolean} littleEndian True if the converted array should be
                                little-endian. Set false for big-endian.
  @return {Object} The converted typed array.
 */
DataStream.nativeToEndian = function(array, littleEndian) {
  if (this.endianness == littleEndian) {
    return array;
  } else {
    return this.flipArrayEndianness(array);
  }
};

/**
  Flips typed array endianness in-place.

  @param {Object} array Typed array to flip.
  @return {Object} The converted typed array.
 */
DataStream.flipArrayEndianness = function(array) {
  var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
  for (var i=0; i<array.byteLength; i+=array.BYTES_PER_ELEMENT) {
    for (var j=i+array.BYTES_PER_ELEMENT-1, k=i; j>k; j--, k++) {
      var tmp = u8[k];
      u8[k] = u8[j];
      u8[j] = tmp;
    }
  }
  return array;
};

/**
  Creates an array from an array of character codes.
  Uses String.fromCharCode in chunks for memory efficiency and then concatenates
  the resulting string chunks.

  @param {array} array Array of character codes.
  @return {string} String created from the character codes.
**/
DataStream.createStringFromArray = function(array) {
  var chunk_size = 0x8000;
  var chunks = [];
  for (var i=0; i < array.length; i += chunk_size) {
    chunks.push(String.fromCharCode.apply(null, array.subarray(i, i + chunk_size)));
  }
  return chunks.join("");
};

/**
  Seek position where DataStream#readStruct ran into a problem.
  Useful for debugging struct parsing.

  @type {number}
 */
DataStream.prototype.failurePosition = 0;

/**
  Reads a struct of data from the DataStream. The struct is defined as
  a flat array of [name, type]-pairs. See the example below:

  ds.readStruct([
    'headerTag', 'uint32', // Uint32 in DataStream endianness.
    'headerTag2', 'uint32be', // Big-endian Uint32.
    'headerTag3', 'uint32le', // Little-endian Uint32.
    'array', ['[]', 'uint32', 16], // Uint32Array of length 16.
    'array2Length', 'uint32',
    'array2', ['[]', 'uint32', 'array2Length'] // Uint32Array of length array2Length
  ]);

  The possible values for the type are as follows:

  // Number types

  // Unsuffixed number types use DataStream endianness.
  // To explicitly specify endianness, suffix the type with
  // 'le' for little-endian or 'be' for big-endian,
  // e.g. 'int32be' for big-endian int32.

  'uint8' -- 8-bit unsigned int
  'uint16' -- 16-bit unsigned int
  'uint32' -- 32-bit unsigned int
  'int8' -- 8-bit int
  'int16' -- 16-bit int
  'int32' -- 32-bit int
  'float32' -- 32-bit float
  'float64' -- 64-bit float

  // String types
  'cstring' -- ASCII string terminated by a zero byte.
  'string:N' -- ASCII string of length N, where N is a literal integer.
  'string:variableName' -- ASCII string of length $variableName,
    where 'variableName' is a previously parsed number in the current struct.
  'string,CHARSET:N' -- String of byteLength N encoded with given CHARSET.
  'u16string:N' -- UCS-2 string of length N in DataStream endianness.
  'u16stringle:N' -- UCS-2 string of length N in little-endian.
  'u16stringbe:N' -- UCS-2 string of length N in big-endian.

  // Complex types
  [name, type, name_2, type_2, ..., name_N, type_N] -- Struct
  function(dataStream, struct) {} -- Callback function to read and return data.
  {get: function(dataStream, struct) {},
   set: function(dataStream, struct) {}}
  -- Getter/setter functions to read and return data, handy for using the same
     struct definition for reading and writing structs.
  ['[]', type, length] -- Array of given type and length. The length can be either
                        a number, a string that references a previously-read
                        field, or a callback function(struct, dataStream, type){}.
                        If length is '*', reads in as many elements as it can.

  @param {Object} structDefinition Struct definition object.
  @return {Object} The read struct. Null if failed to read struct.
 */
DataStream.prototype.readStruct = function(structDefinition) {
  var struct = {}, t, v, n;
  var p = this.position;
  for (var i=0; i<structDefinition.length; i+=2) {
    t = structDefinition[i+1];
    v = this.readType(t, struct);
    if (v == null) {
      if (this.failurePosition == 0) {
        this.failurePosition = this.position;
      }
      this.position = p;
      return null;
    }
    struct[structDefinition[i]] = v;
  }
  return struct;
};

/**
  Read UCS-2 string of desired length and endianness from the DataStream.

  @param {number} length The length of the string to read.
  @param {boolean} endianness The endianness of the string data in the DataStream.
  @return {string} The read string.
 */
DataStream.prototype.readUCS2String = function(length, endianness) {
  return DataStream.createStringFromArray(this.readUint16Array(length, endianness));
};

/**
  Write a UCS-2 string of desired endianness to the DataStream. The
  lengthOverride argument lets you define the number of characters to write.
  If the string is shorter than lengthOverride, the extra space is padded with
  zeroes.

  @param {string} str The string to write.
  @param {?boolean} endianness The endianness to use for the written string data.
  @param {?number} lengthOverride The number of characters to write.
 */
DataStream.prototype.writeUCS2String = function(str, endianness, lengthOverride) {
  if (lengthOverride == null) {
    lengthOverride = str.length;
  }
  for (var i = 0; i < str.length && i < lengthOverride; i++) {
    this.writeUint16(str.charCodeAt(i), endianness);
  }
  for (; i<lengthOverride; i++) {
    this.writeUint16(0);
  }
};

/**
  Read a string of desired length and encoding from the DataStream.

  @param {number} length The length of the string to read in bytes.
  @param {?string} encoding The encoding of the string data in the DataStream.
                            Defaults to ASCII.
  @return {string} The read string.
 */
DataStream.prototype.readString = function(length, encoding) {
  if (encoding == null || encoding == "ASCII") {
    return DataStream.createStringFromArray(this.mapUint8Array(length == null ? this.byteLength-this.position : length));
  } else {
    return (new TextDecoder(encoding)).decode(this.mapUint8Array(length));
  }
};

/**
  Writes a string of desired length and encoding to the DataStream.

  @param {string} s The string to write.
  @param {?string} encoding The encoding for the written string data.
                            Defaults to ASCII.
  @param {?number} length The number of characters to write.
 */
DataStream.prototype.writeString = function(s, encoding, length) {
  if (encoding == null || encoding == "ASCII") {
    if (length != null) {
      var i = 0;
      var len = Math.min(s.length, length);
      for (i=0; i<len; i++) {
        this.writeUint8(s.charCodeAt(i));
      }
      for (; i<length; i++) {
        this.writeUint8(0);
      }
    } else {
      for (var i=0; i<s.length; i++) {
        this.writeUint8(s.charCodeAt(i));
      }
    }
  } else {
    this.writeUint8Array((new TextEncoder(encoding)).encode(s.substring(0, length)));
  }
};


/**
  Read null-terminated string of desired length from the DataStream. Truncates
  the returned string so that the null byte is not a part of it.

  @param {?number} length The length of the string to read.
  @return {string} The read string.
 */
DataStream.prototype.readCString = function(length) {
  var blen = this.byteLength-this.position;
  var u8 = new Uint8Array(this._buffer, this._byteOffset + this.position);
  var len = blen;
  if (length != null) {
    len = Math.min(length, blen);
  }
  for (var i = 0; i < len && u8[i] != 0; i++); // find first zero byte
  var s = DataStream.createStringFromArray(this.mapUint8Array(i));
  if (length != null) {
    this.position += len-i;
  } else if (i != blen) {
    this.position += 1; // trailing zero if not at end of buffer
  }
  return s;
};

/**
  Writes a null-terminated string to DataStream and zero-pads it to length
  bytes. If length is not given, writes the string followed by a zero.
  If string is longer than length, the written part of the string does not have
  a trailing zero.

  @param {string} s The string to write.
  @param {?number} length The number of characters to write.
 */
DataStream.prototype.writeCString = function(s, length) {
  if (length != null) {
    var i = 0;
    var len = Math.min(s.length, length);
    for (i=0; i<len; i++) {
      this.writeUint8(s.charCodeAt(i));
    }
    for (; i<length; i++) {
      this.writeUint8(0);
    }
  } else {
    for (var i=0; i<s.length; i++) {
      this.writeUint8(s.charCodeAt(i));
    }
    this.writeUint8(0);
  }
};

/**
  Reads an object of type t from the DataStream, passing struct as the thus-far
  read struct to possible callbacks that refer to it. Used by readStruct for
  reading in the values, so the type is one of the readStruct types.

  @param {Object} t Type of the object to read.
  @param {?Object} struct Struct to refer to when resolving length references
                          and for calling callbacks.
  @return {?Object} Returns the object on successful read, null on unsuccessful.
 */
DataStream.prototype.readType = function(t, struct) {
  if (typeof t == "function") {
    return t(this, struct);
  } else if (typeof t == "object" && !(t instanceof Array)) {
    return t.get(this, struct);
  } else if (t instanceof Array && t.length != 3) {
    return this.readStruct(t, struct);
  }
  var v = null;
  var lengthOverride = null;
  var charset = "ASCII";
  var pos = this.position;
  var len;
  if (typeof t == 'string' && /:/.test(t)) {
    var tp = t.split(":");
    t = tp[0];
    len = tp[1];

    // allow length to be previously parsed variable
    // e.g. 'string:fieldLength', if `fieldLength` has
    // been parsed previously.
    if (struct[len] != null) {
      lengthOverride = parseInt(struct[len]);
    } else {
      // assume literal integer e.g., 'string:4'
      lengthOverride = parseInt(tp[1]);
    }
  }
  if (typeof t == 'string' && /,/.test(t)) {
    var tp = t.split(",");
    t = tp[0];
    charset = parseInt(tp[1]);
  }
  switch(t) {

    case 'uint8':
      v = this.readUint8(); break;
    case 'int8':
      v = this.readInt8(); break;

    case 'uint16':
      v = this.readUint16(this.endianness); break;
    case 'int16':
      v = this.readInt16(this.endianness); break;
    case 'uint32':
      v = this.readUint32(this.endianness); break;
    case 'int32':
      v = this.readInt32(this.endianness); break;
    case 'float32':
      v = this.readFloat32(this.endianness); break;
    case 'float64':
      v = this.readFloat64(this.endianness); break;

    case 'uint16be':
      v = this.readUint16(DataStream.BIG_ENDIAN); break;
    case 'int16be':
      v = this.readInt16(DataStream.BIG_ENDIAN); break;
    case 'uint32be':
      v = this.readUint32(DataStream.BIG_ENDIAN); break;
    case 'int32be':
      v = this.readInt32(DataStream.BIG_ENDIAN); break;
    case 'float32be':
      v = this.readFloat32(DataStream.BIG_ENDIAN); break;
    case 'float64be':
      v = this.readFloat64(DataStream.BIG_ENDIAN); break;

    case 'uint16le':
      v = this.readUint16(DataStream.LITTLE_ENDIAN); break;
    case 'int16le':
      v = this.readInt16(DataStream.LITTLE_ENDIAN); break;
    case 'uint32le':
      v = this.readUint32(DataStream.LITTLE_ENDIAN); break;
    case 'int32le':
      v = this.readInt32(DataStream.LITTLE_ENDIAN); break;
    case 'float32le':
      v = this.readFloat32(DataStream.LITTLE_ENDIAN); break;
    case 'float64le':
      v = this.readFloat64(DataStream.LITTLE_ENDIAN); break;

    case 'cstring':
      v = this.readCString(lengthOverride); break;

    case 'string':
      v = this.readString(lengthOverride, charset); break;

    case 'u16string':
      v = this.readUCS2String(lengthOverride, this.endianness); break;

    case 'u16stringle':
      v = this.readUCS2String(lengthOverride, DataStream.LITTLE_ENDIAN); break;

    case 'u16stringbe':
      v = this.readUCS2String(lengthOverride, DataStream.BIG_ENDIAN); break;

    default:
      if (t.length == 3) {
        var ta = t[1];
        var len = t[2];
        var length = 0;
        if (typeof len == 'function') {
          length = len(struct, this, t);
        } else if (typeof len == 'string' && struct[len] != null) {
          length = parseInt(struct[len]);
        } else {
          length = parseInt(len);
        }
        if (typeof ta == "string") {
          var tap = ta.replace(/(le|be)$/, '');
          var endianness = null;
          if (/le$/.test(ta)) {
            endianness = DataStream.LITTLE_ENDIAN;
          } else if (/be$/.test(ta)) {
            endianness = DataStream.BIG_ENDIAN;
          }
          if (len == '*') {
            length = null;
          }
          switch(tap) {
            case 'uint8':
              v = this.readUint8Array(length); break;
            case 'uint16':
              v = this.readUint16Array(length, endianness); break;
            case 'uint32':
              v = this.readUint32Array(length, endianness); break;
            case 'int8':
              v = this.readInt8Array(length); break;
            case 'int16':
              v = this.readInt16Array(length, endianness); break;
            case 'int32':
              v = this.readInt32Array(length, endianness); break;
            case 'float32':
              v = this.readFloat32Array(length, endianness); break;
            case 'float64':
              v = this.readFloat64Array(length, endianness); break;
            case 'cstring':
            case 'utf16string':
            case 'string':
              if (length == null) {
                v = [];
                while (!this.isEof()) {
                  var u = this.readType(ta, struct);
                  if (u == null) break;
                  v.push(u);
                }
              } else {
                v = new Array(length);
                for (var i=0; i<length; i++) {
                  v[i] = this.readType(ta, struct);
                }
              }
              break;
          }
        } else {
          if (len == '*') {
            v = [];
            this.buffer;
            while (true) {
              var p = this.position;
              try {
                var o = this.readType(ta, struct);
                if (o == null) {
                  this.position = p;
                  break;
                }
                v.push(o);
              } catch(e) {
                this.position = p;
                break;
              }
            }
          } else {
            v = new Array(length);
            for (var i=0; i<length; i++) {
              var u = this.readType(ta, struct);
              if (u == null) return null;
              v[i] = u;
            }
          }
        }
        break;
      }
  }
  if (lengthOverride != null) {
    this.position = pos + lengthOverride;
  }
  return v;
};

/**
  Writes a struct to the DataStream. Takes a structDefinition that gives the
  types and a struct object that gives the values. Refer to readStruct for the
  structure of structDefinition.

  @param {Object} structDefinition Type definition of the struct.
  @param {Object} struct The struct data object.
  */
DataStream.prototype.writeStruct = function(structDefinition, struct) {
  for (var i = 0; i < structDefinition.length; i+=2) {
    var t = structDefinition[i+1];
    this.writeType(t, struct[structDefinition[i]], struct);
  }
};

/**
  Writes object v of type t to the DataStream.

  @param {Object} t Type of data to write.
  @param {Object} v Value of data to write.
  @param {Object} struct Struct to pass to write callback functions.
  */
DataStream.prototype.writeType = function(t, v, struct) {
  if (typeof t == "function") {
    return t(this, v);
  } else if (typeof t == "object" && !(t instanceof Array)) {
    return t.set(this, v, struct);
  }
  var lengthOverride = null;
  var charset = "ASCII";
  var pos = this.position;
  if (typeof(t) == 'string' && /:/.test(t)) {
    var tp = t.split(":");
    t = tp[0];
    lengthOverride = parseInt(tp[1]);
  }
  if (typeof t == 'string' && /,/.test(t)) {
    var tp = t.split(",");
    t = tp[0];
    charset = parseInt(tp[1]);
  }

  switch(t) {
    case 'uint8':
      this.writeUint8(v);
      break;
    case 'int8':
      this.writeInt8(v);
      break;

    case 'uint16':
      this.writeUint16(v, this.endianness);
      break;
    case 'int16':
      this.writeInt16(v, this.endianness);
      break;
    case 'uint32':
      this.writeUint32(v, this.endianness);
      break;
    case 'int32':
      this.writeInt32(v, this.endianness);
      break;
    case 'float32':
      this.writeFloat32(v, this.endianness);
      break;
    case 'float64':
      this.writeFloat64(v, this.endianness);
      break;

    case 'uint16be':
      this.writeUint16(v, DataStream.BIG_ENDIAN);
      break;
    case 'int16be':
      this.writeInt16(v, DataStream.BIG_ENDIAN);
      break;
    case 'uint32be':
      this.writeUint32(v, DataStream.BIG_ENDIAN);
      break;
    case 'int32be':
      this.writeInt32(v, DataStream.BIG_ENDIAN);
      break;
    case 'float32be':
      this.writeFloat32(v, DataStream.BIG_ENDIAN);
      break;
    case 'float64be':
      this.writeFloat64(v, DataStream.BIG_ENDIAN);
      break;

    case 'uint16le':
      this.writeUint16(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'int16le':
      this.writeInt16(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'uint32le':
      this.writeUint32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'int32le':
      this.writeInt32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'float32le':
      this.writeFloat32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'float64le':
      this.writeFloat64(v, DataStream.LITTLE_ENDIAN);
      break;

    case 'cstring':
      this.writeCString(v, lengthOverride);
      break;

    case 'string':
      this.writeString(v, charset, lengthOverride);
      break;

    case 'u16string':
      this.writeUCS2String(v, this.endianness, lengthOverride);
      break;

    case 'u16stringle':
      this.writeUCS2String(v, DataStream.LITTLE_ENDIAN, lengthOverride);
      break;

    case 'u16stringbe':
      this.writeUCS2String(v, DataStream.BIG_ENDIAN, lengthOverride);
      break;

    default:
      if (t.length == 3) {
        var ta = t[1];
        for (var i=0; i<v.length; i++) {
          this.writeType(ta, v[i]);
        }
        break;
      } else {
        this.writeStruct(t, v);
        break;
      }
  }
  if (lengthOverride != null) {
    this.position = pos;
    this._realloc(lengthOverride);
    this.position = pos + lengthOverride;
  }
};

// Export DataStream for amd environments
if (typeof define === 'function' && define.amd) {
    define('DataStream', [], function() {
      return DataStream;
    });
  }
  
// Export DataStream for CommonJS
if (typeof module === 'object' && module && module.exports) {
  module.exports = DataStream;
}

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.4.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = exports.EPSILON = 0.000001;
var ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = exports.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  var x = v[0],
      y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];

  // calculate quat * vec
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = glMatrix.RANDOM();
  out[1] = glMatrix.RANDOM();
  out[2] = glMatrix.RANDOM();
  out[3] = glMatrix.RANDOM();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];

  // calculate quat * vec
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec4.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec4.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec4.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = undefined;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

var _mat = __webpack_require__(5);

var mat2 = _interopRequireWildcard(_mat);

var _mat2d = __webpack_require__(6);

var mat2d = _interopRequireWildcard(_mat2d);

var _mat2 = __webpack_require__(1);

var mat3 = _interopRequireWildcard(_mat2);

var _mat3 = __webpack_require__(7);

var mat4 = _interopRequireWildcard(_mat3);

var _quat = __webpack_require__(8);

var quat = _interopRequireWildcard(_quat);

var _vec = __webpack_require__(9);

var vec2 = _interopRequireWildcard(_vec);

var _vec2 = __webpack_require__(2);

var vec3 = _interopRequireWildcard(_vec2);

var _vec3 = __webpack_require__(3);

var vec4 = _interopRequireWildcard(_vec3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.glMatrix = glMatrix;
exports.mat2 = mat2;
exports.mat2d = mat2d;
exports.mat3 = mat3;
exports.mat4 = mat4;
exports.quat = quat;
exports.vec2 = vec2;
exports.vec3 = vec3;
exports.vec4 = vec4; /**
                      * @fileoverview gl-matrix - High performance matrix and vector operations
                      * @author Brandon Jones
                      * @author Colin MacKenzie IV
                      * @version 2.4.0
                      */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.str = str;
exports.frob = frob;
exports.LDU = LDU;
exports.add = add;
exports.subtract = subtract;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];

  // Calculate the determinant
  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.invert = invert;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];

  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  // Cache only the current line of the second matrix
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00 = void 0,
      a01 = void 0,
      a02 = void 0,
      a03 = void 0;
  var a10 = void 0,
      a11 = void 0,
      a12 = void 0,
      a13 = void 0;
  var a20 = void 0,
      a21 = void 0,
      a22 = void 0,
      a23 = void 0;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s = void 0,
      c = void 0,
      t = void 0;
  var a00 = void 0,
      a01 = void 0,
      a02 = void 0,
      a03 = void 0;
  var a10 = void 0,
      a11 = void 0,
      a12 = void 0,
      a13 = void 0;
  var a20 = void 0,
      a21 = void 0,
      a22 = void 0,
      a23 = void 0;
  var b00 = void 0,
      b01 = void 0,
      b02 = void 0;
  var b10 = void 0,
      b11 = void 0,
      b12 = void 0;
  var b20 = void 0,
      b21 = void 0,
      b22 = void 0;

  if (Math.abs(len) < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s = void 0,
      c = void 0,
      t = void 0;

  if (Math.abs(len) < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] & mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  var sx = s[0];
  var sy = s[1];
  var sz = s[2];

  var ox = o[0];
  var oy = o[1];
  var oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2);
  var nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = 2 * far * near * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  var x0 = void 0,
      x1 = void 0,
      x2 = void 0,
      y0 = void 0,
      y1 = void 0,
      y2 = void 0,
      z0 = void 0,
      z1 = void 0,
      z2 = void 0,
      len = void 0;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];

  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = undefined;
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.slerp = slerp;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

var _mat = __webpack_require__(1);

var mat3 = _interopRequireWildcard(_mat);

var _vec = __webpack_require__(2);

var vec3 = _interopRequireWildcard(_vec);

var _vec2 = __webpack_require__(3);

var vec4 = _interopRequireWildcard(_vec2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  var omega = void 0,
      cosom = void 0,
      sinom = void 0,
      scale0 = void 0,
      scale1 = void 0;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  // calculate coefficients
  if (1.0 - cosom > 0.000001) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot = void 0;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;

    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;

  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);

  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;

  return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
var clone = exports.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
var fromValues = exports.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
var copy = exports.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
var set = exports.set = vec4.set;

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
var add = exports.add = vec4.add;

/**
 * Alias for {@link quat.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
var scale = exports.scale = vec4.scale;

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
var dot = exports.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
var lerp = exports.lerp = vec4.lerp;

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
var length = exports.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
var len = exports.len = length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
var squaredLength = exports.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
var normalize = exports.normalize = vec4.normalize;

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var exactEquals = exports.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var equals = exports.equals = vec4.equals;

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
var rotationTo = exports.rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);

  return function (out, a, b) {
    var dot = vec3.dot(a, b);
    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
var sqlerp = exports.sqlerp = function () {
  var temp1 = create();
  var temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
var setAxes = exports.setAxes = function () {
  var matr = mat3.create();

  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = undefined;
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = __webpack_require__(0);

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ })
/******/ ]);
});
/**
 * @file tgajs - Javascript decoder & (experimental) encoder for TGA files
 * @desc tgajs is a fork from https://github.com/vthibault/jsTGALoader
 * @author Vincent Thibault (Original author)
 * @author Lukas Schmitt
 * @version 1.0.0
 */

/* Copyright (c) 2013, Vincent Thibault. All rights reserved.

 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

(function (_global) {
  'use strict';

  /**
   * @var {object} TGA type constants
   */
  Targa.Type = {
    NO_DATA: 0,
    INDEXED: 1,
    RGB: 2,
    GREY: 3,
    RLE_INDEXED: 9,
    RLE_RGB: 10,
    RLE_GREY: 11
  };

  /**
   * @var {object} TGA origin constants
   */
  Targa.Origin = {
    BOTTOM_LEFT: 0x00,
    BOTTOM_RIGHT: 0x01,
    TOP_LEFT: 0x02,
    TOP_RIGHT: 0x03,
    SHIFT: 0x04,
    MASK: 0x30,
    ALPHA: 0x08
  };

  Targa.HEADER_SIZE = 18;
  Targa.FOOTER_SIZE = 26;
  Targa.LITTLE_ENDIAN = true;
  Targa.RLE_BIT = 0x80;
  Targa.RLE_MASK = 0x7f;
  Targa.RLE_PACKET = 1;
  Targa.RAW_PACKET = 2;
  Targa.SIGNATURE = "TRUEVISION-XFILE.\0";

  /**
   * TGA Namespace
   * @constructor
   */
  function Targa() {
    if (arguments.length == 1) {
      var h = arguments[0];

      this.header = createHeader(h);
      setHeaderBooleans(this.header);
      checkHeader(this.header);
    }
  }

  /**
   * Sets header or default values
   * @param header header
   * @returns {Object}
   */
  function createHeader(header) {
    return {
      /* 0x00  BYTE */  idLength: defaultFor(header.idLength, 0),
      /* 0x01  BYTE */  colorMapType: defaultFor(header.colorMapType, 0),
      /* 0x02  BYTE */  imageType: defaultFor(header.imageType, Targa.Type.RGB),
      /* 0x03  WORD */  colorMapIndex: defaultFor(header.colorMapIndex, 0),
      /* 0x05  WORD */  colorMapLength: defaultFor(header.colorMapLength, 0),
      /* 0x07  BYTE */  colorMapDepth: defaultFor(header.colorMapDepth, 0),
      /* 0x08  WORD */  offsetX: defaultFor(header.offsetX, 0),
      /* 0x0a  WORD */  offsetY: defaultFor(header.offsetY, 0),
      /* 0x0c  WORD */  width: defaultFor(header.width, 0),
      /* 0x0e  WORD */  height: defaultFor(header.height, 0),
      /* 0x10  BYTE */  pixelDepth: defaultFor(header.pixelDepth,32),
      /* 0x11  BYTE */  flags: defaultFor(header.flags, 8)
    };
  }

  function defaultFor(arg, val) { return typeof arg !== 'undefined' ? arg : val; }

  /**
   * Write footer of TGA file to view
   * Byte 0-3 - Extension Area Offset, 0 if no Extension Area exists
   * Byte 4-7 - Developer Directory Offset, 0 if no Developer Area exists
   * Byte 8-25 - Signature
   * @param {Uint8Array} footer
   */
  function writeFooter(footer) {
    var signature = Targa.SIGNATURE;
    var offset = footer.byteLength - signature.length;
    for (var i = 0; i < signature.length; i++) {
      footer[offset + i] = signature.charCodeAt(i);
    }
  }

  /**
   * Write header of TGA file to view
   * @param header
   * @param view DataView
   */
  function writeHeader(header, view) {
    var littleEndian = Targa.LITTLE_ENDIAN;

    view.setUint8(0x00, header.idLength);
    view.setUint8(0x01, header.colorMapType);
    view.setUint8(0x02, header.imageType);
    view.setUint16(0x03, header.colorMapIndex, littleEndian);
    view.setUint16(0x05, header.colorMapLength, littleEndian);
    view.setUint8(0x07, header.colorMapDepth);
    view.setUint16(0x08, header.offsetX, littleEndian);
    view.setUint16(0x0a, header.offsetY, littleEndian);
    view.setUint16(0x0c, header.width, littleEndian);
    view.setUint16(0x0e, header.height, littleEndian);
    view.setUint8(0x10, header.pixelDepth);
    view.setUint8(0x11, header.flags);
  }

  function readHeader(view) {
    var littleEndian = Targa.LITTLE_ENDIAN;

    // Not enough data to contain header ?
    if (view.byteLength  < 0x12) {
      throw new Error('Targa::load() - Not enough data to contain header');
    }

    var header = {};
    header.idLength = view.getUint8(0x00);
    header.colorMapType = view.getUint8(0x01);
    header.imageType =  view.getUint8(0x02);
    header.colorMapIndex = view.getUint16(0x03, littleEndian);
    header.colorMapLength = view.getUint16(0x05, littleEndian);
    header.colorMapDepth = view.getUint8(0x07);
    header.offsetX = view.getUint16(0x08, littleEndian);
    header.offsetY = view.getUint16(0x0a, littleEndian);
    header.width = view.getUint16(0x0c, littleEndian);
    header.height = view.getUint16(0x0e, littleEndian);
    header.pixelDepth = view.getUint8(0x10);
    header.flags = view.getUint8(0x11);

    return header;
  }

  /**
   * Set additional header booleans
   * @param header
   */
  function setHeaderBooleans(header) {
    header.hasEncoding = (header.imageType === Targa.Type.RLE_INDEXED || header.imageType === Targa.Type.RLE_RGB || header.imageType === Targa.Type.RLE_GREY);
    header.hasColorMap = (header.imageType === Targa.Type.RLE_INDEXED || header.imageType === Targa.Type.INDEXED);
    header.isGreyColor = (header.imageType === Targa.Type.RLE_GREY || header.imageType === Targa.Type.GREY);
    header.bytePerPixel = header.pixelDepth >> 3;
    header.origin = (header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    header.alphaBits = header.flags & Targa.Origin.ALPHA;
  }

  /**
   * Check the header of TGA file to detect errors
   *
   * @param {object} header tga header structure
   * @throws Error
   */
  function checkHeader(header) {
    // What the need of a file without data ?
    if (header.imageType === Targa.Type.NO_DATA) {
      throw new Error('Targa::checkHeader() - No data');
    }

    // Indexed type
    if (header.hasColorMap) {
      if (header.colorMapLength > 256 || header.colorMapType !== 1) {
        throw new Error('Targa::checkHeader() - Unsupported colormap for indexed type');
      }
      if (header.colorMapDepth !== 16 && header.colorMapDepth !== 24  && header.colorMapDepth !== 32) {
        throw new Error('Targa::checkHeader() - Unsupported colormap depth');
      }
    }
    else {
      if (header.colorMapType) {
        throw new Error('Targa::checkHeader() - Why does the image contain a palette ?');
      }
    }

    // Check image size
    if (header.width <= 0 || header.height <= 0) {
      throw new Error('Targa::checkHeader() - Invalid image size');
    }

    // Check pixel size
    if (header.pixelDepth !== 8 &&
      header.pixelDepth !== 16 &&
      header.pixelDepth !== 24 &&
      header.pixelDepth !== 32) {
      throw new Error('Targa::checkHeader() - Invalid pixel size "' + header.pixelDepth + '"');
    }

    // Check alpha size
    if (header.alphaBits !== 0 &&
        header.alphaBits !== 1 &&
        header.alphaBits !== 8) {
      throw new Error('Targa::checkHeader() - Unsuppported alpha size');
    }
  }


  /**
   * Decode RLE compression
   *
   * @param {Uint8Array} data
   * @param {number} bytesPerPixel bytes per Pixel
   * @param {number} outputSize in byte: width * height * pixelSize
   */
  function decodeRLE(data, bytesPerPixel, outputSize) {
    var pos, c, count, i, offset;
    var pixels, output;

    output = new Uint8Array(outputSize);
    pixels = new Uint8Array(bytesPerPixel);
    offset = 0; // offset in data
    pos = 0; // offset for output

    while (pos < outputSize) {
      c = data[offset++]; // current byte to check
      count = (c & Targa.RLE_MASK) + 1; // repetition count of pixels, the lower 7 bits + 1

      // RLE packet, if highest bit is set to 1.
      if (c & Targa.RLE_BIT) {
        // Copy pixel values to be repeated to tmp array
        for (i = 0; i < bytesPerPixel; ++i) {
          pixels[i] = data[offset++];
        }

        // Copy pixel values * count to output
        for (i = 0; i < count; ++i) {
          output.set(pixels, pos);
          pos += bytesPerPixel;
        }
      }

      // Raw packet (Non-Run-Length Encoded)
      else {
        count *= bytesPerPixel;
        for (i = 0; i < count; ++i) {
          output[pos++] = data[offset++];
        }
      }
    }

    if (pos > outputSize) {
      throw new Error("Targa::decodeRLE() - Read bytes: " + pos + " Expected bytes: " + outputSize);
    }

    return output;
  }

  /**
   * Encode ImageData object with RLE compression
   *
   * @param header
   * @param imageData from canvas to compress
   */
  function encodeRLE(header, imageData) {
    var maxRepetitionCount = 128;
    var i;
    var data = imageData;
    var output = []; // output size is unknown
    var pos = 0; // pos in imageData array
    var bytesPerPixel = header.pixelDepth >> 3;
    var offset = 0;
    var packetType, packetLength, packetHeader;
    var tgaLength = header.width * header.height * bytesPerPixel;
    var isSamePixel = function isSamePixel(pos, offset) {
      for (var i = 0; i < bytesPerPixel; i++) {
        if (data[pos * bytesPerPixel + i] !== data[offset * bytesPerPixel + i]) {
          return false;
        }
      }
      return true;
    };
    var getPacketType = function(pos) {
      if (isSamePixel(pos, pos + 1)) {
        return Targa.RLE_PACKET;
      }
      return Targa.RAW_PACKET;
    };

    while (pos * bytesPerPixel < data.length && pos * bytesPerPixel < tgaLength) {
      // determine packet type
      packetType = getPacketType(pos);

      // determine packet length
      packetLength = 0;
      if (packetType === Targa.RLE_PACKET) {
        while (pos + packetLength < data.length
        && packetLength < maxRepetitionCount
        && isSamePixel(pos, pos + packetLength)) {
          packetLength++;
        }
      } else { // packetType === Targa.RAW_PACKET
        while (pos + packetLength < data.length
        && packetLength < maxRepetitionCount
        && getPacketType(pos + packetLength) === Targa.RAW_PACKET) {
          packetLength++;
        }
      }

      // write packet header
      packetHeader = packetLength - 1;
      if (packetType === Targa.RLE_PACKET) {
        packetHeader |= Targa.RLE_BIT;
      }
      output[offset++] = packetHeader;

      // write rle packet pixel OR raw pixels
      if (packetType === Targa.RLE_PACKET) {
        for (i = 0; i < bytesPerPixel; i++) {
          output[i + offset] = data[i + pos * bytesPerPixel];
        }
        offset += bytesPerPixel;
      } else {
        for (i = 0; i < bytesPerPixel * packetLength; i++) {
          output[i + offset] = data[i + pos * bytesPerPixel];
        }
        offset += bytesPerPixel * packetLength;
      }
      pos += packetLength;
    }

    return new Uint8Array(output);
  }


  /**
   * Return a ImageData object from a TGA file (8bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} indexes - index to colorMap
   * @param {Array} colorMap
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData8bits(imageData, indexes, colorMap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, index, offset, i, x, y;
    var bytePerPixel = this.header.colorMapDepth >> 3;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i++) {
        offset = (x + width * y) * 4;
        index = indexes[i] * bytePerPixel;
        if (bytePerPixel === 4) {
          imageData[offset    ] = colorMap[index + 2]; // red
          imageData[offset + 1] = colorMap[index + 1]; // green
          imageData[offset + 2] = colorMap[index    ]; // blue
          imageData[offset + 3] = colorMap[index + 3]; // alpha
        } else if (bytePerPixel === 3) {
          imageData[offset    ] = colorMap[index + 2]; // red
          imageData[offset + 1] = colorMap[index + 1]; // green
          imageData[offset + 2] = colorMap[index    ]; // blue
          imageData[offset + 3] = 255; // alpha
        } else if (bytePerPixel === 2) {
          color = colorMap[index] | (colorMap[index + 1] << 8);
          imageData[offset    ] = (color & 0x7C00) >> 7; // red
          imageData[offset + 1] = (color & 0x03E0) >> 2; // green
          imageData[offset + 2] = (color & 0x001F) << 3; // blue
          imageData[offset + 3] = (color & 0x8000) ? 0 : 255; // overlay 0 = opaque and 1 = transparent Discussion at: https://bugzilla.gnome.org/show_bug.cgi?id=683381
        }
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (16bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData16bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 2) {
        color = pixels[i] | (pixels[i + 1] << 8);
        offset = (x + width * y) * 4;
        imageData[offset    ] = (color & 0x7C00) >> 7; // red
        imageData[offset + 1] = (color & 0x03E0) >> 2; // green
        imageData[offset + 2] = (color & 0x001F) << 3; // blue
        imageData[offset + 3] = (color & 0x8000) ? 0 : 255; // overlay 0 = opaque and 1 = transparent Discussion at: https://bugzilla.gnome.org/show_bug.cgi?id=683381
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (24bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData24bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var offset, i, x, y;
    var bpp = this.header.pixelDepth >> 3;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += bpp) {
        offset = (x + width * y) * 4;
        imageData[offset + 3] = 255;  // alpha
        imageData[offset + 2] = pixels[i    ]; // blue
        imageData[offset + 1] = pixels[i + 1]; // green
        imageData[offset    ] = pixels[i + 2]; // red
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (32bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data from TGA file
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData32bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var i, x, y, offset;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 4) {
        offset = (x + width * y) * 4;
        imageData[offset + 2] = pixels[i    ]; // blue
        imageData[offset + 1] = pixels[i + 1]; // green
        imageData[offset    ] = pixels[i + 2]; // red
        imageData[offset + 3] = pixels[i + 3]; // alpha
      }
    }

    return imageData;
  }

  /**
   * Return a ImageData object from a TGA file (32bits). Uses pre multiplied alpha values
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data from TGA file
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData32bitsPre(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var i, x, y, offset, alpha;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 4) {
        offset = (x + width * y) * 4;
        alpha = pixels[i + 3] * 255; // TODO needs testing
        imageData[offset + 2] = pixels[i    ] / alpha; // blue
        imageData[offset + 1] = pixels[i + 1] / alpha; // green
        imageData[offset    ] = pixels[i + 2] / alpha; // red
        imageData[offset + 3] = pixels[i + 3]; // alpha
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (8bits grey)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageDataGrey8bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i++) {
        color = pixels[i];
        offset = (x + width * y) * 4;
        imageData[offset    ] = color; // red
        imageData[offset + 1] = color; // green
        imageData[offset + 2] = color; // blue
        imageData[offset + 3] = 255;   // alpha
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (16bits grey) 8 Bit RGB and 8 Bit Alpha
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageDataGrey16bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 2) {
        color = pixels[i];
        offset = (x + width * y) * 4;
        imageData[offset] = color;
        imageData[offset + 1] = color;
        imageData[offset + 2] = color;
        imageData[offset + 3] = pixels[i + 1];
      }
    }

    return imageData;
  }


  /**
   * Open a targa file using XHR, be aware with Cross Domain files...
   *
   * @param {string} path - Path of the filename to load
   * @param {function} callback - callback to trigger when the file is loaded
   */
  Targa.prototype.open = function targaOpen(path, callback) {
    var req, tga = this;
    req = new XMLHttpRequest();
    req.open('GET', path, true);
    req.responseType = 'arraybuffer';
    req.onload = function () {
      if (this.status === 200) {
        tga.arrayBuffer = req.response;
        tga.load(tga.arrayBuffer);
        if (callback) {
          callback.call(tga);
        }
      }
    };
    req.send(null);
  };


  function readFooter(view) {
    var offset = view.byteLength - Targa.FOOTER_SIZE;
    var signature = Targa.SIGNATURE;

    var footer = {};

    var signatureArray = new Uint8Array(view.buffer, offset + 0x08, signature.length);
    var str = String.fromCharCode.apply(null, signatureArray);

    if (!isSignatureValid(str)) {
      footer.hasFooter = false;
      return footer;
    }

    footer.hasFooter = true;
    footer.extensionOffset = view.getUint32(offset, Targa.LITTLE_ENDIAN);
    footer.developerOffset = view.getUint32(offset + 0x04, Targa.LITTLE_ENDIAN);
    footer.hasExtensionArea = footer.extensionOffset !== 0;
    footer.hasDeveloperArea = footer.developerOffset !== 0;

    if (footer.extensionOffset) {
      footer.attributeType = view.getUint8(footer.extensionOffset + 494);
    }

    return footer;
  }

  function isSignatureValid(str) {
    var signature = Targa.SIGNATURE;

    for (var i = 0; i < signature.length; i++) {
      if (str.charCodeAt(i) !== signature.charCodeAt(i)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Load and parse a TGA file
   *
   * @param {ArrayBuffer} data - TGA file buffer array
   */
  Targa.prototype.load = function targaLoad(data) {
    var dataView = new DataView(data);

    this.headerData = new Uint8Array(data, 0, Targa.HEADER_SIZE);

    this.header = readHeader(dataView); // Parse Header
    setHeaderBooleans(this.header);
    checkHeader(this.header); // Check if a valid TGA file (or if we can load it)

    var offset = Targa.HEADER_SIZE;
    // Move to data
    offset += this.header.idLength;
    if (offset >= data.byteLength) {
      throw new Error('Targa::load() - No data');
    }

    // Read palette
    if (this.header.hasColorMap) {
      var colorMapSize = this.header.colorMapLength * (this.header.colorMapDepth >> 3);
      this.palette = new Uint8Array(data, offset, colorMapSize);
      offset += colorMapSize;
    }

    var bytesPerPixel = this.header.pixelDepth >> 3;
    var imageSize = this.header.width * this.header.height;
    var pixelTotal = imageSize * bytesPerPixel;

    if (this.header.hasEncoding) { // RLE encoded
      var RLELength = data.byteLength - offset - Targa.FOOTER_SIZE;
      var RLEData = new Uint8Array(data, offset, RLELength);
      this.imageData = decodeRLE(RLEData, bytesPerPixel, pixelTotal);
    } else { // RAW pixels
      this.imageData = new Uint8Array(data, offset, this.header.hasColorMap ? imageSize : pixelTotal);
    }
    
    this.footer = readFooter(dataView);

    if (this.header.alphaBits !== 0  || this.footer.hasExtensionArea && (this.footer.attributeType === 3 || this.footer.attributeType === 4)) {
      this.footer.usesAlpha = true;
    }
  };


  /**
   * Return a ImageData object from a TGA file
   *
   * @param {object} imageData - Optional ImageData to work with
   * @returns {object} imageData
   */
  Targa.prototype.getImageData = function targaGetImageData(imageData) {
    var width = this.header.width;
    var height = this.header.height;
    var origin = (this.header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    var x_start, x_step, x_end, y_start, y_step, y_end;
    var getImageData;

    // Create an imageData
    if (!imageData) {
      if (document) {
        imageData = document.createElement('canvas').getContext('2d').createImageData(width, height);
      }
      // In Thread context ?
      else {
        imageData = {
          width: width,
          height: height,
          data: new Uint8ClampedArray(width * height * 4)
        };
      }
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.TOP_RIGHT) {
      y_start = 0;
      y_step = 1;
      y_end = height;
    }
    else {
      y_start = height - 1;
      y_step = -1;
      y_end = -1;
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.BOTTOM_LEFT) {
      x_start = 0;
      x_step = 1;
      x_end = width;
    }
    else {
      x_start = width - 1;
      x_step = -1;
      x_end = -1;
    }

    // TODO: use this.header.offsetX and this.header.offsetY ?

    switch (this.header.pixelDepth) {
      case 8:
        getImageData = this.header.isGreyColor ? getImageDataGrey8bits : getImageData8bits;
        break;

      case 16:
        getImageData = this.header.isGreyColor ? getImageDataGrey16bits : getImageData16bits;
        break;

      case 24:
        getImageData = getImageData24bits;
        break;

      case 32:
        if (this.footer.hasExtensionArea) {
          if (this.footer.attributeType === 3) { // straight alpha
            getImageData = getImageData32bits;
          } else if (this.footer.attributeType === 4) { // pre multiplied alpha
            getImageData = getImageData32bitsPre;
          } else { // ignore alpha values if attributeType set to 0, 1, 2
            getImageData = getImageData24bits;
          }
        } else {
          if (this.header.alphaBits !== 0) {
            getImageData = getImageData32bits;
          } else { // 32 bits Depth, but alpha Bits set to 0
            getImageData = getImageData24bits;
          }
        }

        break;
    }

    getImageData.call(this, imageData.data, this.imageData, this.palette, width, y_start, y_step, y_end, x_start, x_step, x_end);
    return imageData;
  };

  /** (Experimental)
   *  Encodes imageData into TGA format
   *  Only TGA True Color 32 bit with optional RLE encoding is supported for now
   * @param imageData
   */
  Targa.prototype.setImageData = function targaSetImageData(imageData) {

    if (!imageData) {
      throw new Error('Targa::setImageData() - imageData argument missing');
    }

    var width = this.header.width;
    var height = this.header.height;
    var expectedLength = width * height * (this.header.pixelDepth  >> 3);
    var origin = (this.header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    var x_start, x_step, x_end, y_start, y_step, y_end;

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.TOP_RIGHT) {
      y_start = 0; // start bottom, step upward
      y_step = 1;
      y_end = height;
    } else {
      y_start = height - 1; // start at top, step downward
      y_step = -1;
      y_end = -1;
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.BOTTOM_LEFT) {
      x_start = 0; // start left, step right
      x_step = 1;
      x_end = width;
    } else {
      x_start = width - 1; // start right, step left
      x_step = -1;
      x_end = -1;
    }

    if (!this.imageData) {
      this.imageData = new Uint8Array(expectedLength);
    }

    // start top left if origin is bottom left
    // swapping order of first two arguments does the trick for writing
    // this converts canvas data to internal tga representation
    // this.imageData contains tga data
    getImageData32bits(this.imageData, imageData.data, this.palette, width, y_start, y_step, y_end, x_start, x_step, x_end);

    var data = this.imageData;

    if (this.header.hasEncoding) {
      data = encodeRLE(this.header, data);
    }

    var bufferSize = Targa.HEADER_SIZE + data.length + Targa.FOOTER_SIZE;
    var buffer = new ArrayBuffer(bufferSize);

    this.arrayBuffer = buffer;
    // create array, useful for inspecting data while debugging
    this.headerData = new Uint8Array(buffer, 0, Targa.HEADER_SIZE);
    this.RLEData = new Uint8Array(buffer, Targa.HEADER_SIZE, data.length);
    this.footerData = new Uint8Array(buffer, Targa.HEADER_SIZE + data.length, Targa.FOOTER_SIZE);

    var headerView = new DataView(this.headerData.buffer);
    writeHeader(this.header, headerView);
    this.RLEData.set(data);
    writeFooter(this.footerData);
  };

  /**
   * Return a canvas with the TGA render on it
   *
   * @returns {object} CanvasElement
   */
  Targa.prototype.getCanvas = function targaGetCanvas() {
    var canvas, ctx, imageData;

    canvas = document.createElement('canvas');
    ctx = canvas.getContext('2d');
    imageData = ctx.createImageData(this.header.width, this.header.height);

    canvas.width = this.header.width;
    canvas.height = this.header.height;

    ctx.putImageData(this.getImageData(imageData), 0, 0);

    return canvas;
  };


  /**
   * Return a dataURI of the TGA file
   *
   * @param {string} type - Optional image content-type to output (default: image/png)
   * @returns {string} url
   */
  Targa.prototype.getDataURL = function targaGetDatURL(type) {
    return this.getCanvas().toDataURL(type || 'image/png');
  };

  /**
   * Return a objectURL of the TGA file
   * The url can be used in the download attribute of a link
   * @returns {string} url
   */
  Targa.prototype.getBlobURL = function targetGetBlobURL() {
    if (!this.arrayBuffer) {
      throw new Error('Targa::getBlobURL() - No data available for blob');
    }
    var blob = new Blob([this.arrayBuffer], { type: "image/x-tga" });
    return URL.createObjectURL(blob);
  };


  // Find Context
  var shim = {};
  if (typeof(exports) === 'undefined') {
    if (typeof(define) === 'function' && typeof(define.amd) === 'object' && define.amd) {
      define(function () {
        return Targa;
      });
    } else {
      // Browser
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // Commonjs
    shim.exports = exports;
  }


  // Export
  if (shim.exports) {
    shim.exports.TGA = Targa;
  }

})(this);

'use strict';

/**
 * 버퍼 안의 데이터를 어떻게 읽어야 할지 키가 되는 객체
 * 
 * @alias Accessor
 * @class Accessor
 */
var Accessor = function () 
{

	if (!(this instanceof Accessor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.bufferId;
	// 0= position, 1= normal, 2= color, 3= texcoord.***
	this.accesorType;
	this.bufferStart;
	// 버퍼의 시작 시점
	this.stride;
	// character, int 등
	this.dataType;
	// 2차원, 3차원
	this.dimension;

	// 데이터가 포함되어 있는 x,y,z의 한계를 바운드라고 한다. 바운드 좌표
	this.minX = 0.0;
	this.minY = 0.0;
	this.minZ = 0.0;
	this.maxX = 0.0;
	this.maxY = 0.0;
	this.maxZ = 0.0;
};

'use strict';

/**
 * 블럭 모델
 * @class Block
 */
var Block = function() 
{
	if (!(this instanceof Block)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// This has "VertexIdxVBOArraysContainer" because the "indices" cannot to be greater than 65000, because indices are short type.***
	this.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer(); // Change this for "vbo_VertexIdx_CacheKeys_Container__idx".***
	this.mIFCEntityType = -1;
	this.isSmallObj = false;
	this.radius = 10;
	this.vertexCount = 0; // only for test.*** delete this.***

	this.lego; // legoBlock.***
};

/**
 * 블럭이 가지는 데이터 삭제
 * @returns block
 */
Block.prototype.deleteObjects = function(gl, vboMemManager) 
{

	this.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
	this.vBOVertexIdxCacheKeysContainer = undefined;
	this.mIFCEntityType = undefined;
	this.isSmallObj = undefined;
	this.radius = undefined;
	this.vertexCount = undefined; // only for test.*** delete this.***

	if (this.lego) { this.lego.deleteGlObjects(gl); }

	this.lego = undefined;
};

/**
 * 블록 목록
 * @class BlocksList
 */
var BlocksList = function() 
{
	if (!(this instanceof BlocksList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.name = "";
	this.blocksArray;
	// 0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.***
	this.fileLoadState = CODE.fileLoadState.READY;
	this.dataArraybuffer; // file loaded data, that is no parsed yet.***
};

/**
 * 새 블록 생성
 * @returns block
 */
BlocksList.prototype.newBlock = function() 
{
	if (this.blocksArray === undefined) { this.blocksArray = []; }

	var block = new Block();
	this.blocksArray.push(block);
	return block;
};

/**
 * 블록 획득
 * @param idx 변수
 * @returns block
 */
BlocksList.prototype.getBlock = function(idx) 
{
	if (this.blocksArray === undefined) { return null; }

	if (idx >= 0 && idx < this.blocksArray.length) 
	{
		return this.blocksArray[idx];
	}
	return null;
};

/**
 * 블록을 삭제
 * @param idx 변수
 * @returns block
 */
BlocksList.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.blocksArray === undefined) { return; }

	for (var i = 0, blocksCount = this.blocksArray.length; i < blocksCount; i++ ) 
	{
		var block = this.blocksArray[i];
		block.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
		block.vBOVertexIdxCacheKeysContainer = undefined; // Change this for "vbo_VertexIdx_CacheKeys_Container__idx".***
		block.mIFCEntityType = undefined;
		block.isSmallObj = undefined;
		block.radius = undefined;
		block.vertexCount = undefined; // only for test.*** delete this.***
		if (block.lego) 
		{
			block.lego.vbo_vicks_container.deleteGlObjects(gl, vboMemManager);
			block.lego.vbo_vicks_container = undefined;
		}
		block.lego = undefined; // legoBlock.***
		this.blocksArray[i] = undefined;
	}
	this.blocksArray = undefined;
	this.name = undefined;
	this.fileLoadState = undefined;
	this.dataArraybuffer = undefined; // file loaded data, that is no parsed yet.***
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {arrayBuffer} arrayBuffer Binary data to parse.
 * @param {ReadWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array} motherBlocksArray Global blocks array.
 */
BlocksList.prototype.stepOverBlockVersioned = function(arrayBuffer, bytesReaded, readWriter) 
{
	var vertexCount;
	var verticesFloatValuesCount;
	var normalByteValuesCount;
	var shortIndicesValuesCount;
	var sizeLevels;
	var startBuff, endBuff;
	
	var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	for ( var j = 0; j < vboDatasCount; j++ ) 
	{
		// 1) Positions array.
		vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		verticesFloatValuesCount = vertexCount * 3;
		startBuff = bytesReaded;
		endBuff = bytesReaded + 4 * verticesFloatValuesCount;
		bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.***

		// 2) Normals.
		vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		normalByteValuesCount = vertexCount * 3;
		bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.***

		// 3) Indices.
		shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1);bytesReaded += 1;
		bytesReaded = bytesReaded + sizeLevels * 4;
		bytesReaded = bytesReaded + sizeLevels * 4;
		bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.***
	}
	
	return bytesReaded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {arrayBuffer} arrayBuffer Binary data to parse.
 * @param {ReadWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array} motherBlocksArray Global blocks array.
 */
BlocksList.prototype.parseBlockVersioned = function(arrayBuffer, bytesReaded, block, readWriter, magoManager) 
{
	var posByteSize;
	var norByteSize;
	var idxByteSize;
	var classifiedPosByteSize;
	var classifiedNorByteSize;
	var classifiedIdxByteSize;
	var startBuff, endBuff;
	var vboMemManager = magoManager.vboMemoryManager;
	
	var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	for ( var j = 0; j < vboDatasCount; j++ ) 
	{
		// 1) Positions array.
		var vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var verticesFloatValuesCount = vertexCount * 3;
		// now padding the array to adjust to standard memory size of pool.
		//posByteSize = 4 * verticesFloatValuesCount;
		posByteSize = verticesFloatValuesCount;
		classifiedPosByteSize = vboMemManager.getClassifiedBufferSize(posByteSize);
		
		block.vertexCount = vertexCount;
		startBuff = bytesReaded;
		endBuff = bytesReaded + 4 * verticesFloatValuesCount;
		var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
		vboViCacheKey.posVboDataArray = new Float32Array(classifiedPosByteSize);
		vboViCacheKey.posVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
		vboViCacheKey.posArrayByteSize = classifiedPosByteSize; 
		bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.***
		
		// 2) Normals.
		vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var normalByteValuesCount = vertexCount * 3;
		// now padding the array to adjust to standard memory size of pool.
		norByteSize = 1 * normalByteValuesCount;
		classifiedNorByteSize = vboMemManager.getClassifiedBufferSize(norByteSize);
		
		startBuff = bytesReaded;
		endBuff = bytesReaded + 1 * normalByteValuesCount;
		vboViCacheKey.norVboDataArray = new Int8Array(classifiedNorByteSize);
		vboViCacheKey.norVboDataArray.set(new Int8Array(arrayBuffer.slice(startBuff, endBuff)));
		vboViCacheKey.norArrayByteSize = classifiedNorByteSize;
		bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.***
		
		// 3) Indices.
		var shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		// now padding the array to adjust to standard memory size of pool.
		//idxByteSize = 2 * shortIndicesValuesCount;
		idxByteSize = shortIndicesValuesCount;
		classifiedIdxByteSize = vboMemManager.getClassifiedBufferSize(idxByteSize);

		var sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded +=1;
		var sizeThresholds = [];
		for ( var k = 0; k < sizeLevels; k++ )
		{
			sizeThresholds.push(new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))); bytesReaded += 4;
		}
		var indexMarkers = [];
		for ( var k = 0; k < sizeLevels; k++ )
		{
			indexMarkers.push(readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4)); bytesReaded += 4;
		}
		var bigTrianglesShortIndicesValues_count = indexMarkers[sizeLevels-1];
		vboViCacheKey.bigTrianglesIndicesCount = bigTrianglesShortIndicesValues_count;
		startBuff = bytesReaded;
		endBuff = bytesReaded + 2 * shortIndicesValuesCount;

		vboViCacheKey.idxVboDataArray = new Int16Array(classifiedIdxByteSize);
		vboViCacheKey.idxVboDataArray.set(new Int16Array(arrayBuffer.slice(startBuff, endBuff)));
		vboViCacheKey.idxArrayByteSize = classifiedIdxByteSize;
		bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.***
		vboViCacheKey.indicesCount = shortIndicesValuesCount;
	}
	
	return bytesReaded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {arrayBuffer} arrayBuffer Binary data to parse.
 * @param {ReadWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array} motherBlocksArray Global blocks array.
 */
BlocksList.prototype.parseBlocksListVersioned = function(arrayBuffer, readWriter, motherBlocksArray, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytesReaded = 0;
	var startBuff, endBuff;
	var posByteSize, norByteSize, idxByteSize;
	var vboMemManager = magoManager.vboMemoryManager;
	var classifiedPosByteSize = 0, classifiedNorByteSize = 0, classifiedIdxByteSize = 0;
	var gl = magoManager.sceneState.gl;
	var succesfullyGpuDataBinded = true;
	
	// read the version.
	var versionLength = 5;
	var version = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+versionLength)));
	bytesReaded += versionLength;
	
	var blocksCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded + 4); bytesReaded += 4;
	for ( var i = 0; i< blocksCount; i++ ) 
	{
		var blockIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		// Check if block exist.
		if (motherBlocksArray[blockIdx]) 
		{
			// The block exists, then read data but no create a new block.
			bytesReaded += 4 * 6; // boundingBox.
			// step over vbo datas of the model.
			bytesReaded = this.stepOverBlockVersioned(arrayBuffer, bytesReaded, readWriter) ;
			
			// read lego if exist. (note: lego is exactly same of a model, is a mesh).
			var existLego = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
			if (existLego)
			{
				bytesReaded = this.stepOverBlockVersioned(arrayBuffer, bytesReaded, readWriter) ;
			}
			
			continue;
		}
		
		// The block doesn't exist, so creates a new block and read data.
		var block = new Block();
		block.idx = blockIdx;
		motherBlocksArray[blockIdx] = block;

		// 1rst, read bbox.
		var bbox = new BoundingBox();
		bbox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

		bbox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

		var maxLength = bbox.getMaxLength();
		if (maxLength < 0.5) { block.isSmallObj = true; }
		else { block.isSmallObj = false; }

		block.radius = maxLength/2.0;

		bbox.deleteObjects();
		bbox = undefined;
		
		bytesReaded = this.parseBlockVersioned(arrayBuffer, bytesReaded, block, readWriter, magoManager) ;
		
		// now bind vbo buffer datas.
		var vboDatasCount = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray.length;
		for (var j=0; j<vboDatasCount; j++)
		{
			var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[j];
			
			if (!vboViCacheKey.isReadyPositions(gl, magoManager.vboMemoryManager))
			{ succesfullyGpuDataBinded = false; }
			if (!vboViCacheKey.isReadyNormals(gl, magoManager.vboMemoryManager))
			{ succesfullyGpuDataBinded = false; }
			if (!vboViCacheKey.isReadyFaces(gl, magoManager.vboMemoryManager))
			{ succesfullyGpuDataBinded = false; }
		}
		
		// parse lego if exist.
		var existLego = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
		if (existLego)
		{
			if (block.lego === undefined)
			{ 
				// TODO : this is no used. delete this.***
				block.lego = new Lego(); 
			}
			
			bytesReaded = this.parseBlockVersioned(arrayBuffer, bytesReaded, block.lego, readWriter, magoManager) ;
		}

	}
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return succesfullyGpuDataBinded;
};


/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {arrayBuffer} arrayBuffer Binary data to parse.
 * @param {ReadWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array} motherBlocksArray Global blocks array.
 */
BlocksList.prototype.parseBlocksList = function(arrayBuffer, readWriter, motherBlocksArray, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytesReaded = 0;
	var blocksCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded + 4); bytesReaded += 4;
	
	var startBuff, endBuff;
	var posByteSize, norByteSize, idxByteSize;
	var vboMemManager = magoManager.vboMemoryManager;
	var classifiedPosByteSize = 0, classifiedNorByteSize = 0, classifiedIdxByteSize = 0;
	var gl = magoManager.sceneState.gl;
	var succesfullyGpuDataBinded = true;

	for ( var i = 0; i< blocksCount; i++ ) 
	{
		var blockIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		
		// Check if block exist.
		if (motherBlocksArray[blockIdx]) 
		{
			// The block exists, then read data but no create a new block.
			bytesReaded += 4 * 6; // boundingBox.
			// Read vbo datas (indices cannot superate 65535 value).
			var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
			
			for ( var j = 0; j < vboDatasCount; j++ ) 
			{
				// 1) Positions array.
				var vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var verticesFloatValuesCount = vertexCount * 3;
				startBuff = bytesReaded;
				endBuff = bytesReaded + 4 * verticesFloatValuesCount;
				bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.***

				// 2) Normals.
				vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var normalByteValuesCount = vertexCount * 3;
				bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.***

				// 3) Indices.
				var shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
				
				bytesReaded = bytesReaded + sizeLevels * 4;
				bytesReaded = bytesReaded + sizeLevels * 4;
				bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.***
			}
			// Pendent to load the block's lego.***
			continue;
		}
		
		// The block doesn't exist, so creates a new block and read data.
		var block = new Block();
		block.idx = blockIdx;
		motherBlocksArray[blockIdx] = block;
		
		// 1rst, read bbox.
		var bbox = new BoundingBox();
		bbox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;

		bbox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;

		var maxLength = bbox.getMaxLength();
		if (maxLength < 0.5) { block.isSmallObj = true; }
		else { block.isSmallObj = false; }

		block.radius = maxLength/2.0;

		bbox.deleteObjects();
		bbox = undefined;

		// New for read multiple vbo datas (indices cannot superate 65535 value).***
		var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
		bytesReaded += 4;
		for ( var j = 0; j < vboDatasCount; j++ ) 
		{
			// 1) Positions array.
			var vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
			bytesReaded += 4;
			var verticesFloatValuesCount = vertexCount * 3;
			// now padding the array to adjust to standard memory size of pool.
			posByteSize = 4 * verticesFloatValuesCount;
			classifiedPosByteSize = vboMemManager.getClassifiedBufferSize(posByteSize);
			
			block.vertexCount = vertexCount;
			startBuff = bytesReaded;
			endBuff = bytesReaded + 4 * verticesFloatValuesCount;
			var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
			vboViCacheKey.posVboDataArray = new Float32Array(classifiedPosByteSize);
			vboViCacheKey.posVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
			vboViCacheKey.posArrayByteSize = classifiedPosByteSize; 
			bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.***
			
			// 2) Normals.
			vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
			bytesReaded += 4;
			var normalByteValuesCount = vertexCount * 3;
			// now padding the array to adjust to standard memory size of pool.
			norByteSize = 1 * normalByteValuesCount;
			classifiedNorByteSize = vboMemManager.getClassifiedBufferSize(norByteSize);
			
			startBuff = bytesReaded;
			endBuff = bytesReaded + 1 * normalByteValuesCount;
			vboViCacheKey.norVboDataArray = new Int8Array(classifiedNorByteSize);
			vboViCacheKey.norVboDataArray.set(new Int8Array(arrayBuffer.slice(startBuff, endBuff)));
			vboViCacheKey.norArrayByteSize = classifiedNorByteSize;
			bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.***
			
			// 3) Indices.
			var shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
			// now padding the array to adjust to standard memory size of pool.
			idxByteSize = 2 * shortIndicesValuesCount;
			classifiedIdxByteSize = vboMemManager.getClassifiedBufferSize(idxByteSize);
			
			bytesReaded += 4;
			var sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1);
			bytesReaded +=1;
			var sizeThresholds = [];
			for ( var k = 0; k < sizeLevels; k++ )
			{
				sizeThresholds.push(new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)));
				bytesReaded += 4;
			}
			var indexMarkers = [];
			for ( var k = 0; k < sizeLevels; k++ )
			{
				indexMarkers.push(readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4));
				bytesReaded += 4;
			}
			var bigTrianglesShortIndicesValues_count = indexMarkers[sizeLevels-1];
			vboViCacheKey.bigTrianglesIndicesCount = bigTrianglesShortIndicesValues_count;
			startBuff = bytesReaded;
			endBuff = bytesReaded + 2 * shortIndicesValuesCount;

			vboViCacheKey.idxVboDataArray = new Int16Array(classifiedIdxByteSize);
			vboViCacheKey.idxVboDataArray.set(new Int16Array(arrayBuffer.slice(startBuff, endBuff)));
			vboViCacheKey.idxArrayByteSize = classifiedIdxByteSize;
			bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.***
			vboViCacheKey.indicesCount = shortIndicesValuesCount;

			posByteSize;
			norByteSize;
			idxByteSize;
			
			classifiedPosByteSize;
			classifiedNorByteSize;
			classifiedIdxByteSize;
			
			//var hola = 0;
			
			// test.
			if (!vboViCacheKey.isReadyPositions(gl, magoManager.vboMemoryManager))
			{ succesfullyGpuDataBinded = false; }
			if (!vboViCacheKey.isReadyNormals(gl, magoManager.vboMemoryManager))
			{ succesfullyGpuDataBinded = false; }
			if (!vboViCacheKey.isReadyFaces(gl, magoManager.vboMemoryManager))
			{ succesfullyGpuDataBinded = false; }
		}

		// Pendent to load the block's lego.***
	}
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return succesfullyGpuDataBinded;
};

/**
 * 블록 컨테이너
 * @class BlocksListsContainer
 */
var BlocksListsContainer = function() 
{
	if (!(this instanceof BlocksListsContainer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.blocksListsArray = [];
};

/**
 * 새 블록 리스트를 생성
 * @param blocksListName 변수
 * @returns blocksList
 */
BlocksListsContainer.prototype.newBlocksList = function(blocksListName) 
{
	var blocksList = new BlocksList();
	blocksList.name = blocksListName;
	this.blocksListsArray.push(blocksList);
	return blocksList;
};

/**
 * 블록 리스트 획득
 * @param blockList_name 변수
 * @returns blocksList
 */
BlocksListsContainer.prototype.getBlockList = function(blockList_name) 
{
	var blocksListsCount = this.blocksListsArray.length;
	var found = false;
	var i=0;
	var blocksList = null;
	while (!found && i<blocksListsCount) 
	{
		var currentBlocksList = this.blocksListsArray[i];
		if (currentBlocksList.name === blockList_name) 
		{
			found = true;
			blocksList = currentBlocksList;
		}
		i++;
	}
	return blocksList;
};

'use strict';



/**
 * 블럭 모델
 * @class HierarchyManager
 */
var HierarchyManager = function() 
{
	if (!(this instanceof HierarchyManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// lowest nodes array. initial array to create tiles global distribution.
	this.nodesArray = [];
	this.projectsMap = {};
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
HierarchyManager.prototype.deleteNodes = function(gl, vboMemoryManager) 
{
	//for (var value of this.projectsMap.values()) 
	//{
	//	value.clear();
	//}
	this.projectsMap = {};
	
	var nodesCount = this.nodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		if (this.nodesArray[i])
		{
			this.nodesArray[i].deleteObjects(gl, vboMemoryManager);
			this.nodesArray[i] = undefined;
		}
	}
	this.nodesArray.length = 0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
HierarchyManager.prototype.getNodeByDataName = function(projectId, dataName, dataNameValue) 
{
	// note: here "dataName" refers "nodeId", or other datas that can be inside of"data".***
	var nodesMap = this.getNodesMap(projectId);
	
	if (nodesMap === undefined)
	{ return undefined; }
	
	var resultNode;
	
	//for (var value of nodesMap.values()) 
	for (var key in nodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(nodesMap, key))
		{
			var value = nodesMap[key];
			if (value.data !== undefined && value.data[dataName] === dataNameValue)
			{
				resultNode = value;
				break;
			}
		}
	}
	
	return resultNode;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
HierarchyManager.prototype.getNodeByDataKey = function(projectId, dataKey) 
{
	var nodesMap = this.getNodesMap(projectId);
	
	if (nodesMap === undefined)
	{ return undefined; }
	
	var resultNode = nodesMap[dataKey];
	
	return resultNode;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
HierarchyManager.prototype.getRootNodes = function(resultRootNodesArray) 
{
	if (resultRootNodesArray === undefined)
	{ resultRootNodesArray = []; }
	
	var nodesCount = this.nodesArray.length;
	var node;
	for (var i=0; i<nodesCount; i++)
	{
		node = this.nodesArray[i];
		
		if (node.parent === undefined)
		{
			resultRootNodesArray.push(node);
		}
	}
	
	return resultRootNodesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
HierarchyManager.prototype.existProject = function(projectId) 
{
	return this.projectsMap.hasOwnProperty(projectId);
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
HierarchyManager.prototype.getNodesMap = function(projectId, attributes) 
{
	// 1rst, check if exist.
	var nodesMap = this.projectsMap[projectId];
	if (nodesMap === undefined)
	{
		nodesMap = {};
		if (attributes !== undefined)
		{ nodesMap.attributes = attributes; }
		this.projectsMap[projectId] = nodesMap;
	}
	else 
	{
		if (attributes !== undefined && nodesMap.attributes === undefined)
		{ nodesMap.attributes = attributes; }
	}
	return nodesMap;
};


/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
HierarchyManager.prototype.newNode = function(id, projectId, attributes) 
{
	var nodesMap = this.getNodesMap(projectId, attributes);
	
	var node = new Node();
	node.data = {"nodeId": id};
	this.nodesArray.push(node);
	nodesMap[id] = node;
	return node;
};


'use strict';

/**
 * @class InspectorBox
 */
var InspectorBox = function() 
{
	if (!(this instanceof InspectorBox)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	

};
'use strict';

/**
 * F4D Lego 클래스
 * 
 * @alias Lego
 * @class Lego
 */
var Lego = function() 
{
	if (!(this instanceof Lego)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	this.fileLoadState = CODE.fileLoadState.READY;
	this.bbox;
	this.dataArrayBuffer;
	this.selColor4;
	this.hasTexCoords;
	this.texture;
	this.textureName;
	this.legoKey;
	
	// extra vars.***
	this.renderableType; // triangles, lines, points, etc.***
	this.hasColors;
	
};

/**
 * F4D Lego 자료를 읽는다
 * 
 * @param {any} gl 
 * @param {any} readWriter 
 * @param {any} dataArraybuffer 
 * @param {any} bytesReaded 
 */
Lego.prototype.parseArrayBuffer = function(gl, dataArraybuffer, magoManager)
{
	this.parseLegoData(dataArraybuffer, gl, magoManager);
};

/**
 * F4D Lego 자료를 읽는다
 * 
 */
Lego.prototype.isReadyToRender = function()
{
	if (this.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }
	
	if (this.texture === undefined || this.texture.texId === undefined)
	{ return false; }
	
	return true;
};

/**
 * F4D Lego 자료를 읽는다
 * 
 * @param {any} gl 
 * @param {any} readWriter 
 * @param {any} dataArraybuffer 
 * @param {any} bytesReaded 
 */
Lego.prototype.deleteObjects = function(gl, vboMemManager)
{
	if (this.vbo_vicks_container !== undefined)
	{
		this.vbo_vicks_container.deleteGlObjects(gl, vboMemManager);
		this.vbo_vicks_container = undefined;
	}
	this.fileLoadState = undefined;
	this.dataArrayBuffer = undefined;
	if (this.selColor4 !== undefined)
	{
		this.selColor4.deleteObjects();
		this.selColor4 = undefined;
	}
	
	this.textureName = undefined;
	if (this.texture)
	{
		this.texture.deleteObjects(gl);
	}
	this.texture = undefined;
	if (this.bbox)
	{
		this.bbox.deleteObjects();
	}
	this.bbox = undefined;
};

/**
 * F4D Lego 자료를 읽는다
 * 
 * @param {ArrayBuffer} buffer 
 */
Lego.prototype.parsePointsCloudData = function(buffer, gl, magoManager)
{
	if (this.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)	{ return; }
	var stream = new DataStream(buffer, 0, DataStream.LITTLE_ENDIAN);
	
	var verticesCount = stream.readInt32();
	
	if (verticesCount > 70000000)
	{ var hola = 0; }
	
	var vboMemManager = magoManager.vboMemoryManager;
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	this.bbox = new BoundingBox();
	var bbox = this.bbox;
	var vboCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();

	// BoundingBox in float values.***
	bbox.minX = stream.readFloat32();
	bbox.minY = stream.readFloat32();
	bbox.minZ = stream.readFloat32();
	bbox.maxX = stream.readFloat32();
	bbox.maxY = stream.readFloat32();
	bbox.maxZ = stream.readFloat32();
	
	// positionsBuffer.***
	// read bPositionsCompressed. If this var is true -> positions is in uShort).***
	this.bPositionsCompressed = stream.readInt8();
	var posByteSize = verticesCount * 3;
	var classifiedPosByteSize = vboMemManager.getClassifiedBufferSize(posByteSize);
	var positionBuffer;
	
	if (this.bPositionsCompressed)
	{
		positionBuffer = new Uint16Array(classifiedPosByteSize);
		positionBuffer.set(stream.readUint16Array(verticesCount * 3));
	}
	else 
	{
		positionBuffer = new Float32Array(classifiedPosByteSize);
		positionBuffer.set(stream.readFloat32Array(verticesCount * 3));
	}
	
	vboCacheKey.vertexCount = verticesCount;
	vboCacheKey.posVboDataArray = positionBuffer;
	vboCacheKey.posArrayByteSize = classifiedPosByteSize; 
	// (5120 : signed byte), (5121 : unsigned byte), (5122 : signed short), (5123 : unsigned short), (5126 : float).***
	vboCacheKey.posArrayByteType = 5123; // unsigned short.***
	
	// normals.***
	this.hasNormals = stream.readInt8();
	
	// colors.***
	this.hasColors = stream.readInt8();
	if (this.hasColors)
	{
		var numColors = verticesCount;
		var colByteSize = numColors * 4;
		var classifiedColByteSize = vboMemManager.getClassifiedBufferSize(colByteSize);
		var colorBuffer = new Uint8Array(classifiedColByteSize);
		colorBuffer.set(stream.readUint8Array(numColors * 4));

		vboCacheKey.colVboDataArray = colorBuffer;
		vboCacheKey.colArrayByteSize = classifiedColByteSize;
		vboCacheKey.colArrayByteType = 5121; // unsigned byte.***
	}
	
	// texCoords.***
	this.hasTexCoords = stream.readInt8();
	
	// indices.***
	this.hasIndices = stream.readInt8();
	
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	
};

/**
 * F4D Lego 자료를 읽는다
 * 
 * @param {ArrayBuffer} buffer 
 */
Lego.prototype.parseLegoData = function(buffer, gl, magoManager)
{
	if (this.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)	{ return; }
	
	var vboMemManager = magoManager.vboMemoryManager;

	var stream = new DataStream(buffer, 0, DataStream.LITTLE_ENDIAN);
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	this.bbox = new BoundingBox();
	var bbox = this.bbox;
	var vboCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();

	// BoundingBox
	bbox.minX = stream.readFloat32();
	bbox.minY = stream.readFloat32();
	bbox.minZ = stream.readFloat32();
	bbox.maxX = stream.readFloat32();
	bbox.maxY = stream.readFloat32();
	bbox.maxZ = stream.readFloat32();

	// VBO(Position Buffer) - x,y,z
	var numPositions = stream.readUint32();
	var posByteSize = numPositions * 3;
	var classifiedPosByteSize = vboMemManager.getClassifiedBufferSize(posByteSize);
	var positionBuffer = new Float32Array(classifiedPosByteSize);
	positionBuffer.set(stream.readFloat32Array(numPositions * 3));

	vboCacheKey.vertexCount = numPositions;
	vboCacheKey.posVboDataArray = positionBuffer;
	vboCacheKey.posArrayByteSize = classifiedPosByteSize; 
	// (5120 : signed byte), (5121 : unsigned byte), (5122 : signed short), (5123 : unsigned short), (5126 : float).***
	//vboCacheKey.posArrayByteType = 5123; // unsigned short.***

	// VBO(Normal Buffer) - i,j,k
	var hasNormals = stream.readUint8();
	if (hasNormals) 
	{
		var numNormals = stream.readUint32();
		var norByteSize = numNormals * 3;
		var classifiedNorByteSize = vboMemManager.getClassifiedBufferSize(norByteSize);
		var normalBuffer = new Int8Array(classifiedNorByteSize);
		normalBuffer.set(stream.readInt8Array(numNormals * 3));

		vboCacheKey.norVboDataArray = normalBuffer;
		vboCacheKey.norArrayByteSize = classifiedNorByteSize;
	}

	// VBO(Color Buffer) - r,g,b,a
	var hasColors = stream.readUint8();
	if (hasColors)
	{
		var numColors = stream.readUint32();
		var colByteSize = numColors * 4;
		var classifiedColByteSize = vboMemManager.getClassifiedBufferSize(colByteSize);
		var colorBuffer = new Uint8Array(classifiedColByteSize);
		colorBuffer.set(stream.readUint8Array(numColors * 4));

		vboCacheKey.colVboDataArray = colorBuffer;
		vboCacheKey.colArrayByteSize = classifiedColByteSize;
	}

	// VBO(TextureCoord Buffer) - u,v
	this.hasTexCoords = stream.readUint8();
	if (this.hasTexCoords)
	{
		var dataType = stream.readUint16();
		var numCoords = stream.readUint32();
		var tCoordByteSize = 2 * numCoords;
		var classifiedTCoordByteSize = vboMemManager.getClassifiedBufferSize(tCoordByteSize);
		var coordBuffer = new Float32Array(classifiedTCoordByteSize);
		coordBuffer.set(stream.readFloat32Array(numCoords * 2));

		vboCacheKey.tcoordVboDataArray = coordBuffer; // original.***
		vboCacheKey.tcoordArrayByteSize = classifiedTCoordByteSize;
		//vboCacheKey.tcoordArrayByteType = 5123; // unsigned short.***
	}

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	
	var succesfullyGpuDataBinded = true;
	if (!vboCacheKey.isReadyPositions(gl, magoManager.vboMemoryManager))
	{ succesfullyGpuDataBinded = false; }
	if (!vboCacheKey.isReadyNormals(gl, magoManager.vboMemoryManager))
	{ succesfullyGpuDataBinded = false; }
	if (!vboCacheKey.isReadyColors(gl, magoManager.vboMemoryManager))
	{ succesfullyGpuDataBinded = false; }

	// 4) Texcoord.*********************************************
	if (this.hasTexCoords)
	{
		if (!vboCacheKey.isReadyTexCoords(gl, magoManager.vboMemoryManager))
		{ succesfullyGpuDataBinded = false; }
	}	
	return succesfullyGpuDataBinded;
};




















'use strict';

/**
 * LoadData
 * 
 * @alias LoadData
 * @class LoadData
 */
var LoadData = function() 
{
	if (!(this instanceof LoadData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// dataType:
	// 1. referencesArray.
	// 2. blocksArray.
	// 3. skinData. (octree's skinData & lod3,4,5 skinData).
	// 4. skinTexture.
	
	this.dataType;
	this.distToCam;
	this.lod;
	this.filePath;
	this.texFilePath;
	this.skinMesh;
	this.octree;
	this.texture;
};

LoadData.prototype.deleteObjects = function()
{
	// here deletes deletable objects.***
	this.dataType = undefined;
	this.distToCam = undefined;
	this.lod = undefined;
	this.filePath = undefined;
	this.texFilePath = undefined;
	this.skinMesh = undefined;
	this.octree = undefined;
	this.texture = undefined;
};

/**
 * LoadQueue
 * 
 * @alias LoadQueue
 * @class LoadQueue
 */
var LoadQueue = function(magoManager) 
{
	if (!(this instanceof LoadQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.magoManager;
	
	if (magoManager !== undefined)
	{ this.magoManager = magoManager; }
	
	this.lod2SkinDataMap = {}; // includes data & texture.***
	this.lod2PCloudDataMap = {}; 
	
	this.lowLodSkinDataMap = {};
	this.lowLodSkinTextureMap = {};

	//this.referencesToLoadMap = {};
};

LoadQueue.prototype.putLod2SkinData = function(octree, filePath, texture, texFilePath, aValue)
{
	// "aValue" no used yet.***
	octree.lego.fileLoadState = CODE.fileLoadState.IN_QUEUE;
	var loadData = new LoadData();
	loadData.filePath = filePath;
	loadData.octree = octree;
	
	loadData.texFilePath = texFilePath;
	loadData.texture = texture;
	
	this.lod2SkinDataMap[filePath] = loadData;
};

LoadQueue.prototype.putLod2PCloudData = function(octree, filePath, texture, texFilePath, aValue)
{
	// "aValue" no used yet.***
	octree.lego.fileLoadState = CODE.fileLoadState.IN_QUEUE;
	var loadData = new LoadData();
	loadData.filePath = filePath;
	loadData.octree = octree;
	
	loadData.texFilePath = texFilePath;
	loadData.texture = texture;
	
	this.lod2PCloudDataMap[filePath] = loadData;
};

LoadQueue.prototype.putLowLodSkinData = function(skinMesh, filePath, aValue)
{
	// "aValue" no used yet.***
	skinMesh.fileLoadState = CODE.fileLoadState.IN_QUEUE;
	
	var loadData = new LoadData();
	loadData.dataType = 3;
	loadData.filePath = filePath;
	loadData.skinMesh = skinMesh;
	this.lowLodSkinDataMap[skinMesh.legoKey] = loadData;
};

LoadQueue.prototype.putLowLodSkinTexture = function(filePath, texture, aValue)
{
	// "aValue" no used yet.***
	texture.fileLoadState = CODE.fileLoadState.IN_QUEUE;
	
	var loadData = new LoadData();
	loadData.dataType = 4;
	loadData.filePath = filePath;
	loadData.texture = texture;
	this.lowLodSkinTextureMap[filePath] = loadData;
};

LoadQueue.prototype.resetQueue = function()
{
	for (var key in this.lod2SkinDataMap)
	{
		var loadData = this.lod2SkinDataMap[key];
		if (loadData.octree === undefined || loadData.octree.lego === undefined)
		{ continue; }
		
		loadData.octree.lego.fileLoadState = CODE.fileLoadState.READY;
	}
	
	this.lod2SkinDataMap = {};
	
	// Low lod meshes.***
	for (var key in this.lowLodSkinDataMap)
	{
		var loadData = this.lowLodSkinDataMap[key];
		if (loadData.skinMesh === undefined)
		{ continue; }
		
		loadData.skinMesh.fileLoadState = CODE.fileLoadState.READY;
	}
	
	this.lowLodSkinDataMap = {};
	
	for (var key in this.lowLodSkinTextureMap)
	{
		var loadData = this.lowLodSkinTextureMap[key];
		if (loadData.texture === undefined)
		{ continue; }
		
		loadData.texture.fileLoadState = CODE.fileLoadState.READY;
	}
	
	this.lowLodSkinTextureMap = {};
	
	for (var key in this.lod2PCloudDataMap)
	{
		var loadData = this.lod2PCloudDataMap[key];
		if (loadData.octree === undefined || loadData.octree.lego === undefined)
		{ continue; }
		
		loadData.octree.lego.fileLoadState = CODE.fileLoadState.READY;
	}
	
	this.lod2PCloudDataMap = {};
};

LoadQueue.prototype.manageQueue = function()
{
	var maxFileLoad = 1;
	var readerWriter = this.magoManager.readerWriter;
	var gl = this.magoManager.sceneState.gl;
	var counter = 0;
	var remainLod2 = false;
	
	// Lod2 meshes, 1rst load texture.***.***
	counter = 0;
	for (var key in this.lod2SkinDataMap)
	{
		var loadData = this.lod2SkinDataMap[key];
		var octree = loadData.octree;
		var filePath = loadData.filePath;
		
		if (octree.lego !== undefined)
		{
			if (loadData.texture !== undefined && loadData.texture.fileLoadState === CODE.fileLoadState.READY)
			{ 
				readerWriter.readLegoSimpleBuildingTexture(gl, loadData.texFilePath, loadData.texture, this.magoManager); 
				counter += 4;
			}
			
			readerWriter.getOctreeLegoArraybuffer(filePath, octree, this.magoManager);
		}
		else
		{ var hola = 0; }
		
		delete this.lod2SkinDataMap[key];
		loadData.deleteObjects();
		loadData = undefined;

		counter++;
		if (counter > 4)
		{
			//this.lod2SkinDataMap = {};
			remainLod2 = true;
			break;
		}
	}
	
	if (this.magoManager.fileRequestControler.isFullPlusLowLodImages())	
	{ 
		return; 
	}
	
	// Low lod meshes ( lod 3, 4, 5).***
	counter = 0;
	for (var key in this.lowLodSkinTextureMap)
	{
		var loadData = this.lowLodSkinTextureMap[key];
		var skinMesh = loadData.skinMesh;
		var filePath = loadData.filePath;
		readerWriter.readLegoSimpleBuildingTexture(gl, filePath, loadData.texture, this.magoManager);
		
		delete this.lowLodSkinTextureMap[key];
		loadData.deleteObjects();
		loadData = undefined;
		
		counter++;
		if (counter > maxFileLoad)
		{ break; }
	}
	
	counter = 0;
	for (var key in this.lowLodSkinDataMap)
	{
		var loadData = this.lowLodSkinDataMap[key];
		var skinMesh = loadData.skinMesh;
		var filePath = loadData.filePath;
		readerWriter.getLegoArraybuffer(filePath, skinMesh, this.magoManager);
		
		delete this.lowLodSkinDataMap[key];
		loadData.deleteObjects();
		loadData = undefined;
		
		counter++;
		if (counter > maxFileLoad)
		{ break; }
	}
	
	// pCloud data.***
	counter = 0;
	for (var key in this.lod2PCloudDataMap)
	{
		var loadData = this.lod2PCloudDataMap[key];
		var octree = loadData.octree;
		var filePath = loadData.filePath;
		
		if (octree.lego !== undefined)
		{
			readerWriter.getOctreePCloudArraybuffer(filePath, octree, this.magoManager);
		}
		else
		{ var hola = 0; }
		
		delete this.lod2PCloudDataMap[key];
		loadData.deleteObjects();
		loadData = undefined;

		counter++;
		if (counter > 4)
		{
			//this.lod2PCloudDataMap = {};
			remainLod2 = true;
			break;
		}
	}
	
	this.resetQueue();
};






























'use strict';

/**
 * F4D LodBuildingData 클래스
 * 
 * @alias LodBuildingData
 * @class LodBuildingData
 */
var LodBuildingData = function() 
{
	if (!(this instanceof LodBuildingData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.lod;
	this.isModelRef;
	this.geometryFileName;
	this.textureFileName;
	//this.dataType; // no used yet.***
};
'use strict';

/**
 * F4D MetaData 클래스
 * 
 * @alias MetaData
 * @class MetaData
 */
var MetaData = function() 
{
	if (!(this instanceof MetaData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.guid; // must be undefined initially.***
	this.version = "";
	this.geographicCoord; // longitude, latitude, altitude.***

	this.heading;
	this.pitch;
	this.roll;

	this.bbox; // BoundingBox.***
	this.imageLodCount;
	
	this.projectDataType;
	this.offSetX;
	this.offSetY;
	this.offSetZ;

	// Buildings octree mother size.***
	this.oct_min_x = 0.0;
	this.oct_max_x = 0.0;
	this.oct_min_y = 0.0;
	this.oct_max_y = 0.0;
	this.oct_min_z = 0.0;
	this.oct_max_z = 0.0;

	this.isSmall = false;
	this.fileLoadState = CODE.fileLoadState.READY;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param arrayBuffer 변수
 * @param readWriter 변수
 */
MetaData.prototype.deleteObjects = function() 
{
	this.guid = undefined; // must be undefined initially.***
	//this.version = undefined;
	if (this.geographicCoord)
	{ this.geographicCoord.deleteObjects(); }
	this.geographicCoord = undefined; // longitude, latitude, altitude.***

	this.heading = undefined;
	this.pitch = undefined;
	this.roll = undefined;

	if (this.bbox)
	{ this.bbox.deleteObjects(); }
	this.bbox = undefined; // BoundingBox.***
	this.imageLodCount = undefined;

	// Buildings octree mother size.***
	this.oct_min_x = undefined;
	this.oct_max_x = undefined;
	this.oct_min_y = undefined;
	this.oct_max_y = undefined;
	this.oct_min_z = undefined;
	this.oct_max_z = undefined;

	this.isSmall = undefined;
	this.fileLoadState = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param arrayBuffer 변수
 * @param readWriter 변수
 */
MetaData.prototype.parseFileHeaderAsimetricVersion = function(arrayBuffer, readWriter) 
{
	var version_string_length = 5;
	var intAux_scratch = 0;
	var bytes_readed = 0;

	if (readWriter === undefined) { readWriter = new ReaderWriter(); }

	// 1) Version(5 chars).***********
	this.version = "";
	for (var j=0; j<version_string_length; j++)
	{
		this.version += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
	}

	// 3) Global unique ID.*********************
	if (this.guid === undefined) { this.guid =""; }

	intAux_scratch = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var j=0; j<intAux_scratch; j++)
	{
		this.guid += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
	}

	// 4) Location.*************************
	if (this.longitude === undefined) 
	{
		this.longitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	}
	else { bytes_readed += 8; }

	if (this.latitude === undefined) 
	{
		this.latitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	}
	else { bytes_readed += 8; }

	if (this.altitude === undefined) 
	{
		this.altitude = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	}
	else { bytes_readed += 4; }

	if (this.bbox === undefined) { this.bbox = new BoundingBox(); }

	// 6) BoundingBox.************************
	this.bbox.minX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.minY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.minZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.maxX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.maxY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	this.bbox.maxZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;

	var isLarge = false;
	if (this.bbox.maxX - this.bbox.minX > 40.0 || this.bbox.maxY - this.bbox.minY > 40.0) 
	{
		isLarge = true;
	}

	if (!isLarge && this.bbox.maxZ - this.bbox.minZ < 30.0) 
	{
		this.isSmall = true;
	}
	
	// if header version is "0.0.2", then must read extra parameters.***
	if (this.version === "0.0.2")
	{
		// parse dataType (unsigned short).***
		this.projectDataType = (new Uint16Array(arrayBuffer.slice(bytes_readed, bytes_readed+2)))[0]; bytes_readed += 2;
		
		// parse Project's offSet (double x 6).***
		this.offSetX = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
		this.offSetY = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
		this.offSetZ = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	}

	return bytes_readed;
};


























'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ModelReferencedGroup
 */
var ModelReferencedGroup = function() 
{
	if (!(this instanceof ModelReferencedGroup)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.modelIdx; // there are only one model.
	this.referencesIdxArray = []; // all references has the same model.
};


/**
 * 어떤 일을 하고 있습니까?
 * @class ModelReferencedGroupsList
 */
var ModelReferencedGroupsList = function() 
{
	if (!(this instanceof ModelReferencedGroupsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.modelReferencedGroupsMap = [];
	this.modelReferencedGroupsArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.getModelReferencedGroup = function(modelIdx) 
{
	var modelReferencedGroup = this.modelReferencedGroupsMap[modelIdx];
	
	if (modelReferencedGroup === undefined)
	{
		modelReferencedGroup = new ModelReferencedGroup();
		modelReferencedGroup.modelIdx = modelIdx;
		this.modelReferencedGroupsMap[modelIdx] = modelReferencedGroup;
	}
	
	return modelReferencedGroup;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.makeModelReferencedGroupsArray = function() 
{
	this.modelReferencedGroupsArray.length = 0;
	
	var modelRefGroupsCount = this.modelReferencedGroupsMap.length;
	for (var i=0; i<modelRefGroupsCount; i++)
	{
		if (this.modelReferencedGroupsMap[i] !== undefined)
		{ this.modelReferencedGroupsArray.push(this.modelReferencedGroupsMap[i]); }
	}
	this.modelReferencedGroupsMap.length = 0;
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.createModelReferencedGroups = function(neoRefsIndices, motherNeoRefsList) 
{
	// Group all the references that has the same model.
	if (neoRefsIndices === undefined)
	{ return; }
	
	if (motherNeoRefsList === undefined)
	{ return; }
	
	var referenceIdx;
	var modelIdx;
	var modelRefGroup;
	var referencesCount = neoRefsIndices.length;
	for (var i=0; i<referencesCount; i++)
	{
		referenceIdx = neoRefsIndices[i];
		modelIdx = motherNeoRefsList[referenceIdx]._block_idx;
		modelRefGroup = this.getModelReferencedGroup(modelIdx);
		modelRefGroup.referencesIdxArray.push(referenceIdx);
	}
	
	// Now, delete the "modelReferencedGroupsMap" and make a simple array.
	this.makeModelReferencedGroupsArray();
	
};





'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoBuilding
 */
var NeoBuilding = function() 
{
	if (!(this instanceof NeoBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.name = "";
	this.metaData;
	this.buildingId;
	this.buildingType; // use this for classify a building.***
	this.buildingFileName = "";
	this.bbox;
	this.bboxAbsoluteCenterPos;
	
	// References and Models.*********************************************
	this.motherNeoReferencesArray = []; 
	this.motherNeoReferencesMap; 
	this.motherBlocksArray = []; 
	
	// Current visible objects.*******************************************
	this.currentVisibleOctreesControler; //  class VisibleObjectsControler;
	
	// Aditional Color.***************************************************
	this.isHighLighted;
	this.isColorChanged;
	this.aditionalColor; // use for colorChanged.***

	// Textures loaded.***************************************************
	this.texturesLoaded; // material textures.***

	// The octree.********************************************************
	this.octree; // f4d_octree. ***

	// auxiliar vars.
	this.distToCam; // used to sort neoBuildings by distance to cam, and other things.***
	this.currentLod;

	// The simple building.***********************************************
	this.simpleBuilding3x3Texture; // old version.***
	
	// In version 001, there are 6 lods.***
	this.lodMeshesMap;
	this.lodBuildingDatasMap;
	
	// Render settings.***************************************************
	// provisionally put this here.
	this.applyOcclusionCulling;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getImageFileNameForLOD = function(lod) 
{
	var lodBuildingData = this.getLodBuildingData(lod);
	
	if (lodBuildingData === undefined)
	{ return undefined; }
	
	return lodBuildingData.textureFileName;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getReferenceObject = function(refObjectIndex) 
{
	if (this.motherNeoReferencesArray === undefined)
	{ return undefined; }
	return this.motherNeoReferencesArray[refObjectIndex];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getReferenceObjectsArrayByObjectId = function(objectId) 
{
	if (this.motherNeoReferencesMap === undefined)
	{ return undefined; }

	var refObject = this.motherNeoReferencesMap[objectId];
	return refObject;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.putReferenceObject = function(refObject, refObjectIdx) 
{
	// function called by "NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferencesVersioned".***
	if (this.motherNeoReferencesArray === undefined)
	{ this.motherNeoReferencesArray = []; }

	this.motherNeoReferencesArray[refObjectIdx] = refObject;
	
	// Additionally, make a objects map.
	if (this.motherNeoReferencesMap === undefined)
	{ this.motherNeoReferencesMap = {}; }
	
	var objectsArray = this.motherNeoReferencesMap[refObject.objectId];
	if (objectsArray === undefined)
	{ objectsArray = []; }
	
	objectsArray.push(refObject);
	
	this.motherNeoReferencesMap[refObject.objectId] = objectsArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getRenderSettingApplyOcclusionCulling = function() 
{
	return this.applyOcclusionCulling;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.setRenderSettingApplyOcclusionCulling = function(applyOcclusionCulling) 
{
	this.applyOcclusionCulling = applyOcclusionCulling;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsModelReferences = function(gl, vboMemoryManager) 
{
	// 1rst, clear this.motherNeoReferencesMap.
	if (this.motherNeoReferencesMap)
	{ 
		this.motherNeoReferencesMap = {}; 
		this.motherNeoReferencesMap = undefined;
	}
	
	var blocksCount = this.motherBlocksArray.length;
	for (var i=0; i<blocksCount; i++)
	{
		if (this.motherBlocksArray[i])
		{ this.motherBlocksArray[i].deleteObjects(gl, vboMemoryManager); }
		this.motherBlocksArray[i] = undefined;
	}
	this.motherBlocksArray = [];

	var referencesCount = this.motherNeoReferencesArray.length;
	for (var i=0; i<referencesCount; i++)
	{
		if (this.motherNeoReferencesArray[i])
		{ this.motherNeoReferencesArray[i].deleteObjects(gl, vboMemoryManager); }
		this.motherNeoReferencesArray[i] = undefined;
	}
	this.motherNeoReferencesArray = [];
	
	// delete textures on the GPU.***.
	if (this.texturesLoaded)
	{
		var texture;
		var texturesCount = this.texturesLoaded.length;
		for (var i=0; i<texturesCount; i++)
		{
			texture = this.texturesLoaded[i];
			if (texture)
			{
				if (texture.texId)
				{
					gl.deleteTexture(texture.texId);
					texture.texId = undefined;
					texture.fileLoadState = CODE.fileLoadState.READY;
				}
			}
		}
	}

};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsLodMesh = function(gl, vboMemoryManager, lodMeshKey) 
{
	// TEST delete lod 3.***
	if (this.lodMeshesMap !== undefined)
	{
		if (Object.prototype.hasOwnProperty.call(this.lodMeshesMap, lodMeshKey))
		{
			var legoSkin = this.lodMeshesMap[lodMeshKey];
			if (legoSkin === undefined)
			{ return; }
			
			delete this.lodMeshesMap[lodMeshKey];
			legoSkin.deleteObjects(gl, vboMemoryManager);
			legoSkin = undefined;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsLod2 = function(gl, vboMemoryManager) 
{
	if (this.octree !== undefined)
	{ 
		// deletes the geometry and the texture.***
		this.octree.deleteObjectsLego(gl, vboMemoryManager); 
	}
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjects = function(gl, vboMemoryManager, deleteMetadata) 
{
	if (deleteMetadata)
	{
		this.metaData.deleteObjects();
		this.metaData.fileLoadState = CODE.fileLoadState.READY;
	}

	this.deleteObjectsModelReferences(gl, vboMemoryManager);

	// The octree.
	if (this.octree !== undefined)
	{ this.octree.deleteObjects(gl, vboMemoryManager); }
	this.octree = undefined; // f4d_octree. Interior objects.***
	
	//this.buildingFileName = "";

	this.allFilesLoaded = false;
	this.isReadyToRender = false;

	// delete textures.
	if (this.texturesLoaded)
	{
		var texturesCount = this.texturesLoaded.length;
		for (var i=0; i<texturesCount; i++)
		{
			if (this.texturesLoaded[i])
			{
				this.texturesLoaded[i].deleteObjects(gl);
			}
			this.texturesLoaded[i] = undefined;
		}
		this.texturesLoaded.length = 0;
	}
	this.texturesLoaded = undefined;
	
	// delete lod3, lod4, lod5.***
	if (this.lodMeshesMap !== undefined)
	{
		for (var key in this.lodMeshesMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.lodMeshesMap, key))
			{
				var legoSkin = this.lodMeshesMap[key];
				if (legoSkin === undefined)
				{ continue; }
				legoSkin.deleteObjects(gl, vboMemoryManager);
				legoSkin = undefined;
			}
		}
		this.lodMeshesMap = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteLodMesh = function(gl, lod, vboMemoryManager) 
{
	if (this.lodMeshesMap !== undefined)
	{
		var legoSkin = this.lodMeshesMap[lod];
		if (legoSkin !== undefined)
		{
			legoSkin.deleteObjects(gl, vboMemoryManager);
			legoSkin = undefined;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	if (this.bboxAbsoluteCenterPos === undefined)
	{
		this.calculateBBoxCenterPositionWorldCoord(geoLoc);
	}
	
	return this.bboxAbsoluteCenterPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.calculateBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	var bboxCenterPoint;
	
	bboxCenterPoint = this.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
	this.bboxAbsoluteCenterPos = geoLoc.tMatrix.transformPoint3D(bboxCenterPoint, this.bboxAbsoluteCenterPos);
	
	// Now, must applicate the aditional translation vector. Aditional translation is made when we translate the pivot point.
	if (geoLoc.pivotPointTraslation)
	{
		var traslationVector;
		traslationVector = geoLoc.tMatrix.rotatePoint3D(geoLoc.pivotPointTraslation, traslationVector );
		this.bboxAbsoluteCenterPos.add(traslationVector.x, traslationVector.y, traslationVector.z);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getTextureId = function(texture) 
{
	var texId;
	var texturesLoadedCount = this.texturesLoaded.length;
	var find = false;
	var i=0;
	while (!find && i < texturesLoadedCount ) 
	{
		if (this.texturesLoaded[i].textureImageFileName === texture.textureImageFileName) 
		{
			find = true;
			texId = this.texturesLoaded[i].texId;
		}
		i++;
	}

	return texId;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getSameTexture = function(texture) 
{
	var sameTexture;
	var texturesLoadedCount = this.texturesLoaded.length;
	var find = false;
	var i=0;
	while (!find && i < texturesLoadedCount ) 
	{
		if (this.texturesLoaded[i].textureImageFileName === texture.textureImageFileName) 
		{
			find = true;
			sameTexture = this.texturesLoaded[i];
		}
		i++;
	}

	return sameTexture;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eyeX 변수
 * @param eyeY 변수
 * @param eyeZ 변수
 */
NeoBuilding.prototype.updateCurrentVisibleIndicesExterior = function(eyeX, eyeY, eyeZ) 
{
	this._neoRefLists_Container.updateCurrentVisibleIndicesOfLists(eyeX, eyeY, eyeZ);
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.updateCurrentAllIndicesExterior = function() 
{
	this._neoRefLists_Container.updateCurrentAllIndicesOfLists();
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns metaData.bbox.isPoint3dInside(eyeX, eyeY, eyeZ);
 */
NeoBuilding.prototype.isCameraInsideOfBuilding = function(eyeX, eyeY, eyeZ) 
{
	return this.metaData.bbox.isPoint3dInside(eyeX, eyeY, eyeZ);
	/*
	var intersectedOctree = this.octree.getIntersectedSubBoxByPoint3D(eyeX, eyeY, eyeZ);
	if(intersectedOctree)
	{
		if(intersectedOctree.triPolyhedronsCount > 0)
			return true;
		else
			return false;
	}
	else
		return false;
	*/
};

/**
 * 어떤 일을 하고 있습니까?
 * @param absoluteEyeX 변수
 * @param absoluteEyeY 변수
 * @param absoluteEyeZ 변수
 * @returns point3dScrath2
 */
NeoBuilding.prototype.getTransformedRelativeEyePositionToBuilding = function(absoluteEyeX, absoluteEyeY, absoluteEyeZ, resultRelEyePosToBuilding) 
{
	// 1rst, calculate the relative eye position.***
	var buildingPosition = this.buildingPosition;
	var relativeEyePosX = absoluteEyeX - buildingPosition.x;
	var relativeEyePosY = absoluteEyeY - buildingPosition.y;
	var relativeEyePosZ = absoluteEyeZ - buildingPosition.z;

	if (this.buildingPosMatInv === undefined) 
	{
		this.buildingPosMatInv = new Matrix4();
		this.buildingPosMatInv.setByFloat32Array(this.moveMatrixInv);
	}

	var point3dScratch = new Point3D();
	
	if (resultRelEyePosToBuilding === undefined)
	{ resultRelEyePosToBuilding = new Point3D(); }
	
	point3dScratch.set(relativeEyePosX, relativeEyePosY, relativeEyePosZ);
	resultRelEyePosToBuilding = this.buildingPosMatInv.transformPoint3D(point3dScratch, resultRelEyePosToBuilding);

	return resultRelEyePosToBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getHeaderVersion = function() 
{
	return this.metaData.version;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param lod 변수
 */
NeoBuilding.prototype.getLodBuildingData = function(lod) 
{
	if (this.lodBuildingDatasMap === undefined)
	{ return undefined; }
	
	return this.lodBuildingDatasMap[lod];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getCurrentLodString = function() 
{
	var currentLodString = undefined;
	var lodBuildingData = this.getLodBuildingData(this.currentLod);
	currentLodString = lodBuildingData.geometryFileName;
	return currentLodString;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getCurrentSkin = function() 
{
	if (this.lodMeshesMap === undefined)
	{ return undefined; }
	
	var skinLego;
	//var currLodString = this.getCurrentLodString();
	//skinLego = this.lodMeshesMap[currLodString];
	//if(skinLego)
	//var hola = 0;
	
	//return skinLego;
	
	var lodBuildingData = this.getLodBuildingData(this.currentLod);
	if (lodBuildingData === undefined)
	{ return; }
		
	//textureFileName = lodBuildingData.textureFileName;
	var lodString = lodBuildingData.geometryFileName;
	skinLego = this.lodMeshesMap[lodString];
		
	if (skinLego !== undefined && skinLego.isReadyToRender())
	{ return skinLego; }
		
	
	if (this.currentLod === 0)
	{
		skinLego = this.lodMeshesMap.lod0;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod1;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod2;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod3;
					if (skinLego === undefined || !skinLego.isReadyToRender())
					{
						skinLego = this.lodMeshesMap.lod4;
						if (skinLego === undefined || !skinLego.isReadyToRender())
						{
							skinLego = this.lodMeshesMap.lod5;
						}
					}
				}
			}
		}
		
	}
	else if (this.currentLod === 1)
	{
		skinLego = this.lodMeshesMap.lod1;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod2;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod3;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod4;
					if (skinLego === undefined || !skinLego.isReadyToRender())
					{
						skinLego = this.lodMeshesMap.lod5;
					}
				}
			}
		}
		
	}
	else if (this.currentLod === 2)
	{
		skinLego = this.lodMeshesMap.lod2;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod3;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod4;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod5;
				}
			}
		}
		
	}
	else if (this.currentLod === 3)
	{
		skinLego = this.lodMeshesMap.lod3;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod4;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod5;
			}
		}
		
	}
	else if (this.currentLod === 4)
	{
		skinLego = this.lodMeshesMap.lod4;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod5;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod3;
			}
		}
		
	}
	else if (this.currentLod === 5)
	{
		skinLego = this.lodMeshesMap.lod5;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod4;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod3;
			}
		}
		
	}

	return skinLego;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.manageNeoReferenceTexture = function(neoReference, magoManager) 
{
	var texture = undefined;
	
	if (this.metaData.version[0] === "v")
	{
		// this is the version beta.
		if (neoReference.texture === undefined)
		{ return undefined; }
		
		if (neoReference.texture.texId === undefined && neoReference.texture.textureImageFileName !== "") 
		{
			// 1rst, check if the texture is loaded.
			if (this.texturesLoaded === undefined)
			{ this.texturesLoaded = []; }
			
			var sameTexture = this.getSameTexture(neoReference.texture);
			if (sameTexture === undefined)
			{
				if (magoManager.backGround_fileReadings_count > 10) 
				{ return; }
			
				if (neoReference.texture.fileLoadState === CODE.fileLoadState.READY) 
				{
					var gl = magoManager.sceneState.gl;
					neoReference.texture.texId = gl.createTexture();
					// Load the texture.***
					var projectFolderName = this.projectFolderName;
					var geometryDataPath = magoManager.readerWriter.geometryDataPath;
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + this.buildingFileName + "/Images_Resized/" + neoReference.texture.textureImageFileName;

					this.texturesLoaded.push(neoReference.texture);
					magoManager.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, neoReference.texture, this, magoManager);
					magoManager.backGround_fileReadings_count ++;
				}
			}
			else 
			{
				if (sameTexture.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
				{
					neoReference.texture = sameTexture;
				}
			}
		}
		
		return neoReference.texture.fileLoadState;
	}
	else if (this.metaData.version[0] === '0' && this.metaData.version[2] === '0' && this.metaData.version[4] === '1' )
	{
		if (neoReference.texture === undefined || neoReference.texture.fileLoadState === CODE.fileLoadState.READY)
		{
			// provisionally use materialId as textureId.
			var textureId = neoReference.materialId;
			texture = this.texturesLoaded[textureId];
			neoReference.texture = texture;
			
			if (texture.texId === undefined && texture.textureImageFileName !== "")
			{
				if (magoManager.backGround_fileReadings_count > 10) 
				{ return undefined; }
	
				if (texture.fileLoadState === CODE.fileLoadState.READY) 
				{
					var gl = magoManager.sceneState.gl;
					texture.texId = gl.createTexture();
					// Load the texture.***
					var projectFolderName = this.projectFolderName;
					var geometryDataPath = magoManager.readerWriter.getCurrentDataPath();
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + this.buildingFileName + "/Images_Resized/" + texture.textureImageFileName;

					magoManager.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, texture, this, magoManager);
					magoManager.backGround_fileReadings_count ++;
				}
			}
		}
		
		return neoReference.texture.fileLoadState;
	}
	
};


'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoBuildingsList
 */
var NeoBuildingsList = function() 
{
	if (!(this instanceof NeoBuildingsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	//Array.apply(this, arguments);

	this.neoBuildingsArray = [];
};
//NeoBuildingsList.prototype = Object.create(Array.prototype);

/**
 * 어떤 일을 하고 있습니까?
 * @returns neoBuilding
 */
NeoBuildingsList.prototype.newNeoBuilding = function() 
{
	var neoBuilding = new NeoBuilding();
	this.neoBuildingsArray.push(neoBuilding);
	return neoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns neoBuilding
 */
NeoBuildingsList.prototype.getNeoBuildingByTypeId = function(buildingType, buildingId) 
{
	var resultBuilding;
	var buildingsCount = this.neoBuildingsArray.length;
	var found = false;
	var i=0;
	while (!found && i < buildingsCount)
	{
		if (this.neoBuildingsArray[i].buildingType === buildingType && this.neoBuildingsArray[i].buildingId === buildingId)
		{
			found = true;
			resultBuilding = this.neoBuildingsArray[i];
		}
		i++;
	}

	return resultBuilding;
};


NeoBuildingsList.prototype.get = function (index)
{
	return this.neoBuildingsArray[index];
};

NeoBuildingsList.prototype.add = function (item)
{
	if (item !== undefined)	{ this.neoBuildingsArray.push(item); }
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoReference
 */
var NeoReference = function() 
{
	if (!(this instanceof NeoReference)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// 1) Object IDX.***
	this._id = 0;

	this.objectId = "";

	// 2) Block Idx.***
	this._block_idx = -1;

	// 3) Transformation Matrix.***
	this._matrix4 = new Matrix4(); // initial and necessary matrix.***
	this._originalMatrix4 = new Matrix4(); // original matrix, for use with block-reference (do not modify).***
	this.tMatrixAuxArray; // use for deploying mode, cronological transformations for example.***
	this.refMatrixType = 2; // 0 = identity matrix, 1 = translate matrix, 2 = transformation matrix.
	this.refTranslationVec; // use this if "refMatrixType" === 1.
	// 4) VBO datas container.***
	this.vBOVertexIdxCacheKeysContainer; // initially undefined.***

	// 5) The texture image.***
	this.materialId;
	this.hasTexture = false;
	this.texture; // Texture

	// 6) 1 color.***
	this.color4; //new Color();
	this.aditionalColor; // used when object color was changed.***

	this.vertexCount = 0;// provisional. for checking vertexCount of the block.*** delete this.****

	// 7) movement of the object.***
	this.moveVectorRelToBuilding; // Point3D.***
	this.moveVector; // Point3D.***

	// 8) check for render.***
	this.renderingFase = false;
};

/**
 * 카메라가 이동중인지를 확인
 * @param cameraPosition 변수
 * @param squareDistUmbral 변수
 * @returns camera_was_moved
 */
NeoReference.prototype.swapRenderingFase = function() 
{
	this.renderingFase = !this.renderingFase;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.multiplyTransformMatrix = function(matrix) 
{
	this._matrix4 = this._originalMatrix4.getMultipliedByMatrix(matrix); // Original.***
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	// this function multiplies the originalMatrix by "matrix" and stores it in the "idxKey" position.***
	if (this.tMatrixAuxArray === undefined)
	{ this.tMatrixAuxArray = []; }

	this.tMatrixAuxArray[idxKey] = this._originalMatrix4.getMultipliedByMatrix(matrix, this.tMatrixAuxArray[idxKey]);
	
	if (this.moveVectorRelToBuilding)
	{
		this.moveVector = matrix.rotatePoint3D(this.moveVectorRelToBuilding, this.moveVector); 
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.hasKeyMatrix = function(idxKey) 
{
	if (this.tMatrixAuxArray === undefined)
	{ return false; }

	if (this.tMatrixAuxArray[idxKey] === undefined)
	{ return false; }
	else
	{ return true; }
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.deleteObjects = function(gl, vboMemManager) 
{
	// 1) Object ID.***
	this._id = undefined;

	// 2) Block Idx.***
	this._block_idx = undefined;

	// 3) Transformation Matrix.***
	this._matrix4._floatArrays = undefined;
	this._matrix4 = undefined;
	this._originalMatrix4._floatArrays = undefined;
	this._originalMatrix4 = undefined; //

	// 5) The texture image.***
	this.hasTexture = undefined;
	// no delete the texture, only break the referencing.
	this.texture = undefined; // Texture

	// 6) 1 color.***
	if (this.color4)
	{ this.color4.deleteObjects(); }
	this.color4 = undefined; //new Color();

	// 7) selection color.***
	if (this.selColor4)
	{ this.selColor4.deleteObjects(); }
	this.selColor4 = undefined; //new Color(); // use for selection only.***

	this.vertexCount = undefined;// provisional. for checking vertexCount of the block.*** delete this.****

	// 8) movement of the object.***
	if (this.moveVector)
	{ this.moveVector.deleteObjects(); }
	this.moveVector = undefined; // Point3D.***

	this.bRendered = undefined;
	
	if (this.vBOVertexIdxCacheKeysContainer !== undefined)
	{
		this.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
		this.vBOVertexIdxCacheKeysContainer = undefined;
	}
};

//*************************************************************************************************************************************************************
//*************************************************************************************************************************************************************
//*************************************************************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @class NeoReferencesMotherAndIndices
 */
var NeoReferencesMotherAndIndices = function() 
{
	if (!(this instanceof NeoReferencesMotherAndIndices)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.motherNeoRefsList; // this is a NeoReferencesList pointer.***
	this.neoRefsIndices = []; // All objects(references) of this class.
	this.modelReferencedGroupsList; // (for new format).
	this.blocksList;

	this.fileLoadState = 0; // init as "READY".
	this.dataArraybuffer;
	this.succesfullyGpuDataBinded;

	this.exterior_ocCullOctree; // octree that contains the visible indices.
	this.interior_ocCullOctree; // octree that contains the visible indices.
	
	this.currentVisibleIndices = [];
	this.currentVisibleMRG; // MRG = ModelReferencedGroup (for new format).
};

/**
 * 어떤 일을 하고 있습니까?
 * @param matrix 변수
 */
NeoReferencesMotherAndIndices.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	var refIndicesCount = this.neoRefsIndices.length;
	for (var i=0; i<refIndicesCount; i++)
	{
		this.motherNeoRefsList[this.neoRefsIndices[i]].multiplyKeyTransformMatrix(idxKey, matrix);
	}
};

NeoReferencesMotherAndIndices.prototype.updateCurrentVisibleIndices = function(eye_x, eye_y, eye_z, applyOcclusionCulling) 
{
	if (applyOcclusionCulling === undefined)
	{ applyOcclusionCulling = true; }

	// check if is interior.***
	var isExterior = false;
	if (this.interior_ocCullOctree !== undefined)
	{
		var thisHasOcCullData = false;
		if (this.interior_ocCullOctree._subBoxesArray && this.interior_ocCullOctree._subBoxesArray.length > 0)
		{ thisHasOcCullData = true; }
	
		if (thisHasOcCullData && applyOcclusionCulling)
		{
			//if (this.currentVisibleMRG === undefined)
			//{ this.currentVisibleMRG = new ModelReferencedGroupsList(); }
			
			var intersectedSubBox = this.interior_ocCullOctree.getIntersectedSubBoxByPoint3D(eye_x, eye_y, eye_z);
			if (intersectedSubBox !== undefined && intersectedSubBox._indicesArray.length > 0) 
			{
				this.currentVisibleIndices = intersectedSubBox._indicesArray;
				//if (result_modelReferencedGroup)
				//{
				//	result_modelReferencedGroup = this.modelReferencedGroupsList;
				//}
				isExterior = false;
			}
			else 
			{
				isExterior = true;
			}
		}
		else
		{
			// In this case there are no occlusionCulling data.
			this.currentVisibleIndices = this.neoRefsIndices;
			this.currentVisibleMRG = this.modelReferencedGroupsList;
		}
	}
	
	if (isExterior)
	{
		if (this.exterior_ocCullOctree !== undefined)
		{
			var thisHasOcCullData = false;
			if (this.exterior_ocCullOctree._subBoxesArray && this.exterior_ocCullOctree._subBoxesArray.length > 0)
			{ thisHasOcCullData = true; }
		
			if (thisHasOcCullData && applyOcclusionCulling)
			{
				if (this.currentVisibleMRG === undefined)
				{ this.currentVisibleMRG = new ModelReferencedGroupsList(); }
				
				this.currentVisibleIndices = this.exterior_ocCullOctree.getIndicesVisiblesForEye(eye_x, eye_y, eye_z, this.currentVisibleIndices, this.currentVisibleMRG);
			}
			else 
			{
				// In this case there are no occlusionCulling data.
				this.currentVisibleIndices = this.neoRefsIndices;
				this.currentVisibleMRG = this.modelReferencedGroupsList;
			}
		}
	}
};

/**
 * Returns the neoReference
 * @param matrix 변수
 */
NeoReferencesMotherAndIndices.prototype.getNeoReference = function(idx) 
{
	return this.motherNeoRefsList[this.neoRefsIndices[idx]];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.deleteObjects = function(gl, vboMemManager) 
{
	this.motherNeoRefsList = undefined; // this is a NeoReferencesList pointer.***
	this.neoRefsIndices = undefined;
	this.blocksList = undefined;

	this.fileLoadState = undefined;
	this.dataArraybuffer = undefined;

	this.exterior_ocCullOctree = undefined;
	this.interior_ocCullOctree = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.setRenderedFalseToAllReferences = function() 
{
	var refIndicesCount = this.neoRefsIndices.length;
	for (var i=0; i<refIndicesCount; i++)
	{
		this.motherNeoRefsList[this.neoRefsIndices[i]].bRendered = false;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.createModelReferencedGroups = function() 
{
	// Group all the references that has the same model.
	if (this.neoRefsIndices === undefined)
	{ return; }
	
	if (this.modelReferencedGroupsList === undefined)
	{ this.modelReferencedGroupsList = new ModelReferencedGroupsList(); }

	this.modelReferencedGroupsList.createModelReferencedGroups(this.neoRefsIndices, this.motherNeoRefsList);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param arrayBuffer 변수
 * @param neoBuilding 변수
 * @param readWriter 변수
 */
NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferencesVersioned = function(gl, arrayBuffer, readWriter, neoBuilding, tMatrix4, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	var startBuff;
	var endBuff;
	var bytes_readed = 0;
	var testIdentityMatsCount = 0;
	var stadistic_refMat_Identities_count = 0;
	var stadistic_refMat_Translates_count = 0;
	var stadistic_refMat_Transforms_count = 0;
	var vboMemManager = magoManager.vboMemoryManager;
	var classifiedTCoordByteSize = 0, classifiedColByteSize = 0;
	var colByteSize, tCoordByteSize;
	this.succesfullyGpuDataBinded = true;
	var translationX, translationY, translationZ;
	
	// read the version.
	var versionLength = 5;
	var version = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+versionLength)));
	bytes_readed += versionLength;

	var neoRefsCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var i = 0; i < neoRefsCount; i++) 
	{
		var neoRef = new NeoReference();

		// 1) Id.***
		var ref_ID =  readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		neoRef._id = ref_ID;

		this.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
		if (this.motherNeoRefsList[neoRef._id] !== undefined)
		{
			// pass this neoReference because exist in the motherNeoReferencesArray.***
			neoRef = this.motherNeoRefsList[neoRef._id];
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			
			neoRef.objectId = objectId;
			bytes_readed += objectIdLength;

			// 2) Block's Idx.***
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.***
			// in versioned mode read the matrixType first.
			var matrixType = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (matrixType === 0)
			{ 
				// do nothing.
			}
			else if (matrixType === 1)
			{
				// read the translation vector.
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			}
			else if (matrixType === 2)
			{
				// read the transformation matrix.
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			}

			// Float mode.**************************************************************
			// New modifications for xxxx 20161013.*****************************
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				for (var j=0; j<vboDatasCount; j++)
				{
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.***
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.***
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount;
					}
				}
			}
			
			// 4) short texcoords. OLD. Change this for Materials.***
			var materialIdAux = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			
			// do the stadistic recount.
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1){ stadistic_refMat_Translates_count +=1; }
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }
		}
		else
		{
			
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			if (objectId === "noObjectId")
			{ objectId = neoRef._id; }
		
			neoRef.objectId = objectId;
			bytes_readed += objectIdLength;
			
			neoBuilding.putReferenceObject(neoRef, neoRef._id);

			// 2) Block's Idx.***
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.***
			neoRef.refMatrixType = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (neoRef.refMatrixType === 0)
			{ 
				// do nothing.
				stadistic_refMat_Identities_count +=1;
			}
			else if (neoRef.refMatrixType === 1)
			{
				// read the translation vector.
				translationX = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				translationY = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				translationZ = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef.refTranslationVec = new Float32Array([translationX, translationY, translationZ]);
				
				stadistic_refMat_Translates_count +=1;
			}
			else if (neoRef.refMatrixType === 2)
			{
				// read the transformation matrix.
				neoRef._originalMatrix4._floatArrays[0] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[1] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[2] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[3] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[4] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[5] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[6] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[7] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[8] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[9] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[10] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[11] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[12] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[13] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[14] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[15] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				stadistic_refMat_Transforms_count +=1;
			}

			// Float mode.**************************************************************
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}

				neoRef.color4 = new Color();
				neoRef.color4.set(r, g, b, alfa);
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				if (vboDatasCount > 0)
				{
					if (neoRef.vBOVertexIdxCacheKeysContainer === undefined)
					{ neoRef.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
				}
				
				for (var j=0; j<vboDatasCount; j++)
				{
					var vboViCacheKey = neoRef.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
					
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						colByteSize = daya_bytes * verticesFloatValuesCount;
						classifiedColByteSize = vboMemManager.getClassifiedBufferSize(colByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.***
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.colVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.***
						// TODO: Float32Array or UintArray depending of dataType.***
						vboViCacheKey.colVboDataArray = new Float32Array(classifiedColByteSize);
						vboViCacheKey.colVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
						vboViCacheKey.colArrayByteSize = classifiedColByteSize;
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.***
						
						// send data to gpu.
						if (!vboViCacheKey.isReadyColors(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.***
						// example: posByteSize = 4 * verticesFloatValuesCount;
						tCoordByteSize = daya_bytes * verticesFloatValuesCount;
						classifiedTCoordByteSize = vboMemManager.getClassifiedBufferSize(tCoordByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.***
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.tcoordVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.***
						vboViCacheKey.tcoordVboDataArray = new Float32Array(classifiedTCoordByteSize);
						vboViCacheKey.tcoordVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
						vboViCacheKey.tcoordArrayByteSize = classifiedTCoordByteSize;
						bytes_readed += daya_bytes * verticesFloatValuesCount;
						
						// send data to gpu.
						if (!vboViCacheKey.isReadyTexCoords(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
					}
				}
			}

			// 4) read the reference material id.
			neoRef.materialId = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			if (neoRef.materialId === -1)
			{ neoRef.hasTexture = false; }
			else 
			{ 
				neoRef.hasTexture = true; 
			}

			if (tMatrix4)
			{
				// multiply the building transformation matrix with the reference matrix, then we save aditional multiplications inside the shader.
				neoRef.multiplyTransformMatrix(tMatrix4);
			}
		}

	}
	
	// finally read the triangles count.
	var trianglesCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	
	//this.createModelReferencedGroups(); // test for stadistics.
	

	// Now occlusion cullings.***
	// Occlusion culling octree data.*****
	if (this.exterior_ocCullOctree === undefined)
	{ this.exterior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var infiniteOcCullBox = this.exterior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, infiniteOcCullBox); // old.***
	bytes_readed = this.exterior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	infiniteOcCullBox.expandBox(1000); // Only for the infinite box.***
	infiniteOcCullBox.setSizesSubBoxes();
	infiniteOcCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	if (this.interior_ocCullOctree === undefined)
	{ this.interior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var ocCullBox = this.interior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, ocCullBox); // old.***
	bytes_readed = this.interior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	ocCullBox.setSizesSubBoxes();
	ocCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return this.succesfullyGpuDataBinded;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param arrayBuffer 변수
 * @param neoBuilding 변수
 * @param readWriter 변수
 */
NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferences = function(gl, arrayBuffer, readWriter, neoBuilding, tMatrix4, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	var startBuff;
	var endBuff;
	var bytes_readed = 0;
	var neoRefsCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	var testIdentityMatsCount = 0;
	var stadistic_refMat_Identities_count = 0;
	var stadistic_refMat_Translates_count = 0;
	var stadistic_refMat_Transforms_count = 0;
	var vboMemManager = magoManager.vboMemoryManager;
	var classifiedTCoordByteSize = 0, classifiedColByteSize = 0;
	var colByteSize, tCoordByteSize;
	this.succesfullyGpuDataBinded = true;

	for (var i = 0; i < neoRefsCount; i++) 
	{
		var neoRef = new NeoReference();

		// 1) Id.***
		var ref_ID =  readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		neoRef._id = ref_ID;
		
		
		this.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
		if (this.motherNeoRefsList[neoRef._id] !== undefined)
		{
			// pass this neoReference because exist in the motherNeoReferencesArray.***
			neoRef = this.motherNeoRefsList[neoRef._id];
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			bytes_readed += objectIdLength;

			// 2) Block's Idx.***
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.***
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			// Float mode.**************************************************************
			// New modifications for xxxx 20161013.*****************************
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				for (var j=0; j<vboDatasCount; j++)
				{
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.***
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.***
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount;
					}
				}
			}
			
			// 4) short texcoords. OLD. Change this for Materials.***
			var textures_count = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // this is only indicative that there are a texcoords.***
			if (textures_count > 0) 
			{

				// Now, read the texture_type and texture_file_name.***
				var texture_type_nameLegth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_type_nameLegth; j++) 
				{
					bytes_readed += 1; // for example "diffuse".***
				}

				var texture_fileName_Legth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_fileName_Legth; j++) 
				{
					bytes_readed += 1;
				}
			} 
			
			// do the stadistic recount.
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1){ stadistic_refMat_Translates_count +=1; }
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }
		}
		else
		{
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			if (objectId === "noObjectId" || objectId === "")
			{ objectId = neoRef._id; }
		
			neoRef.objectId = objectId;
			bytes_readed += objectIdLength;
			
			neoBuilding.putReferenceObject(neoRef, neoRef._id);

			// 2) Block's Idx.***
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.***
			neoRef._originalMatrix4._floatArrays[0] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[1] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[2] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[3] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[4] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[5] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[6] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[7] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[8] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[9] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[10] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[11] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[12] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[13] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[14] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[15] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			
			// Compute the references matrix type.
			neoRef.refMatrixType = neoRef._originalMatrix4.computeMatrixType();
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1)
			{
				neoRef.refTranslationVec = new Float32Array([neoRef._originalMatrix4._floatArrays[12], neoRef._originalMatrix4._floatArrays[13], neoRef._originalMatrix4._floatArrays[14]]);
				stadistic_refMat_Translates_count +=1;
			}
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }

			// Float mode.**************************************************************
			// New modifications for xxxx 20161013.*****************************
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}

				neoRef.color4 = new Color();
				neoRef.color4.set(r, g, b, alfa);
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				if (vboDatasCount > 0)
				{
					if (neoRef.vBOVertexIdxCacheKeysContainer === undefined)
					{ neoRef.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
				}
				
				for (var j=0; j<vboDatasCount; j++)
				{
					var vboViCacheKey = neoRef.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
					
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						colByteSize = daya_bytes * verticesFloatValuesCount;
						classifiedColByteSize = vboMemManager.getClassifiedBufferSize(colByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.***
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.colVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.***
						// TODO: Float32Array or UintArray depending of dataType.***
						vboViCacheKey.colVboDataArray = new Float32Array(classifiedColByteSize);
						vboViCacheKey.colVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
						vboViCacheKey.colArrayByteSize = classifiedColByteSize;
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.***
						
						// send data to gpu.
						if (!vboViCacheKey.isReadyColors(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.***
						// example: posByteSize = 4 * verticesFloatValuesCount;
						tCoordByteSize = daya_bytes * verticesFloatValuesCount;
						classifiedTCoordByteSize = vboMemManager.getClassifiedBufferSize(tCoordByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.***
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.tcoordVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.***
						vboViCacheKey.tcoordVboDataArray = new Float32Array(classifiedTCoordByteSize);
						vboViCacheKey.tcoordVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
						vboViCacheKey.tcoordArrayByteSize = classifiedTCoordByteSize;
						bytes_readed += daya_bytes * verticesFloatValuesCount;
						
						// send data to gpu.
						if (!vboViCacheKey.isReadyTexCoords(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
					}
				}
			}

			// 4) short texcoords. OLD. Change this for Materials.***
			var textures_count = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // this is only indicative that there are a texcoords.***
			if (textures_count > 0) 
			{
				var textureTypeName = "";
				var textureImageFileName = "";

				// Now, read the texture_type and texture_file_name.***
				var texture_type_nameLegth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_type_nameLegth; j++) 
				{
					textureTypeName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1; // for example "diffuse".***
				}

				var texture_fileName_Legth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				// utf8.***
				var charArray = new Uint8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ texture_fileName_Legth)); bytes_readed += texture_fileName_Legth;
				var decoder = new TextDecoder('utf-8');
				textureImageFileName = decoder.decode(charArray);
					
				//for (var j=0; j<texture_fileName_Legth; j++) 
				//{
				//	textureImageFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
				//}
				
				if (texture_fileName_Legth > 0)
				{
					neoRef.texture = new Texture();
					neoRef.hasTexture = true;
					neoRef.texture.textureTypeName = textureTypeName;
					neoRef.texture.textureImageFileName = textureImageFileName;
				}

				/*
				// 1pixel texture, wait for texture to load.********************************************
				if(neoRef.texture.texId === undefined)
					neoRef.texture.texId = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, neoRef.texture.texId);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([90, 80, 85, 255])); // red
				gl.bindTexture(gl.TEXTURE_2D, null);
				*/
			}
			else 
			{
				neoRef.hasTexture = false;
			}

			if (tMatrix4)
			{
				neoRef.multiplyTransformMatrix(tMatrix4);
			}
		}

	}
	
	//this.createModelReferencedGroups(); // test for new format.
	

	// Now occlusion cullings.***
	// Occlusion culling octree data.*****
	if (this.exterior_ocCullOctree === undefined)
	{ this.exterior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var infiniteOcCullBox = this.exterior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, infiniteOcCullBox); // old.***
	bytes_readed = this.exterior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	infiniteOcCullBox.expandBox(1000); // Only for the infinite box.***
	infiniteOcCullBox.setSizesSubBoxes();
	infiniteOcCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	if (this.interior_ocCullOctree === undefined)
	{ this.interior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var ocCullBox = this.interior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, ocCullBox); // old.***
	bytes_readed = this.interior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	ocCullBox.setSizesSubBoxes();
	ocCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return this.succesfullyGpuDataBinded;
};













'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoSimpleBuilding
 */
var NeoSimpleBuilding = function() 
{
	if (!(this instanceof NeoSimpleBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.accesorsArray = [];
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	this.texturesArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns accesor
 */
NeoSimpleBuilding.prototype.newAccesor = function() 
{
	var accesor = new Accessor();
	this.accesorsArray.push(accesor);
	return accesor;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns texture
 */
NeoSimpleBuilding.prototype.newTexture = function() 
{
	var texture = new NeoTexture();
	this.texturesArray.push(texture);
	return texture;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoTexture
 */
var NeoTexture = function() 
{
	if (!(this instanceof NeoTexture)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.lod;
	this.textureId; // texture id in gl.***
	this.texImage; // image. delete this once upload to gl.***
	this.loadStarted = false;
	this.loadFinished = false;
};
'use strict';

/**
 * @class Node
 */
var Node = function() 
{
	if (!(this instanceof Node)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// parent.
	this.parent;
	
	// children array.
	this.children = []; 
	
	// data.
	this.data; // {}.
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.deleteObjects = function(gl, vboMemoryManager) 
{
	this.parent = undefined;
	if (this.data)
	{
		if (this.data.neoBuilding)
		{
			this.data.neoBuilding.deleteObjects(gl, vboMemoryManager);
			this.data.neoBuilding = undefined;
		}
		
		if (this.data.geographicCoord)
		{
			this.data.geographicCoord.deleteObjects();
			this.data.geographicCoord = undefined;
		}
		
		if (this.data.rotationsDegree)
		{
			this.data.rotationsDegree.deleteObjects();
			this.data.rotationsDegree = undefined;
		}
		
		if (this.data.bbox)
		{
			this.data.bbox.deleteObjects();
			this.data.bbox = undefined;
		}
		
		this.data = undefined;
	}
	
	if (this.children)
	{
		var childrenCount = this.children.length;
		for (var i=0; i<childrenCount; i++)
		{
			this.children[i].deleteObjects(gl, vboMemoryManager);
			this.children[i] = undefined;
		}
		this.children = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.addChildren = function(children) 
{
	children.setParent(this);
	this.children.push(children);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.setParent = function(parent) 
{
	this.parent = parent;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.getRoot = function() 
{
	if (this.parent === undefined)
	{ return this; }
	else
	{
		return this.parent.getRoot();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.getClosestParentWithData = function(dataName) 
{
	if (this.data && this.data[dataName])
	{
		return this;
	}
	else 
	{
		if (this.parent)
		{ return this.parent.getClosestParentWithData(dataName); }
		else { return undefined; }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.extractNodesByDataName = function(nodesArray, dataname) 
{
	// this function extracts nodes that has a data named dataname, including children.
	if (this.data[dataname])
	{
		nodesArray.push(this);
	}
	
	var childrenCount = this.children.length;
	for (var i=0; i<childrenCount; i++)
	{
		this.children[i].extractNodesByDataName(nodesArray, dataname);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.extractNodes = function(nodesArray) 
{
	// this function extracts nodes that has a data named dataname, including children.
	nodesArray.push(this);
	
	var childrenCount = this.children.length;
	for (var i=0; i<childrenCount; i++)
	{
		this.children[i].extractNodes(nodesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
Node.prototype.getBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	if (this.bboxAbsoluteCenterPos === undefined)
	{
		this.calculateBBoxCenterPositionWorldCoord(geoLoc);
	}
	
	return this.bboxAbsoluteCenterPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
Node.prototype.calculateBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	var bboxCenterPoint;
	bboxCenterPoint = this.data.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
	this.bboxAbsoluteCenterPos = geoLoc.tMatrix.transformPoint3D(bboxCenterPoint, this.bboxAbsoluteCenterPos);
	
	// Now, must applicate the aditional translation vector. Aditional translation is made when we translate the pivot point.
	if (geoLoc.pivotPointTraslation)
	{
		var traslationVector;
		traslationVector = geoLoc.tMatrix.rotatePoint3D(geoLoc.pivotPointTraslation, traslationVector );
		this.bboxAbsoluteCenterPos.add(traslationVector.x, traslationVector.y, traslationVector.z);
	}
};

















'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Octree
 *
 * @param octreeOwner 변수
 */
var Octree = function(octreeOwner) 
{
	if (!(this instanceof Octree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// Note: an octree is a cube, not a box.***
	this.centerPos = new Point3D();
	this.half_dx = 0.0; // half width.***
	this.half_dy = 0.0; // half length.***
	this.half_dz = 0.0; // half height.***

	this.octree_owner;
	this.octree_level = 0;
	this.octree_number_name = 0;
	this.neoBuildingOwnerId;
	this.octreeKey;
	this.distToCamera;
	this.triPolyhedronsCount = 0; // no calculated. Readed when parsing.***
	this.fileLoadState = CODE.fileLoadState.READY;

	if (octreeOwner) 
	{
		this.octree_owner = octreeOwner;
		this.octree_level = octreeOwner.octree_level + 1;
	}

	this.subOctrees_array = [];
	this.neoReferencesMotherAndIndices; // Asimetric mode.***
	this.lowestOctrees_array; // pre extract lowestOctrees for speedUp, if this is motherOctree.***

	// now, for legoStructure.***
	this.lego;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns subOctree 변수
 */
Octree.prototype.new_subOctree = function() 
{
	var subOctree = new Octree(this);
	subOctree.octree_level = this.octree_level + 1;
	this.subOctrees_array.push(subOctree);
	return subOctree;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteObjectsModelReferences = function(gl, vboMemManager) 
{
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	this.neoReferencesMotherAndIndices = undefined;

	// delete the blocksList.***
	if (this.neoRefsList_Array !== undefined) 
	{
		for (var i=0, neoRefListsCount = this.neoRefsList_Array.length; i<neoRefListsCount; i++) 
		{
			if (this.neoRefsList_Array[i]) 
			{
				this.neoRefsList_Array[i].deleteObjects(gl, vboMemManager);
			}
			this.neoRefsList_Array[i] = undefined;
		}
		this.neoRefsList_Array = undefined;
	}

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjectsModelReferences(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteObjectsLego = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		// deletes the geometry and the texture.***
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjectsLego(gl, vboMemManager);
		}
	}
	
};

/**
 * Deletes all objects of the octree.
 * @param gl : current gl.
 * @param vboMemManager : gpu memory manager
 */
Octree.prototype.deleteObjects = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	this.legoDataArrayBuffer = undefined;
	if (this.centerPos)
	{ this.centerPos.deleteObjects(); }
	this.centerPos = undefined;
	this.half_dx = undefined; // half width.***
	this.half_dy = undefined; // half length.***
	this.half_dz = undefined; // half height.***

	this.octree_owner = undefined;
	this.octree_level = undefined;
	this.octree_number_name = undefined;
	this.distToCamera = undefined;
	this.triPolyhedronsCount = undefined; // no calculated. Readed when parsing.***
	this.fileLoadState = undefined; // 0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.***

	this.neoBuildingOwner = undefined;

	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	this.neoReferencesMotherAndIndices = undefined;

	// delete the blocksList.***
	if (this.neoRefsList_Array !== undefined) 
	{
		for (var i=0, neoRefListsCount = this.neoRefsList_Array.length; i<neoRefListsCount; i++) 
		{
			if (this.neoRefsList_Array[i]) 
			{
				this.neoRefsList_Array[i].deleteObjects(gl, vboMemManager);
			}
			this.neoRefsList_Array[i] = undefined;
		}
		this.neoRefsList_Array = undefined;
	}

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjects(gl, vboMemManager);
			this.subOctrees_array[i] = undefined;
		}
		this.subOctrees_array = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteLod0GlObjects = function(gl, vboMemManager) 
{
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteLod0GlObjects(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteLod2GlObjects = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteLod2GlObjects(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.makeTree = function(treeDepth) 
{
	if (this.octree_level < treeDepth) 
	{
		for (var i=0; i<8; i++) 
		{
			var subOctree = this.new_subOctree();
			subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
			subOctree.neoBuildingOwnerId = this.neoBuildingOwnerId;
			subOctree.octreeKey = this.neoBuildingOwnerId + "_" + subOctree.octree_number_name;
		}

		this.setSizesSubBoxes();

		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].makeTree(treeDepth);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.getNumberOfDigits = function(intNumber) 
{
	if (intNumber > 0) 
	{
		var numDigits = Math.floor(Math.log10(intNumber)+1);
		return numDigits;
	}
	else 
	{
		return 1;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getMotherOctree = function() 
{
	if (this.octree_owner === undefined) { return this; }

	return this.octree_owner.getMotherOctree();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreeNumberName 변수
 * @param numDigits 변수
 * @returns subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1)
 */
Octree.prototype.getOctree = function(octreeNumberName, numDigits) 
{
	if (numDigits === 1) 
	{
		if (octreeNumberName === 0) { return this.getMotherOctree(); }
		else { return this.subOctrees_array[octreeNumberName-1]; }
	}

	// determine the next level octree.***
	var exp = numDigits-1;
	var denominator = Math.pow(10, exp);
	var idx = Math.floor(octreeNumberName /denominator) % 10;
	var rest_octreeNumberName = octreeNumberName - idx * denominator;
	return this.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreeNumberName 변수
 * @returns motherOctree.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1)
 */
Octree.prototype.getOctreeByNumberName = function(octreeNumberName) 
{
	var motherOctree = this.getMotherOctree();
	var numDigits = this.getNumberOfDigits(octreeNumberName);
	if (numDigits === 1) 
	{
		if (octreeNumberName === 0) { return motherOctree; }
		else { return motherOctree.subOctrees_array[octreeNumberName-1]; }
	}

	if (motherOctree.subOctrees_array.length === 0) { return undefined; }

	// determine the next level octree.***
	var exp = numDigits-1;
	var denominator = Math.pow(10, exp);
	var idx = Math.floor(octreeNumberName /denominator) % 10;
	var rest_octreeNumberName = octreeNumberName - idx * denominator;
	return motherOctree.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.setSizesSubBoxes = function() 
{
	// Octree number name.********************************
	// Bottom                      Top
	// |---------|---------|     |---------|---------|
	// |         |         |     |         |         |       Y
	// |    3    |    2    |     |    7    |    6    |       ^
	// |         |         |     |         |         |       |
	// |---------+---------|     |---------+---------|       |
	// |         |         |     |         |         |       |
	// |    0    |    1    |     |    4    |    5    |       |
	// |         |         |     |         |         |       |-----------> X
	// |---------|---------|     |---------|---------|

	if (this.subOctrees_array.length > 0) 
	{
		var half_x = this.centerPos.x;
		var half_y = this.centerPos.y;
		var half_z = this.centerPos.z;

		var min_x = this.centerPos.x - this.half_dx;
		var min_y = this.centerPos.y - this.half_dy;
		var min_z = this.centerPos.z - this.half_dz;

		var max_x = this.centerPos.x + this.half_dx;
		var max_y = this.centerPos.y + this.half_dy;
		var max_z = this.centerPos.z + this.half_dz;

		this.subOctrees_array[0].setBoxSize(min_x, half_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[1].setBoxSize(half_x, max_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[2].setBoxSize(half_x, max_x, half_y, max_y, min_z, half_z);
		this.subOctrees_array[3].setBoxSize(min_x, half_x, half_y, max_y, min_z, half_z);

		this.subOctrees_array[4].setBoxSize(min_x, half_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[5].setBoxSize(half_x, max_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[6].setBoxSize(half_x, max_x, half_y, max_y, half_z, max_z);
		this.subOctrees_array[7].setBoxSize(min_x, half_x, half_y, max_y, half_z, max_z);

		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].setSizesSubBoxes();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param Min_x 변수
 * @param Max_x 변수
 * @param Min_y 변수
 * @param Max_y 변수
 * @param Min_z 변수
 * @param Max_z 변수
 */
Octree.prototype.setBoxSize = function(Min_X, Max_X, Min_Y, Max_Y, Min_Z, Max_Z) 
{
	this.centerPos.x = (Max_X + Min_X)/2.0;
	this.centerPos.y = (Max_Y + Min_Y)/2.0;
	this.centerPos.z = (Max_Z + Min_Z)/2.0;

	this.half_dx = (Max_X - Min_X)/2.0; // half width.***
	this.half_dy = (Max_Y - Min_Y)/2.0; // half length.***
	this.half_dz = (Max_Z - Min_Z)/2.0; // half height.***
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns centerPos
 */
Octree.prototype.getCenterPos = function() 
{
	return this.centerPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns Math.abs(this.half_dx*1.2);
 */
Octree.prototype.getRadiusAprox = function() 
{
	return this.half_dx*1.7;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_NeoRefListsArray 변수
 */
Octree.prototype.getNeoRefListArray = function(result_NeoRefListsArray) 
{
	if (result_NeoRefListsArray === undefined) { result_NeoRefListsArray = []; }

	var subOctreesArrayLength = this.subOctrees_array.length;
	if (subOctreesArrayLength > 0) 
	{
		for (var i=0; i<subOctreesArrayLength; i++) 
		{
			this.subOctrees_array[i].getNeoRefListArray(result_NeoRefListsArray);
		}
	}
	else 
	{
		if (this.neoRefsList_Array.length>0) // original.***
		//if(this.triPolyhedronsCount>0)
		{
			result_NeoRefListsArray.push(this.neoRefsList_Array[0]); // there are only 1.***
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cullingVolume 변수
 * @param result_NeoRefListsArray 변수
 * @param boundingSphere_scratch 변수
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.getFrustumVisibleLowestOctreesByLOD = function(cullingVolume, visibleObjControlerOctrees, globalVisibleObjControlerOctrees,
	boundingSphere_scratch, cameraPosition, squaredDistLod0, squaredDistLod1, squaredDistLod2) 
{
	var visibleOctreesArray = [];
	var find = false;

	//this.getAllSubOctrees(visibleOctreesArray); // Test.***
	this.getFrustumVisibleOctreesNeoBuildingAsimetricVersion(cullingVolume, visibleOctreesArray, boundingSphere_scratch); // Original.***

	// Now, we must sort the subOctrees near->far from eye.***
	var visibleOctrees_count = visibleOctreesArray.length;
	for (var i=0; i<visibleOctrees_count; i++) 
	{
		visibleOctreesArray[i].setDistToCamera(cameraPosition);
	}

	for (var i=0; i<visibleOctrees_count; i++) 
	{
		if (visibleOctreesArray[i].distToCamera < squaredDistLod0) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles0, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles0.push(visibleOctreesArray[i]);
				find = true;
			}
		}
		else if (visibleOctreesArray[i].distToCamera < squaredDistLod1) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles1, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles1.push(visibleOctreesArray[i]);
				find = true;
			}
		}
		else if (visibleOctreesArray[i].distToCamera < squaredDistLod2) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles2, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles2.push(visibleOctreesArray[i]);
				find = true;
			}
		}
		else 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ globalVisibleObjControlerOctrees.currentVisibles3.push(visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles3.push(visibleOctreesArray[i]);
				find = true;
			}
		}
	}

	visibleOctreesArray = undefined;
	return find;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
Octree.prototype.intersectsWithPoint3D = function(x, y, z) 
{
	//this.centerPos = new Point3D();
	//this.half_dx = 0.0; // half width.***
	//this.half_dy = 0.0; // half length.***
	//this.half_dz = 0.0; // half height.***
	var minX = this.centerPos.x - this.half_dx;
	var minY = this.centerPos.y - this.half_dz;
	var minZ = this.centerPos.z - this.half_dz;
	var maxX = this.centerPos.x + this.half_dx;
	var maxY = this.centerPos.y + this.half_dz;
	var maxZ = this.centerPos.z + this.half_dz;
	
	var intersects = false;
	if (x> minX && x<maxX) 
	{
		if (y> minY && y<maxY) 
		{
			if (z> minZ && z<maxZ) 
			{
				intersects = true;
			}
		}
	}
	
	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersectedSubBox
 */
Octree.prototype.getIntersectedSubBoxByPoint3D = function(x, y, z) 
{
	if (this.octree_owner === undefined) 
	{
		// This is the mother_cell.***
		if (!this.intersectsWithPoint3D(x, y, z)) 
		{
			return false;
		}
	}
	
	var intersectedSubBox = undefined;
	var subBoxes_count = this.subOctrees_array.length;
	if (subBoxes_count > 0) 
	{
		var center_x = this.centerPos.x;
		var center_y = this.centerPos.y;
		var center_z = this.centerPos.z;
		
		var intersectedSubBox_aux = undefined;
		var intersectedSubBox_idx;
		if (x<center_x) 
		{
			// Here are the boxes number 0, 3, 4, 7.***
			if (y<center_y) 
			{
				// Here are 0, 4.***
				if (z<center_z) { intersectedSubBox_idx = 0; }
				else { intersectedSubBox_idx = 4; }
			}
			else 
			{
				// Here are 3, 7.***
				if (z<center_z) { intersectedSubBox_idx = 3; }
				else { intersectedSubBox_idx = 7; }
			}
		}
		else 
		{
			// Here are the boxes number 1, 2, 5, 6.***
			if (y<center_y) 
			{
				// Here are 1, 5.***
				if (z<center_z) { intersectedSubBox_idx = 1; }
				else { intersectedSubBox_idx = 5; }
			}
			else 
			{
				// Here are 2, 6.***
				if (z<center_z) { intersectedSubBox_idx = 2; }
				else { intersectedSubBox_idx = 6; }
			}
		}
		
		intersectedSubBox_aux = this.subOctrees_array[intersectedSubBox_idx];
		intersectedSubBox = intersectedSubBox_aux.getIntersectedSubBoxByPoint3D(x, y, z);
		
	}
	else 
	{
		intersectedSubBox = this;
	}
	
	return intersectedSubBox;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getMinDistToCamera = function(cameraPosition)
{
	// this function returns the minDistToCamera of the lowestOctrees.***
	var minDistToCam = 1000000.0;
	
	if (this.lowestOctrees_array === undefined)
	{
		this.lowestOctrees_array = [];
		this.extractLowestOctreesIfHasTriPolyhedrons(this.lowestOctrees_array);
	}
	
	var distToCamera;
	var lowestOctree;
	var lowestOctreesCount = this.lowestOctrees_array.length;
	for (var i=0; i<lowestOctreesCount; i++)
	{
		lowestOctree = this.lowestOctrees_array[i];
		distToCamera = lowestOctree.centerPos.distToPoint(cameraPosition) - this.getRadiusAprox();
		if (distToCamera < minDistToCam)
		{ minDistToCam = distToCamera; }
	}
	
	return minDistToCam;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cullingVolume 변수
 * @param result_NeoRefListsArray 변수
 * @param boundingSphere_scratch 변수
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.extractLowestOctreesByLOD = function(visibleObjControlerOctrees, globalVisibleObjControlerOctrees,
	boundingSphere_scratch, cameraPosition, squaredDistLod0, squaredDistLod1, squaredDistLod2 ) 
{
	var distAux = 0.0;
	var find = false;
	
	var eye_x = cameraPosition.x;
	var eye_y = cameraPosition.y;
	var eye_z = cameraPosition.z;
	if (this.lowestOctrees_array === undefined)
	{
		this.lowestOctrees_array = [];
		this.extractLowestOctreesIfHasTriPolyhedrons(this.lowestOctrees_array);
	}
	
	// Now, we must sort the subOctrees near->far from eye.***
	var visibleOctrees_count = this.lowestOctrees_array.length;
	for (var i=0; i<visibleOctrees_count; i++) 
	{
		this.lowestOctrees_array[i].setDistToCamera(cameraPosition);
	}

	for (var i=0; i<visibleOctrees_count; i++) 
	{
		if (this.lowestOctrees_array[i].distToCamera < squaredDistLod0) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles0, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles0.push(this.lowestOctrees_array[i]);
				find = true;
			}
		}
		else if (this.lowestOctrees_array[i].distToCamera < squaredDistLod1) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles1, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles1.push(this.lowestOctrees_array[i]);
				find = true;
			}
		}
		else if (this.lowestOctrees_array[i].distToCamera < squaredDistLod2) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles2, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles2.push(this.lowestOctrees_array[i]);
				find = true;
			}
		}
		else 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ globalVisibleObjControlerOctrees.currentVisibles3.push(this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles3.push(this.lowestOctrees_array[i]);
				find = true;
			}
		}
	}

	return find;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param cesium_cullingVolume 변수
 * @param result_octreesArray 변수
 * @param boundingSphere_scratch 변수
 */
Octree.prototype.getFrustumVisibleOctreesNeoBuildingAsimetricVersion = function(cullingVolume, result_octreesArray, boundingSphere_scratch) 
{
	//if(this.subOctrees_array.length === 0 && this.neoRefsList_Array.length === 0) // original.***
	if (this.subOctrees_array === undefined) { return; }

	if (this.subOctrees_array.length === 0 && this.triPolyhedronsCount === 0)
	//if(this.subOctrees_array.length === 0 && this.compRefsListArray.length === 0) // For use with ifc buildings.***
	{ return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }
	
	if (boundingSphere_scratch === undefined) 
	{ boundingSphere_scratch = new Sphere(); } 

	boundingSphere_scratch.centerPoint.x = this.centerPos.x;
	boundingSphere_scratch.centerPoint.y = this.centerPos.y;
	boundingSphere_scratch.centerPoint.z = this.centerPos.z;
	boundingSphere_scratch.r = this.getRadiusAprox();

	var frustumCull = cullingVolume.intersectionSphere(boundingSphere_scratch);
	if (frustumCull === Constant.INTERSECTION_INSIDE ) 
	{
		//result_octreesArray.push(this);
		this.getAllSubOctreesIfHasRefLists(result_octreesArray);
	}
	else if (frustumCull === Constant.INTERSECTION_INTERSECT  ) 
	{
		if (this.subOctrees_array.length === 0) 
		{
			//if(this.neoRefsList_Array.length > 0) // original.***
			//if(this.triPolyhedronsCount > 0)
			result_octreesArray.push(this);
		}
		else 
		{
			for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++ ) 
			{
				this.subOctrees_array[i].getFrustumVisibleOctreesNeoBuildingAsimetricVersion(cullingVolume, result_octreesArray, boundingSphere_scratch);
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cesium_cullingVolume 변수
 * @param result_octreesArray 변수
 * @param boundingSphere_scratch 변수
 */
Octree.prototype.getBBoxIntersectedOctreesNeoBuildingAsimetricVersion = function(bbox, result_octreesArray, bbox_scratch) 
{
	if (this.subOctrees_array === undefined) { return; }

	if (this.subOctrees_array.length === 0 && this.triPolyhedronsCount === 0)
	{ return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }
	
	if (bbox_scratch === undefined) 
	{ bbox_scratch = new BoundingBox(); } 
	

	bbox_scratch.minX = this.centerPos.x - this.half_dx;
	bbox_scratch.maxX = this.centerPos.x + this.half_dx;
	bbox_scratch.minY = this.centerPos.y - this.half_dy;
	bbox_scratch.maxY = this.centerPos.y + this.half_dy;
	bbox_scratch.minZ = this.centerPos.z - this.half_dz;
	bbox_scratch.maxZ = this.centerPos.z + this.half_dz;

	var intersects = bbox.intersectsWithBBox(bbox_scratch);
	if (intersects)
	{
		this.getAllSubOctreesIfHasRefLists(result_octreesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.setDistToCamera = function(cameraPosition) 
{
	// distance to camera as a sphere.
	var distToCamera = this.centerPos.distToPoint(cameraPosition) - this.getRadiusAprox();
	this.distToCamera = distToCamera;
	return distToCamera;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreesArray 변수
 * @param octree 변수
 * @returns result_idx
 */
Octree.prototype.getIndexToInsertBySquaredDistToEye = function(octreesArray, octree, startIdx, endIdx) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	if (startIdx === undefined)
	{ startIdx = 0; }
	
	if (endIdx === undefined)
	{ endIdx = octreesArray.length-1; }
	
	var range = endIdx - startIdx;
	
	if (range <= 0)
	{ return 0; }
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		var octreesCount = octreesArray.length;
		while (!finished && i<=endIdx)
		{
			if (octree.distToCamera < octreesArray[i].distToCamera)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (octreesArray[middleIdx].distToCamera > octree.distToCamera)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getIndexToInsertBySquaredDistToEye(octreesArray, octree, newStartIdx, newEndIdx);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 * @param octree 변수
 */
Octree.prototype.putOctreeInEyeDistanceSortedArray = function(result_octreesArray, octree) 
{
	// sorting is from minDist to maxDist.***
	if (result_octreesArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = result_octreesArray.length - 1;
		var insert_idx= this.getIndexToInsertBySquaredDistToEye(result_octreesArray, octree, startIdx, endIdx);

		result_octreesArray.splice(insert_idx, 0, octree);
	}
	else 
	{
		result_octreesArray.push(octree);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.getAllSubOctreesIfHasRefLists = function(result_octreesArray) 
{
	if (this.subOctrees_array === undefined) { return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }

	if (this.subOctrees_array.length > 0) 
	{
		for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++) 
		{
			this.subOctrees_array[i].getAllSubOctreesIfHasRefLists(result_octreesArray);
		}
	}
	else 
	{
		//if(this.neoRefsList_Array.length > 0)
		if (this.triPolyhedronsCount > 0) { result_octreesArray.push(this); } // there are only 1.***
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.getAllSubOctrees = function(result_octreesArray) 
{
	if (result_octreesArray === undefined) { result_octreesArray = []; }

	if (this.subOctrees_array.length > 0) 
	{
		for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++) 
		{
			this.subOctrees_array[i].getAllSubOctrees(result_octreesArray);
		}
	}
	else 
	{
		result_octreesArray.push(this); // there are only 1.***
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.extractLowestOctreesIfHasTriPolyhedrons = function(lowestOctreesArray) 
{
	if (this.subOctrees_array === undefined)
	{ return; }
	
	var subOctreesCount = this.subOctrees_array.length;

	if (subOctreesCount === 0 && this.triPolyhedronsCount > 0) 
	{
		lowestOctreesArray.push(this);
	}
	else 
	{
		for (var i=0; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].extractLowestOctreesIfHasTriPolyhedrons(lowestOctreesArray);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	var subOctreesCount = this.subOctrees_array.length;

	if (subOctreesCount === 0 && this.triPolyhedronsCount > 0) 
	{
		if (this.neoReferencesMotherAndIndices)
		{ this.neoReferencesMotherAndIndices.multiplyKeyTransformMatrix(idxKey, matrix); }
	}
	else 
	{
		for (var i=0; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].multiplyKeyTransformMatrix(idxKey, matrix);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.parseAsimetricVersion = function(arrayBuffer, readerWriter, bytesReaded, neoBuildingOwner) 
{
	var octreeLevel = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

	if (octreeLevel === 0) 
	{
		// this is the mother octree, so read the mother octree's size.***
		var minX = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxX = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minY = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxY = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minZ = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxZ = readerWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		this.setBoxSize(minX, maxX, minY, maxY, minZ, maxZ );
		this.octree_number_name = 0;
	}

	var subOctreesCount = readerWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1; // this must be 0 or 8.***
	this.triPolyhedronsCount = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	if (this.triPolyhedronsCount > 0)
	{ this.neoBuildingOwner = neoBuildingOwner; }

	// 1rst, create the 8 subOctrees.***
	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.new_subOctree();
		subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
		subOctree.neoBuildingOwnerId = this.neoBuildingOwnerId;
		subOctree.octreeKey = this.neoBuildingOwnerId + "_" + subOctree.octree_number_name;
	}

	// now, set size of subOctrees.***
	this.setSizesSubBoxes();

	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.subOctrees_array[i];
		bytesReaded = subOctree.parseAsimetricVersion(arrayBuffer, readerWriter, bytesReaded, neoBuildingOwner);
	}

	return bytesReaded;
};

'use strict';

/**
 * ParseQueue
 * 
 * @alias ParseQueue
 * @class ParseQueue
 */
var ParseQueue = function() 
{
	if (!(this instanceof ParseQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.octreesLod0ReferencesToParseMap = {};
	this.octreesLod0ModelsToParseMap = {};
	this.octreesLod2LegosToParseMap = {};
	this.octreesPCloudToParseMap = {};
	this.skinLegosToParseMap = {};
	this.tinTerrainsToParseMap = {};
};



ParseQueue.prototype.putTinTerrainToParse = function(tinTerrain, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.tinTerrainsToParseMap[tinTerrain.pathName] = tinTerrain;
};

ParseQueue.prototype.eraseTinTerrainToParse = function(tinTerrain)
{
	if (tinTerrain === undefined)
	{ return; }
	
	var key = tinTerrain.pathName;
	if (this.tinTerrainsToParseMap.hasOwnProperty(key)) 
	{
		delete this.tinTerrainsToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.parseOctreesPCloud = function(gl, visibleObjControlerOctrees, magoManager, maxParsesCount)
{
	var neoBuilding;
	var lowestOctree;
	var headerVersion;
	var node;
	var rootNode;
	var geoLocDataManager;
	
	if (this.matrix4SC === undefined)
	{ this.matrix4SC = new Matrix4(); }
	
	var octreesParsedCount = 0;
	if (maxParsesCount === undefined)
	{ maxParsesCount = 20; }
	
	var octreesCount = Object.keys(this.octreesLod0ReferencesToParseMap).length;
	if (octreesCount > 0)
	{
		// 1rst parse the currently closest lowestOctrees to camera.
		var octreesLod0Count = visibleObjControlerOctrees.currentVisibles0.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = visibleObjControlerOctrees.currentVisibles0[i];
			if (this.parseOctreesLod0References(gl, lowestOctree, magoManager))
			{
				octreesParsedCount++;
			}
			else 
			{
				// test else.
				//if (lowestOctree.neoReferencesMotherAndIndices)
				//{
				//	if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
				//	{ var hola = 0; }
				//}
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		// now clear queue.***
		
		
		// if no parsed any octree, then parse some octrees of the queue.
		if (octreesParsedCount === 0)
		{
			//var octreesArray = Array.from(this.octreesLod0ReferencesToParseMap.keys());
			//var octreesArray = Object.keys(this.octreesLod0ReferencesToParseMap);
			///for (var i=0; i<octreesArray.length; i++)
			for (var key in this.octreesLod0ReferencesToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(foo, key))
				{
					lowestOctree = this.octreesLod0ReferencesToParseMap[key];
					delete this.octreesLod0ReferencesToParseMap[key];
					this.parseOctreesLod0References(gl, lowestOctree, magoManager);
	
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
	}
	
	if (octreesParsedCount > 0)
	{ return true; }
	else { return false; }
};

ParseQueue.prototype.parseOctreesLod0References = function(gl, visibleObjControlerOctrees, magoManager, maxParsesCount)
{
	var neoBuilding;
	var lowestOctree;
	var headerVersion;
	var node;
	var rootNode;
	var geoLocDataManager;
	
	if (this.matrix4SC === undefined)
	{ this.matrix4SC = new Matrix4(); }
	
	var octreesParsedCount = 0;
	if (maxParsesCount === undefined)
	{ maxParsesCount = 20; }
	
	var octreesCount = Object.keys(this.octreesLod0ReferencesToParseMap).length;
	if (octreesCount > 0)
	{
		// 1rst parse the currently closest lowestOctrees to camera.
		var octreesLod0Count = visibleObjControlerOctrees.currentVisibles0.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = visibleObjControlerOctrees.currentVisibles0[i];
			if (this.parseOctreesLod0References(gl, lowestOctree, magoManager))
			{
				octreesParsedCount++;
			}
			else 
			{
				// test else.
				//if (lowestOctree.neoReferencesMotherAndIndices)
				//{
				//	if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
				//	{ var hola = 0; }
				//}
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		// clear queue.***
		this.octreesLod0ReferencesToParseMap = {};
		/*
		
		// if no parsed any octree, then parse some octrees of the queue.
		if (octreesParsedCount === 0)
		{
			//var octreesArray = Array.from(this.octreesLod0ReferencesToParseMap.keys());
			//var octreesArray = Object.keys(this.octreesLod0ReferencesToParseMap);
			///for (var i=0; i<octreesArray.length; i++)
			for (var key in this.octreesLod0ReferencesToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(foo, key))
				{
					lowestOctree = this.octreesLod0ReferencesToParseMap[key];
					delete this.octreesLod0ReferencesToParseMap[key];
					this.parseOctreesLod0References(gl, lowestOctree, magoManager);
	
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		*/
	}
	
	if (octreesParsedCount > 0)
	{ return true; }
	else { return false; }
};

ParseQueue.prototype.parseOctreesLod0References = function(gl, lowestOctree, magoManager)
{
	var parsed = false;
	if (this.octreesLod0ReferencesToParseMap.hasOwnProperty(lowestOctree.octreeKey))
	{
		delete this.octreesLod0ReferencesToParseMap[lowestOctree.octreeKey];
		if (lowestOctree.neoReferencesMotherAndIndices === undefined)
		{ return false; }
		
		if (lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer === undefined)
		{ return false; }
	
		if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
		{ return false; }
		
		var neoBuilding = lowestOctree.neoBuildingOwner;
		var node = neoBuilding.nodeOwner;
		var rootNode;
		if (node)
		{ rootNode = node.getRoot(); }
		else
		{ rootNode = undefined; }
		
		if (rootNode === undefined)
		{ return false; }
		
		if (rootNode.data === undefined)
		{ return false; }
		
		var geoLocDataManager = rootNode.data.geoLocDataManager;
		
		if (geoLocDataManager === undefined)
		{ return false; }
	
		if (this.matrix4SC === undefined)
		{ this.matrix4SC = new Matrix4(); }
		
		//var buildingGeoLocation = neoBuilding.getGeoLocationData(); // old.***
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		var headerVersion = neoBuilding.getHeaderVersion();
		this.matrix4SC.setByFloat32Array(buildingGeoLocation.rotMatrix._floatArrays);
		if (headerVersion[0] === "v")
		{
			// parse beta version.
			lowestOctree.neoReferencesMotherAndIndices.parseArrayBufferReferences(gl, lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer, magoManager.readerWriter, neoBuilding, this.matrix4SC, magoManager);
		}
		else 
		{
			// parse vesioned.
			lowestOctree.neoReferencesMotherAndIndices.parseArrayBufferReferencesVersioned(gl, lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer, magoManager.readerWriter, neoBuilding, this.matrix4SC, magoManager);
		}
		lowestOctree.neoReferencesMotherAndIndices.multiplyKeyTransformMatrix(0, buildingGeoLocation.rotMatrix);
		lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer = undefined;
		parsed = true;
	}
	
	return parsed;
};


ParseQueue.prototype.putOctreeLod0ReferencesToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	///this.octreesLod0ReferencesToParseMap.set(octree, aValue);
	this.octreesLod0ReferencesToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreeLod0ReferencesToParse = function(octree)
{
	delete this.octreesLod0ReferencesToParseMap[octree.octreeKey];
};

ParseQueue.prototype.putOctreeLod0ModelsToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesLod0ModelsToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreeLod0ModelsToParse = function(octree)
{
	delete this.octreesLod0ModelsToParseMap[octree.octreeKey];
};

ParseQueue.prototype.putOctreeLod2LegosToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesLod2LegosToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreeLod2LegosToParse = function(octree)
{
	delete this.octreesLod2LegosToParseMap[octree.octreeKey];
};

ParseQueue.prototype.putOctreePCloudToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesPCloudToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreePCloudToParse = function(octree)
{
	if (octree === undefined)
	{ return false; }
	
	var key = octree.octreeKey;
	if (this.octreesPCloudToParseMap.hasOwnProperty(key)) 
	{
		delete this.octreesPCloudToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putSkinLegosToParse = function(skinLego, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.skinLegosToParseMap[skinLego.legoKey] = skinLego;
};

ParseQueue.prototype.eraseSkinLegosToParse = function(skinLego)
{
	delete this.skinLegosToParseMap[skinLego.legoKey];
};

ParseQueue.prototype.clearAll = function()
{
	this.octreesLod0ReferencesToParseMap = {};
	this.octreesLod0ModelsToParseMap = {};
	this.octreesLod2LegosToParseMap = {};
	
};

ParseQueue.prototype.eraseAny = function(octree)
{
	this.eraseOctreeLod0ReferencesToParse(octree);
	this.eraseOctreeLod0ModelsToParse(octree);
	this.eraseOctreeLod2LegosToParse(octree);
};




















'use strict';

/**
 * ProcessQueue
 * 
 * @alias ProcessQueue
 * @class ProcessQueue
 */
var ProcessQueue = function() 
{
	if (!(this instanceof ProcessQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.nodesToDeleteMap = {};
	this.nodesToDeleteModelReferencesMap = {};
	this.nodesToDeleteLessThanLod3Map = {};
	this.nodesToDeleteLessThanLod4Map = {};
	this.nodesToDeleteLessThanLod5Map = {};
	this.nodesToDeleteLodMeshMap = {}; // no used.***
	this.tinTerrainsToDeleteMap = {};
};

ProcessQueue.prototype.putNodeToDeleteLodMesh = function(node, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLodMeshMap[key] = node;
	
	//this.nodesToDeleteLodMeshMap.set(node, aValue);
};

ProcessQueue.prototype.eraseNodeToDeleteLodMesh = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod3Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLodMeshMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLodMeshMap[key];
		return true;
	}
	return false;
	//return this.nodesToDeleteLodMeshMap.delete(node);
};

ProcessQueue.prototype.putTinTerrainToDelete = function(tinTerrain, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (tinTerrain === undefined)
	{ return; }
	
	var key = tinTerrain.pathName;
	this.tinTerrainsToDeleteMap[key] = tinTerrain;
};

ProcessQueue.prototype.eraseTinTerrainToDelete = function(tinTerrain)
{
	// this erases the tinTerrain from the "tinTerrainsToDeleteMap".
	if (tinTerrain === undefined)
	{ return; }
	
	var key = tinTerrain.pathName;
	if (this.tinTerrainsToDeleteMap.hasOwnProperty(key)) 
	{
		delete this.tinTerrainsToDeleteMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod3 = function(node, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod3Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod3 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod3Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod3Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod3Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod4 = function(node, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod4Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod4 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod4Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod4Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod4Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod5 = function(node, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod5Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod5 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod5Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod5Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod5Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteModelReferences = function(node, aValue)
{
	// this puts the node to the "nodesToDeleteModelReferencesMap".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteModelReferencesMap[key] = node;
	//this.nodesToDeleteModelReferencesMap.set(node, aValue);
};

ProcessQueue.prototype.eraseNodeToDeleteModelReferences = function(node)
{
	// this erases the node from the "nodesToDeleteModelReferencesMap".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteModelReferencesMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteModelReferencesMap[key];
		return true;
	}
	return false;
	//return this.nodesToDeleteModelReferencesMap.delete(node);
};

ProcessQueue.prototype.putNodeToDelete = function(node, aValue)
{
	// this puts the node to the "nodesToDeleteMap".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteMap[key] = node;
};

ProcessQueue.prototype.putNodesArrayToDelete = function(nodesToDeleteArray, aValue)
{
	if (nodesToDeleteArray === undefined)
	{ return; }
	
	// this puts the nodesToDeleteArray to the "nodesToDeleteArray".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	var nodesToDeleteCount = nodesToDeleteArray.length;
	for (var i=0; i<nodesToDeleteCount; i++)
	{
		this.putNodeToDelete(nodesToDeleteArray[i], aValue);
	}
};

ProcessQueue.prototype.eraseNodeToDelete = function(node)
{
	// this erases the node from the "nodesToDeleteMap".
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.eraseNodesArrayToDelete = function(nodesToEraseArray)
{
	// this erases the node from the "nodesToDeleteMap".
	var key;
	var nodesCount = nodesToEraseArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		key = nodesToEraseArray[i].data.neoBuilding.buildingId;
		delete this.nodesToDeleteMap[key];
	}
};

ProcessQueue.prototype.clearAll = function()
{
	this.nodesToDeleteMap = {};
	this.nodesToDeleteModelReferencesMap = {};
};



'use strict';

/**
 * @class ProjectTree
 */
var ProjectTree = function() 
{
	if (!(this instanceof ProjectTree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.root;
	
	this.nodesArray = [];
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ReaderWriter
 */
var ReaderWriter = function() 
{
	if (!(this instanceof ReaderWriter)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	//this.geometryDataPath = "/F4D_GeometryData";
	var serverPolicy = MagoConfig.getPolicy();
	if (serverPolicy !== undefined)
	{ this.geometryDataPath = serverPolicy.geo_data_path; }
	
	this.geometrySubDataPath;

	this.j_counter;
	this.k_counter;

	this.gl;
	this.incre_latAng = 0.001;
	this.incre_longAng = 0.001;
	this.GAIA3D__offset_latitude = -0.001;
	this.GAIA3D__offset_longitude = -0.001;
	this.GAIA3D__counter = 0;

	// Var for reading files.
	this.uint32;
	this.uint16;
	this.int16;
	this.float32;
	this.float16;
	this.int8;
	this.int8_value;
	this.max_color_value = 126;

	this.startBuff;
	this.endBuff;

	this.filesReadings_count = 0;

	// SCRATCH.*** 
	this.temp_var_to_waste;
	this.countSC;
	this.xSC;
	this.ySC;
	this.zSC;
	this.point3dSC = new Point3D();
	this.bboxSC = new BoundingBox();
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 */
ReaderWriter.prototype.getCurrentDataPath = function() 
{
	var currentDataPath;
	
	if (this.geometrySubDataPath !== undefined && this.geometrySubDataPath !== "")
	{
		currentDataPath = this.geometryDataPath + "/" + this.geometrySubDataPath;
	}
	else
		
	{
		currentDataPath = this.geometryDataPath;
	}
	
	return currentDataPath;
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint32[0]
 */
ReaderWriter.prototype.readUInt32 = function(buffer, start, end) 
{
	var uint32 = new Uint32Array(buffer.slice(start, end));
	return uint32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int32[0]
 */
ReaderWriter.prototype.readInt32 = function(buffer, start, end) 
{
	var int32 = new Int32Array(buffer.slice(start, end));
	return int32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 16비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint16[0]
 */
ReaderWriter.prototype.readUInt16 = function(buffer, start, end) 
{
	var uint16 = new Uint16Array(buffer.slice(start, end));
	return uint16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int16[0]
 */
ReaderWriter.prototype.readInt16 = function(buffer, start, end) 
{
	var int16 = new Int16Array(buffer.slice(start, end));
	return int16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 64비트 float값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float64[0]
 */
ReaderWriter.prototype.readFloat64 = function(buffer, start, end) 
{
	var float64 = new Float64Array(buffer.slice(start, end));
	return float64[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 float값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float32[0]
 */
ReaderWriter.prototype.readFloat32 = function(buffer, start, end) 
{
	var float32 = new Float32Array(buffer.slice(start, end));
	return float32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float16[0]
 */
ReaderWriter.prototype.readFloat16 = function(buffer, start, end) 
{
	var float16 = new Float32Array(buffer.slice(start, end));
	return float16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 8비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int8[0]
 */
ReaderWriter.prototype.readInt8 = function(buffer, start, end) 
{
	var int8 = new Int8Array(buffer.slice(start, end));
	return int8[0];
};

/**
 * 버퍼에서 데이터를 읽어서 8비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint8[0]
 */
ReaderWriter.prototype.readUInt8 = function(buffer, start, end) 
{
	var uint8 = new Uint8Array(buffer.slice(start, end));
	return uint8[0];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param buffer 변수
 * @param start 변수
 * @param end 변수
 * @returns int8_value
 */
ReaderWriter.prototype.readInt8ByteColor = function(buffer, start, end) 
{
	var int8 = new Int8Array(buffer.slice(start, end));
	var int8_value = int8[0];

	if (int8_value > max_color_value) { int8_value = max_color_value; }

	if (int8_value < 0) { int8_value += 256; }

	return int8_value;
};

function loadWithXhr(fileName) 
{
	// 1) 사용될 jQuery Deferred 객체를 생성한다.
	var deferred = $.Deferred();
	
	var xhr = new XMLHttpRequest();
	xhr.open("GET", fileName, true);
	xhr.responseType = "arraybuffer";;
	  
	// 이벤트 핸들러를 등록한다.
	xhr.onload = function() 
	{
		if (xhr.status < 200 || xhr.status >= 300) 
		{
			deferred.reject(xhr.status);
			return;
		}
		else 
		{
			// 3.1) DEFERRED를 해결한다. (모든 done()...을 동작시킬 것이다.)
			deferred.resolve(xhr.response);
		} 
	};
	
	xhr.onerror = function(e) 
	{
		console.log("Invalid XMLHttpRequest response type.");
		deferred.reject(xhr.status);
	};

	// 작업을 수행한다.
	xhr.send(null);
	
	// 참고: jQuery.ajax를 사용할 수 있었고 해야할 수 있었다.
	// 참고: jQuery.ajax는 Promise를 반환하지만 다른 Deferred/Promise를 사용하여 애플리케이션에 의미있는 구문으로 감싸는 것은 언제나 좋은 생각이다.
	// ---- /AJAX 호출 ---- //
	  
	// 2) 이 deferred의 promise를 반환한다.
	return deferred.promise();
};

ReaderWriter.prototype.getNeoBlocksArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
	blocksList.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			blocksList.dataArraybuffer = arrayBuffer;
			blocksList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
			
			
			magoManager.parseQueue.putOctreeLod0ModelsToParse(lowestOctree);
		}
		else 
		{
			blocksList.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("Invalid XMLHttpRequest status = " + status);
		if (status === 0) { blocksList.fileLoadState = 500; }
		else { blocksList.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getNeoReferencesArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			var neoRefsList = lowestOctree.neoReferencesMotherAndIndices;
			if (neoRefsList)
			{
				neoRefsList.dataArraybuffer = arrayBuffer;
				neoRefsList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putOctreeLod0ReferencesToParse(lowestOctree);
			}
			arrayBuffer = null;
			
		}
		else 
		{
			lowestOctree.neoReferencesMotherAndIndices.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { lowestOctree.neoReferencesMotherAndIndices.fileLoadState = 500; }
		else { lowestOctree.neoReferencesMotherAndIndices.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getOctreeLegoArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	if (lowestOctree.lego === undefined)
	{ return; }
	
	magoManager.fileRequestControler.filesRequestedCount += 1;
	lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (lowestOctree.lego)
			{
				lowestOctree.lego.dataArrayBuffer = arrayBuffer;
				lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putOctreeLod2LegosToParse(lowestOctree);
			}
			else 
			{
				lowestOctree = undefined;
			}
			arrayBuffer = null;
		}
		else 
		{
			lowestOctree.lego.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { lowestOctree.lego.fileLoadState = 500; }
		else { lowestOctree.lego.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.fileRequestControler.filesRequestedCount -= 1;
		if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getOctreePCloudArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	if (lowestOctree.lego === undefined)
	{ return; }
	
	magoManager.fileRequestControler.filesRequestedCount += 1;
	lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (lowestOctree.lego)
			{
				lowestOctree.lego.dataArrayBuffer = arrayBuffer;
				lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putOctreePCloudToParse(lowestOctree);
			}
			else 
			{
				lowestOctree = undefined;
			}
			arrayBuffer = null;
		}
		else 
		{
			lowestOctree.lego.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { lowestOctree.lego.fileLoadState = 500; }
		else { lowestOctree.lego.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.fileRequestControler.filesRequestedCount -= 1;
		if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getLegoArraybuffer = function(fileName, legoMesh, magoManager) 
{
	//magoManager.fileRequestControler.filesRequestedCount += 1;
	magoManager.fileRequestControler.lowLodDataRequestedCount += 1;
	legoMesh.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (legoMesh)
			{
				legoMesh.dataArrayBuffer = arrayBuffer;
				legoMesh.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putSkinLegosToParse(legoMesh);
			}
			arrayBuffer = null;
		}
		else 
		{
			legoMesh.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { legoMesh.fileLoadState = 500; }
		//else { legoMesh.fileLoadState = status; }
		else 
		{ 
			legoMesh.fileLoadState = -1; 
		}
	}).always(function() 
	{
		//magoManager.fileRequestControler.filesRequestedCount -= 1;
		magoManager.fileRequestControler.lowLodDataRequestedCount -= 1;
		//if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
		if (magoManager.fileRequestControler.lowLodDataRequestedCount < 0) { magoManager.fileRequestControler.lowLodDataRequestedCount = 0; }
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param gl gl context
 * @param fileName 파일명
 * @param readerWriter 파일 처리를 담당
 * @param neoBuildingsList object index 파일을 파싱한 정보를 저장할 배열
 */
ReaderWriter.prototype.getObjectIndexFileForSmartTile = function(fileName, magoManager, buildingSeedList, projectId) 
{
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			buildingSeedList.dataArrayBuffer = arrayBuffer;
			buildingSeedList.parseBuildingSeedArrayBuffer();
			
			magoManager.makeSmartTile(buildingSeedList, projectId);
			arrayBuffer = null;
			//MagoConfig.setObjectIndex("append", );
		}
		else 
		{
			// blocksList.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).always(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param gl gl context
 * @param fileName 파일명
 * @param readerWriter 파일 처리를 담당
 * @param neoBuildingsList object index 파일을 파싱한 정보를 저장할 배열
 */
ReaderWriter.prototype.getObjectIndexFile = function(fileName, readerWriter, neoBuildingsList, magoManager) 
{
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			readerWriter.parseObjectIndexFile(arrayBuffer, neoBuildingsList);
			arrayBuffer = null;
			magoManager.createDeploymentGeoLocationsForHeavyIndustries();
		}
		else 
		{
			//			blocksList.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).always(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param arrayBuffer object index file binary data
 * @param neoBuildingsList object index 파일을 파싱한 정보를 저장할 배열
 */
ReaderWriter.prototype.parseObjectIndexFile = function(arrayBuffer, neoBuildingsList) 
{
	var bytesReaded = 0;
	var buildingNameLength;
	var longitude;
	var latitude;
	var altitude;

	var buildingsCount = this.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	for (var i =0; i<buildingsCount; i++) 
	{
		// read the building location data.***
		var neoBuilding = neoBuildingsList.newNeoBuilding();
		if (neoBuilding.metaData === undefined) 
		{
			neoBuilding.metaData = new MetaData();
		}

		if (neoBuilding.metaData.geographicCoord === undefined)
		{ neoBuilding.metaData.geographicCoord = new GeographicCoord(); }

		if (neoBuilding.metaData.bbox === undefined) 
		{
			neoBuilding.metaData.bbox = new BoundingBox();
		}

		buildingNameLength = this.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
		bytesReaded += 4;
		var buildingName = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		bytesReaded += buildingNameLength;

		longitude = this.readFloat64(arrayBuffer, bytesReaded, bytesReaded+8); bytesReaded += 8;
		latitude = this.readFloat64(arrayBuffer, bytesReaded, bytesReaded+8); bytesReaded += 8;
		altitude = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		neoBuilding.bbox = new BoundingBox();
		neoBuilding.bbox.minX = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.minY = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.minZ = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxX = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxY = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxZ = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		// create a building and set the location.***
		neoBuilding.buildingId = buildingName.substr(4, buildingNameLength-4);
		neoBuilding.buildingType = "basicBuilding";
		neoBuilding.buildingFileName = buildingName;
		neoBuilding.metaData.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
	}

	neoBuildingsList.neoBuildingsArray.reverse();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 변수
 * @param neoBuilding 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.getNeoHeaderAsimetricVersion = function(gl, fileName, neoBuilding, readerWriter, magoManager) 
{
	function Utf8ArrayToStr(array) 
	{
		var out, i, len, c;
		var char2, char3;

		out = "";
		len = array.length;
		i = 0;
		while (i < len) 
		{
			c = array[i++];
			switch (c >> 4)
			{ 
			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
				// 0xxxxxxx
				out += String.fromCharCode(c);
				break;
			case 12: case 13:
				// 110x xxxx   10xx xxxx
				char2 = array[i++];
				out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
				break;
			case 14:
				// 1110 xxxx  10xx xxxx  10xx xxxx
				char2 = array[i++];
				char3 = array[i++];
				out += String.fromCharCode(((c & 0x0F) << 12) |
                       ((char2 & 0x3F) << 6) |
                       ((char3 & 0x3F) << 0));
				break;
			}
		}

		return out;
	};

	//BR_Project._f4d_header_readed = true;
	magoManager.fileRequestControler.headerFilesRequestedCount += 1;
	neoBuilding.metaData.fileLoadState = CODE.fileLoadState.LOADING_STARTED;

	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (neoBuilding.metaData === undefined) 
			{
				neoBuilding.metaData = new MetaData();
			}
			var bytesReaded = neoBuilding.metaData.parseFileHeaderAsimetricVersion(arrayBuffer, readerWriter);
			
			// Now, make the neoBuilding's octree.***
			if (neoBuilding.octree === undefined) { neoBuilding.octree = new Octree(undefined); }
			neoBuilding.octree.neoBuildingOwnerId = neoBuilding.buildingId;
			neoBuilding.octree.octreeKey = neoBuilding.buildingId + "_" + neoBuilding.octree.octree_number_name;

			// now, parse octreeAsimetric.***
			bytesReaded = neoBuilding.octree.parseAsimetricVersion(arrayBuffer, readerWriter, bytesReaded, neoBuilding);

			neoBuilding.metaData.oct_min_x = neoBuilding.octree.centerPos.x - neoBuilding.octree.half_dx;
			neoBuilding.metaData.oct_max_x = neoBuilding.octree.centerPos.x + neoBuilding.octree.half_dx;
			neoBuilding.metaData.oct_min_y = neoBuilding.octree.centerPos.y - neoBuilding.octree.half_dy;
			neoBuilding.metaData.oct_max_y = neoBuilding.octree.centerPos.y + neoBuilding.octree.half_dy;
			neoBuilding.metaData.oct_min_z = neoBuilding.octree.centerPos.z - neoBuilding.octree.half_dz;
			neoBuilding.metaData.oct_max_z = neoBuilding.octree.centerPos.z + neoBuilding.octree.half_dz;
			
			// now parse materialsList of the neoBuilding.
			//var ver0 = neoBuilding.metaData.version[0];
			//var ver1 = neoBuilding.metaData.version[2];
			//var ver2 = neoBuilding.metaData.version[4];
			
			//if (ver0 === '0' && ver1 === '0' && ver2 === '1')
			if (neoBuilding.metaData.version === "0.0.1" || neoBuilding.metaData.version === "0.0.2")
			{
				// read materials list.
				var materialsCount = readerWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				for (var i=0; i<materialsCount; i++)
				{
					var textureTypeName = "";
					var textureImageFileName = "";

					// Now, read the texture_type and texture_file_name.***
					var texture_type_nameLegth = readerWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
					for (var j=0; j<texture_type_nameLegth; j++) 
					{
						textureTypeName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)));bytesReaded += 1; // for example "diffuse".***
					}

					var texture_fileName_Legth = readerWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
					var charArray = new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ texture_fileName_Legth)); bytesReaded += texture_fileName_Legth;
					var decoder = new TextDecoder('utf-8');
					textureImageFileName = decoder.decode(charArray);
					
					if (texture_fileName_Legth > 0)
					{
						var texture = new Texture();
						texture.textureTypeName = textureTypeName;
						texture.textureImageFileName = textureImageFileName;
						
						if (neoBuilding.texturesLoaded === undefined)
						{ neoBuilding.texturesLoaded = []; }
						
						neoBuilding.texturesLoaded.push(texture);
					}
				}
				
				// read geometry type data.***
				var lod;
				var nameLength;
				var lodBuildingDatasCount = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
				if (lodBuildingDatasCount !== undefined)
				{
					neoBuilding.lodBuildingDatasMap = {};
					
					for (var i =0; i<lodBuildingDatasCount; i++)
					{
						var lodBuildingData = new LodBuildingData();
						lodBuildingData.lod = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
						lodBuildingData.isModelRef = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
						
						if (lodBuildingData.lod === 2)
						{
							// read the lod2_textureFileName.***
							nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
							lodBuildingData.textureFileName = "";
							for (var j=0; j<nameLength; j++) 
							{
								lodBuildingData.textureFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)));bytesReaded += 1; 
							}
						}
						
						if (!lodBuildingData.isModelRef)
						{
							nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
							lodBuildingData.geometryFileName = "";
							for (var j=0; j<nameLength; j++) 
							{
								lodBuildingData.geometryFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)));bytesReaded += 1; 
							}
							
							nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
							lodBuildingData.textureFileName = "";
							for (var j=0; j<nameLength; j++) 
							{
								lodBuildingData.textureFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)));bytesReaded += 1; 
							}
						}
						neoBuilding.lodBuildingDatasMap[lodBuildingData.lod] = lodBuildingData;
					}

				}
			}

			neoBuilding.metaData.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;

			//BR_Project._f4d_header_readed_finished = true;
			arrayBuffer = undefined;
		}
		else 
		{
			neoBuilding.metaData.fileLoadState = 500;
			arrayBuffer = undefined;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { neoBuilding.metaData.fileLoadState = 500; }
		else { neoBuilding.metaData.fileLoadState = status; }
	}).always(function() 
	{
		magoManager.fileRequestControler.headerFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.headerFilesRequestedCount < 0) { magoManager.fileRequestControler.headerFilesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param imageArrayBuffer 변수
 * @param BR_Project 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 * @param imageLod 변수
 */
ReaderWriter.prototype.readNailImageOfArrayBuffer = function(gl, imageArrayBuffer, BR_Project, readerWriter, magoManager, imageLod) 
{
	var simpBuildingV1 = BR_Project._simpleBuilding_v1;
	var blob = new Blob( [ imageArrayBuffer ], { type: "image/jpeg" } );
	var urlCreator = window.URL || window.webkitURL;
	var imagenUrl = urlCreator.createObjectURL(blob);
	var simpleBuildingImage = new Image();

	simpleBuildingImage.onload = function () 
	{
		//console.log("Image Onload");
		if (simpBuildingV1._simpleBuildingTexture === undefined)
		{ simpBuildingV1._simpleBuildingTexture = gl.createTexture(); }
		handleTextureLoaded(gl, simpleBuildingImage, simpBuildingV1._simpleBuildingTexture);
		BR_Project._f4d_nailImage_readed_finished = true;
		imageArrayBuffer = null;
		BR_Project._simpleBuilding_v1.textureArrayBuffer = null;

		if (magoManager.backGround_imageReadings_count > 0) 
		{
			magoManager.backGround_imageReadings_count--;
		}
	};

	simpleBuildingImage.onerror = function() 
	{
		// doesn't exist or error loading

		//BR_Project._f4d_lod0Image_readed_finished = false;
		//BR_Project._f4d_lod0Image_exists = false;
		//if(magoManager.backGround_fileReadings_count > 0 )
		//	  magoManager.backGround_fileReadings_count -=1;

		return;
	};

	simpleBuildingImage.src = imagenUrl;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param BR_Project 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 * @param imageLod 변수
 */
ReaderWriter.prototype.readNailImage = function(gl, filePath_inServer, BR_Project, readerWriter, magoManager, imageLod) 
{
	if (imageLod === undefined) { imageLod = 3; } // The lowest lod.***

	if (imageLod === 3) { BR_Project._f4d_nailImage_readed = true; }
	else if (imageLod === 0) { BR_Project._f4d_lod0Image_readed  = true; }

	if (BR_Project._simpleBuilding_v1 === undefined) { BR_Project._simpleBuilding_v1 = new SimpleBuildingV1(); }

	var simpBuildingV1 = BR_Project._simpleBuilding_v1;

	var simpleBuildingImage = new Image();
	simpleBuildingImage.onload = function() 
	{
	/*
		if(magoManager.render_time > 20)// for the moment is a test.***
		{
			if(imageLod === 3)
				BR_Project._f4d_nailImage_readed = false;
			else if(imageLod === 0)
				BR_Project._f4d_lod0Image_readed  = false;

			if(magoManager.backGround_fileReadings_count > 0 )
			  magoManager.backGround_fileReadings_count -=1;

			return;
		}
		*/

		if (imageLod === 3) 
		{
			handleTextureLoaded(gl, simpleBuildingImage, simpBuildingV1._simpleBuildingTexture);
			BR_Project._f4d_nailImage_readed_finished = true;
		}
		else if (imageLod === 0) 
		{
			if (simpBuildingV1._texture_0 === undefined) { simpBuildingV1._texture_0 = gl.createTexture(); }

			handleTextureLoaded(gl, simpleBuildingImage, simpBuildingV1._texture_0);
			BR_Project._f4d_lod0Image_readed_finished = true;
		}

		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
	};

	simpleBuildingImage.onerror = function() 
	{
		// doesn't exist or error loading
		BR_Project._f4d_lod0Image_readed_finished = false;
		BR_Project._f4d_lod0Image_exists = false;
		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
		return;
	};

	var filePath_inServer_SimpleBuildingImage = filePath_inServer;
	simpleBuildingImage.src = filePath_inServer_SimpleBuildingImage;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param f4dTex 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readTexture = function(gl, filePath_inServer, f4dTex, magoManager) 
{
	f4dTex.loadStarted = true;
	//f4dTex.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	f4dTex.texImage = new Image();
	f4dTex.texImage.onload = function() 
	{
		f4dTex.loadFinished = true;
		//f4dTex.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;

		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
	};

	f4dTex.texImage.onerror = function() 
	{
		// doesn't exist or error loading
		f4dTex.loadStarted = false;
		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
		return;
	};

	f4dTex.texImage.src = filePath_inServer;
};

ReaderWriter.prototype.decodeTGA = function(arrayBuffer) 
{
	// code from toji.***
	var content = new Uint8Array(arrayBuffer),
		contentOffset = 18 + content[0],
		imagetype = content[2], // 2 = rgb, only supported format for now
		width = content[12] + (content[13] << 8),
		height = content[14] + (content[15] << 8),
		bpp = content[16], // should be 8,16,24,32
		
		bytesPerPixel = bpp / 8,
		bytesPerRow = width * 4,
		data, i, j, x, y;

	if (!width || !height) 
	{
		console.error("Invalid dimensions");
		return null;
	}

	if (imagetype !== 2) 
	{
		console.error("Unsupported TGA format:", imagetype);
		return null;
	}

	data = new Uint8Array(width * height * 4);
	i = contentOffset;

	// Oy, with the flipping of the rows...
	for (y = height-1; y >= 0; --y) 
	{
		for (x = 0; x < width; ++x, i += bytesPerPixel) 
		{
			j = (x * 4) + (y * bytesPerRow);
			data[j] = content[i+2];
			data[j+1] = content[i+1];
			data[j+2] = content[i+0];
			data[j+3] = (bpp === 32 ? content[i+3] : 255);
		}
	}

	return {
		width  : width,
		height : height,
		data   : data
	};
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readNeoReferenceTexture = function(gl, filePath_inServer, texture, neoBuilding, magoManager) 
{
	// Must know the fileExtension.***
	var extension = filePath_inServer.split('.').pop();
	
	if (extension === "tga" || extension === "TGA" || extension === "Tga")
	{
		texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
		loadWithXhr(filePath_inServer).done(function(response) 
		{
			var arrayBuffer = response;
			if (arrayBuffer) 
			{
				// decode tga.***
				// Test with tga decoder from https://github.com/schmittl/tgajs
				var tga = new TGA();
				tga.load(arrayBuffer);
				// End decoding.---------------------------------------------------
				
				//var tga = magoManager.readerWriter.decodeTGA(arrayBuffer); // old code.
				//if(tga) {
				//    gl.bindTexture(gl.TEXTURE_2D, texture.texId);
				//     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, tga.width, tga.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tga.data);
				//    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				//	gl.generateMipmap(gl.TEXTURE_2D);
				//	texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***
				//}
				
				// example values of tga.header
				// alphaBits 0
				// bytePerPixel 3
				// colorMapDepth 0
				// colorMapIndex 0
				// colorMapLength 0
				// colorMapType 0
				// flags 32
				// hasColorMap false
				// hasEncoding false
				// height 2048
				// idLength 0
				// imageType 2
				// isGreyColor false
				// offsetX 0
				// offsetY 0
				// origin 2
				// pixelDepth 24
				// width 2048
				
				if (tga) 
				{
					var rgbType;
					if (tga.header.bytePerPixel === 3)
					{
						rgbType = gl.RGB;
						
						// test change rgb to bgr.***
						/*
						var imageDataLength = tga.imageData.length;
						var pixelsCount = imageDataLength/3;
						var r, g, b;
						for(var i=0; i<pixelsCount; i++)
						{
							r = tga.imageData[i*3];
							g = tga.imageData[i*3+1];
							b = tga.imageData[i*3+2];
							
							tga.imageData[i*3] = b;
							tga.imageData[i*3+1] = g;
							tga.imageData[i*3+2] = r;
						}
						*/
					}
					else if (tga.header.bytePerPixel === 4)
					{
						rgbType = gl.RGBA;
						
						// test change rgb to bgr.***
						
						var imageDataLength = tga.imageData.length;
						var pixelsCount = imageDataLength/4;
						var r, g, b, a;
						for (var i=0; i<pixelsCount; i++)
						{
							r = tga.imageData[i*4];
							g = tga.imageData[i*4+1];
							b = tga.imageData[i*4+2];
							a = tga.imageData[i*4+3];
							
							tga.imageData[i*4] = b;
							tga.imageData[i*4+1] = g;
							tga.imageData[i*4+2] = r;
							tga.imageData[i*4+3] = a;
						}
						
					}
					
					
					if (tga.imageData !== undefined && tga.imageData.length > 0 && texture.texId !== undefined)
					{
						gl.bindTexture(gl.TEXTURE_2D, texture.texId);
						gl.texImage2D(gl.TEXTURE_2D, 0, rgbType, tga.header.width, tga.header.height, 0, rgbType, gl.UNSIGNED_BYTE, tga.imageData);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
						gl.generateMipmap(gl.TEXTURE_2D);
						texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***
						gl.bindTexture(gl.TEXTURE_2D, null);
					}
					else 
					{
						var hola = 0;

					}
				}
			}
		}).fail(function(status) 
		{
			if (neoBuilding)
			{
				console.log("xhr status = " + status);
				if (status === 0) { neoBuilding.metaData.fileLoadState = 500; }
				else { neoBuilding.metaData.fileLoadState = status; }
			}
		}).always(function() 
		{
			magoManager.backGround_fileReadings_count -= 1;
			if (magoManager.backGround_fileReadings_count < 0) { magoManager.backGround_fileReadings_count = 0; }
		});
	}
	else 
	{
		var neoRefImage = new Image();
		texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED; // file load started.***
		
		//magoManager.backGround_fileReadings_count ++;
		neoRefImage.onload = function() 
		{
			// is possible that during loading image the building was deleted. Then return.
			if (texture.texId === undefined)
			{
				return;
			}
			
			// if "texture.texId" exist then bind it.
			handleTextureLoaded(gl, neoRefImage, texture.texId);
			texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***

			if (magoManager.backGround_fileReadings_count > 0 ) 
			{ magoManager.backGround_fileReadings_count -=1; }
		};

		neoRefImage.onerror = function() 
		{
			// doesn't exist or error loading
			return;
		};
		neoRefImage.src = filePath_inServer;
	}	
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readLegoSimpleBuildingTexture = function(gl, filePath_inServer, texture, magoManager) 
{
	var neoRefImage = new Image();
	texture.fileLoadState == CODE.fileLoadState.LOADING_STARTED;
	magoManager.fileRequestControler.lowLodImagesRequestedCount += 1;

	neoRefImage.onload = function() 
	{
		if (texture.texId === undefined) 
		{ texture.texId = gl.createTexture(); }

		handleTextureLoaded(gl, neoRefImage, texture.texId);
		texture.fileLoadState == CODE.fileLoadState.LOADING_FINISHED;
		
		magoManager.fileRequestControler.lowLodImagesRequestedCount -= 1;

		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
		if (magoManager.fileRequestControler.lowLodImagesRequestedCount < 0) { magoManager.fileRequestControler.lowLodImagesRequestedCount = 0; }
	};

	neoRefImage.onerror = function() 
	{
		if (texture.texId === undefined) 
		{
			texture.texId = gl.createTexture();
			// Test wait for texture to load.********************************************
			gl.bindTexture(gl.TEXTURE_2D, texture.texId);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([200, 200, 200, 255])); // clear grey
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
		
		texture.fileLoadState == CODE.fileLoadState.READY;
		
		magoManager.fileRequestControler.lowLodImagesRequestedCount -= 1;
		if (magoManager.fileRequestControler.lowLodImagesRequestedCount < 0) { magoManager.fileRequestControler.lowLodImagesRequestedCount = 0; }
	};

	neoRefImage.src = filePath_inServer;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 변수
 * @param terranTile 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.getTileArrayBuffer = function(gl, fileName, terranTile, readerWriter, magoManager) 
{
	// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data
	terranTile.fileReading_started = true;
	//	magoManager.fileRequestControler.backGround_fileReadings_count += 1;
	//	blocksList.fileLoadState = CODE.fileLoadState.LOADING_STARTED;

	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			//var BR_Project = new BRBuildingProject(); // Test.***
			//readerWriter.readF4D_Header(gl, arrayBuffer, BR_Project ); // Test.***
			terranTile.fileArrayBuffer = arrayBuffer;
			terranTile.fileReading_finished = true;

			if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
			//			blocksList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
		}
		else 
		{
			//			blocksList.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).always(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param pCloud 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.loadTINTerrain = function(gl, fileName, tinTerrain, magoManager) 
{
	//magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	tinTerrain.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).done(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			tinTerrain.dataArrayBuffer = arrayBuffer;
			tinTerrain.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			//magoManager.parseQueue.putTinTerrainToParse(lowestOctree); // todo.***
			arrayBuffer = undefined;
		}
		else 
		{
			tinTerrain.fileLoadState = 500;
		}
	}).fail(function(status) 
	{
		//console.log("xhr status = " + status);
		//if (status === 0) { lowestOctree.neoReferencesMotherAndIndices.fileLoadState = 500; }
		//else { lowestOctree.neoReferencesMotherAndIndices.fileLoadState = status; }
	}).always(function() 
	{
		//magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		//if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};


//load neoTextures
ReaderWriter.prototype.handleTextureLoaded = function(gl, image, texture) 
{
	// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL
	//var gl = viewer.scene.context._gl;
	gl.bindTexture(gl.TEXTURE_2D, texture);
	//gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true); // if need vertical mirror of the image.***
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Original.***
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	gl.generateMipmap(gl.TEXTURE_2D);
	gl.bindTexture(gl.TEXTURE_2D, null);
};

'use strict';

/**
 * @class TinTerrain
 */
var TinTerrain = function() 
{
	if (!(this instanceof TinTerrain)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.owner; // undefined if depth = 0.***
	this.geographicExtent;
	this.fileLoadState = 0;
	this.dataArrayBuffer;
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeysContainer.***
	this.terrainPositionHIGH;
	this.terrainPositionLOW;
	this.pathName; // example: "14//4567//516".***
	this.texture;
};

TinTerrain.prototype.zigZagDecode = function(value)
{
	return (value >> 1) ^ (-(value & 1));
};

TinTerrain.prototype.makeVbo = function()
{
	if (this.cartesiansArray === undefined)
	{ return; }
	
	// rest the CenterPosition to the this.cartesiansArray.***
	var coordsCount = this.cartesiansArray.length/3;
	for (var i=0; i<coordsCount; i++)
	{
		this.cartesiansArray[i*3] -= this.centerX;
		this.cartesiansArray[i*3+1] -= this.centerY;
		this.cartesiansArray[i*3+2] -= this.centerZ;
	}
	
	if (this.terrainPositionHIGH === undefined)
	{ this.terrainPositionHIGH = new Float32Array(3); }

	if (this.terrainPositionLOW === undefined)
	{ this.terrainPositionLOW = new Float32Array(3); }
	ManagerUtils.calculateSplited3fv([this.centerX[0], this.centerY[0], this.centerZ[0]], this.terrainPositionHIGH, this.terrainPositionLOW);
	
	if (this.vboKeyContainer === undefined)
	{ this.vboKeyContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var vboKey = this.vboKeyContainer.newVBOVertexIdxCacheKey();
	vboKey.posVboDataArray = this.cartesiansArray;
	vboKey.tcoordVboDataArray = this.texCoordsArray;
	vboKey.idxVboDataArray = this.indices;
	vboKey.indicesCount = this.indices.length;
	/*
	if (normal)
	{ vboKey.norVboDataArray = Int8Array.from(norArray); }
	
	if (color)
	{ vboKey.colVboDataArray = Uint8Array.from(colArray); }
	
*/
};

TinTerrain.prototype.decodeData = function()
{
	if (this.geographicExtent === undefined)
	{ return; }
	
	if (this.vertexArray === undefined)
	{ this.vertexArray = []; }
	
	var degToRadFactor = Math.PI/180.0;
	// latitude & longitude in RADIANS.***
	var minLon = this.geographicExtent.minGeographicCoord.longitude * degToRadFactor;
	var minLat = this.geographicExtent.minGeographicCoord.latitude * degToRadFactor;
	var maxLon = this.geographicExtent.maxGeographicCoord.longitude * degToRadFactor;
	var maxLat = this.geographicExtent.maxGeographicCoord.latitude * degToRadFactor;
	var lonRange = maxLon - minLon;
	var latRange = maxLat - minLat;
	
	var minHeight = this.minHeight[0];
	var maxHeight = this.maxHeight[0];
	var heightRange = maxHeight - minHeight;
	
	var vertexCount = this.vertexCount[0];
	this.texCoordsArray = new Float32Array(vertexCount*2);
	var lonArray = new Float32Array(vertexCount);
	var latArray = new Float32Array(vertexCount);
	var altArray = new Float32Array(vertexCount);
	var shortMax = 32767; // 65536
	var lonRangeDivShortMax = lonRange/shortMax;
	var latRangeDivShortMax = latRange/shortMax;
	var heightRangeDivShortMax = heightRange/shortMax;
	var uValues = this.uValues;
	var vValues = this.vValues;
	var hValues = this.hValues;
	for (var i=0; i<vertexCount; i++)
	{
		lonArray[i] = minLon + uValues[i]*lonRangeDivShortMax;
		latArray[i] = minLat + vValues[i]*latRangeDivShortMax;
		altArray[i] = minHeight + hValues[i]*heightRangeDivShortMax + 2.0;
		
		// Test.***
		//altArray[i] *= 3;
		
		// make texcoords.***
		this.texCoordsArray[i*2] = uValues[i]/shortMax;
		this.texCoordsArray[i*2+1] = vValues[i]/shortMax;
	}
	
	this.cartesiansArray = Globe.geographicRadianArrayToFloat32ArrayWgs84(lonArray, latArray, altArray, this.cartesiansArray);
	
	// free memory.***
	this.uValues = undefined;
	this.vValues = undefined;
	this.hValues = undefined;
	
	lonArray = undefined;
	latArray = undefined;
	altArray = undefined;
	
};

TinTerrain.prototype.parseData = function(dataArrayBuffer)
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytes_readed = 0;
	
	// 1. header.***
	this.centerX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.centerY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.centerZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	this.minHeight = new Float32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	this.maxHeight = new Float32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	
	this.boundingSphereCenterX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereCenterY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereCenterZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereRadius = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	this.horizonOcclusionPointX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.horizonOcclusionPointY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.horizonOcclusionPointZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	// 2. vertex data.***
	this.vertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	var vertexCount = this.vertexCount[0];
	this.uValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	this.vValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	this.hValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	
	// decode data.***
	var u = 0;
	var v = 0;
	var height = 0;
	for (var i=0; i<vertexCount; i++)
	{
		u += this.zigZagDecode(this.uValues[i]);
		v += this.zigZagDecode(this.vValues[i]);
		height += this.zigZagDecode(this.hValues[i]);
		
		this.uValues[i] = u;
		this.vValues[i] = v;
		this.hValues[i] = height;
	}
	
	// 3. indices.***
	this.trianglesCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
	var trianglesCount = this.trianglesCount;
	if (vertexCount > 65536 )
	{
		this.indices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * trianglesCount * 3)); bytes_readed += 4 * trianglesCount * 3;
	}
	else 
	{
		this.indices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * trianglesCount * 3)); bytes_readed += 2 * trianglesCount * 3;
	}
	
	// decode indices.***
	var code;
	var highest = 0;
	var indicesCount = this.indices.length;
	for (var i=0; i<indicesCount; i++)
	{
		code = this.indices[i];
		this.indices[i] = highest - code;
		if (code === 0) 
		{
			++highest;
		}
	}
	
	// 4. edges indices.***
	if (vertexCount > 65536 )
	{
		this.westVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.westIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.westVertexCount)); bytes_readed += 4 * this.westVertexCount;
		
		this.southVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.southIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.southVertexCount)); bytes_readed += 4 * this.southVertexCount;
		
		this.eastVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.eastIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.eastVertexCount)); bytes_readed += 4 * this.eastVertexCount;
		
		this.northVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.northIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.northVertexCount)); bytes_readed += 4 * this.northVertexCount;
	}
	else
	{
		this.westVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.westIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.westVertexCount)); bytes_readed += 2 * this.westVertexCount;
		
		this.southVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.southIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.southVertexCount)); bytes_readed += 2 * this.southVertexCount;
		
		this.eastVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.eastIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.eastVertexCount)); bytes_readed += 2 * this.eastVertexCount;
		
		this.northVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.northIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.northVertexCount)); bytes_readed += 2 * this.northVertexCount;
	}
	
	// 5. extension header.***
	this.extensionId = new Uint8Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 1)); bytes_readed += 1;
	this.extensionLength = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
	
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	
	if (this.extensionId.length === 0)
	{
		dataArrayBuffer = undefined;
		return;
	}
	
	dataArrayBuffer = undefined;
};





















































'use strict';

/**
 * @class TinTerrainManager
 */
var TinTerrainManager = function() 
{
	if (!(this instanceof TinTerrainManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.maxDepth = 15;
	this.currentVisibles_terrName_geoCoords_map = {}; // current visible terrains map[terrainPathName, geographicCoords].***
	this.currentTerrainsMap = {}; // current terrains (that was created) map[terrainPathName, tinTerrain].***
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Arc
 */
var Arc = function() 
{
	if (!(this instanceof Arc)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// sweeping in CounterClockWise is positive.***
	// zero startAngle is in "X" axis positive.***
	this.centerPoint; // Point3D.***
	this.radius;
	this.startAngleDeg;
	this.sweepAngleDeg;
	this.numPointsFor360Deg; // interpolation param.***
	
	// Alternative vars.***
	this.startPoint; // if no exist radius, then startPoint define the radius.***
	this.endPoint;
	this.sweepSense; // 1=CCW, -1=CW.***
};

/**
 * Set the center position of arc.
 * @class Arc
 */
Arc.prototype.deleteObjects = function()
{
	if (this.centerPoint !== undefined)
	{ this.centerPoint.deleteObjects(); } // Point3D.***
	this.centerPoint = undefined;
	this.radius = undefined;
	this.startAngleDeg = undefined;
	this.sweepAngleDeg = undefined;
	this.numPointsFor360Deg = undefined;
	
	if (this.startPoint !== undefined)
	{ this.startPoint.deleteObjects(); } 
	
	this.startPoint = undefined;
	
	if (this.endPoint !== undefined)
	{ this.endPoint.deleteObjects(); } 
	
	this.endPoint = undefined;
	this.sweepSense = undefined; // 1=CCW, -1=CW.***
};

/**
 * Set the center position of arc.
 * @class Arc
 */
Arc.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * Set the center position of arc.
 * @class Arc
 */
Arc.prototype.setRadius = function(radius)
{
	this.radius = radius;
};

/**
 * Set the start angle of the arc.
 * @class Arc
 */
Arc.prototype.setStartAngleDegree = function(startAngleDegree)
{
	this.startAngleDeg = startAngleDegree;
};

/**
 * Set the start angle of the arc.
 * @class Arc
 */
Arc.prototype.setStartPoint = function(x, y)
{
	// If no exist startAngle, then use this to calculate startAngle.***
	if (this.startPoint === undefined)
	{ this.startPoint = new Point2D(); }
	
	this.startPoint.set(x, y);
};

/**
 * Set the start angle of the arc.
 * @class Arc
 */
Arc.prototype.setEndPoint = function(x, y)
{
	// If no exist sweepAngle, then use this to calculate sweepAngle.***
	if (this.endPoint === undefined)
	{ this.endPoint = new Point2D(); }
	
	this.endPoint.set(x, y);
};

/**
 * Set the start angle of the arc.
 * @class Arc
 */
Arc.prototype.setSense = function(sense)
{
	this.sweepSense = sense; // 1=CCW, -1=CW.***
};

/**
 * Set the sweep angle of the arc.
 * @class Arc
 */
Arc.prototype.setSweepAngleDegree = function(sweepAngleDegree)
{
	this.sweepAngleDeg = sweepAngleDegree;
};

/**
 * Returns the points of the arc.
 * @class Arc
 */
Arc.prototype.getPoints = function(resultPointsArray, pointsCountFor360Deg)
{
	if (this.centerPoint === undefined)
	{ return resultPointsArray; }
	
	if (pointsCountFor360Deg)
	{ this.numPointsFor360Deg = pointsCountFor360Deg; }

	if (this.numPointsFor360Deg === undefined)
	{ this.numPointsFor360Deg = 36; }

	// Check if exist strAng.*********************************************************************************
	var strVector, endVector;
	var strVectorModul;
	if (this.startAngleDeg === undefined)
	{
		if (this.startPoint === undefined)
		{ return resultPointsArray; }
		
		strVector = new Point2D();
		strVector.set(this.startPoint.x - this.centerPoint.x, this.startPoint.y - this.centerPoint.y);
		strVectorModul = strVector.getModul();
		
		var angRad = Math.acos(x/strVectorModul);
		if (this.startPoint.y < 0)
		{
			angRad *= -1;
		}
		
		this.startAngleDeg = angRad * 180.0/Math.PI;
	}
	
	// Check if exist radius.*********************************************************************************
	if (this.radius === undefined)
	{
		// calculate by startPoint.***
		if (this.startPoint === undefined)
		{ return resultPointsArray; }
		
		if (strVectorModul === undefined)
		{
			if (strVector === undefined)
			{
				strVector = new Point2D();
				strVector.set(this.startPoint.x - this.centerPoint.x, this.startPoint.y - this.centerPoint.y);
			}
			strVectorModul = strVector.getModul();
		}
		
		this.radius = strVectorModul;
	}
	
	// check if exist sweepAng.*********************************************************************************
	if (this.sweepAngleDeg === undefined)
	{
		if (this.endPoint === undefined || this.sweepSense === undefined)
		{ return resultPointsArray; }
		
		endVector = new Point2D();
		endVector.set(this.endPoint.x - this.centerPoint.x, this.endPoint.y - this.endPoint.y);
		var endVectorModul = endPoint.getModul();
		
		var angRad = Math.acos(x/strVectorModul);
		if (this.endPoint.y < 0)
		{
			angRad *= -1;
		}
		
		this.sweepAngleDeg = angRad * 180.0/Math.PI;
		
		if (this.sweepSense < 0)
		{ this.sweepAngleDeg = 360 - this.sweepAngleDeg; }
	}
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var pointsArray = [];
	
	var increAngRad = 2.0 * Math.PI / this.numPointsFor360Deg;
	var cx = this.centerPoint.x;
	var cy = this.centerPoint.y;
	var x, y;
	var startAngRad = Math.PI/180.0 * this.startAngleDeg;
	var sweepAngRad = Math.PI/180.0 * this.sweepAngleDeg;
	var point;
	
	if (sweepAngRad >=0)
	{
		for (var currAngRad = 0.0; currAngRad<sweepAngRad; currAngRad += increAngRad)
		{
			x = cx + this.radius * Math.cos(currAngRad + startAngRad);
			y = cy + this.radius * Math.sin(currAngRad + startAngRad);
			point = new Point2D(x, y);
			pointsArray.push(point);
		}
	}
	else 
	{
		for (var currAngRad = 0.0; currAngRad>sweepAngRad; currAngRad -= increAngRad)
		{
			x = cx + this.radius * Math.cos(currAngRad + startAngRad);
			y = cy + this.radius * Math.sin(currAngRad + startAngRad);
			point = new Point2D(x, y);
			pointsArray.push(point);
		}
	}
	
	// once finished, mark the 1rst point and the last point as"important point".***
	var pointsCount = pointsArray.length;
	if (pointsCount > 0)
	{
		pointsArray[0].pointType = 1;
		pointsArray[pointsCount-1].pointType = 1;
	}
	
	// now merge points into "resultPointsArray".***
	var errorDist = 0.0001; // 0.1mm.***
	var resultExistentPointsCount = resultPointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		if (i===0)
		{
			if (resultExistentPointsCount > 0)
			{
				// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.***
				var lastExistentPoint = resultPointsArray[resultExistentPointsCount-1];
				point = pointsArray[i];
				if (!lastExistentPoint.isCoincidentToPoint(point, errorDist))
				{
					resultPointsArray.push(point);
				}
			}
			else
			{
				resultPointsArray.push(pointsArray[i]);
			}
		}
		else
		{
			resultPointsArray.push(pointsArray[i]);
		}
	}
	
	// Last check: finally, in case of sweepAngle = 360 degrees, or is closed pointsArray, then pop the last insertedPoint.***
	resultExistentPointsCount = resultPointsArray.length;
	if (resultExistentPointsCount > 0)
	{
		// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.***
		var lastPoint = resultPointsArray[resultExistentPointsCount-1];
		var firstPoint = resultPointsArray[0];
		if (lastPoint.isCoincidentToPoint(firstPoint, errorDist))
		{
			resultPointsArray.pop();
			lastPoint.deleteObjects();
		}
	}
	
	return resultPointsArray;
};




















'use strict';

/**
 * 선
 * @class AxisXYZ
 */
var AxisXYZ = function(length) 
{
	if (!(this instanceof AxisXYZ)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	if (length === undefined)
	{ this.length = 60; }
	else { this.length = length; }
	
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	//this.vboKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();
};

AxisXYZ.prototype.setDimension = function(length)
{
	this.length = length;
};

AxisXYZ.prototype.makeMesh = function(length)
{
	if (length !== undefined)
	{ this.length = length; }
	
	var pMesh = new ParametricMesh();
		
	pMesh.profile = new Profile(); 
	var profileAux = pMesh.profile; 
	
	// create a halfArrow profile.***
	var outerRing = profileAux.newOuterRing();
	var arrowLength = this.length;
	var arrowWidth  = this.length*0.1;
	var polyLine = outerRing.newElement("POLYLINE");
	var point3d = polyLine.newPoint2d(0, 0); // 0
	point3d = polyLine.newPoint2d(arrowWidth*0.25, arrowLength*0.25); // 1
	point3d = polyLine.newPoint2d(arrowWidth*0.25, arrowLength*0.75); // 2
	point3d = polyLine.newPoint2d(arrowWidth*0.5, arrowLength*0.75); // 3
	point3d = polyLine.newPoint2d(0, arrowLength); // 3
	//--------------------------------------------------------------------
	
	var bIncludeBottomCap, bIncludeTopCap;
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = 360.0;
	
	// create a rotation axis by a segment.***
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(0, -10);
	var endPoint2d = new Point2D(0, 10);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 8;
	
	// rotate the profile and create the Y axis.***
	pMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	
	bIncludeBottomCap = false;
	bIncludeTopCap = false;
	var mesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	mesh.setColor(0.1, 1.0, 0.1, 1.0); // set the color.***
	mesh.reverseSense();
	
	// copy & rotate the mesh and create the X axis.***
	var tMatTest = new Matrix4();
	var mesh2 = mesh.getCopy(undefined);
	tMatTest.rotationAxisAngDeg(-90.0, 0, 0, 1);
	mesh2.transformByMatrix4(tMatTest);
	mesh2.setColor(1.0, 0.1, 0.1, 1.0); // set the color.***
	
	// copy & rotate the mesh and create the Z axis.***
	var mesh3 = mesh.getCopy(undefined);
	tMatTest.rotationAxisAngDeg(90.0, 1, 0, 0);
	mesh3.transformByMatrix4(tMatTest);
	mesh3.setColor(0.1, 0.1, 1.0, 1.0); // set the color.***

	// Merge all meshes into a one mesh and make a unique vbo.***
	mesh.mergeMesh(mesh2);
	mesh.mergeMesh(mesh3);
	return mesh;
};

AxisXYZ.prototype.getVboKeysContainer = function()
{
	return this.vbo_vicks_container;
};

'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class BoundingRectangle
*/
var BoundingRectangle = function(x, y) 
{
	if (!(this instanceof BoundingRectangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.minX = 100000;
	this.maxX = -100000;
	this.minY = 100000;
	this.maxY = -100000;
};

BoundingRectangle.prototype.setInit = function(point)
{
	if (point === undefined)
	{ return; }
	
	this.minX = point.x;
	this.minY = point.y;
	this.maxX = point.x;
	this.maxY = point.y;
};

BoundingRectangle.prototype.setInitByRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return; }
	
	this.minX = bRect.minX;
	this.minY = bRect.minY;
	this.maxX = bRect.maxX;
	this.maxY = bRect.maxY;
};

BoundingRectangle.prototype.addPoint = function(point)
{
	if (point === undefined)
	{ return; }
	
	if (point.x < this.minX)
	{ this.minX = point.x; }
	else if (point.x > this.maxX)
	{ this.maxX = point.x; }
	
	if (point.y < this.minY)
	{ this.minY = point.y; }
	else if (point.y > this.maxY)
	{ this.maxY = point.y; }
};

BoundingRectangle.prototype.addRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return; }
	
	if (bRect.minX < this.minX)
	{ this.minX = bRect.minX; }
	if (bRect.maxX > this.maxX)
	{ this.maxX = bRect.maxX; }
	
	if (bRect.minY < this.minY)
	{ this.minY = bRect.minY; }
	if (bRect.maxY > this.maxY)
	{ this.maxY = bRect.maxY; }
};

BoundingRectangle.prototype.intersectsWithRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return false; }
	
	if (bRect.minX > this.maxX)
	{ return false; }
	else if (bRect.maxX < this.minX)
	{ return false; }
	else if (bRect.minY > this.maxY)
	{ return false; }
	else if (bRect.maxY < this.minY)
	{ return false; }
	
	return true;
};
















































'use strict';

/**
 * 영역 박스
 * @class BoxAux
 */
var BoxAux = function() 
{
	if (!(this instanceof BoxAux)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// vertex indices of the BoxAux.***
	//    3----------2        7----------6      
	//    |          |        |          |
	//    |  bottom  |        |   top    |
	//    |          |        |          |
	//    0----------1        4----------5
	
	this.triPolyhedron = new TriPolyhedron();
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	this.vBOVertexIdxCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();
};

/**
 * axis aligned bounding BoxAux
 * @param xLength
 * @param yLength
 * @param zLength
 */
BoxAux.prototype.getVboKeysContainer = function()
{
	return this.vbo_vicks_container;
};

/**
 * axis aligned bounding BoxAux
 * @param xLength
 * @param yLength
 * @param zLength
 */
BoxAux.prototype.makeAABB = function(xLength, yLength, zLength)
{
	// this makes a BoxAux centered on the center of the BoxAux.***
	var minX = -xLength/2.0;
	var minY = -yLength/2.0;
	var minZ = -zLength/2.0;
	
	var maxX = xLength/2.0;
	var maxY = yLength/2.0;
	var maxZ = zLength/2.0;
	
	// make 8 vertices and 6 triSurfaces.***
	var vertexList = this.triPolyhedron.vertexList;
	
	// Bottom.****
	var vertex = vertexList.newVertex(); // 0.***
	vertex.setPosition(minX, minY, minZ);
	
	vertex = vertexList.newVertex(); // 1.***
	vertex.setPosition(maxX, minY, minZ);
	
	vertex = vertexList.newVertex(); // 2.***
	vertex.setPosition(maxX, maxY, minZ);
	
	vertex = vertexList.newVertex(); // 3.***
	vertex.setPosition(minX, maxY, minZ);
	
	// Top.***
	vertex = vertexList.newVertex(); // 4.***
	vertex.setPosition(minX, minY, maxZ);
	
	vertex = vertexList.newVertex(); // 5.***
	vertex.setPosition(maxX, minY, maxZ);
	
	vertex = vertexList.newVertex(); // 6.***
	vertex.setPosition(maxX, maxY, maxZ);
	
	vertex = vertexList.newVertex(); // 7.***
	vertex.setPosition(minX, maxY, maxZ);
	
	
	// now, create triSurfaces and triangles.***
	var triSurface;
	var triangle;
	// Bottom surface.***
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(2), vertexList.getVertex(1));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(3), vertexList.getVertex(2));
	
	// Top surface.***
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(4), vertexList.getVertex(5), vertexList.getVertex(6));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(4), vertexList.getVertex(6), vertexList.getVertex(7));
	
	// Front surface.***
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(1), vertexList.getVertex(5));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(5), vertexList.getVertex(4));
	
	// Right surface.***
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(1), vertexList.getVertex(2), vertexList.getVertex(6));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(1), vertexList.getVertex(6), vertexList.getVertex(5));
	
	// Rear surface.***
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(2), vertexList.getVertex(3), vertexList.getVertex(7));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(2), vertexList.getVertex(7), vertexList.getVertex(6));
	
	// Left surface.***
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(3), vertexList.getVertex(0), vertexList.getVertex(4));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(3), vertexList.getVertex(4), vertexList.getVertex(7));
	
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Circle
 */
var Circle = function() 
{
	if (!(this instanceof Circle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// sweeping in CounterClockWise is positive.***
	// zero startAngle is in "X" axis positive.***
	this.centerPoint; // Point3D.***
	this.radius;
	this.numPointsFor360Deg; // interpolation param.***
};

/**
 * Set the center position of Circle.
 * @class Circle
 */
Circle.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * Set the center position of Circle.
 * @class Circle
 */
Circle.prototype.setRadius = function(radius)
{
	this.radius = radius;
};

/**
 * Returns the points of the arc.
 * @class Arc
 */
Circle.prototype.getPoints = function(resultPointsArray, pointsCountFor360Deg)
{
	if (pointsCountFor360Deg)
	{ this.numPointsFor360Deg = pointsCountFor360Deg; }

	if (this.numPointsFor360Deg === undefined)
	{ this.numPointsFor360Deg = 36; }
	
	// use an arc to make points.***
	if (this.centerPoint === undefined || this.radius === undefined)
	{ return resultPointsArray; }
	
	var arc = new Arc();
	arc.setCenterPosition(this.centerPoint.x, this.centerPoint.y);
	
	arc.setRadius(this.radius);
	arc.setStartAngleDegree(0);
	arc.setSweepAngleDegree(360.0);
	arc.setSense(1);
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	resultPointsArray = arc.getPoints(resultPointsArray, this.numPointsFor360Deg);
	return resultPointsArray;
};
















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Ellipsoid
 */
var Ellipsoid = function(radiusX, radiusY, radiusZ) 
{
	if (!(this instanceof Ellipsoid)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// Ellipsoid: x^2/a^2 + y^2/b^2 + z^2/c^2 = 1, (a, b, c) = (radiusX, radiusY, radiusZ).***
	
	this.radiusX;
	this.radiusY;
	this.radiusZ;
	
	if (radiusX !== undefined)
	{ this.radiusX = radiusX; }
	
	if (radiusY !== undefined)
	{ this.radiusY = radiusY; }
	
	if (radiusZ !== undefined)
	{ this.radiusZ = radiusZ; }

};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Face
 */
var Face = function() 
{
	if (!(this instanceof Face)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertexArray;
	this.hEdge;
	this.planeNormal;
	this.surfaceOwner;
};

Face.prototype.getVerticesCount = function()
{
	if (this.vertexArray === undefined)
	{ return 0; }

	return this.vertexArray.length;
};

Face.prototype.addVertex = function(vertex)
{
	if (this.vertexArray === undefined)
	{ this.vertexArray = []; }
	
	this.vertexArray.push(vertex);
};

Face.prototype.getVertex = function(idx)
{
	if (this.vertexArray === undefined)
	{ return undefined; }

	return this.vertexArray[idx];
};

Face.prototype.reverseSense = function()
{
	this.vertexArray.reverse();
};

Face.prototype.setColor = function(r, g, b, a)
{
	var vertex;
	var verticesCount = this.getVerticesCount();
	for (var i=0; i<verticesCount; i++)
	{
		vertex = this.getVertex(i);
		vertex.setColorRGBA(r, g, b, a);
	}
};

Face.prototype.calculateVerticesNormals = function()
{
	// provisionally calculate the plane normal and assign to the vertices.***
	var finished = false;
	var verticesCount = this.vertexArray.length;
	var i=0;
	while (!finished && i<verticesCount)
	{
		this.planeNormal = VertexList.getCrossProduct(i, this.vertexArray, this.planeNormal);
		if (this.planeNormal.x !== 0 || this.planeNormal.y !== 0 || this.planeNormal.z !== 0 )
		{
			finished = true;
		}
		i++;
	}
	this.planeNormal.unitary();
	var verticesCount = this.getVerticesCount();
	for (var i=0; i<verticesCount; i++)
	{
		this.vertexArray[i].setNormal(this.planeNormal.x, this.planeNormal.y, this.planeNormal.z);
	}
};

Face.prototype.getTrianglesConvex = function(resultTrianglesArray)
{
	// To call this method, the face must be convex.***
	if (this.vertexArray === undefined || this.vertexArray.length === 0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var vertex0, vertex1, vertex2;
	var triangle;
	vertex0 = this.getVertex(0);
	var verticesCount = this.getVerticesCount();
	for (var i=1; i<verticesCount-1; i++)
	{
		vertex1 = this.getVertex(i);
		vertex2 = this.getVertex(i+1);
		triangle = new Triangle(vertex0, vertex1, vertex2);
		resultTrianglesArray.push(triangle);
	}
	
	return resultTrianglesArray;
};

Face.prototype.setTwinHalfEdge = function(hedge)
{
	var twined = false;
	var finished = false;
	var startHEdge = this.hEdge;
	var currHEdge = this.hEdge;
	while (!finished)
	{
		if (currHEdge.setTwin(hedge))
		{ return true; }

		currHEdge = currHEdge.next;
		if (currHEdge === startHEdge)
		{ finished = true; }
	}
	return twined;
};

Face.prototype.getFrontierHalfEdges = function(resultHedgesArray)
{
	var hedgesArray = this.getHalfEdgesLoop(undefined);
	if (hedgesArray === undefined)
	{ return resultHedgesArray; }
	
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }

	var hedgesCount = hedgesArray.length;
	var hedge;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = hedgesArray[i];
		if (hedge.isFrontier())
		{
			resultHedgesArray.push(hedge);
		}
	}
	return resultHedgesArray;
};

Face.prototype.getHalfEdgesLoop = function(resultHedgesArray)
{
	if (this.hEdge === undefined)
	{ return resultHedgesArray; }
	
	resultHedgesArray = HalfEdge.getHalfEdgesLoop(this.hEdge, resultHedgesArray);
	return resultHedgesArray;
};

Face.prototype.setTwinFace = function(face)
{
	if (face === undefined)
	{ return false; }
	
	if (this.hEdge === undefined || face.hEdge === undefined)
	{ return false; }
	
	var hedgesArray = face.getHalfEdgesLoop(undefined);
	var hedgesCount = hedgesArray.length;
	var hedge;
	var twined = false;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = hedgesArray[i];
		if (this.setTwinHalfEdge(hedge))
		{ twined = true; }
	}
	
	return twined;
};

Face.prototype.createHalfEdges = function(resultHalfEdgesArray)
{
	if (this.vertexArray === undefined || this.vertexArray.length === 0)
	{ return resultHalfEdgesArray; }
	
	if (resultHalfEdgesArray === undefined)
	{ resultHalfEdgesArray = []; }
	
	var vertex;
	var hedge;
	var verticesCount = this.getVerticesCount();
	
	// 1rst, create the half edges.***
	for (var i=0; i<verticesCount; i++)
	{
		vertex = this.getVertex(i);
		hedge = new HalfEdge();
		hedge.setStartVertex(vertex);
		hedge.setFace(this);
		resultHalfEdgesArray.push(hedge);
	}
	
	// now, for all half edges, set the nextHalfEdge.***
	var nextHedge;
	var nextIdx;
	for (var i=0; i<verticesCount; i++)
	{
		hedge = resultHalfEdgesArray[i];
		nextIdx = VertexList.getNextIdx(i, this.vertexArray);
		nextHedge = resultHalfEdgesArray[nextIdx];
		hedge.setNext(nextHedge);
	}
	
	// set a hedge for this face.***
	this.hEdge = resultHalfEdgesArray[0];
	
	return resultHalfEdgesArray;
};






















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class HalfEdge
 */
var HalfEdge = function() 
{
	if (!(this instanceof HalfEdge)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.startVertex;
	this.next;
	this.twin;
	this.face;
};

HalfEdge.prototype.setStartVertex = function(vertex)
{
	this.startVertex = vertex;
	vertex.outingHedge = this;
};

HalfEdge.prototype.setNext = function(hedge)
{
	this.next = hedge;
};

HalfEdge.prototype.setTwin = function(hedge)
{
	var isTwinable = HalfEdge.areTwinables(hedge, this);
	if (isTwinable)
	{
		this.twin = hedge;
		hedge.twin = this;
	}
	return isTwinable;
};

HalfEdge.prototype.setFace = function(face)
{
	this.face = face;
};

HalfEdge.prototype.getEndVertex = function()
{
	if (this.next === undefined)
	{ return undefined; }
	
	return this.next.startVertex;
};

HalfEdge.prototype.isFrontier = function()
{
	if (this.twin === undefined || this.twin === null)
	{ return true; }
	
	return false;
};

HalfEdge.prototype.getPrev = function()
{
	var currHedge = this;
	var prevHedge;
	var finished = false;
	while (!finished)
	{
		if (currHedge.next === this)
		{ return currHedge; }
		
		if (currHedge.next === undefined)
		{ return undefined; }
		
		currHedge = currHedge.next;
	}
	
	return undefined;
};

HalfEdge.areTwinables = function(hedgeA, hedgeB)
{
	// check if "hedgeA" is twinable with "hedgeB".***
	if (hedgeA.startVertex === hedgeB.getEndVertex())
	{
		if (hedgeA.getEndVertex() === hedgeB.startVertex)
		{ return true; }
	}
	
	return false;
};

HalfEdge.getHalfEdgesLoop = function(hedge, resultHedgesArray)
{
	if (hedge === undefined)
	{ return resultHedgesArray; }
	
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }
	
	resultHedgesArray.length = 0; // init the array.***
	
	var startHedge = hedge;
	var currHedge = hedge;
	var finished = false;
	while (!finished)
	{
		resultHedgesArray.push(currHedge);
		currHedge = currHedge.next;
		if (currHedge === startHedge || currHedge === undefined)
		{ finished = true; }
	}
	
	return resultHedgesArray;
};















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class HalfEdgesList
 */
var HalfEdgesList = function() 
{
	if (!(this instanceof HalfEdgesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.hEdgesArray;
};

HalfEdgesList.prototype.newHalfEdge = function()
{
	if (this.hEdgesArray === undefined)
	{ this.hEdgesArray = []; }
	
	var hedge = new HalfEdge();
	this.hEdgesArray.push(hedge);
	return hedge;
};

HalfEdgesList.prototype.addHalfEdgesArray = function(hEdgesArray)
{
	if (hEdgesArray === undefined)
	{ return; }
	
	if (this.hEdgesArray === undefined)
	{ this.hEdgesArray = []; }
	
	Array.prototype.push.apply(this.hEdgesArray, hEdgesArray);
};
'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class IndexData
*/
var IndexData = function() 
{
	if (!(this instanceof IndexData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.owner;
	this.idx;
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class IndexRange
 */
var IndexRange = function() 
{
	if (!(this instanceof IndexRange)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.strIdx;
	this.endIdx;
};

IndexRange.prototype.copyFrom = function(indexRange)
{
	if (indexRange === undefined)
	{ return; }
	
	this.strIdx = indexRange.strIdx;
	this.endIdx = indexRange.endIdx;
};
'use strict';

/**
 * 선
 * @class Line
 */
var Line = function() 
{
	if (!(this instanceof Line)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// (x,y,z) = (x0,y0,z0) + lambda * (u, v, w);
	this.point = new Point3D();
	this.direction = new Point3D();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @param dx 변수
 * @param dy 변수
 * @param dz 변수
 */
Line.prototype.setPointAndDir = function(px, py, pz, dx, dy, dz) 
{
	this.point.set(px, py, pz);
	this.direction.set(dx, dy, dz);
	this.direction.unitary();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 */
Line.prototype.getProjectedPoint = function(point, projectedPoint) 
{
	if (projectedPoint === undefined)
	{ projectedPoint = new Point3D(); }
	
	var plane = new Plane();
	plane.setPointAndNormal(point.x, point.y, point.z, this.direction.x, this.direction.y, this.direction.z);
	projectedPoint = plane.intersectionLine(this, projectedPoint);
	
	return projectedPoint;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 */
Line.prototype.isCoincidentPoint = function(point, error) 
{
	if (point === undefined)
	{ return false; }
	
	var projectedPoint = this.getProjectedPoint(point);
	
	if (projectedPoint === undefined)
	{ return false; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	var squaredDist = projectedPoint.squareDistToPoint(point);
	
	if (squaredDist < error*error)
	{ return true; }
	
	return false;
};


















































'use strict';

/**
 * 선
 * @class Line2D
 */
var Line2D = function() 
{
	if (!(this instanceof Line2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// (x,y) = (x0,y0) + lambda * (u, v);
	this.point = new Point2D();
	this.direction = new Point2D();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param dx 변수
 * @param dy 변수
 */
Line2D.prototype.setPointAndDir = function(px, py, dx, dy) 
{
	this.point.set(px, py);
	this.direction.set(dx, dy);
	this.direction.unitary();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 */
Line2D.prototype.getPerpendicularRight = function(point) 
{
	var perpendicular = new Line2D();
	
	if (point)
	{ perpendicular.point.set(point.x, point.y); }
	else
	{ perpendicular.point.set(this.point.x, this.point.y); }
	
	perpendicular.direction.set(this.direction.y, -this.direction.x);
	return perpendicular;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 */
Line2D.prototype.getPerpendicularLeft = function(point) 
{
	var perpendicular = new Line2D();
	
	if (point)
	{ perpendicular.point.set(point.x, point.y); }
	else
	{ perpendicular.point.set(this.point.x, this.point.y); }
	
	perpendicular.direction.set(-this.direction.y, this.direction.x);
	return perpendicular;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 */
Line2D.prototype.getProjectedPoint = function(point, projectedPoint) 
{
	if (point === undefined)
	{ return undefined; }
	
	if (projectedPoint === undefined)
	{ projectedPoint = new Point2D(); }
	
	var perpendicular = this.getPerpendicularLeft(point);
	projectedPoint = this.intersectionWithLine(perpendicular, projectedPoint);
	
	return projectedPoint;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 */
Line2D.prototype.isCoincidentPoint = function(point, error) 
{
	if (point === undefined)
	{ return false; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	var projectedPoint = this.getProjectedPoint(point, projectedPoint);
	var squaredDist = point.squareDistToPoint(projectedPoint);
	
	if (squaredDist < error*error)
	{ return true; }

	return false;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 */
Line2D.prototype.isParallelToLine = function(line) 
{
	if (line === undefined)
	{ return false; }
	
	var zero = 10E-10;
	var angRad = this.direction.angleRadToVector(line.direction);
	
	// if angle is zero or 180 degree, then this is parallel to "line".***
	if (angRad < zero || Math.abs(angRad - Math.PI) < zero)
	{ return true; }
	
	return false;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 */
Line2D.prototype.intersectionWithLine = function(line, resultIntersectPoint) 
{
	if (line === undefined)
	{ return undefined; }
	
	// 1rst, check that this is not parallel to "line".***
	if (this.isParallelToLine(line))
	{ return undefined; }
	
	// now, check if this or "line" are vertical or horizontal.***
	var intersectX;
	var intersectY;
	
	var zero = 10E-10;
	if (Math.abs(this.direction.x) < zero)
	{
		// this is a vertical line.***
		var slope = line.direction.y / line.direction.x;
		var b = line.point.y - slope * line.point.x;
		
		intersectX = this.point.x;
		intersectY = slope * this.point.x + b;
	}
	else if (Math.abs(this.direction.y) < zero)
	{
		// this is a horizontal line.***
		// must check if the "line" is vertical.***
		if (Math.abs(line.direction.x) < zero)
		{
			// "line" is vertical.***
			intersectX = line.point.x;
			intersectY = this.point.y;
		}
		else 
		{
			var slope = line.direction.y / line.direction.x;
			var b = line.point.y - slope * line.point.x;
			
			intersectX = (this.point.y - b)/slope;
			intersectY = this.point.y;
		}	
	}
	else 
	{
		// this is oblique.***
		if (Math.abs(line.direction.x) < zero)
		{
			// "line" is vertical.***
			var mySlope = this.direction.y / this.direction.x;
			var myB = this.point.y - mySlope * this.point.x;
			intersectX = line.point.x;
			intersectY = line.point.x * mySlope + myB;
		}
		else 
		{
			var mySlope = this.direction.y / this.direction.x;
			var myB = this.point.y - mySlope * this.point.x;
			
			var slope = line.direction.y / line.direction.x;
			var b = line.point.y - slope * line.point.x;
			
			intersectX = (myB - b)/ (slope - mySlope);
			intersectY = slope * intersectX + b;
		}
	}
	
	if (resultIntersectPoint === undefined)
	{ resultIntersectPoint = new Point2D(); }
	
	resultIntersectPoint.set(intersectX, intersectY);
	return resultIntersectPoint;
};















































'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class MagoNativeProject
 */
var MagoNativeProject = function() 
{
	if (!(this instanceof MagoNativeProject)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// This is a "ParametricMeshes" composition.***
	this.meshesArray;
	this.geoLocDataManager;
	this.vboKeysContainer; // class: VBOVertexIdxCacheKeysContainer
};

MagoNativeProject.prototype.newParametricMesh = function()
{
	if (this.meshesArray === undefined)
	{ this.meshesArray = []; }
	
	var parametricMesh = new ParametricMesh();
	this.meshesArray.push(parametricMesh);
	return parametricMesh;
};

MagoNativeProject.prototype.deleteObjects = function()
{
	if (this.meshesArray === undefined)
	{ return; }
	
	var parametricMeshesCount = this.meshesArray.length;
	for (var i=0; i<parametricMeshesCount; i++)
	{
		this.meshesArray[i].deleteObjects();
		this.meshesArray[i] = undefined;
	}
	this.meshesArray = undefined;
	
	if (this.geoLocDataManager)
	{ this.geoLocDataManager.deleteObjects(); }
	
	this.geoLocDataManager = undefined;
};

MagoNativeProject.prototype.getMeshesCount = function()
{
	if (this.meshesArray === undefined)
	{ return 0; }
	
	return this.meshesArray.length;
};

MagoNativeProject.prototype.getMesh = function(idx)
{
	if (this.meshesArray === undefined)
	{ return undefined; }
	
	return this.meshesArray[idx];
};

















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class MagoWorld
 */
var MagoWorld = function(magoManager) 
{
	if (!(this instanceof MagoWorld)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.magoManager = magoManager;
};

MagoWorld.prototype.prepareVisibles = function()
{
	// 1rst, do terrain frustum culling.***
	
};

MagoWorld.prototype.renderScene = function()
{
	this.renderTest();
};

MagoWorld.prototype.renderTest = function()
{
	var gl = this.magoManager.sceneState.gl;
	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	this.magoManager.start(undefined, true, 0, 1);
	
};

MagoWorld.prototype.goto = function(longitude, latitude, altitude)
{
	var resultCartesian;
	resultCartesian = Globe.geographicToCartesianWgs84(longitude, latitude, altitude, resultCartesian);
	
	var camera = this.magoManager.sceneState.camera;
	var camPos = camera.position;
	var camDir = camera.direction;
	var camUp = camera.up;
	
	var matrixAux;
	matrixAux = this.magoManager.globe.transformMatrixAtCartesianPointWgs84(resultCartesian[0], resultCartesian[1], resultCartesian[2], matrixAux);
	
	camPos.set(resultCartesian[0], resultCartesian[1], resultCartesian[2]);
	
	// calculate camDir & camUp.***
	camDir.set(-matrixAux[8], -matrixAux[9], -matrixAux[10]);
	camUp.set(matrixAux[4], matrixAux[5], matrixAux[6]); // tangent north direction.***
	
	this.updateModelViewMatrixByCamera(camera);
	
	//var modelViewMatrix = this.magoManager.sceneState.modelViewMatrix;
	//modelViewMatrix._floatArrays = mat4.lookAt(modelViewMatrix._floatArrays, [camPos.x, camPos.y, camPos.z], [0.0, 0.0, 0.0], [camUp.x, camUp.y, camUp.z]);
	
	var hola = 0;
	
};

MagoWorld.prototype.mousedown = function(event)
{
	this.magoManager.sceneState.mouseButton = event.button;
	this.updateMouseCurrent(event.clientX, event.clientY);
	this.magoManager.isCameraMoving = true;
};

MagoWorld.prototype.updateMouseCurrent = function(mouseX, mouseY)
{
	var gl = this.magoManager.sceneState.gl;
	var mouseAction = this.magoManager.sceneState.mouseAction;
	
	// if button = 1 (middleButton), then rotate camera.***
	mouseAction.curX = mouseX;
	mouseAction.curY = mouseY;
	if (this.magoManager.sceneState.mouseButton === 0)
	{
		// determine worldPosition of the mouse.***
		this.magoManager.bPicking = true;
		//this.magoManager.mouse_x = mouseX;
		//this.magoManager.mouse_y = mouseY;
	}
	
	// determine world position of the X,Y.***
	mouseAction.curCamCoordPoint = this.magoManager.calculatePixelPositionCamCoord(gl, mouseAction.curX, mouseAction.curY, mouseAction.curCamCoordPoint);
	mouseAction.curWorldPoint = this.magoManager.cameraCoordPositionToWorldCoord(mouseAction.curCamCoordPoint, mouseAction.curWorldPoint);
	
	// now, copy camera to curCamera.***
	var camera = this.magoManager.sceneState.camera;
	var curCamera = mouseAction.curCamera;
	
	curCamera.copyPosDirUpFrom(camera);
	
	// copy modelViewMatrix.***
	var modelViewMatrix = this.magoManager.sceneState.modelViewMatrix;
	var modelViewMatrixInv = this.magoManager.sceneState.modelViewMatrixInv;
	mouseAction.curModelViewMatrix._floatArrays = mat4.copy(mouseAction.curModelViewMatrix._floatArrays, modelViewMatrix._floatArrays);
	mouseAction.curModelViewMatrixInv._floatArrays = mat4.copy(mouseAction.curModelViewMatrixInv._floatArrays, modelViewMatrixInv._floatArrays);
	
	
	// save the sphere pick.***
	var camRay;
	camRay = this.magoManager.getRayWorldSpace(gl, mouseX, mouseY, camRay);
	mouseAction.curWorldPoint2 = this.magoManager.globe.intersectionLineWgs84(camRay, mouseAction.curWorldPoint2);

};

MagoWorld.prototype.updateModelViewMatrixByCamera = function(camera, target)
{
	var mouseAction = this.magoManager.sceneState.mouseAction;
	
	var camera = this.magoManager.sceneState.camera;
	var camPos = camera.position;
	var camDir = camera.direction;
	var camUp = camera.up;
	var far = camera.frustum.far[0];
	
	var camRay;
	var camTarget;

	camTarget = new Float32Array(3);
	camTarget[0] = camPos.x + camDir.x * far;
	camTarget[1] = camPos.y + camDir.y * far;
	camTarget[2] = camPos.z + camDir.z * far;
	
	// test comprovation.***
	var posModul = camPos.getModul();
	var targetModul = Math.sqrt(camTarget[0]*camTarget[0], camTarget[1]*camTarget[1], camTarget[2]*camTarget[2]);
	
	if (posModul < targetModul)
	{ var hola = 0; }

	var modelViewMatrix = this.magoManager.sceneState.modelViewMatrix;
	modelViewMatrix._floatArrays = mat4.lookAt(modelViewMatrix._floatArrays, [camPos.x, camPos.y, camPos.z], [camTarget[0], camTarget[1], camTarget[2]], [camUp.x, camUp.y, camUp.z]);
};

MagoWorld.prototype.mouseup = function(event)
{
	this.magoManager.sceneState.mouseButton = -1;
	this.magoManager.bPicking = false;
	this.magoManager.isCameraMoving = false;
};

MagoWorld.prototype.mousewheel = function(event)
{
	var delta = event.wheelDelta / 10;
	
	var mouseAction = this.magoManager.sceneState.mouseAction;
	
	// move camera.***
	var camera = this.magoManager.sceneState.camera;
	var camPos = camera.position;
	var camDir = camera.direction;
	var camUp = camera.up;
	
	var camHeght = camera.getCameraElevation();
	var deltaA;
	var deltaB;
	
	// under building...
	if (camHeght > 20000)
	{
		deltaA = camHeght*camHeght * 0.000000001;
		deltaB = camHeght * 0.01;
	}
	if (camHeght > 16000)
	{
		deltaA = camHeght*camHeght * 0.000000001;
		deltaB = camHeght * 0.001;
	}
	else if (camHeght > 14000)
	{
		deltaA = camHeght*camHeght * 0.000000001;
		deltaB = camHeght * 0.001;
	}
	else if (camHeght > 10000)
	{
		deltaA = camHeght*camHeght * 0.0000000001;
		deltaB = camHeght * 0.0001;
	}
	else if (camHeght > 6000)
	{
		deltaA = camHeght*camHeght * 0.00000000001;
		deltaB = camHeght * 0.0000001;
	}
	else 
	{
		deltaA = camHeght*camHeght * 0.00000000001;
		deltaB = camHeght * 0.00000001;
	}
	delta *= deltaA + deltaB + 1;
	camPos.add(camDir.x * delta,  camDir.y * delta,  camDir.z * delta);
	
	this.updateModelViewMatrixByCamera(camera);
};

MagoWorld.prototype.mousemove = function(event)
{
	var mouseAction = this.magoManager.sceneState.mouseAction;
	if (this.magoManager.sceneState.mouseButton === 0)
	{
		// left button pressed.***
		var gl = this.magoManager.sceneState.gl;
		var sceneState = this.magoManager.sceneState;
		var curCamera = mouseAction.curCamera;
		var camera = this.magoManager.sceneState.camera;
		
		// now, calculate the angle and the rotationAxis.***
		var curWorldPoint = mouseAction.curWorldPoint;
		var currEarthRadius = curWorldPoint.getModul();
		var nowX = event.clientX;
		var nowY = event.clientY;
		if (nowX === mouseAction.curX && nowY === mouseAction.curY)
		{ return; }
		
		var nowPoint;
		var camRay, camRayCamCoord;
		
		camRayCamCoord = this.magoManager.getRayCamSpace(nowX, nowY, camRayCamCoord);
		
		// now calculate rayWorldCoord.***
		if (this.pointSC === undefined)
		{ this.pointSC = new Point3D(); }
		
		this.pointSC.set(camRayCamCoord[0], camRayCamCoord[1], camRayCamCoord[2]);

		// now, must transform this posCamCoord to world coord.***
		var mv_inv = mouseAction.curModelViewMatrixInv;
		this.pointSC2 = mv_inv.rotatePoint3D(this.pointSC, this.pointSC2); // rayWorldSpace.***
		this.pointSC2.unitary(); // rayWorldSpace.***
		camRay = new Line();
		camRay.setPointAndDir(curCamera.position.x, curCamera.position.y, curCamera.position.z,       this.pointSC2.x, this.pointSC2.y, this.pointSC2.z);// original.***
		// end calculate camRayWorldCoord.---------------
		
		var nowWorldPoint;
		nowWorldPoint = this.magoManager.globe.intersectionLineWgs84(camRay, nowWorldPoint, currEarthRadius);
		
		if (nowWorldPoint === undefined)
		{
			return;
		}

		var curPoint = new Point3D(curWorldPoint.x, curWorldPoint.y, curWorldPoint.z);
		var nowPoint = new Point3D(nowWorldPoint[0], nowWorldPoint[1], nowWorldPoint[2]);
		
		var rotAxis;
		rotAxis = curPoint.crossProduct(nowPoint, rotAxis);
		rotAxis.unitary();
		if (rotAxis.isNAN())
		{ return; }
		
		var angRad = curPoint.angleRadToVector(nowPoint);
		if (angRad === 0 || isNaN(angRad))
		{ return; }
		
		// recalculate position and direction of the camera.***
		
		camera.copyPosDirUpFrom(curCamera);
		
		var matAux = mat4.create(); // create as identity.***
		matAux = mat4.rotate( matAux, matAux, -angRad, [rotAxis.x, rotAxis.y, rotAxis.z] );
		camera.transformByMatrix4(matAux);
		
		this.updateModelViewMatrixByCamera(camera);
		
	}
	else if (this.magoManager.sceneState.mouseButton === 1)
	{
		// middle button pressed.***
		var curCamera = mouseAction.curCamera;
		var camera = this.magoManager.sceneState.camera;
		camera.copyPosDirUpFrom(curCamera);
		var camPos = camera.position;
		var camDir = camera.direction;
		var camUp = camera.up;
		
		// 1rst, determine the point of rotation.***
		var rotPoint = mouseAction.curWorldPoint;
		
		// now determine the rotation axis.***
		// the rotation axis are the camRight & normalToSurface.***
		if (this.magoManager.globe === undefined)
		{ this.magoManager.globe = new Globe(); }
		
		var pivotPointNormal;
		pivotPointNormal = this.magoManager.globe.normalAtCartesianPointWgs84(rotPoint.x, rotPoint.y, rotPoint.z, pivotPointNormal);
		
		var xAxis = camera.getCameraRight();
		
		// now determine camZRot & camXRot angles.***
		var nowX = event.clientX;
		var nowY = event.clientY;
		var increX = nowX - mouseAction.curX;
		var increY = nowY - mouseAction.curY;
		
		var zRotAngRad = increX * 0.003;
		var xRotAngRad = increY * 0.003;
		
		if (zRotAngRad === 0 && xRotAngRad == 0)
		{ return; }
		
		if (this.rotMatX === undefined)
		{ this.rotMatX = mat4.create(); }
		
		if (this.rotMatZ === undefined)
		{ this.rotMatZ = mat4.create(); }
		
		if (this.rotMat === undefined)
		{ this.rotMat = mat4.create(); }
		
		this.rotMatX = mat4.identity(this.rotMatX);
		this.rotMatZ = mat4.identity(this.rotMatZ);
		this.rotMat = mat4.identity(this.rotMat);
		
		//ManagerUtils.calculateSplited3fv = function(point3fv, resultSplitPoint3fvHigh, resultSplitPoint3fvLow)
		
		this.rotMatX = mat4.fromRotation(this.rotMatX, -xRotAngRad, [xAxis.x, xAxis.y, xAxis.z]);
		this.rotMatZ = mat4.fromRotation(this.rotMatZ, -zRotAngRad, pivotPointNormal);
		this.rotMat = mat4.multiply(this.rotMat, this.rotMatZ, this.rotMatX);
		var translateMat_1 = mat4.create();
		var translateMat_2 = mat4.create();
		translateMat_1 = mat4.fromTranslation(translateMat_1, [-rotPoint.x, -rotPoint.y, -rotPoint.z]);
		translateMat_2 = mat4.fromTranslation(translateMat_2, [rotPoint.x, rotPoint.y, rotPoint.z]);
		
		var totalMatPrev = mat4.create();
		totalMatPrev = mat4.multiply(totalMatPrev, translateMat_2, this.rotMat);
		
		var totalMat = mat4.create();
		totalMat = mat4.multiply(totalMat, totalMatPrev, translateMat_2);
		
		camera.transformByMatrix4(translateMat_1);
		camera.transformByMatrix4(this.rotMat);
		camera.transformByMatrix4(translateMat_2);
		
		this.updateModelViewMatrixByCamera(camera);
	}
};

MagoWorld.prototype.keydown = function(event)
{
	var hola = 0;
};





























'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Mesh
 */
var Mesh = function() 
{
	if (!(this instanceof Mesh)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.vertexList;
	this.surfacesArray;
	this.hedgesList;
};

Mesh.prototype.newSurface = function()
{
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	var surface = new Surface();
	this.surfacesArray.push(surface);
	return surface;
};

Mesh.prototype.getSurface = function(idx)
{
	if (this.surfacesArray === undefined)
	{ return undefined; }
	
	return this.surfacesArray[idx];
};

Mesh.prototype.addSurface = function(surface)
{
	if (surface === undefined)
	{ return; }
	
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	this.surfacesArray.push(surface);
};

Mesh.prototype.mergeMesh = function(mesh)
{
	if (mesh === undefined)
	{ return; }
	
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	var surfacesCount = mesh.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		this.addSurface(mesh.getSurface(i));
	}
	mesh.surfacesArray = undefined;
};

Mesh.prototype.getSurfacesCount = function()
{
	if (this.surfacesArray === undefined)
	{ return 0; }
	
	return this.surfacesArray.length;
};

Mesh.prototype.getCopySurfaceIndependentMesh = function(resultMesh)
{
	// In a surfaceIndependentMesh, the surfaces are disconex.***
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }
	
	var surface, surfaceCopy;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surfaceCopy = resultMesh.newSurface();
		surfaceCopy = surface.getCopyIndependentSurface(surfaceCopy);
	}
	
	return resultMesh;
};

Mesh.prototype.getTrianglesConvex = function(resultTrianglesArray)
{
	// To call this method, the faces must be CONVEX.***
	if (this.surfacesArray === undefined || this.surfacesArray.length === 0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		resultTrianglesArray = surface.getTrianglesConvex(resultTrianglesArray);
	}
	
	return resultTrianglesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
Mesh.prototype.getNoRepeatedVerticesArray = function(resultVerticesArray) 
{
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	// 1rst, assign vertex-IdxInList for all used vertices.***
	var facesCount;
	var face;
	var surface;
	var idxAux = 0;
	var vtx;
	var verticesCount;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				if (vtx === undefined)
				{ var hola = 0; }
				vtx.setIdxInList(idxAux);
				idxAux++;
			}
		}
	}
	
	// now, make a map of unique vertices map using "idxInList" of vertices.***
	var verticesMap = {};
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				verticesMap[vtx.getIdxInList().toString()] = vtx;
			}
		}
	}
	
	// finally make the unique vertices array.***
	var vertex;
	for (var key in verticesMap)
	{
		vertex = verticesMap[key];
		resultVerticesArray.push(vertex);
	}
	
	return resultVerticesArray;
};

Mesh.prototype.transformByMatrix4 = function(tMat4)
{
	if (this.vertexList === undefined)
	{
		this.vertexList = new VertexList();
		this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray);
	}
	
	this.vertexList.transformPointsByMatrix4(tMat4);
	this.calculateVerticesNormals();
};

Mesh.prototype.translate = function(x, y, z)
{
	if (this.vertexList === undefined)
	{
		this.vertexList = new VertexList();
		this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray);
	}
	
	this.vertexList.translateVertices(x, y, z);
};

Mesh.prototype.calculateVerticesNormals = function()
{
	// PROVISIONAL.***
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.calculateVerticesNormals();
	}
};

Mesh.prototype.setColor = function(r, g, b, a)
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.setColor(r, g, b, a);
	}
};

Mesh.prototype.reverseSense = function()
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.reverseSense();
	}
	
	this.calculateVerticesNormals();
};

Mesh.prototype.getFrontierHalfEdges = function(resultHedgesArray)
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		resultHedgesArray = surface.getFrontierHalfEdges(resultHedgesArray);
	}
	
	return resultHedgesArray;
};

Mesh.prototype.getCopy = function(resultMeshCopy)
{
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }
	
	if (this.vertexList.vertexArray === undefined || this.vertexList.vertexArray.length === 0)
	{ this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray); }
	
	if (resultMeshCopy === undefined)
	{ resultMeshCopy = new Mesh(); }
	
	// 1rst copy vertexList.***
	if (resultMeshCopy.vertexList === undefined)
	{ resultMeshCopy.vertexList = new VertexList(); }
	
	resultMeshCopy.vertexList.copyFrom(this.vertexList);
	
	// set idxInList both vertexLists.***
	this.vertexList.setIdxInList();
	resultMeshCopy.vertexList.setIdxInList();
	
	// now copy surfaces.***
	var surface, facesCount, face, verticesCount;
	var vtxIdx;
	var surfaceCopy, faceCopy, vtxCopy;
	var vtx;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surfaceCopy = resultMeshCopy.newSurface();
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			faceCopy = surfaceCopy.newFace();
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				vtxIdx = vtx.getIdxInList();
				vtxCopy = resultMeshCopy.vertexList.getVertex(vtxIdx);
				faceCopy.addVertex(vtxCopy);
			}
		}
	}
	
	resultMeshCopy.calculateVerticesNormals();
	
	return resultMeshCopy;
};

Mesh.prototype.getTrianglesListsArrayBy2ByteSize = function(trianglesArray, resultTrianglesListsArray)
{
	if (resultTrianglesListsArray === undefined)
	{ resultTrianglesListsArray = []; }
	
	// This function returns trianglesListsArray. Each trianglesList's vertices count is lower than 65535.***
	var shortSize = 65535;
	var trianglesList = new TrianglesList();
	resultTrianglesListsArray.push(trianglesList);
	var trianglesCount = trianglesArray.length;
	if (trianglesCount*3 <shortSize)
	{
		trianglesList.trianglesArray = [];
		Array.prototype.push.apply(trianglesList.trianglesArray, trianglesArray);
		return resultTrianglesListsArray;
	}
	
	// 1rst, make global vertices array.***
	var globalVerticesArray = TrianglesList.getNoRepeatedVerticesArray(trianglesArray, undefined);
	var verticesCount = globalVerticesArray.length;
	
	if (verticesCount <shortSize)
	{
		trianglesList.trianglesArray = [];
		Array.prototype.push.apply(trianglesList.trianglesArray, trianglesArray);
		return resultTrianglesListsArray;
	}
	
	VertexList.setIdxInList(globalVerticesArray);
	var rejectedTrianglesArray = [];
	var trianglesCount = trianglesArray.length;
	var triangle;
	
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = trianglesArray[i];
		if (triangle.vertex0.idxInList < shortSize && triangle.vertex1.idxInList< shortSize && triangle.vertex2.idxInList< shortSize)
		{
			trianglesList.addTriangle(triangle);
		}
		else 
		{
			rejectedTrianglesArray.push(triangle);
		}
	};
	
	if (rejectedTrianglesArray.length > 0)
	{
		resultTrianglesListsArray = this.getTrianglesListsArrayBy2ByteSize(rejectedTrianglesArray, resultTrianglesListsArray);
	}
	
	return resultTrianglesListsArray;
};

Mesh.prototype.getVbo = function(resultVboContainer)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	// make global triangles array.***
	var trianglesArray = this.getTrianglesConvex(undefined);
	var trianglesCount = trianglesArray.length;
	
	// If vertices count > shortSize(65535), then must split the mesh.***
	var trianglesListsArray = this.getTrianglesListsArrayBy2ByteSize(trianglesArray, undefined);
	var trianglesList;
	var verticesArray;
	var trianglesListsCount = trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		trianglesList = trianglesListsArray[i];
		verticesArray = trianglesList.getNoRepeatedVerticesArray(undefined);
		var vbo = resultVboContainer.newVBOVertexIdxCacheKey();
		VertexList.setIdxInList(verticesArray);
		VertexList.getVboDataArrays(verticesArray, vbo);
		trianglesList.assignVerticesIdx();
		TrianglesList.getVboFaceDataArray(trianglesList.trianglesArray, vbo);
		
	}

	return resultVboContainer;
};

Mesh.prototype.getVboEdges = function(resultVboContainer)
{
	// provisionally make edges by this.***
	var frontierHedgesArray = this.getFrontierHalfEdges(undefined);
	var hedgesCount = frontierHedgesArray.length;
	var hedge;
	var vertexArray = [];
	var indicesArray = [];
	var strVertex, endVertex;
	var index = 0;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = frontierHedgesArray[i];
		strVertex = hedge.startVertex;
		endVertex = hedge.getEndVertex();
		vertexArray.push(strVertex.point3d.x);
		vertexArray.push(strVertex.point3d.y);
		vertexArray.push(strVertex.point3d.z);
		vertexArray.push(endVertex.point3d.x);
		vertexArray.push(endVertex.point3d.y);
		vertexArray.push(endVertex.point3d.z);
		
		indicesArray.push(index); index++;
		indicesArray.push(index); index++;
	}
	
	var resultVbo = resultVboContainer.newVBOVertexIdxCacheKey();
	resultVbo.posVboDataArray = Float32Array.from(vertexArray);
	resultVbo.idxVboDataArray = Int16Array.from(indicesArray);
	resultVbo.indicesCount = resultVbo.idxVboDataArray.length;
};





















































'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class ParametricMesh
 */
var ParametricMesh = function() 
{
	if (!(this instanceof ParametricMesh)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.vtxProfilesList; // class: VtxProfilesList.***
	this.profile; // class: Profile. is a 2d object.***
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.***
	this.vboKeyContainerEdges; // class: VBOVertexIdxCacheKeyContainer.***
};

/**
 * 어떤 일을 하고 있습니까?
 */
ParametricMesh.prototype.deleteObjects = function() 
{
	if (this.profile)
	{ this.profile.deleteObjects(); }
	
	this.profile = undefined;
};

ParametricMesh.prototype.getVboKeysContainer = function()
{
	return this.vboKeyContainer;
};

ParametricMesh.prototype.getMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap)
{
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	// must separate vbo groups by surfaces.***
	resultMesh = this.vtxProfilesList.getMesh(resultMesh, bIncludeBottomCap, bIncludeTopCap);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

ParametricMesh.prototype.getSurfaceIndependentMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap)
{
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	// must separate vbo groups by surfaces.***
	this.mesh = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	resultMesh = this.mesh.getCopySurfaceIndependentMesh(resultMesh);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

/**
 * 어떤 일을 하고 있습니까?
 */
ParametricMesh.prototype.revolve = function(profile, revolveAngDeg, revolveSegmentsCount, revolveSegment2d) 
{
	if (profile === undefined)
	{ return undefined; }
	
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	
	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile before creating vtxProfiles.***
	this.vtxProfilesList.convexFacesIndicesData = profile.getConvexFacesIndicesData(undefined);
	
	// create vtxProfiles.***
	// make the base-vtxProfile.***
	var baseVtxProfile = this.vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByProfile(profile);
	
	var increAngDeg = revolveAngDeg/revolveSegmentsCount;
	
	// calculate the translation.***
	var line2d = revolveSegment2d.getLine();
	var origin2d = new Point2D(0, 0);
	var translationVector = line2d.getProjectedPoint(origin2d);
	translationVector.inverse();
	
	var rotMat = new Matrix4();
	var quaternion = new Quaternion();
	var rotAxis2d = revolveSegment2d.getDirection();
	var rotAxis = new Point3D(rotAxis2d.x, rotAxis2d.y, 0);
	rotAxis.unitary();
	
	for (var i=0; i<revolveSegmentsCount; i++)
	{
		// calculate rotation.***
		quaternion.rotationAngDeg(increAngDeg*(i+1), rotAxis.x, rotAxis.y, rotAxis.z);
		rotMat.rotationByQuaternion(quaternion);
		
		// test top profile.***
		var nextVtxProfile = this.vtxProfilesList.newVtxProfile();
		nextVtxProfile.copyFrom(baseVtxProfile);
		nextVtxProfile.translate(translationVector.x, translationVector.y, 0);
		nextVtxProfile.transformPointsByMatrix4(rotMat);
		nextVtxProfile.translate(-translationVector.x, -translationVector.y, 0);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
ParametricMesh.prototype.extrude = function(profile, extrusionDist, extrudeSegmentsCount, extrusionVector) 
{
	if (profile === undefined || extrusionDist === undefined)
	{ return undefined; }
	
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	

	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile before creating vtxProfiles.***
	this.vtxProfilesList.convexFacesIndicesData = profile.getConvexFacesIndicesData(undefined);
	
	// create vtxProfiles.***
	// make the base-vtxProfile.***
	var baseVtxProfile = this.vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByProfile(profile);
	
	if (extrusionVector === undefined)
	{ extrusionVector = new Point3D(0, 0, 1); }
	
	var increDist = extrusionDist/extrudeSegmentsCount;
	for (var i=0; i<extrudeSegmentsCount; i++)
	{
		// test with a 1 segment extrusion.***
		var nextVtxProfile = this.vtxProfilesList.newVtxProfile();
		nextVtxProfile.copyFrom(baseVtxProfile);
		nextVtxProfile.translate(0, 0, increDist*(i+1));
	}
};




































'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class Point2D
*/
var Point2D = function(x, y) 
{
	if (!(this instanceof Point2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	if (x) { this.x = x; }
	else { this.x = 0.0; }
	if (y) { this.y = y; }
	else { this.y = 0.0; }
	
	// aux test.***
	this.associated;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Point2D.prototype.deleteObjects = function() 
{
	this.x = undefined;
	this.y = undefined;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Point2D.prototype.setAssociated = function(associated) 
{
	// aux test.***
	this.associated = associated;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Point2D.prototype.getAssociated = function() 
{
	// aux test.***
	return this.associated;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Point2D.prototype.copyFrom = function(point2d) 
{
	this.x = point2d.x;
	this.y = point2d.y;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Point2D.prototype.inverse = function() 
{
	this.x = -this.x;
	this.y = -this.y;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Point2D.prototype.set = function(x, y) 
{
	this.x = x;
	this.y = y;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns this.x*this.x + this.y*this.y + this.z*this.z;
 */
Point2D.prototype.getSquaredModul = function() 
{
	return this.x*this.x + this.y*this.y;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z );
 */
Point2D.prototype.getModul = function() 
{
	return Math.sqrt(this.getSquaredModul());
};

/**
 * 
 * 어떤 일을 하고 있습니까?
 */
Point2D.prototype.unitary = function() 
{
	var modul = this.getModul();
	this.x /= modul;
	this.y /= modul;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point2D.prototype.squareDistToPoint = function(point) 
{
	var dx = this.x - point.x;
	var dy = this.y - point.y;

	return dx*dx + dy*dy;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point2D.prototype.distToPoint = function(point) 
{
	return Math.sqrt(this.squareDistToPoint(point));
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point2D.prototype.isCoincidentToPoint = function(point, errorDist) 
{
	var squareDist = this.distToPoint(point);
	var coincident = false;
	if (squareDist < errorDist*errorDist)
	{
		coincident = true;
	}

	return coincident;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 */
Point2D.prototype.getVectorToPoint = function(targetPoint, resultVector) 
{
	// this returns a vector that points to "targetPoint" from "this".***
	// the "resultVector" has the direction from "this" to "targetPoint", but is NOT normalized.***
	if (targetPoint === undefined)
	{ return undefined; }
	
	if (resultVector === undefined)
	{ resultVector = new Point2D(); }
	
	resultVector.set(targetPoint.x - this.x, targetPoint.y - this.y);
	
	return resultVector;
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point2D.prototype.crossProduct = function(point) 
{
	return this.x * point.y - point.x * this.y;
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point2D.prototype.scalarProduct = function(point) 
{
	var scalarProd = this.x*point.x + this.y*point.y;
	return scalarProd;
};

/**
 * nomal 계산
 * @param vector 변수
 */
Point2D.prototype.angleRadToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	//******************************************************
	//var scalarProd = this.scalarProduct(vector);
	var myModul = this.getModul();
	var vecModul = vector.getModul();
	
	// calcule by cos.***
	//var cosAlfa = scalarProd / (myModul * vecModul); 
	//var angRad = Math.acos(cosAlfa);
	//var angDeg = alfa * 180.0/Math.PI;
	//------------------------------------------------------
	var error = 10E-10;
	if (myModul < error || vecModul < error)
	{ return undefined; }
	
	return Math.acos(this.scalarProduct(vector) / (myModul * vecModul));
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point2D.prototype.angleDegToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	var angRad = this.angleRadToVector(vector);
	
	if (angRad === undefined)
	{ return undefined; }
		
	return angRad * 180.0/Math.PI;
};

















































'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class Point2DList
*/
var Point2DList = function(x, y) 
{
	if (!(this instanceof Point2DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.pointsArray;
};

Point2DList.prototype.deleteObjects = function()
{
	if (this.pointsArray === undefined)
	{ return; }
	
	var pointsCount = this.pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.pointsArray[i].deleteObjects();
		this.pointsArray[i] = undefined;
	}
	this.pointsArray = undefined;
};

Point2DList.prototype.addPoint = function(point2d)
{
	if (point2d === undefined)
	{ return; }
	
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }

	this.pointsArray.push(point2d);
};

Point2DList.prototype.newPoint = function(x, y)
{
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }
	
	var point = new Point2D(x, y);
	this.pointsArray.push(point);
	return point;
};

Point2DList.prototype.getPoint = function(idx)
{
	return this.pointsArray[idx];
};

Point2DList.prototype.getPointsCount = function()
{
	if (this.pointsArray === undefined)
	{ return 0; }
	
	return this.pointsArray.length;
};

Point2DList.prototype.getPrevIdx = function(idx)
{
	var pointsCount = this.pointsArray.length;
	var prevIdx;
	
	if (idx === 0)
	{ prevIdx = pointsCount - 1; }
	else
	{ prevIdx = idx - 1; }

	return prevIdx;
};

Point2DList.prototype.getNextIdx = function(idx)
{
	var pointsCount = this.pointsArray.length;
	var nextIdx;
	
	if (idx === pointsCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	return nextIdx;
};

Point2DList.prototype.getIdxOfPoint = function(point)
{
	var pointsCount = this.pointsArray.length;
	var i=0;
	var idx = -1;
	var found = false;
	while (!found && i<pointsCount)
	{
		if (this.pointsArray[i] === point)
		{
			found = true;
			idx = i;
		}
		i++;
	}
	
	return idx;
};

Point2DList.prototype.getSegment = function(idx, resultSegment)
{
	var currPoint = this.getPoint(idx);
	var nextIdx = this.getNextIdx(idx);
	var nextPoint = this.getPoint(nextIdx);
	
	if (resultSegment === undefined)
	{ resultSegment = new Segment2D(currPoint, nextPoint); }
	else 
	{
		resultSegment.setPoints(currPoint, nextPoint);
	}

	return resultSegment;
};

Point2DList.prototype.setIdxInList = function()
{
	var pointsCount = this.pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.pointsArray[i].idxInList = i;
	}
};

/**
 * nomal 계산
 */
Point2DList.prototype.getCopy = function(resultPoint2dList) 
{
	if (resultPoint2dList === undefined)
	{ resultPoint2dList = new Point2DList(); }
	else
	{ resultPoint2dList.deleteObjects(); }
	
	var myPoint, copyPoint;
	var pointsCount = this.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		myPoint = this.getPoint(i);
		copyPoint = resultPoint2dList.newPoint(myPoint.x, myPoint.y);
	}
	
	return resultPoint2dList;
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point2DList.prototype.getBoundingRectangle = function(resultBRect) 
{
	var pointsCount = this.getPointsCount();
	if (pointsCount === 0)
	{ return resultBRect; }
	
	if (resultBRect === undefined)
	{ resultBRect = new BoundingRectangle(); }
	
	var point;
	for (var i=0; i<pointsCount; i++)
	{
		if (i === 0)
		{ resultBRect.setInit(this.getPoint(i)); }
		else
		{ resultBRect.addPoint(this.getPoint(i)); }
	}
	
	return resultBRect;
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point2DList.prototype.getNearestPointIdxToPoint = function(point) 
{
	if (point === undefined)
	{ return undefined; }
	
	var currPoint, candidatePointIdx;
	var currSquaredDist, candidateSquaredDist;
	var pointsCount = this.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		currPoint = this.getPoint(i);
		currSquaredDist = currPoint.squareDistToPoint(point);
		if (candidatePointIdx === undefined)
		{
			candidatePointIdx = i;
			candidateSquaredDist = currSquaredDist;
		}
		else 
		{
			if (currSquaredDist < candidateSquaredDist)
			{
				candidatePointIdx = i;
				candidateSquaredDist = currSquaredDist;
			}
		}
	}
	
	return candidatePointIdx;
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point2DList.prototype.reverse = function() 
{
	if (this.pointsArray !== undefined)
	{ this.pointsArray.reverse(); }
};

Point2DList.prototype.getPointsIdxSortedByDistToPoint = function(thePoint, resultSortedPointsIdxArray)
{
	if (this.pointsArray === undefined)
	{ return resultSortedPointsIdxArray; }
	
	// Static function.***
	// Sorting minDist to maxDist.***
	if (resultSortedPointsIdxArray === undefined)
	{ resultSortedPointsIdxArray = []; }
	
	var pointsArray = this.pointsArray;
	
	var objectAux;
	var objectsAuxArray = [];
	var point;
	var squaredDist;
	var startIdx, endIdx, insertIdx;
	var pointsCount = pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		point = pointsArray[i];
		if (point === thePoint)
		{ continue; }
		
		squaredDist = thePoint.squareDistToPoint(point);
		objectAux = {};
		objectAux.pointIdx = i;
		objectAux.squaredDist = squaredDist;
		startIdx = 0;
		endIdx = objectsAuxArray.length - 1;
		
		insertIdx = this.getIndexToInsertBySquaredDist(objectsAuxArray, objectAux, startIdx, endIdx);
		objectsAuxArray.splice(insertIdx, 0, objectAux);
	}
	
	resultSortedPointsIdxArray.length = 0;
	var objectsCount = objectsAuxArray.length;
	for (var i=0; i<objectsCount; i++)
	{
		resultSortedPointsIdxArray.push(objectsAuxArray[i].pointIdx);
	}
	
	return resultSortedPointsIdxArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns result_idx
 */
Point2DList.prototype.getIndexToInsertBySquaredDist = function(objectsArray, object, startIdx, endIdx) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	
	var range = endIdx - startIdx;
	
	if (objectsArray.length === 0)
	{ return 0; }
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		//var objectsCount = objectsArray.length;
		while (!finished && i<=endIdx)
		{
			if (object.squaredDist < objectsArray[i].squaredDist)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (objectsArray[middleIdx].squaredDist > object.squaredDist)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getIndexToInsertBySquaredDist(objectsArray, object, newStartIdx, newEndIdx);
	}
};
















































'use strict';

/**
 * 3차원 정보
 * @class Point3D
 */
var Point3D = function(x, y, z) 
{
	if (!(this instanceof Point3D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	if (x !== undefined)
	{ this.x = x; }
	else
	{ this.x = 0.0; }
	
	if (y !== undefined)
	{ this.y = y; }
	else
	{ this.y = 0.0; }
	
	if (z !== undefined)
	{ this.z = z; }
	else
	{ this.z = 0.0; }
	
	this.pointType; // 1 = important point.***
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Point3D.prototype.deleteObjects = function() 
{
	this.x = undefined;
	this.y = undefined;
	this.z = undefined;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Point3D.prototype.copyFrom = function(point3d) 
{
	this.x = point3d.x;
	this.y = point3d.y;
	this.z = point3d.z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns this.x*this.x + this.y*this.y + this.z*this.z;
 */
Point3D.prototype.getSquaredModul = function() 
{
	return this.x*this.x + this.y*this.y + this.z*this.z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z );
 */
Point3D.prototype.getModul = function() 
{
	return Math.sqrt(this.getSquaredModul());
};

/**
 * 
 * 어떤 일을 하고 있습니까?
 */
Point3D.prototype.unitary = function() 
{
	var modul = this.getModul();
	this.x /= modul;
	this.y /= modul;
	this.z /= modul;
};

/**
 * 
 * 어떤 일을 하고 있습니까?
 */
Point3D.prototype.isNAN = function() 
{
	if (isNaN(this.x) || isNaN(this.y) || isNaN(this.z) )
	{ return true; }
	else
	{ return false; }
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point3D.prototype.crossProduct = function(point, resultPoint) 
{
	if (resultPoint === undefined) { resultPoint = new Point3D(); }

	resultPoint.x = this.y * point.z - point.y * this.z;
	resultPoint.y = point.x * this.z - this.x * point.z;
	resultPoint.z = this.x * point.y - point.x * this.y;

	return resultPoint;
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point3D.prototype.scalarProduct = function(point) 
{
	var scalarProd = this.x*point.x + this.y*point.y + this.z*point.z;
	return scalarProd;
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point3D.prototype.angleRadToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	//******************************************************
	//var scalarProd = this.scalarProd(vector);
	var myModul = this.getModul();
	var vecModul = vector.getModul();
	
	// calcule by cos.***
	//var cosAlfa = scalarProd / (myModul * vecModul); 
	//var angRad = Math.acos(cosAlfa);
	//var angDeg = alfa * 180.0/Math.PI;
	//------------------------------------------------------
	var error = 10E-10;
	if (myModul < error || vecModul < error)
	{ return undefined; }
	
	return Math.acos(this.scalarProduct(vector) / (myModul * vecModul));
};

/**
 * nomal 계산
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point3D.prototype.angleDegToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	var angRad = this.angleRadToVector(vector);
	
	if (angRad === undefined)
	{ return undefined; }
		
	return angRad * 180.0/Math.PI;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.squareDistToPoint = function(point) 
{
	var dx = this.x - point.x;
	var dy = this.y - point.y;
	var dz = this.z - point.z;

	return dx*dx + dy*dy + dz*dz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.isCoincidentToPoint = function(point, errorDist) 
{
	var squareDist = this.distToPoint(point);
	var coincident = false;
	if (squareDist < errorDist*errorDist)
	{
		coincident = true;
	}

	return coincident;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.squareDistTo = function(x, y, z) 
{
	var dx = this.x - x;
	var dy = this.y - y;
	var dz = this.z - z;

	return dx*dx + dy*dy + dz*dz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distTo = function(x, y, z) 
{
	return Math.sqrt(this.squareDistTo(x, y, z));
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distToPoint = function(point) 
{
	return Math.sqrt(this.squareDistToPoint(point));
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distToSphere = function(sphere) 
{
	return Math.sqrt(this.squareDistToPoint(sphere.centerPoint)) - sphere.r;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.aproxDistTo = function(pointB, sqrtTable) 
{
	var difX = Math.abs(this.x - pointB.x);
	var difY = Math.abs(this.y - pointB.y);
	var difZ = Math.abs(this.z - pointB.z);
	
	// find the big value.
	var maxValue, value1, value2;
	var value1Idx, value2Idx;
	
	if (difX > difY)
	{
		if (difX > difZ)
		{
			maxValue = difX;
			value1 = difY/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difY/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
	}
	else 
	{
		if (difY > difZ)
		{
			maxValue = difY;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difY/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.getVectorToPoint = function(targetPoint, resultVector) 
{
	// this returns a vector that points to "targetPoint" from "this".***
	// the "resultVector" has the direction from "this" to "targetPoint", but is NOT normalized.***
	if (targetPoint === undefined)
	{ return undefined; }
	
	if (resultVector === undefined)
	{ resultVector = new Point3D(); }
	
	resultVector.set(targetPoint.x - this.x, targetPoint.y - this.y, targetPoint.z - this.z);
	
	return resultVector;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.set = function(x, y, z) 
{
	this.x = x; this.y = y; this.z = z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.add = function(x, y, z) 
{
	this.x += x; this.y += y; this.z += z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.addPoint = function(point) 
{
	this.x += point.x; this.y += point.y; this.z += point.z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.scale = function(scaleFactor) 
{
	this.x *= scaleFactor; this.y *= scaleFactor; this.z *= scaleFactor;
};





































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Polygon
 */
var Polygon = function() 
{
	if (!(this instanceof Polygon)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.point2dList;
	this.normal; // polygon sense. (normal = 1) -> CCW. (normal = -1) -> CW.***
	this.convexPolygonsArray; // tessellation result.***
	this.bRect; // boundary rectangle.***
};

Polygon.prototype.deleteObjects = function()
{
	if (this.point2dList !== undefined)
	{
		this.point2dList.deleteObjects();
		this.point2dList = undefined;
	}
	
	this.normal = undefined;
};

Polygon.prototype.getBoundingRectangle = function(resultBRect)
{
	if (this.point2dList === undefined)
	{ return resultBRect; }
	
	resultBRect = this.point2dList.getBoundingRectangle(resultBRect);
	return resultBRect;
};

Polygon.prototype.getEdgeDirection = function(idx)
{
	// the direction is unitary vector.***
	var segment = this.point2dList.getSegment(idx);
	var direction = segment.getDirection(undefined);
	return direction;
};

Polygon.prototype.getEdgeVector = function(idx)
{
	var segment = this.point2dList.getSegment(idx);
	var vector = segment.getVector(undefined);
	return vector;
};

Polygon.prototype.reverseSense = function()
{
	if (this.point2dList !== undefined)
	{ this.point2dList.reverse(); }
};

Polygon.prototype.getCopy = function(resultCopyPolygon)
{
	if (this.point2dList === undefined)
	{ return resultCopyPolygon; }
	
	if (resultCopyPolygon === undefined)
	{ resultCopyPolygon = new Polygon(); }
	
	// copy the point2dList and the normal.***
	if (resultCopyPolygon.point2dList === undefined)
	{ resultCopyPolygon.point2dList = new Point2DList(); }
	
	resultCopyPolygon.point2dList = this.point2dList.getCopy(resultCopyPolygon.point2dList);
	
	if (this.normal)
	{ resultCopyPolygon.normal = this.normal; }
	
	return resultCopyPolygon;
};

Polygon.prototype.calculateNormal = function(resultConcavePointsIdxArray)
{
	// must check if the verticesCount is 3. Then is a convex polygon.***
	
	// A & B are vectors.
	// A*B is scalarProduct.
	// A*B = |A|*|B|*cos(alfa)
	var point;
	var crossProd;
	
	if (resultConcavePointsIdxArray === undefined)
	{ resultConcavePointsIdxArray = []; }
	
	//var candidate_1 = {}; // normal candidate 1.***
	//var candidate_2 = {}; // normal candidate 2.***
	
	this.normal = 0; // unknown sense.***
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = this.point2dList.getPoint(i);
		var prevIdx = this.point2dList.getPrevIdx(i);
		
		// get unitari directions of the vertex.***
		var startVec = this.getEdgeDirection(prevIdx); // Point3D.
		var endVec = this.getEdgeDirection(i); // Point3D.
		
		// calculate the cross product.***
		var crossProd = startVec.crossProduct(endVec, crossProd); // Point3D.
		var scalarProd = startVec.scalarProduct(endVec);
		
		if (crossProd < 0.0) 
		{
			crossProd = -1;
			resultConcavePointsIdxArray.push(i);
		}
		else if (crossProd > 0.0) 
		{
			crossProd = 1;
		}
		// calcule by cos.***
		// cosAlfa = scalarProd / (strModul * endModul); (but strVecModul = 1 & endVecModul = 1), so:
		var cosAlfa = scalarProd;
		var alfa = Math.acos(cosAlfa);
		this.normal += (crossProd * alfa);
	}
	
	if (this.normal > 0 )
	{ this.normal = 1; }
	else
	{ this.normal = -1; }
	
	return resultConcavePointsIdxArray;
};


Polygon.prototype.tessellate = function(concaveVerticesIndices, convexPolygonsArray)
{
	var concaveVerticesCount = concaveVerticesIndices.length;
	
	if (concaveVerticesCount === 0)
	{
		convexPolygonsArray.push(this);
		return convexPolygonsArray;
	}
	
	// now, for any concave vertex, find the closest vertex to split the polygon.***
	var find = false;
	var idx_B;
	var i=0;
	
	while (!find && i<concaveVerticesCount)
	{
		var idx = concaveVerticesIndices[i];
		var point = this.point2dList.getPoint(idx);
		var resultSortedPointsIdxArray = [];
		
		// get vertices indices sorted by distance to "point".***
		this.getPointsIdxSortedByDistToPoint(point, resultSortedPointsIdxArray);
		
		var sortedVerticesCount = resultSortedPointsIdxArray.length;
		var j=0;
		while (!find && j<sortedVerticesCount)
		{
			idx_B = resultSortedPointsIdxArray[j];
			
			// skip adjacent vertices.***
			if (this.point2dList.getPrevIdx(idx) === idx_B || this.point2dList.getNextIdx(idx) === idx_B)
			{
				j++;
				continue;
			}
			
			// check if is splittable by idx-idx_B.***
			var segment = new Segment2D(this.point2dList.getPoint(idx), this.point2dList.getPoint(idx_B));
			if (this.intersectionWithSegment(segment))
			{
				j++;
				continue;
			}
			
			var resultSplittedPolygons = this.splitPolygon(idx, idx_B);
			
			if (resultSplittedPolygons.length < 2)
			{
				j++;
				continue;
			}
			
			// now, compare splittedPolygon's normals with myNormal.***
			var polygon_A = resultSplittedPolygons[0];
			var polygon_B = resultSplittedPolygons[1];
			var concavePoints_A = polygon_A.calculateNormal();
			var concavePoints_B = polygon_B.calculateNormal();
			
			var normal_A = polygon_A.normal;
			var normal_B = polygon_B.normal;
			if (normal_A === this.normal && normal_B === this.normal)
			{
				find = true;
				// polygon_A.***
				if (concavePoints_A.length > 0)
				{
					convexPolygonsArray = polygon_A.tessellate(concavePoints_A, convexPolygonsArray);
				}
				else 
				{
					if (convexPolygonsArray === undefined)
					{ convexPolygonsArray = []; }
					
					convexPolygonsArray.push(polygon_A);
				}
				
				// polygon_B.***
				if (concavePoints_B.length > 0)
				{
					convexPolygonsArray = polygon_B.tessellate(concavePoints_B, convexPolygonsArray);
				}
				else 
				{
					if (convexPolygonsArray === undefined)
					{ convexPolygonsArray = []; }
					
					convexPolygonsArray.push(polygon_B);
				}
			}
			
			j++;
		}
		i++;
	}
	
	return convexPolygonsArray;
};

Polygon.prototype.intersectionWithSegment = function(segment)
{
	// "segment" cut a polygons edge.***
	// "segment" coincident with a polygons vertex.***
	if (this.bRect !== undefined)
	{
		// if exist boundary rectangle, check bRect intersection.***
		var segmentsBRect = segment.getBoundaryRectangle(segmentsBRect);
		if (!this.bRect.intersectsWithRectangle(segmentsBRect))
		{ return false; }
	}
	
	// 1rst check if the segment is coincident with any polygons vertex.***
	var mySegment;
	var intersectionType;
	var error = 10E-8;
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		mySegment = this.point2dList.getSegment(i, mySegment);
		
		// if segment shares points, then must not cross.***
		if (segment.sharesPointsWithSegment(mySegment))
		{
			continue;
		}
		
		if (segment.intersectionWithSegment(mySegment, error))
		{
			return true;
		}
	}
	
	return false;
};

Polygon.prototype.splitPolygon = function(idx1, idx2, resultSplittedPolygonsArray)
{
	if (resultSplittedPolygonsArray === undefined)
	{ resultSplittedPolygonsArray = []; }
	
	// polygon A. idx1 -> idx2.***
	var polygon_A = new Polygon();
	polygon_A.point2dList = new Point2DList();
	polygon_A.point2dList.pointsArray = [];
	
	// 1rst, put vertex1 & vertex2 in to the polygon_A.***
	polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(idx1));
	polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(idx2));
	
	var finished = false;
	var currIdx = idx2;
	var startIdx = idx1;
	var i=0;
	var totalPointsCount = this.point2dList.getPointsCount();
	while (!finished && i<totalPointsCount)
	{
		var nextIdx = this.point2dList.getNextIdx(currIdx);
		if (nextIdx === startIdx)
		{
			finished = true;
		}
		else 
		{
			polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(nextIdx));
			currIdx = nextIdx;
		}
		i++;
	}
	
	resultSplittedPolygonsArray.push(polygon_A);
	
	// polygon B. idx2 -> idx1.***
	var polygon_B = new Polygon();
	polygon_B.point2dList = new Point2DList();
	polygon_B.point2dList.pointsArray = [];
	
	// 1rst, put vertex2 & vertex1 in to the polygon_B.***
	polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(idx2));
	polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(idx1));
	
	finished = false;
	currIdx = idx1;
	startIdx = idx2;
	i=0;
	while (!finished && i<totalPointsCount)
	{
		var nextIdx = this.point2dList.getNextIdx(currIdx);
		if (nextIdx === startIdx)
		{
			finished = true;
		}
		else 
		{
			polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(nextIdx));
			currIdx = nextIdx;
		}
		i++;
	}
	
	resultSplittedPolygonsArray.push(polygon_B);
	return resultSplittedPolygonsArray;
};

Polygon.prototype.getPointsIdxSortedByDistToPoint = function(thePoint, resultSortedPointsIdxArray)
{
	// Static function.***
	// Sorting minDist to maxDist.***
	if (resultSortedPointsIdxArray === undefined)
	{ resultSortedPointsIdxArray = []; }
	
	resultSortedPointsIdxArray = this.point2dList.getPointsIdxSortedByDistToPoint(thePoint, resultSortedPointsIdxArray);
	
	return resultSortedPointsIdxArray;
};

Polygon.prototype.getTrianglesConvexPolygon = function(resultTrianglesArray)
{
	// PROVISIONAL.***
	// in this case, consider the polygon is convex.***
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }

	var pointsCount = this.point2dList.getPointsCount();
	if (pointsCount <3)
	{ return resultTrianglesArray; }
	
	var triangle;
	for (var i=1; i<pointsCount-1; i++)
	{
		triangle = new Triangle();
		
		var point0idx = this.point2dList.getPoint(0).idxInList;
		var point1idx = this.point2dList.getPoint(i).idxInList;
		var point2idx = this.point2dList.getPoint(i+1).idxInList;
		
		triangle.vtxIdx0 = point0idx;
		triangle.vtxIdx1 = point1idx;
		triangle.vtxIdx2 = point2idx;
		
		resultTrianglesArray.push(triangle);
	}
	
	return resultTrianglesArray;
};

Polygon.prototype.getVbo = function(resultVbo)
{
	// PROVISIONAL.***
	// return positions, normals and indices.***
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	// 1rst, obtain pos, nor.***
	var posArray = [];
	var norArray = [];
	var point;
	var normal;
	if (this.normal > 0)
	{ normal = 1; }
	else
	{ normal = -1; }
		
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = this.point2dList.getPoint(i);
		
		posArray.push(point.x);
		posArray.push(point.y);
		posArray.push(0.0);
		
		norArray.push(0);
		norArray.push(0);
		norArray.push(normal*255);
	}
	
	resultVbo.posVboDataArray = Float32Array.from(posArray);
	resultVbo.norVboDataArray = Int8Array.from(norArray);
	
	// now calculate triangles indices.***
	this.point2dList.setIdxInList(); // use this function instead a map.***
	
	var trianglesArray = [];
	var convexPolygonsCount = this.convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		var convexPolygon = this.convexPolygonsArray[i];
		trianglesArray = convexPolygon.getTrianglesConvexPolygon(trianglesArray); // provisional.***
	}
	TrianglesList.getVboFaceDataArray(trianglesArray, resultVbo);

	return resultVbo;
};

Polygon.getVbo = function(concavePolygon, convexPolygonsArray, resultVbo)
{
	// PROVISIONAL.***
	// return positions, normals and indices.***
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	// 1rst, obtain pos, nor.***
	var posArray = [];
	var norArray = [];
	var point;
	var normal;
	if (concavePolygon.normal > 0)
	{ normal = 1; }
	else
	{ normal = -1; }
		
	var pointsCount = concavePolygon.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = concavePolygon.point2dList.getPoint(i);
		
		posArray.push(point.x);
		posArray.push(point.y);
		posArray.push(0.0);
		
		norArray.push(0);
		norArray.push(0);
		norArray.push(normal*255);
	}
	
	resultVbo.posVboDataArray = Float32Array.from(posArray);
	resultVbo.norVboDataArray = Int8Array.from(norArray);
	
	// now calculate triangles indices.***
	concavePolygon.point2dList.setIdxInList(); // use this function instead a map.***
	
	var trianglesArray = [];
	var convexPolygonsCount = convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		var convexPolygon = convexPolygonsArray[i];
		trianglesArray = convexPolygon.getTrianglesConvexPolygon(trianglesArray); // provisional.***
	}
	TrianglesList.getVboFaceDataArray(trianglesArray, resultVbo);

	return resultVbo;
};
























'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class PolyLine
 */
var PolyLine = function() 
{
	if (!(this instanceof PolyLine)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.point2dArray;
};

/**
 * Creates a new Point2D.
 * @class PolyLine
 */
PolyLine.prototype.newPoint2d = function(x, y)
{
	if (this.point2dArray === undefined)
	{ this.point2dArray = []; }
	
	var point2d = new Point2D(x, y);
	this.point2dArray.push(point2d);
	return point2d;
};

/**
 * Creates a new Point2D.
 * @class PolyLine
 */
PolyLine.prototype.deleteObjects = function()
{
	var pointsCount = this.point2dArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.point2dArray[i].deleteObjects();
		this.point2dArray[i] = undefined;
	}
	this.point2dArray = undefined;
};

/**
 * Creates a new Point2D.
 * @class PolyLine
 */
PolyLine.prototype.getPoints = function(resultPointsArray)
{
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var point;
	var errorDist = 10E-8;
	var resultExistentPointsCount = resultPointsArray.length;
	var pointsCount = this.point2dArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		if (i===0)
		{
			if (resultExistentPointsCount > 0)
			{
				// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.***
				var lastExistentPoint = resultPointsArray[resultExistentPointsCount-1];
				var point0 = this.point2dArray[i];
				if (!lastExistentPoint.isCoincidentToPoint(point0, errorDist))
				{
					point = new Point2D();
					point.copyFrom(this.point2dArray[i]); 
					point.pointType = 1; // mark as "important point".***
					resultPointsArray.push(point);
				}
			}
			else
			{
				point = new Point2D();
				point.copyFrom(this.point2dArray[i]); 
				point.pointType = 1; // mark as "important point".***
				resultPointsArray.push(point);
			}
		}
		else
		{
			point = new Point2D();
			point.copyFrom(this.point2dArray[i]); 
			point.pointType = 1; // mark as "important point".***
			resultPointsArray.push(point);
		}
	}
	
	return resultPointsArray;
};













































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Profile
 */
var Profile = function() 
{
	if (!(this instanceof Profile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.outerRing; // one Ring. 
	this.innerRingsList; // class: RingsList. 
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.newOuterRing = function() 
{
	if (this.outerRing === undefined)
	{ this.outerRing = new Ring(); }
	else 
	{
		this.outerRing.deleteObjects();
	}
	
	return this.outerRing;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.newInnerRing = function() 
{
	if (this.innerRingsList === undefined)
	{ this.innerRingsList = new RingsList(); }
	
	var innerRing = this.innerRingsList.newRing();
	
	return innerRing;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.deleteObjects = function() 
{
	if (this.outerRing)
	{
		this.outerRing.deleteObjects();
		this.outerRing = undefined;
	}

	if (this.innerRingsList)
	{
		this.innerRingsList.deleteObjects();
		this.innerRingsList = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */

Profile.prototype.hasHoles = function() 
{
	if (this.innerRingsList === undefined || this.innerRingsList.getRingsCount() === 0)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile.prototype.getVBO = function(resultVbo) 
{
	if (this.outerRing === undefined)
	{ return resultVbo; }
	
	var generalPolygon = this.getGeneralPolygon(undefined);
	generalPolygon.getVbo(resultVbo);
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile.prototype.getConvexFacesIndicesData = function(resultGeneralIndicesData) 
{
	if (this.outerRing === undefined)
	{ return resultVbo; }
	
	var generalPolygon = this.getGeneralPolygon(undefined);
	
	if (resultGeneralIndicesData === undefined)
	{ resultGeneralIndicesData = []; }
	
	// 1rst, set idxInList all points.***
	this.outerRing.polygon.point2dList.setIdxInList();
	
	if (this.innerRingsList !== undefined)
	{
		var innerRingsCount = this.innerRingsList.getRingsCount();
		for (var i=0; i<innerRingsCount; i++)
		{
			var innerRing = this.innerRingsList.getRing(i);
			innerRing.polygon.point2dList.setIdxInList();
		}
	}
	
	var convexDatas;
	var convexPolygon;
	var indexData;
	var currRing;
	var ringIdxInList;
	var point;
	var convexPolygonsCount = generalPolygon.convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		convexPolygon = generalPolygon.convexPolygonsArray[i];
		convexDatas = [];
		var pointsCount = convexPolygon.point2dList.getPointsCount();
		for (var j=0; j<pointsCount; j++)
		{
			point = convexPolygon.point2dList.getPoint(j);
			indexData = point.indexData;
			currRing = indexData.owner;
			indexData.idxInList = point.idxInList;
			if (currRing === this.outerRing)
			{
				ringIdxInList = -1;
			}
			else 
			{
				ringIdxInList = this.innerRingsList.getRingIdx(currRing);
			}
			indexData.ownerIdx = ringIdxInList;
			convexDatas.push(indexData);
		}
		resultGeneralIndicesData.push(convexDatas);
	}
	
	return resultGeneralIndicesData;
};


/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile.prototype.getGeneralPolygon = function(generalPolygon) 
{
	// this returns a holesTessellatedPolygon, and inside it has convexPolygons.***
	this.checkNormals(); // here makes outer & inner's polygons.***
	
	if (!this.hasHoles())
	{
		// Simply, put all points of outerPolygon into generalPolygon(computingPolygon).***
		if (generalPolygon === undefined)
		{ generalPolygon = new Polygon(); }
		
		if (generalPolygon.point2dList === undefined)
		{ generalPolygon.point2dList = new Point2DList(); }
		
		var outerPolygon = this.outerRing.polygon;
		var point;
		var outerPointsCount = outerPolygon.point2dList.getPointsCount();
		for (var i=0; i<outerPointsCount; i++)
		{
			point = outerPolygon.point2dList.getPoint(i);
			generalPolygon.point2dList.addPoint(outerPolygon.point2dList.getPoint(i));
		}
	}
	else 
	{
		// 1rst, check normals congruences.***
		generalPolygon = this.tessellateHoles(generalPolygon);
	}
	
	generalPolygon.convexPolygonsArray = [];
	var concavePointsIndices = generalPolygon.calculateNormal(concavePointsIndices);
	generalPolygon.convexPolygonsArray = generalPolygon.tessellate(concavePointsIndices, generalPolygon.convexPolygonsArray);
	
	return generalPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.eliminateHolePolygonBySplitPoints = function(outerPolygon, innerPolygon, outerPointIdx, innerPointIdx, resultPolygon) 
{
	if (resultPolygon === undefined)
	{ resultPolygon = new Polygon(); }
	
	if (resultPolygon.point2dList === undefined)
	{ resultPolygon.point2dList = new Point2DList(); }
	
	// 1rst, copy in newPolygon the outerPolygon.***
	var outerPointsCount = outerPolygon.point2dList.getPointsCount();
	var finished = false;
	var i=0;
	var newPoint;
	var outerPoint;
	var currIdx = outerPointIdx;
	
	while (!finished && i<outerPointsCount)
	{
		outerPoint = outerPolygon.point2dList.getPoint(currIdx);
		resultPolygon.point2dList.addPoint(outerPoint);
		
		currIdx = outerPolygon.point2dList.getNextIdx(currIdx);
		if (currIdx === outerPointIdx)
		{
			finished = true;
			
			// must add the firstPoint point.***
			outerPoint = outerPolygon.point2dList.getPoint(currIdx);
			resultPolygon.point2dList.addPoint(outerPoint);
		}
		
		i++;
	}
	// now add innerPolygon's points.***
	var innerPointsCount = innerPolygon.point2dList.getPointsCount();
	finished = false;
	i=0;
	newPoint;
	var innerPoint;
	currIdx = innerPointIdx;
	while (!finished && i<innerPointsCount)
	{
		innerPoint = innerPolygon.point2dList.getPoint(currIdx);
		resultPolygon.point2dList.addPoint(innerPoint);
		
		currIdx = innerPolygon.point2dList.getNextIdx(currIdx);
		if (currIdx === innerPointIdx)
		{
			finished = true;
			// must add the firstPoint point.***
			innerPoint = innerPolygon.point2dList.getPoint(currIdx);
			resultPolygon.point2dList.addPoint(innerPoint);
		}
		
		i++;
	}
	
	return resultPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.eliminateHolePolygon = function(computingPolygon, innerRing, innerPointIdx, resultPolygon) 
{
	// 1rst, make a sorted by dist of points of outer to "innerPoint".***
	var resultSortedPointsIdxArray = [];
	var innerPolygon = innerRing.polygon;
	var innerPoint = innerPolygon.point2dList.getPoint(innerPointIdx);
	resultSortedPointsIdxArray = computingPolygon.getPointsIdxSortedByDistToPoint(innerPoint, resultSortedPointsIdxArray);
	
	var outerSortedPointsCount = resultSortedPointsIdxArray.length;
	var splitSegment = new Segment2D();;
	var finished = false;
	var i=0;
	var outPointIdx;
	var outPoint;
	while (!finished && i<outerSortedPointsCount)
	{
		outPointIdx = resultSortedPointsIdxArray[i];
		outPoint = computingPolygon.point2dList.getPoint(outPointIdx);
		splitSegment.setPoints(outPoint, innerPoint);
		
		// check if splitSegment intersects the computingPolygon or any innerPolygons.***
		if (computingPolygon.intersectionWithSegment(splitSegment) || innerPolygon.intersectionWithSegment(splitSegment))
		{
			i++;
			continue;
		}
		
		resultPolygon = this.eliminateHolePolygonBySplitPoints(computingPolygon, innerPolygon, outPointIdx, innerPointIdx, resultPolygon);
		finished = true;
		
		i++;
	}
	
	if (!finished)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.tessellateHoles = function(resultHolesEliminatedPolygon) 
{
	if (this.outerRing === undefined)
	{ return resultHolesEliminatedPolygon; }
	
	if (!this.hasHoles())
	{ return resultHolesEliminatedPolygon; }
	
	if (resultHolesEliminatedPolygon === undefined)
	{ resultHolesEliminatedPolygon = new Polygon(); }
	
	var hole;
	var holeIdx;
	var holePolygon;
	var objectAux;
	var innerPointIdx;
	var innersBRect;
	
	// prepare outerRing if necessary.***
	var outerRing = this.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	var outerPolygon = outerRing.polygon;
	var concavePointsIndices = outerPolygon.calculateNormal(concavePointsIndices);
	
	// make a innerRingsArray copy.***
	var innerRingsArray = [];
	var innerRingsCount = this.innerRingsList.getRingsCount();
	for (var i=0; i<innerRingsCount; i++)
	{
		innerRingsArray.push(this.innerRingsList.getRing(i));
	}
	
	var resultPolygon = new Polygon();
	var computingPolygon = new Polygon();
	computingPolygon.point2dList = new Point2DList();
	
	// put all points of outerPolygon into computingPolygon.***
	var indexData;
	var point;
	var outerPointsCount = outerPolygon.point2dList.getPointsCount();
	for (var i=0; i<outerPointsCount; i++)
	{
		point = outerPolygon.point2dList.getPoint(i);
		//point.owner
		computingPolygon.point2dList.addPoint(outerPolygon.point2dList.getPoint(i));
	}
	
	var innersBRectLeftDownPoint = new Point2D();
	var objectsArray = [];
	
	// now, for each innerRing, try to merge to outerRing by splitSegment.***
	var innerRingsCount = innerRingsArray.length;
	var i=0;
	var finished = false;
	while (!finished && i<innerRingsCount)
	{
		// calculate the most left-down innerRing.***
		innersBRect = RingsList.getBoundingRectangle(innerRingsArray, innersBRect);
		innersBRectLeftDownPoint.set(innersBRect.minX, innersBRect.minY);
		
		objectsArray.length = 0; // init.***
		objectsArray = RingsList.getSortedRingsByDistToPoint(innersBRectLeftDownPoint, innerRingsArray, objectsArray);
	
		objectAux = objectsArray[0];
		hole = objectAux.ring;
		holeIdx = objectAux.ringIdx;
		holePolygon = hole.polygon;
		innerPointIdx = objectAux.pointIdx;
		holePolygon.calculateNormal();
		
		if (this.eliminateHolePolygon(computingPolygon, hole, innerPointIdx, resultPolygon))
		{
			computingPolygon = resultPolygon;
			
			if (innerRingsArray.length == 1)
			{
				finished = true;
				break;
			}
			// erase the hole from innerRingsArray.***
			innerRingsArray.splice(holeIdx, 1);
			resultPolygon = new Polygon();
		}
		i++;
	}
	resultHolesEliminatedPolygon = computingPolygon;
	return resultHolesEliminatedPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.checkNormals = function() 
{
	if (this.outerRing === undefined)
	{ return; }
	
	// 1rst, calculate the outerNormal.***
	var outerRing = this.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	var outerPolygon = outerRing.polygon;
	var concavePointsIndices = outerPolygon.calculateNormal(concavePointsIndices);
	var outerNormal = outerPolygon.normal;
	
	if (this.innerRingsList === undefined)
	{ return; }
	
	// if there are inners, the innerNormals must be inverse of the outerNormal.***
	var innerRing;
	var innerPolygon;
	var innerNormal;
	var innersCount = this.innerRingsList.getRingsCount();
	for (var i=0; i<innersCount; i++)
	{
		innerRing = this.innerRingsList.getRing(i);
		if (innerRing.polygon === undefined)
		{ innerRing.makePolygon(); }
		var innerPolygon = innerRing.polygon;
		innerPolygon.calculateNormal();
		var innerNormal = innerPolygon.normal;
		
		if (innerNormal === outerNormal)
		{
			// then reverse innerPolygon.***
			innerPolygon.reverseSense();
			innerPolygon.normal = -innerNormal;
		}
		
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.TEST__setFigure_1 = function() 
{
	// complicated polygon with multiple holes.***
	var polyLine;
	var arc;
	var circle;
	var rect;
	var point3d;
	var star;
	
	// Outer ring.**************************************
	var outerRing = this.newOuterRing();
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(7, 7); // 0
	point3d = polyLine.newPoint2d(0, 7); // 1
	point3d = polyLine.newPoint2d(0, 0); // 2
	point3d = polyLine.newPoint2d(7, 0); // 3
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(7, 3.5);
	arc.setRadius(3.5);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	// hole.***
	var innerRing = this.newInnerRing();
	rect = innerRing.newElement("RECTANGLE");
	rect.setCenterPosition(3, 3);
	rect.setDimensions(2, 2);
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile.prototype.TEST__setFigureHole_2 = function() 
{
	// complicated polygon with multiple holes.***
	var polyLine;
	var arc;
	var circle;
	var rect;
	var point3d;
	var star;
	
	// Outer ring.**************************************
	var outerRing = this.newOuterRing();
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-13, 3); // 0
	point3d = polyLine.newPoint2d(-13, -11); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-8, -11);
	arc.setRadius(5);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-8, -16); // 0
	point3d = polyLine.newPoint2d(-5, -16); // 1
	point3d = polyLine.newPoint2d(-3, -15); // 2
	point3d = polyLine.newPoint2d(-3, -14); // 3
	point3d = polyLine.newPoint2d(-5, -12); // 4
	point3d = polyLine.newPoint2d(-3, -11); // 5
	point3d = polyLine.newPoint2d(-2, -9); // 6
	point3d = polyLine.newPoint2d(3, -9); // 7
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(9, -9);
	arc.setRadius(6);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(15, -9); // 0
	point3d = polyLine.newPoint2d(16, -9); // 1
	point3d = polyLine.newPoint2d(16, 4); // 2
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(11, 4);
	arc.setRadius(5);
	arc.setStartAngleDegree(0.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(11, 9); // 0
	point3d = polyLine.newPoint2d(4, 9); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(4, 11);
	arc.setRadius(2);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(-180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(4, 13); // 0
	point3d = polyLine.newPoint2d(9, 13); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(9, 14.5);
	arc.setRadius(1.5);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(9, 16); // 0
	point3d = polyLine.newPoint2d(2, 16); // 1
	point3d = polyLine.newPoint2d(0, 14); // 2
	point3d = polyLine.newPoint2d(-4, 16); // 3
	point3d = polyLine.newPoint2d(-9, 16); // 4
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-9, 14);
	arc.setRadius(2);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-9, 12); // 0
	point3d = polyLine.newPoint2d(-6, 12); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-6, 10.5);
	arc.setRadius(1.5);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(-180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-6, 9); // 0
	point3d = polyLine.newPoint2d(-7, 9); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-7, 3);
	arc.setRadius(6);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	// Holes.**************************************************
	// Hole 1.*************************************************
	var innerRing = this.newInnerRing();
	
	polyLine = innerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-9, 3); // 0
	point3d = polyLine.newPoint2d(-10, -4); // 1
	point3d = polyLine.newPoint2d(-10, -8); // 2
	point3d = polyLine.newPoint2d(-8, -11); // 3
	point3d = polyLine.newPoint2d(-3, -7); // 4
	point3d = polyLine.newPoint2d(4, -7); // 5
	
	arc = innerRing.newElement("ARC");
	arc.setCenterPosition(8, -7);
	arc.setRadius(4);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = innerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(12, -7); // 0
	point3d = polyLine.newPoint2d(12, -4); // 1
	point3d = polyLine.newPoint2d(8, -10); // 2
	point3d = polyLine.newPoint2d(4, -5); // 3
	point3d = polyLine.newPoint2d(-8, -5); // 4
	point3d = polyLine.newPoint2d(-7, 4); // 5
	point3d = polyLine.newPoint2d(9, 4); // 6
	point3d = polyLine.newPoint2d(9, -5); // 7
	point3d = polyLine.newPoint2d(14, 2); // 8
	point3d = polyLine.newPoint2d(13, 2); // 9
	point3d = polyLine.newPoint2d(11, 0); // 10
	point3d = polyLine.newPoint2d(11, 7); // 11
	point3d = polyLine.newPoint2d(13, 8); // 12
	point3d = polyLine.newPoint2d(5, 8); // 13
	point3d = polyLine.newPoint2d(9, 6); // 14
	point3d = polyLine.newPoint2d(-6, 6); // 15
	
	arc = innerRing.newElement("ARC");
	arc.setCenterPosition(-6, 3);
	arc.setRadius(3);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	
		
	// Hole 2.*************************************************
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-10, -13);
	circle.setRadius(1);
	
	// Hole 3.*************************************************
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-6.5, -14);
	star.setRadiusCount(5);
	star.setInteriorRadius(0.6);
	star.setExteriorRadius(2);

	// Hole 4.*************************************************
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-9, 14);
	star.setRadiusCount(6);
	star.setInteriorRadius(0.5);
	star.setExteriorRadius(1.5);
	
	// Hole 5.*************************************************
	innerRing = this.newInnerRing();
	rect = innerRing.newElement("RECTANGLE");
	rect.setCenterPosition(-4.5, 1.5);
	rect.setDimensions(3, 3);
	
	// Hole 6.*************************************************
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-4.5, -2.5);
	circle.setRadius(2);
	
	// Hole 7.*************************************************
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(0, 0);
	star.setRadiusCount(5);
	star.setInteriorRadius(1);
	star.setExteriorRadius(2.5);
	
	// Hole 8.*************************************************
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-6, 14);
	circle.setRadius(1.5);
	
	// Hole 9.*************************************************
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-1.5, 11);
	star.setRadiusCount(12);
	star.setInteriorRadius(0.6);
	star.setExteriorRadius(2);
	
	// Hole 10.*************************************************
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(13.5, 5);
	star.setRadiusCount(25);
	star.setInteriorRadius(0.4);
	star.setExteriorRadius(1.5);
	
	// Hole 11.*************************************************
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(9, -13);
	star.setRadiusCount(10);
	star.setInteriorRadius(0.4);
	star.setExteriorRadius(1.5);
	
	// Hole 12.*************************************************
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(5.5, 1.5);
	star.setRadiusCount(7);
	star.setInteriorRadius(0.7);
	star.setExteriorRadius(2);
};



















'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ProfilesList
 */
var ProfilesList = function() 
{
	if (!(this instanceof ProfilesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.profilesArray;
	this.auxiliarAxis;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
ProfilesList.prototype.newProfile = function() 
{
	if (this.profilesArray === undefined)
	{ this.profilesArray = []; }
	
	var profile = new Profile();
	this.profilesArray.push(profile);
	return profile;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
ProfilesList.prototype.deleteObjects = function() 
{
	if (this.profilesArray)
	{
		var profilesCount = this.profilesArray.length;
		for (var i=0; i<profilesCount; i++)
		{
			this.profilesArray[i].deleteObjects();
			this.profilesArray = undefined;
		}
		this.profilesArray = undefined;
	}
};





























'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class Rectangle
*/
var Rectangle = function() 
{
	if (!(this instanceof Rectangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.centerPoint;
	this.width;
	this.height;
};

Rectangle.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

Rectangle.prototype.setDimensions = function(width, height)
{
	this.width = width;
	this.height = height;
};

/**
 * Returns the points of the Rectangle.
 * @class Rectangle
 */
Rectangle.prototype.getPoints = function(resultPointsArray)
{
	if (this.centerPoint === undefined || this.width === undefined || this.height === undefined)
	{ return resultPointsArray; }
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var point;
	var halfWidth = this.width / 2;
	var halfHeight = this.height / 2;
	
	// starting in left-down corner, go in CCW.***
	point = new Point2D(this.centerPoint.x - halfWidth, this.centerPoint.y - halfHeight);
	point.pointType = 1; // mark as "important point".***
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x + halfWidth, this.centerPoint.y - halfHeight);
	point.pointType = 1; // mark as "important point".***
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x + halfWidth, this.centerPoint.y + halfHeight);
	point.pointType = 1; // mark as "important point".***
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x - halfWidth, this.centerPoint.y + halfHeight);
	point.pointType = 1; // mark as "important point".***
	resultPointsArray.push(point);
	
	return resultPointsArray;
};



















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Ring
 */
var Ring = function() 
{
	if (!(this instanceof Ring)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.elemsArray;
	this.polygon; // auxiliar.***
};

/**
 * @class Ring
 */
Ring.prototype.deleteObjects = function()
{
	if (this.elemsArray !== undefined)
	{
		var elemsCount = this.elemsArray.length;
		for (var i=0; i<elemsCount; i++)
		{
			this.elemsArray[i].deleteObjects();
			this.elemsArray[i] = undefined;
		}
		this.elemsArray = undefined;
	}
	
	if (this.polygon !== undefined)
	{ this.polygon.deleteObjects(); }
	
	this.polygon = undefined;
};

/**
 * @class Ring
 */
Ring.prototype.newElement = function(elementTypeString)
{
	var elem;
	
	if (elementTypeString === "ARC")
	{ elem = new Arc(); }
	else if (elementTypeString === "CIRCLE")
	{ elem = new Circle(); }
	else if (elementTypeString === "POLYLINE")
	{ elem = new PolyLine(); }
	else if (elementTypeString === "RECTANGLE")
	{ elem = new Rectangle(); }
	else if (elementTypeString === "STAR")
	{ elem = new Star(); }
	
	if (elem === undefined)
	{ return undefined; }
	
	if (this.elemsArray === undefined)
	{ this.elemsArray = []; }

	this.elemsArray.push(elem);
	
	return elem;
};

/**
 * returns the points array of the ring.
 * @class Ring
 */
Ring.prototype.makePolygon = function()
{
	this.polygon = this.getPolygon(this.polygon);
	return this.polygon;
};

/**
 * returns the points array of the ring.
 * @class Ring
 */
Ring.prototype.getPolygon = function(resultPolygon)
{
	if (resultPolygon === undefined)
	{ resultPolygon = new Polygon(); }
	
	if (resultPolygon.point2dList === undefined)
	{ resultPolygon.point2dList = new Point2DList(); }
	
	// reset polygon.***
	resultPolygon.point2dList.deleteObjects();
	resultPolygon.point2dList.pointsArray = this.getPoints(resultPolygon.point2dList.pointsArray);
	
	// set idxData for all points.***
	var point;
	var pointsCount = resultPolygon.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = resultPolygon.point2dList.getPoint(i);
		point.indexData = new IndexData();
		point.indexData.owner = this;
	}
	
	return resultPolygon;
};

/**
 * returns the points array of the ring.
 * @class Ring
 */
Ring.prototype.getPoints = function(resultPointsArray)
{
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	if (this.elemsArray === undefined)
	{ return resultPointsArray; }
	
	var elem;
	var elemsCount = this.elemsArray.length;
	for (var i=0; i<elemsCount; i++)
	{
		elem = this.elemsArray[i];
		elem.getPoints(resultPointsArray);
	}

	// finally check if the 1rst point and the last point are coincidents.***
	var totalPointsCount = resultPointsArray.length;
	
	if (totalPointsCount > 1)
	{
		// mark the last as pointType = 0
		resultPointsArray[totalPointsCount-1].pointType = 0; // delete this.***
		
		var errorDist = 10E-8;
		var firstPoint = resultPointsArray[0];
		var lastPoint = resultPointsArray[totalPointsCount-1];
		if (firstPoint.isCoincidentToPoint(lastPoint, errorDist))
		{
			// delete the last point.***
			lastPoint = resultPointsArray.pop();
			lastPoint.deleteObjects();
			lastPoint = undefined;
		}
	}
	
	return resultPointsArray;
};








































'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class RingsList
*/
var RingsList = function() 
{
	if (!(this instanceof RingsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.ringsArray;
	this.idxInList;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.prototype.newRing = function() 
{
	if (this.ringsArray === undefined)
	{ this.ringsArray = []; }
	
	var ring = new Ring();
	this.ringsArray.push(ring);
	
	return ring;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.prototype.deleteObjects = function() 
{
	if (this.ringsArray)
	{
		var ringsCount = this.ringsArray.length;
		for (var i=0; i<ringsCount; i++)
		{
			this.ringsArray[i].deleteObjects();
			this.ringsArray[i] = undefined;
		}
		this.ringsArray = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.prototype.getRingsCount = function() 
{
	if (this.ringsArray === undefined)
	{ return 0; }

	return this.ringsArray.length;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.prototype.getRingIdx = function(ring) 
{
	if (ring === undefined)
	{ return undefined; }

	var ringIdx;
	var ringsCount = this.getRingsCount();
	var find = false;
	var i=0; 
	while (!find && i<ringsCount)
	{
		if (this.getRing(i) === ring)
		{
			find = true;
			ringIdx = i;
		}
		i++;
	}
	
	return ringIdx;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.prototype.getRing = function(idx) 
{
	if (this.ringsArray === undefined)
	{ return undefined; }

	return this.ringsArray[idx];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.getBoundingRectangle = function(ringsArray, resultBRect) 
{
	if (this.resultBRect === undefined)
	{ resultBRect = new BoundingRectangle(); }
	
	var ring;
	var currBRect;
	var ringsCount = ringsArray.length;
	for (var i=0; i<ringsCount; i++)
	{
		ring = ringsArray[i];
		if (ring.polygon === undefined)
		{ ring.makePolygon(); }
		
		currBRect = ring.polygon.getBoundingRectangle(currBRect);
		if (i === 0)
		{ resultBRect.setInitByRectangle(currBRect); }
		else 
		{
			resultBRect.addRectangle(currBRect);
		}
	}

	return resultBRect;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.prototype.setIdxInList = function() 
{
	var ringsCount = this.ringsArray.length;
	for (var i=0; i<ringsCount; i++)
	{
		this.ringsArray[i].idxInList = i;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.prototype.intersectionWithSegment = function(segment) 
{
	// returns true if any ring's polygon intersects with "segment".***
	if (segment === undefined)
	{ return false; }
	
	var intersects = false;
	var ringsCount = this.getRingsCount();
	var i=0;
	while (!intersects && i<ringsCount)
	{
		if (this.ringsArray[i].intersectionWithSegment(segment))
		{
			intersects = true;
		}
		i++;
	}
	
	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
RingsList.getSortedRingsByDistToPoint = function(point, ringsArray, resultSortedObjectsArray) 
{
	if (point === undefined)
	{ return resultSortedObjectsArray; }
	
	if (resultSortedObjectsArray === undefined)
	{ resultSortedObjectsArray = []; }
	
	var objectsAuxArray = [];
	var ring;
	var ringPoint;
	var ringPointIdx;
	var squaredDist;
	var objectAux;
	var startIdx, endIdx, insertIdx;
	var ringsCount = ringsArray.length;
	for (var i=0; i<ringsCount; i++)
	{
		ring = ringsArray[i];
		if (ring.polygon === undefined)
		{ ring.makePolygon(); }
		ringPointIdx = ring.polygon.point2dList.getNearestPointIdxToPoint(point);
		ringPoint = ring.polygon.point2dList.getPoint(ringPointIdx);
		squaredDist = ringPoint.squareDistToPoint(point);
		objectAux = {};
		objectAux.ring = ring;
		objectAux.ringIdx = i;
		objectAux.pointIdx = ringPointIdx;
		objectAux.squaredDist = squaredDist;
		
		startIdx = 0;
		endIdx = objectsAuxArray.length - 1;
		
		insertIdx = RingsList.getIndexToInsertBySquaredDist(objectsAuxArray, objectAux, startIdx, endIdx);
		objectsAuxArray.splice(insertIdx, 0, objectAux);
	}
	
	if (resultSortedObjectsArray === undefined)
	{ resultSortedObjectsArray = []; }
	
	resultSortedObjectsArray.length = 0;
	
	var objectsCount = objectsAuxArray.length;
	for (var i=0; i<objectsCount; i++)
	{
		resultSortedObjectsArray.push(objectsAuxArray[i]);
	}
	
	return resultSortedObjectsArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns result_idx
 */
RingsList.getIndexToInsertBySquaredDist = function(objectsArray, object, startIdx, endIdx) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	
	var range = endIdx - startIdx;
	
	if (objectsArray.length === 0)
	{ return 0; }
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		//var objectsCount = objectsArray.length;
		while (!finished && i<=endIdx)
		{
			if (object.squaredDist < objectsArray[i].squaredDist)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (objectsArray[middleIdx].squaredDist > object.squaredDist)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getIndexToInsertBySquaredDist(objectsArray, object, newStartIdx, newEndIdx);
	}
};


















































'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class Segment2D
*/
var Segment2D = function(strPoint2D, endPoint2D) 
{
	if (!(this instanceof Segment2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.startPoint2d;
	this.endPoint2d;
	
	if (strPoint2D)
	{ this.startPoint2d = strPoint2D; }
	
	if (endPoint2D)
	{ this.endPoint2d = endPoint2D; }
};

Segment2D.prototype.setPoints = function(strPoint2D, endPoint2D)
{
	if (strPoint2D)
	{ this.startPoint2d = strPoint2D; }
	
	if (endPoint2D)
	{ this.endPoint2d = endPoint2D; }
};

Segment2D.prototype.getVector = function(resultVector)
{
	if (this.startPoint2d === undefined || this.endPoint2d === undefined)
	{ return undefined; }
	
	if (resultVector === undefined)
	{ resultVector = new Point2D(); }
	
	resultVector = this.startPoint2d.getVectorToPoint(this.endPoint2d, resultVector);
	return resultVector;
};

Segment2D.prototype.getDirection = function(resultDir)
{
	if (resultDir === undefined)
	{ resultDir = new Point2D(); }
	
	resultDir = this.getVector(resultDir);
	resultDir.unitary();
	
	return resultDir;
};

Segment2D.prototype.getBoundaryRectangle = function(resultBRect)
{
	if (resultBRect === undefined)
	{ resultBRect = new BoundaryRectangle(); }
	
	resultBRect.setInit(this.startPoint2d);
	resultBRect.addPoint(this.endPoint2d);
	
	return resultBRect;
};

Segment2D.prototype.getLine = function(resultLine)
{
	if (resultLine === undefined)
	{ resultLine = new Line2D(); }
	
	var dir = this.getDirection(); // unitary direction.***
	var strPoint = this.startPoint2d;
	resultLine.setPointAndDir(strPoint.x, strPoint.y, dir.x, dir.y);
	return resultLine;
};

Segment2D.prototype.getSquaredLength = function()
{
	return this.startPoint2d.squareDistToPoint(this.endPoint2d);
};

Segment2D.prototype.getLength = function()
{
	return Math.sqrt(this.getSquaredLength());
};

Segment2D.prototype.intersectionWithPointByDistances = function(point, error)
{
	if (point === undefined)
	{ return undefined; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	// here no check line-point coincidance.***
	
	// now, check if is inside of the segment or if is coincident with any vertex of segment.***
	var distA = this.startPoint2d.distToPoint(point);
	var distB = this.endPoint2d.distToPoint(point);
	var distTotal = this.getLength();
	
	if (distA < error)
	{ return Constant.INTERSECTION_POINT_A; }
	
	if (distB < error)
	{ return Constant.INTERSECTION_POINT_B; }
	
	if (distA> distTotal || distB> distTotal)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	if (Math.abs(distA + distB - distTotal) < error)
	{ return Constant.INTERSECTION_INSIDE; }
};

Segment2D.prototype.intersectionWithPoint = function(point, error)
{
	if (point === undefined)
	{ return undefined; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	var line = this.getLine();
	if (!line.isCoincidentPoint(point, error))
	{ return Constant.INTERSECTION_OUTSIDE; } // no intersection.***
	
	return this.intersectionWithPointByDistances(point, error);
};

Segment2D.prototype.intersectionWithSegment = function(segment_B, error)
{
	if (segment_B === undefined)
	{ return undefined; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	var myLine = this.getLine();
	var line = segment_B.getLine();
	var intersectionPoint = myLine.intersectionWithLine(line);
	
	if (intersectionPoint === undefined)
	{ return undefined; } // are parallels.***
	
	// now use "intersectionWithPointByDistances" instead "intersectionWithPoint" bcos line-point intersection check is no necesary.***
	var intersectionType_A = this.intersectionWithPointByDistances(intersectionPoint);
	
	if (intersectionType_A === Constant.INTERSECTION_OUTSIDE)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var intersectionType_B = segment_B.intersectionWithPointByDistances(intersectionPoint);
	
	if (intersectionType_B === Constant.INTERSECTION_OUTSIDE)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	return Constant.INTERSECTION_INTERSECT;
};

Segment2D.prototype.hasPoint = function(point)
{
	// returns if this segment has "point" as startPoint or endPoint.***
	if (point === undefined)
	{ return false; }
	
	if (point === this.startPoint2d || point === this.endPoint2d)
	{ return true; }
	
	return false;
};

Segment2D.prototype.sharesPointsWithSegment = function(segment)
{
	if (segment === undefined)
	{ return false; }
	
	if (this.hasPoint(segment.startPoint2d) || this.hasPoint(segment.endPoint2d))
	{ return true; }
	
	return false;
};

















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Star
 */
var Star = function() 
{
	if (!(this instanceof Star)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// this is a closed element.***
	this.centerPoint; // Point3D.***
	this.interiorRadius;
	this.exteriorRadius;
	this.radiusCount;

};

/**
 * Set the center position of Star.
 * @class Star
 */
Star.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * @class Star
 */
Star.prototype.setInteriorRadius = function(radius)
{
	this.interiorRadius = radius;
};

/**
 * @class Star
 */
Star.prototype.setExteriorRadius = function(radius)
{
	this.exteriorRadius = radius;
};

/**
 * @class Star
 */
Star.prototype.setRadiusCount = function(rediusCount)
{
	this.radiusCount = rediusCount;
};

/**
 * Returns the points of the Star.
 * @class Star
 */
Star.prototype.getPoints = function(resultPointsArray)
{
	// star has an arrow to up.***
	var increAngDeg = 360 / this.radiusCount;
	var increAngRad = increAngDeg * Math.PI/180;
	var halfIncreAngRad = increAngRad / 2;
	var startAngRad = 90 * Math.PI/180;
	var currAngRad = startAngRad;
	var point;
	var x, y;
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	for (var i=0; i<this.radiusCount; i++)
	{
		// exterior.***
		x = this.centerPoint.x + this.exteriorRadius * Math.cos(currAngRad);
		y = this.centerPoint.y + this.exteriorRadius * Math.sin(currAngRad);
		point = new Point2D(x, y);
		point.pointType = 1; // mark as "important point".***
		resultPointsArray.push(point);
		
		// interior.***
		x = this.centerPoint.x + this.interiorRadius * Math.cos(currAngRad + halfIncreAngRad);
		y = this.centerPoint.y + this.interiorRadius * Math.sin(currAngRad + halfIncreAngRad);
		point = new Point2D(x, y);
		point.pointType = 1; // mark as "important point".***
		resultPointsArray.push(point);
		
		currAngRad += increAngRad;
	}
	
	return resultPointsArray;
};


















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Surface
 */
var Surface = function() 
{
	if (!(this instanceof Surface)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.facesArray;
	this.localVertexList; // vertices used only for this surface.***
};

Surface.prototype.newFace = function()
{
	if (this.facesArray === undefined)
	{ this.facesArray = []; }
	
	var face = new Face();
	this.facesArray.push(face);
	return face;
};

Surface.prototype.getFacesCount = function()
{
	if (this.facesArray === undefined)
	{ return 0; }

	return this.facesArray.length;
};

Surface.prototype.getFace = function(idx)
{
	if (this.facesArray === undefined)
	{ return undefined; }

	return this.facesArray[idx];
};

Surface.prototype.setColor = function(r, g, b, a)
{
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		face.setColor(r, g, b, a);
	}
};

Surface.prototype.addFacesArray = function(facesArray)
{
	if (facesArray === undefined)
	{ return; }
	
	if (this.facesArray === undefined)
	{ this.facesArray = []; }
	
	Array.prototype.push.apply(this.facesArray, facesArray);
};

Surface.prototype.getFrontierHalfEdges = function(resultHedgesArray)
{
	if (this.facesArray === undefined)
	{ return resultHedgesArray; }
	
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }
	
	var facesCount = this.getFacesCount();
	var face;
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		resultHedgesArray = face.getFrontierHalfEdges(resultHedgesArray);
	}
	
	return resultHedgesArray;
};

Surface.prototype.getHalfEdges = function(resultHedgesArray)
{
	if (this.facesArray === undefined)
	{ return resultHedgesArray; }
	
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }
	
	var facesCount = this.getFacesCount();
	var face;
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		resultHedgesArray = face.getHalfEdgesLoop(resultHedgesArray);
	}
	
	return resultHedgesArray;
};

Surface.prototype.getCopyIndependentSurface = function(resultSurface)
{
	if (this.facesArray === undefined)
	{ return resultSurface; }
	
	if (resultSurface === undefined)
	{ resultSurface = new Surface(); }
	
	if (resultSurface.localVertexList === undefined)
	{ resultSurface.localVertexList = new VertexList(); }
	
	var resultLocalvertexList = resultSurface.localVertexList;
	
	// 1rst, copy the localVertexList.***
	var verticesArray = this.getNoRepeatedVerticesArray(undefined);
	var verticesCount = verticesArray.length;
	var vertex, vertexCopy;
	for (var i=0; i<verticesCount; i++)
	{
		vertex = verticesArray[i];
		vertex.setIdxInList(i); // set idxInList.***
		vertexCopy = resultLocalvertexList.newVertex();
		vertexCopy.copyFrom(vertex);
	}

	// now, copy the faces.***
	var face, faceCopy;
	var vertexIdxInList;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		faceCopy = resultSurface.newFace();
		faceCopy.vertexArray = [];
		
		verticesCount = face.getVerticesCount();
		for (var j=0; j<verticesCount; j++)
		{
			vertex = face.getVertex(j);
			vertexIdxInList = vertex.getIdxInList();
			faceCopy.vertexArray.push(resultLocalvertexList.getVertex(vertexIdxInList));
		}
		var halfEdgesArray = [];
		faceCopy.createHalfEdges(halfEdgesArray);
	}
	
	resultSurface.setTwinsFaces();
	
	return resultSurface;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
Surface.prototype.setTwinsFaces = function() 
{
	// this func set twins between all faces of this surface.***
	var facesCount = this.facesArray.length;
	var face, face2;
	
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		for (var j=0; j<facesCount; j++)
		{
			if (i !== j)
			{
				face2 = this.getFace(j);
				face.setTwinFace(face2);
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
Surface.prototype.getNoRepeatedVerticesArray = function(resultVerticesArray) 
{
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	// 1rst, assign vertex-IdxInList for all used vertices.***
	var facesCount = this.getFacesCount();
	var face;
	var idxAux = 0;
	var vtx;
	var verticesCount;
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		verticesCount = face.getVerticesCount();
		for (var j=0; j<verticesCount; j++)
		{
			vtx = face.getVertex(j);
			if (vtx === undefined)
			{ var hola = 0; }
			vtx.setIdxInList(idxAux);
			idxAux++;
		}
	}
	
	// now, make a map of unique vertices map using "idxInList" of vertices.***
	var verticesMap = {};
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		verticesCount = face.getVerticesCount();
		for (var j=0; j<verticesCount; j++)
		{
			vtx = face.getVertex(j);
			verticesMap[vtx.getIdxInList().toString()] = vtx;
		}
	}
	
	// finally make the unique vertices array.***
	var vertex;
	for (var key in verticesMap)
	{
		vertex = verticesMap[key];
		resultVerticesArray.push(vertex);
	}
	
	return resultVerticesArray;
};

Surface.prototype.getTrianglesConvex = function(resultTrianglesArray)
{
	// To call this method, the faces must be convex.***
	if (this.facesArray === undefined || this.facesArray.length ===0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		resultTrianglesArray = face.getTrianglesConvex(resultTrianglesArray);
	}
	
	return resultTrianglesArray;
};

Surface.prototype.calculateVerticesNormals = function()
{
	// PROVISIONAL.***
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		face.calculateVerticesNormals();
	}
};

Surface.prototype.reverseSense = function()
{
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		face.reverseSense();
	}
};



















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Tessellator
 */
var Tessellator = function() 
{
	if (!(this instanceof Tessellator)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

};






















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Triangle
 */
var Triangle= function(vertex0, vertex1, vertex2) 
{
	if (!(this instanceof Triangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertex0;
	this.vertex1;
	this.vertex2;
	this.vtxIdx0;
	this.vtxIdx1;
	this.vtxIdx2;
	this.normal; // plainNormal.
	
	if (vertex0 !== undefined)
	{ this.vertex0 = vertex0; }
	
	if (vertex1 !== undefined)
	{ this.vertex1 = vertex1; }
	
	if (vertex2 !== undefined)
	{ this.vertex2 = vertex2; }
	
	this.hEdge;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Triangle.prototype.deleteObjects = function() 
{
	// the triangle no deletes vertices.***
	if (this.vertex0)
	{
		this.vertex0 = undefined;
	}
	if (this.vertex1)
	{
		this.vertex1 = undefined;
	}
	if (this.vertex2)
	{
		this.vertex2 = undefined;
	}
	if (this.normal)
	{
		this.normal.deleteObjects();
		this.normal = undefined;
	}
	
	this.vtxIdx0 = undefined;
	this.vtxIdx1 = undefined;
	this.vtxIdx2 = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param vertex0 변수
 * @param vertex1 변수
 * @param vertex2 변수
 */
Triangle.prototype.setVertices = function(vertex0, vertex1, vertex2) 
{
	this.vertex0 = vertex0;
	this.vertex1 = vertex1;
	this.vertex2 = vertex2;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param vertex0 변수
 * @param vertex1 변수
 * @param vertex2 변수
 */
Triangle.prototype.assignVerticesIdx = function() 
{
	if (this.vertex0 === undefined || this.vertex1 === undefined || this.vertex2 === undefined)
	{ return; }
	
	this.vtxIdx0 = this.vertex0.getIdxInList();
	this.vtxIdx1 = this.vertex1.getIdxInList();
	this.vtxIdx2 = this.vertex2.getIdxInList();
};

Triangle.prototype.getIndicesArray = function(indicesArray)
{
	if (indicesArray === undefined)
	{ indicesArray = []; }
	
	if (this.vtxIdx0 !== undefined && this.vtxIdx1 !== undefined && this.vtxIdx2 !== undefined )
	{
		indicesArray.push(this.vtxIdx0);
		indicesArray.push(this.vtxIdx1);
		indicesArray.push(this.vtxIdx2);
	}
	
	return indicesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Triangle.prototype.invertSense = function() 
{
	var vertexAux = this.vertex1;
	this.vertex1 = this.vertex2;
	this.vertex2 = vertexAux;
	
	this.calculatePlaneNormal();
};

/**
 * 어떤 일을 하고 있습니까?
 */
Triangle.prototype.calculatePlaneNormal = function() 
{
	if (this.normal === undefined)
	{ this.normal = new Point3D(); }

	this.getCrossProduct(0, this.normal);
	this.normal.unitary();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idxVertex 변수
 * @param resultCrossProduct 변수
 * @returns resultCrossProduct
 */
Triangle.prototype.getCrossProduct = function(idxVertex, resultCrossProduct) 
{
	if (resultCrossProduct === undefined)
	{ resultCrossProduct = new Point3D(); }

	var currentPoint, prevPoint, nextPoint;

	if (idxVertex === 0)
	{
		currentPoint = this.vertex0.point3d;
		prevPoint = this.vertex2.point3d;
		nextPoint = this.vertex1.point3d;
	}
	else if (idxVertex === 1)
	{
		currentPoint = this.vertex1.point3d;
		prevPoint = this.vertex0.point3d;
		nextPoint = this.vertex2.point3d;
	}
	else if (idxVertex === 2)
	{
		currentPoint = this.vertex2.point3d;
		prevPoint = this.vertex1.point3d;
		nextPoint = this.vertex0.point3d;
	}

	var v1 = new Point3D();
	var v2 = new Point3D();

	v1.set(currentPoint.x - prevPoint.x,     currentPoint.y - prevPoint.y,     currentPoint.z - prevPoint.z);
	v2.set(nextPoint.x - currentPoint.x,     nextPoint.y - currentPoint.y,     nextPoint.z - currentPoint.z);

	v1.unitary();
	v2.unitary();

	resultCrossProduct = v1.crossProduct(v2, resultCrossProduct);

	return resultCrossProduct;
};
































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class TrianglesList
 */
var TrianglesList = function() 
{
	if (!(this instanceof TrianglesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.trianglesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.prototype.newTriangle = function(vertex0, vertex1, vertex2) 
{
	if (this.trianglesArray === undefined)
	{ this.trianglesArray = []; }
	
	var triangle = new Triangle(vertex0, vertex1, vertex2);
	this.trianglesArray.push(triangle);
	return triangle;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.prototype.addTriangle = function(triangle) 
{
	if (this.trianglesArray === undefined)
	{ this.trianglesArray = []; }

	this.trianglesArray.push(triangle);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.prototype.deleteObjects = function() 
{
	if (this.trianglesArray === undefined)
	{ return; }
	
	var trianglesCount = this.getTrianglesCount();
	for (var i=0; i<trianglesCount; i++)
	{
		this.trianglesArray[i].deleteObjects();
		this.trianglesArray[i] = undefined;
	}
	this.trianglesArray = undefined;
};

TrianglesList.prototype.getTrianglesCount = function() 
{
	if (this.trianglesArray === undefined)
	{ return 0; }
	
	return this.trianglesArray.length;
};

TrianglesList.prototype.getTriangle = function(idx) 
{
	if (this.trianglesArray === undefined)
	{ return undefined; }
	
	return this.trianglesArray[idx];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.prototype.assignVerticesIdx = function() 
{
	if (this.trianglesArray === undefined)
	{ return; }
	
	TrianglesList.assignVerticesIdx(this.trianglesArray);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.assignVerticesIdx = function(trianglesArray) 
{
	if (trianglesArray === undefined)
	{ return; }
	
	var trianglesCount = trianglesArray.length;
	var trianglesArray = trianglesArray;
	for (var i=0; i<trianglesCount; i++)
	{
		trianglesArray[i].assignVerticesIdx();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.getTrianglesIndicesArray = function(trianglesArray, indicesArray) 
{
	if (indicesArray === undefined)
	{ indicesArray = []; }
	
	var trianglesCount = trianglesArray.length;
	for (var i=0; i<trianglesCount; i++)
	{
		trianglesArray[i].getIndicesArray(indicesArray);
	}
	
	return indicesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.prototype.getNoRepeatedVerticesArray = function(resultVerticesArray) 
{
	resultVerticesArray = TrianglesList.getNoRepeatedVerticesArray(this.trianglesArray, resultVerticesArray);
	return resultVerticesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.getNoRepeatedVerticesArray = function(trianglesArray, resultVerticesArray) 
{
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	// 1rst, assign vertexIdxInList for all used vertives.***
	var trianglesCount = trianglesArray.length;
	var triangle;
	var idxAux = 0;
	var vtx_0, vtx_1, vtx_2;
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = trianglesArray[i];
		vtx_0 = triangle.vertex0;
		vtx_1 = triangle.vertex1;
		vtx_2 = triangle.vertex2;
		
		vtx_0.setIdxInList(idxAux);
		idxAux++;
		vtx_1.setIdxInList(idxAux);
		idxAux++;
		vtx_2.setIdxInList(idxAux);
		idxAux++;
	}
	
	// now, make a map of unique vertices map using "idxInList" of vertices.***
	var verticesMap = {};
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = trianglesArray[i];
		vtx_0 = triangle.vertex0;
		vtx_1 = triangle.vertex1;
		vtx_2 = triangle.vertex2;
		
		verticesMap[vtx_0.getIdxInList().toString()] = vtx_0;
		verticesMap[vtx_1.getIdxInList().toString()] = vtx_1;
		verticesMap[vtx_2.getIdxInList().toString()] = vtx_2;
	}
	
	// finally make the unique vertices array.***
	var vertex;
	for (var key in verticesMap)
	{
		vertex = verticesMap[key];
		resultVerticesArray.push(vertex);
	}
	
	return resultVerticesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesList.getVboFaceDataArray = function(trianglesArray, resultVbo) 
{
	// PROVISIONAL.***
	if (trianglesArray === undefined)
	{ return resultVbo; }
	
	var trianglesCount = trianglesArray.length;
	if (trianglesCount === 0)
	{ return resultVbo; }
	
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }

	var indicesArray = TrianglesList.getTrianglesIndicesArray(trianglesArray, undefined);
	resultVbo.idxVboDataArray = Int16Array.from(indicesArray);
	resultVbo.indicesCount = resultVbo.idxVboDataArray.length;
	return resultVbo;
};









































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class TrianglesMatrix
 */
var TrianglesMatrix= function() 
{
	if (!(this instanceof TrianglesMatrix)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.trianglesListsArray;
};

TrianglesMatrix.prototype.deleteObjects = function()
{
	if (this.trianglesListsArray === undefined)
	{ return; }
	
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		this.trianglesListsArray[i].deleteObjects();
		this.trianglesListsArray[i] = undefined;
	}
	this.trianglesListsArray = undefined;
};

TrianglesMatrix.prototype.getTrianglesList = function(idx)
{
	if (this.trianglesListsArray === undefined)
	{ return undefined; }
	
	return this.trianglesListsArray[idx];
};

TrianglesMatrix.prototype.getTrianglesListsCount = function()
{
	if (this.trianglesListsArray === undefined)
	{ return 0; }
	
	return this.trianglesListsArray.length;
};

TrianglesMatrix.prototype.newTrianglesList = function()
{
	if (this.trianglesListsArray === undefined)
	{ this.trianglesListsArray = []; }
	
	var trianglesList = new TrianglesList();
	this.trianglesListsArray.push(trianglesList);
	return trianglesList;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
TrianglesMatrix.prototype.assignVerticesIdx = function() 
{
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		this.trianglesListsArray[i].assignVerticesIdx();
	}
};

TrianglesMatrix.prototype.getVboFaceDataArray = function(resultVbo)
{
	// PROVISIONAL.***
	if (this.trianglesListsArray === undefined)
	{ return resultVbo; }
	
	var indicesArray = [];
	
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		indicesArray = this.trianglesListsArray[i].getTrianglesIndicesArray(indicesArray);
	}
	
	resultVbo.idxVboDataArray = Int16Array.from(indicesArray);
	resultVbo.indicesCount = resultVbo.idxVboDataArray.length;
	
	return resultVbo;
};





















































'use strict';

  
/**
 * 어떤 일을 하고 있습니까?
 * @class Vertex
 */
var Vertex = function(position) 
{
	if (!(this instanceof Vertex)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.point3d;
	this.normal; // class: Point3D.
	this.texCoord; // class: Point2D.
	this.color4; // class: Color.
	
	this.outingHedge; // class: HalfEdge
	//this.outingHalfEdgesArray; // Array [class: HalfEdge]. 
	this.vertexType; // 1 = important vertex.***
	this.idxInList; // auxiliar var.***
	
	if (position)
	{ this.point3d = position; }
	else
	{
		this.point3d = new Point3D();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Vertex.prototype.deleteObjects = function() 
{
	if (this.point3d)
	{ this.point3d.deleteObjects(); }
	if (this.normal)
	{ this.normal.deleteObjects(); }
	if (this.texCoord)
	{ this.texCoord.deleteObjects(); }
	if (this.color4)
	{ this.color4.deleteObjects(); }
	
	this.point3d = undefined;
	this.normal = undefined;
	this.texCoord = undefined;
	this.color4 = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Vertex.prototype.getIdxInList = function() 
{
	return this.idxInList;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Vertex.prototype.setIdxInList = function(idx) 
{
	this.idxInList = idx;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Vertex.prototype.copyFrom = function(vertex) 
{
	// copy position if exist.
	if (vertex.point3d)
	{
		if (this.point3d === undefined)
		{ this.point3d = new Point3D(); }
		
		this.point3d.copyFrom(vertex.point3d);
	}
	
	// copy normal if exist.
	if (vertex.normal)
	{
		if (this.normal === undefined)
		{ this.normal = new Point3D(); }
		
		this.normal.copyFrom(vertex.normal);
	}
	
	// copy texCoord if exist.
	if (vertex.texCoord)
	{
		if (this.texCoord === undefined)
		{ this.texCoord = new Point2D(); }
		
		this.texCoord.copyFrom(vertex.texCoord);
	}
	
	// copy color4 if exist.
	if (vertex.color4)
	{
		if (this.color4 === undefined)
		{ this.color4 = new Color(); }
		
		this.color4.copyFrom(vertex.color4);
	}
	
	this.vertexType = vertex.vertexType;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Vertex.prototype.setPosition = function(x, y, z) 
{
	this.point3d.set(x, y, z);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param r 변수
 * @param g 변수
 * @param b 변수
 */
Vertex.prototype.setColorRGB = function(r, g, b) 
{
	if (this.color4 === undefined) { this.color4 = new Color(); }
	
	this.color4.setRGB(r, g, b);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param r 변수
 * @param g 변수
 * @param b 변수
 * @param alpha 변수
 */
Vertex.prototype.setColorRGBA = function(r, g, b, alpha) 
{
	if (this.color4 === undefined) { this.color4 = new Color(); }
	
	this.color4.setRGBA(r, g, b, alpha);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param r 변수
 * @param g 변수
 * @param b 변수
 * @param alpha 변수
 */
Vertex.prototype.setNormal = function(nx, ny, nz) 
{
	if (this.normal === undefined) { this.normal = new Point3D(); }
	
	this.normal.set(nx, ny, nz);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param dirX 변수
 * @param dirY 변수
 * @param dirZ 변수
 * @param distance 변수
 */
Vertex.prototype.translate = function(dx, dy, dz) 
{
	this.point3d.add(dx, dy, dz);
};

















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VertexList
 */
var VertexList = function() 
{
	if (!(this instanceof VertexList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertexArray = [];
};

VertexList.getPrevIdx = function(idx, vertexArray)
{
	var verticesCount = vertexArray.length;
	
	if (idx < 0 || idx > verticesCount-1)
	{ return undefined; }
	
	var prevIdx;
	
	if (idx === 0)
	{ prevIdx = verticesCount - 1; }
	else
	{ prevIdx = idx - 1; }

	return prevIdx;
};

VertexList.getNextIdx = function(idx, vertexArray)
{
	var verticesCount = vertexArray.length;
	
	if (idx < 0 || idx > verticesCount-1)
	{ return undefined; }
	
	var nextIdx;
	
	if (idx === verticesCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	return nextIdx;
};

VertexList.getVtxSegment = function(idx, vertexArray, resultVtxSegment)
{
	var currVertex = vertexArray[idx];
	var nextIdx = VertexList.getNextIdx(idx, vertexArray);
	var nextVertex = vertexArray[nextIdx];
	
	if (resultVtxSegment === undefined)
	{ resultVtxSegment = new VtxSegment(currVertex, nextVertex); }
	else 
	{
		resultVtxSegment.setVertices(currVertex, nextVertex);
	}

	return resultVtxSegment;
};

VertexList.getVector = function(idx, vertexArray, resultVector)
{
	var currVertex = vertexArray[idx];
	var nextIdx = VertexList.getNextIdx(idx, vertexArray);
	var nextVertex = vertexArray[nextIdx];
	
	var currPoint = currVertex.point3d;
	var nextPoint = nextVertex.point3d;
	
	if (resultVector === undefined)
	{ resultVector = new Point3D(nextPoint.x - currPoint.x, nextPoint.y - currPoint.y, nextPoint.z - currPoint.z); }
	else 
	{
		resultVector.setVertices(nextPoint.x - currPoint.x, nextPoint.y - currPoint.y, nextPoint.z - currPoint.z);
	}

	return resultVector;
};

VertexList.getCrossProduct = function(idx, vertexArray, resultCrossProduct)
{
	var currVector = VertexList.getVector(idx, vertexArray, undefined);
	var prevIdx = VertexList.getPrevIdx(idx, vertexArray);
	var prevVector = VertexList.getVector(prevIdx, vertexArray, undefined);
	resultCrossProduct = prevVector.crossProduct(currVector, resultCrossProduct);

	return resultCrossProduct;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertex
 */
VertexList.prototype.deleteObjects = function() 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].deleteObjects();
		this.vertexArray[i] = undefined;
	}
	this.vertexArray = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertex
 */
VertexList.prototype.copyFrom = function(vertexList) 
{
	// first reset vertexArray.
	this.deleteObjects();
	this.vertexArray = [];
	
	var vertex;
	var myVertex;
	var vertexCount = vertexList.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = vertexList.getVertex(i);
		myVertex = this.newVertex();
		myVertex.copyFrom(vertex);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertex
 */
VertexList.prototype.copyFromPoint2DList = function(point2dList, z) 
{
	// first reset vertexArray.
	this.deleteObjects();
	this.vertexArray = [];
	
	var point2d;
	var vertex;
	if (z === undefined)
	{ z = 0; }

	var pointsCount = point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point2d = point2dList.getPoint(i);
		vertex = this.newVertex();
		vertex.point3d = new Point3D();
		vertex.point3d.set(point2d.x, point2d.y, z);
		vertex.vertexType = point2d.pointType;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertex
 */
VertexList.prototype.setNormal = function(nx, ny, nz) 
{
	var vertex;
	var vertexCount = this.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = this.getVertex(i);
		vertex.setNormal(nx, ny, nz);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertex
 */
VertexList.prototype.newVertex = function() 
{
	var vertex = new Vertex();
	this.vertexArray.push(vertex);
	return vertex;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexArray[idx]
 */
VertexList.prototype.getVertex = function(idx) 
{
	return this.vertexArray[idx];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexArray.length
 */
VertexList.prototype.getVertexCount = function() 
{
	return this.vertexArray.length;
};

VertexList.prototype.getPrevIdx = function(idx)
{
	return VertexList.getPrevIdx(idx, this.vertexArray);
};

VertexList.prototype.getNextIdx = function(idx)
{
	return VertexList.getNextIdx(idx, this.vertexArray);
};

VertexList.prototype.getIdxOfVertex = function(vertex)
{
	var verticesCount = this.vertexArray.length;
	var i=0;
	var idx = -1;
	var found = false;
	while (!found && i<verticesCount)
	{
		if (this.vertexArray[i] === vertex)
		{
			found = true;
			idx = i;
		}
		i++;
	}
	
	return idx;
};

VertexList.prototype.getVtxSegment = function(idx, resultVtxSegment)
{
	return VertexList.getVtxSegment(idx, this.vertexArray, resultVtxSegment);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param dirX 변수
 * @param dirY 변수
 * @param dirZ 변수
 * @param distance 변수
 */
VertexList.prototype.translateVertices = function(dx, dy, dz) 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].translate(dx, dy, dz);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param resultBox 변수
 * @returns resultBox
 */
VertexList.prototype.getBoundingBox = function(resultBox) 
{
	if (resultBox === undefined) { resultBox = new BoundingBox(); }

	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		if (i === 0) { resultBox.init(this.vertexArray[i].point3d); }
		else { resultBox.addPoint(this.vertexArray[i].point3d); }
	}
	return resultBox;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param transformMatrix 변수
 */
VertexList.prototype.transformPointsByMatrix4 = function(transformMatrix) 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		var vertex = this.vertexArray[i];
		transformMatrix.transformPoint3D(vertex.point3d, vertex.point3d);
	}
};

VertexList.prototype.setIdxInList = function()
{
	VertexList.setIdxInList(this.vertexArray);
	/*
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].idxInList = i;
	}
	*/
};

VertexList.setIdxInList = function(vertexArray)
{
	if (vertexArray === undefined)
	{ return; }
	
	for (var i = 0, vertexCount = vertexArray.length; i < vertexCount; i++) 
	{
		vertexArray[i].idxInList = i;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param transformMatrix 변수
 */
VertexList.prototype.getVboDataArrays = function(resultVbo) 
{
	VertexList.getVboDataArrays(this.vertexArray, resultVbo) ;
	return resultVbo;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param transformMatrix 변수
 */
VertexList.getVboDataArrays = function(vertexArray, resultVbo) 
{
	// returns positions, and if exist, normals, colors, texCoords.***
	var verticesCount = vertexArray.length;
	if (verticesCount === 0)
	{ return resultVbo; }
	
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	var posArray = [];
	var norArray;
	var colArray;
	var texCoordArray;
	
	var vertex, position, normal, color, texCoord;
	
	for (var i = 0; i < verticesCount; i++) 
	{
		vertex = vertexArray[i];
		if (vertex.point3d === undefined)
		{ continue; }
		
		position = vertex.point3d;
		posArray.push(position.x);
		posArray.push(position.y);
		posArray.push(position.z);
		
		normal = vertex.normal;
		if (normal)
		{
			if (norArray === undefined)
			{ norArray = []; }
			
			norArray.push(normal.x*127);
			norArray.push(normal.y*127);
			norArray.push(normal.z*127);
		}
		
		color = vertex.color4;
		if (color)
		{
			if (colArray === undefined)
			{ colArray = []; }
			
			colArray.push(color.r*255);
			colArray.push(color.g*255);
			colArray.push(color.b*255);
			colArray.push(color.a*255);
		}
		
		texCoord = vertex.texCoord;
		if (texCoord)
		{
			if (texCoordArray === undefined)
			{ texCoordArray = []; }
			
			texCoordArray.push(texCoord.x);
			texCoordArray.push(texCoord.y);
		}
	}
	
	resultVbo.posVboDataArray = Float32Array.from(posArray);
	if (normal)
	{ resultVbo.norVboDataArray = Int8Array.from(norArray); }
	
	if (color)
	{ resultVbo.colVboDataArray = Uint8Array.from(colArray); }
	
	if (texCoord)
	{ resultVbo.tcoordVboDataArray = Float32Array.from(texCoordArray); }
	
	return resultVbo;
};








































'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class VertexMatrix
 */
var VertexMatrix = function() 
{
	if (!(this instanceof VertexMatrix)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.vertexListsArray = [];
	// SCTRATXH.******************
	this.totalVertexArraySC = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
VertexMatrix.prototype.deleteObjects = function() 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		this.vertexListsArray[i].deleteObjects();
		this.vertexListsArray[i] = undefined;
	}
	this.vertexListsArray = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
VertexMatrix.prototype.newVertexList = function() 
{
	var vertexList = new VertexList();
	this.vertexListsArray.push(vertexList);
	return vertexList;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns vertexListArray[idx]
 */
VertexMatrix.prototype.getVertexList = function(idx) 
{
	if (idx >= 0 && idx < this.vertexListsArray.length) 
	{
		return this.vertexListsArray[idx];
	}
	else 
	{
		return undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param vertexMatrix 변수
 */
VertexMatrix.prototype.copyFrom = function(vertexMatrix) 
{
	if (vertexMatrix === undefined)
	{ return; }
	
	var vertexList, myVertexList;
	var vertexListsCount = vertexMatrix.vertexListsArray.length;
	for (var i=0; i<vertexListsCount; i++)
	{
		vertexList = vertexMatrix.getVertexList(i);
		myVertexList = this.newVertexList();
		myVertexList.copyFrom(vertexList);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param resultBox
 * @returns resultBox
 */
VertexMatrix.prototype.getBoundingBox = function(resultBox) 
{
	if (resultBox === undefined) { resultBox = new BoundingBox(); }
	
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	for (var i = 0, totalVertexCount = this.totalVertexArraySC.length; i < totalVertexCount; i++) 
	{
		if (i === 0) { resultBox.init(this.totalVertexArraySC[i].point3d); }
		else { resultBox.addPoint(this.totalVertexArraySC[i].point3d); }
	}
	return resultBox;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VertexMatrix.prototype.setVertexIdxInList = function() 
{
	var idxInList = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		for (var j = 0, vertexCount = vtxList.vertexArray.length; j < vertexCount; j++) 
		{
			var vertex = vtxList.getVertex(j);
			vertex.mIdxInList = idxInList;
			idxInList++;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexCount
 */
VertexMatrix.prototype.getVertexCount = function() 
{
	var vertexCount = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		vertexCount += this.vertexListsArray[i].getVertexCount();
	}
	
	return vertexCount;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param resultTotalVertexArray 변수
 * @returns resultTotalVertexArray
 */
VertexMatrix.prototype.getTotalVertexArray = function(resultTotalVertexArray) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		for (var j = 0, vertexCount = vtxList.vertexArray.length; j < vertexCount; j++) 
		{
			var vertex = vtxList.getVertex(j);
			resultTotalVertexArray.push(vertex);
		}
	}
	
	return resultTotalVertexArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param resultFloatArray 변수
 * @returns resultFloatArray
 */
VertexMatrix.prototype.getVBOVertexColorFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 6); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*6] = vertex.point3d.x;
		resultFloatArray[i*6+1] = vertex.point3d.y;
		resultFloatArray[i*6+2] = vertex.point3d.z;
		
		resultFloatArray[i*6+3] = vertex.color4.r;
		resultFloatArray[i*6+4] = vertex.color4.g;
		resultFloatArray[i*6+5] = vertex.color4.b;
	}
	
	return resultFloatArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param resultFloatArray 변수
 * @returns resultFloatArray
 */
VertexMatrix.prototype.getVBOVertexColorRGBAFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 7); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*7] = vertex.point3d.x;
		resultFloatArray[i*7+1] = vertex.point3d.y;
		resultFloatArray[i*7+2] = vertex.point3d.z;
		
		resultFloatArray[i*7+3] = vertex.color4.r;
		resultFloatArray[i*7+4] = vertex.color4.g;
		resultFloatArray[i*7+5] = vertex.color4.b;
		resultFloatArray[i*7+6] = vertex.color4.a;
	}
	
	return resultFloatArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param resultFloatArray 변수
 * @returns resultFloatArray
 */
VertexMatrix.prototype.getVBOVertexFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 3); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*3] = vertex.point3d.x;
		resultFloatArray[i*3+1] = vertex.point3d.y;
		resultFloatArray[i*3+2] = vertex.point3d.z;
	}
	
	return resultFloatArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param dirX 변수
 * @param dirY 변수
 * @param dirZ 변수
 * @param distance 변수
 */
VertexMatrix.prototype.translateVertices = function(dx, dy, dz) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		this.vertexListsArray[i].translateVertices(dx, dy, dz);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param tTrianglesMatrix 변수
 */
VertexMatrix.prototype.makeTTrianglesLateralSidesLOOP = function(tTrianglesMatrix) 
{
	// condition: all the vertex lists must have the same number of vertex.***
	var vtxList1;
	var vtxList2;
	var tTrianglesList;
	var tTriangle1;
	var tTriangle2;
	var vertexCount = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount-1; i++) 
	{
		vtxList1 = this.vertexListsArray[i];
		vtxList2 = this.vertexListsArray[i+1];
		tTrianglesList = tTrianglesMatrix.newTTrianglesList();
		
		vertexCount = vtxList1.vertexArray.length;
		for (var j = 0; j < vertexCount; j++) 
		{
			tTriangle1 = tTrianglesList.newTTriangle();
			tTriangle2 = tTrianglesList.newTTriangle();
			
			if (j === vertexCount-1) 
			{
				tTriangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(0)); 
				tTriangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(0), vtxList1.getVertex(0)); 
			}
			else 
			{
				tTriangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(j+1)); 
				tTriangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j+1), vtxList1.getVertex(j+1)); 
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param transformMatrix
 */
VertexMatrix.prototype.transformPointsByMatrix4 = function(transformMatrix) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		vtxList.transformPointsByMatrix4(transformMatrix);
	}
};


'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class VtxProfile
*/
var VtxProfile = function(x, y) 
{
	if (!(this instanceof VtxProfile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.outerVtxRing;
	this.innerVtxRingsList;
};

VtxProfile.prototype.getInnerVtxRingsCount = function()
{
	if (this.innerVtxRingsList === undefined || this.innerVtxRingsList.getRingsCount === 0)
	{ return 0; }
	
	return this.innerVtxRingsList.getVtxRingsCount();
};

VtxProfile.prototype.getInnerVtxRing = function(idx)
{
	if (this.innerVtxRingsList === undefined || this.innerVtxRingsList.getRingsCount === 0)
	{ return undefined; }
	
	return this.innerVtxRingsList.getVtxRing(idx);
};

VtxProfile.prototype.setVerticesIdxInList = function()
{
	if (this.outerVtxRing && this.outerVtxRing.vertexList)
	{
		this.outerVtxRing.vertexList.setIdxInList();
	}
	
	if (this.innerVtxRingsList)
	{
		this.innerVtxRingsList.setVerticesIdxInList();
	}
};

VtxProfile.prototype.copyFrom = function(vtxProfile)
{
	if (vtxProfile.outerVtxRing)
	{
		if (this.outerVtxRing === undefined)
		{ this.outerVtxRing = new VtxRing(); }
		
		this.outerVtxRing.copyFrom(vtxProfile.outerVtxRing);
	}
	
	if (vtxProfile.innerVtxRingsList)
	{
		if (this.innerVtxRingsList === undefined)
		{ this.innerVtxRingsList = new VtxRingsList(); }
		
		this.innerVtxRingsList.copyFrom(vtxProfile.innerVtxRingsList);
	}
};

VtxProfile.prototype.translate = function(dx, dy, dz)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.translate(dx, dy, dz); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.translate(dx, dy, dz); }
};

VtxProfile.prototype.transformPointsByMatrix4 = function(tMat4)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.transformPointsByMatrix4(tMat4); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.transformPointsByMatrix4(tMat4); }
};

VtxProfile.prototype.makeByProfile = function(profile)
{
	if (profile === undefined || profile.outerRing === undefined)
	{ return undefined; }
	
	var outerRing = profile.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	
	// outer.***************************************
	if (this.outerVtxRing === undefined)
	{ this.outerVtxRing = new VtxRing(); }
	
	var z = 0;
	var outerPolygon = outerRing.polygon;
	var point2dList = outerPolygon.point2dList;
	this.outerVtxRing.makeByPoint2DList(point2dList, z);

	// inners.***************************************
	if (profile.innerRingsList === undefined)
	{ return; } 
	
	var innerRingsList = profile.innerRingsList;
	var innerRingsCount = innerRingsList.getRingsCount();
	
	if (innerRingsCount === 0)
	{ return; }
	
	if (this.innerVtxRingsList === undefined)
	{ this.innerVtxRingsList = new VtxRingsList(); }
	
	var innerRing;
	var innerPolygon;
	var innerVtxRing;
	
	for (var i=0; i<innerRingsCount; i++)
	{
		innerRing = innerRingsList.getRing(i);
		if (innerRing.polygon === undefined)
		{ innerRing.makePolygon(); }
		innerPolygon = innerRing.polygon;
		point2dList = innerPolygon.point2dList;
		
		innerVtxRing = this.innerVtxRingsList.newVtxRing();
		innerVtxRing.makeByPoint2DList(point2dList, z);
	}
};

VtxProfile.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.getAllVertices(resultVerticesArray); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.getAllVertices(resultVerticesArray); }
	
	return resultVerticesArray;
};




















































'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class VtxProfilesList
*/
var VtxProfilesList = function(x, y) 
{
	if (!(this instanceof VtxProfilesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vtxProfilesArray;
	this.convexFacesIndicesData;
};

VtxProfilesList.getLateralFaces = function(bottomVtxRing, topVtxRing, resultFacesArray, resultMesh, elemIndexRange)
{
	// This returns a lateral surface between "bottomVtxRing" & "topVtxRing" limited by "elemIndexRange".***
	if (resultFacesArray === undefined)
	{ resultFacesArray = []; }
	
	if (resultMesh.hedgesList === undefined)
	{ resultMesh.hedgesList = new HalfEdgesList(); }
	
	var hedgesList = resultMesh.hedgesList;
	
	var strIdx, currIdx, endIdx, nextIdx;
	var vtx0, vtx1, vtx2, vtx3;
	var face, prevFace;
	var hedgesArray = [];
	currIdx = elemIndexRange.strIdx;
	while (currIdx !== elemIndexRange.endIdx)
	{
		nextIdx = bottomVtxRing.vertexList.getNextIdx(currIdx);
		
		face = new Face();
		resultFacesArray.push(face);
		face.vertexArray = [];
		
		vtx0 = bottomVtxRing.vertexList.getVertex(currIdx);
		vtx1 = bottomVtxRing.vertexList.getVertex(nextIdx);
		vtx2 = topVtxRing.vertexList.getVertex(nextIdx);
		vtx3 = topVtxRing.vertexList.getVertex(currIdx);
		Array.prototype.push.apply(face.vertexArray, [vtx0, vtx1, vtx2, vtx3]);
		
		// now create hedges of the face.***
		hedgesArray.length = 0;
		hedgesArray = face.createHalfEdges(hedgesArray);
		hedgesList.addHalfEdgesArray(hedgesArray);
		
		if (prevFace !== undefined)
		{
			// set twins between face and prevFace.***
			face.setTwinFace(prevFace);
		}
		prevFace = face;

		currIdx = nextIdx;
	}
	
	return resultFacesArray;
};

VtxProfilesList.prototype.newVtxProfile = function()
{
	if (this.vtxProfilesArray === undefined)
	{ this.vtxProfilesArray = []; }
	
	var vtxProfile = new VtxProfile();
	this.vtxProfilesArray.push(vtxProfile);
	return vtxProfile;
};

VtxProfilesList.prototype.getVtxProfilesCount = function()
{
	if (this.vtxProfilesArray === undefined)
	{ return 0; }
	
	return this.vtxProfilesArray.length;
};

VtxProfilesList.prototype.getVtxProfile = function(idx)
{
	if (this.vtxProfilesArray === undefined)
	{ return undefined; }
	
	return this.vtxProfilesArray[idx];
};

VtxProfilesList.prototype.getAllVertices = function(resultVerticesArray)
{
	// collect all vertices of all vtxProfiles.***
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	var vtxProfile;
	var vtxProfilesCount = this.getVtxProfilesCount();
	for (var i=0; i<vtxProfilesCount; i++)
	{
		vtxProfile = this.getVtxProfile(i);
		resultVerticesArray = vtxProfile.getAllVertices(resultVerticesArray);
	}
	
	return resultVerticesArray;
};

VtxProfilesList.prototype.getMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap)
{
	// face's vertex order.***
	// 3-------2
	// |       |
	// |       |
	// |       |
	// 0-------1
	
	if (this.vtxProfilesArray === undefined)
	{ return resultTriangleMatrix; }
	
	// outerLateral.***************************************************
	var vtxProfilesCount = this.getVtxProfilesCount();
	
	if (vtxProfilesCount < 2)
	{ return resultTriangleMatrix; }
	
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }
	
	if (resultMesh.vertexList === undefined)
	{ resultMesh.vertexList = new VertexList(); }
	
	// 1rst, get all vertices and put it into the resultMesh.***
	resultMesh.vertexList.vertexArray = this.getAllVertices(resultMesh.vertexList.vertexArray);
		
	var bottomVtxProfile, topVtxProfile;

	bottomVtxProfile = this.getVtxProfile(0);
	var outerVtxRing = bottomVtxProfile.outerVtxRing;
	var elemIndexRange;
	var bottomVtxRing, topVtxRing;
	var elemIndicesCount;
	var strIdx, currIdx, endIdx, nextIdx;
	var vtx0, vtx1, vtx2, vtx3;
	var face, surface;
	var k;
	var facesArray = [];
	var prevFacesArray;
	var elemsCount = outerVtxRing.elemsIndexRangesArray.length;
	
	for (var i=0; i<elemsCount; i++)
	{
		surface = resultMesh.newSurface();
		prevFacesArray = undefined;
		elemIndexRange = outerVtxRing.getElementIndexRange(i);
		for (var j=0; j<vtxProfilesCount-1; j++)
		{
			bottomVtxProfile = this.getVtxProfile(j);
			topVtxProfile = this.getVtxProfile(j+1);
			
			bottomVtxRing = bottomVtxProfile.outerVtxRing;
			topVtxRing = topVtxProfile.outerVtxRing;
			
			facesArray.length = 0;
			facesArray = VtxProfilesList.getLateralFaces(bottomVtxRing, topVtxRing, facesArray, resultMesh, elemIndexRange);
			surface.addFacesArray(facesArray);
			
			if (prevFacesArray !== undefined && prevFacesArray.length > 0)
			{
				// set twins between "prevFacesArray" & "facesArray".***
				var currFace, prevFace;
				var facesCount = facesArray.length;
				for (var k=0; k<facesCount; k++)
				{
					currFace = facesArray[k];
					prevFace = prevFacesArray[k];
					currFace.setTwinFace(prevFace);
				}
			}
			
			prevFacesArray = [];
			Array.prototype.push.apply(prevFacesArray, facesArray);
			
		}
	}
	
	// Inner laterals.************************************************************************
	var innerVtxRing;
	var innerRinsCount = bottomVtxProfile.getInnerVtxRingsCount();
	for (var k=0; k<innerRinsCount; k++)
	{
		innerVtxRing = bottomVtxProfile.getInnerVtxRing(k);
		elemsCount = innerVtxRing.elemsIndexRangesArray.length;
		for (var i=0; i<elemsCount; i++)
		{
			surface = resultMesh.newSurface();
			prevFacesArray = undefined;
			elemIndexRange = innerVtxRing.getElementIndexRange(i);
			for (var j=0; j<vtxProfilesCount-1; j++)
			{
				bottomVtxProfile = this.getVtxProfile(j);
				topVtxProfile = this.getVtxProfile(j+1);
				
				bottomVtxRing = bottomVtxProfile.getInnerVtxRing(k);
				topVtxRing = topVtxProfile.getInnerVtxRing(k);
				
				facesArray.length = 0;
				facesArray = VtxProfilesList.getLateralFaces(bottomVtxRing, topVtxRing, facesArray, resultMesh, elemIndexRange);
				surface.addFacesArray(facesArray);
				
				if (prevFacesArray !== undefined && prevFacesArray.length>0)
				{
					// set twins between "prevFacesArray" & "facesArray".***
					var currFace, prevFace;
					var facesCount = facesArray.length;
					for (var a=0; a<facesCount; a++)
					{
						currFace = facesArray[a];
						prevFace = prevFacesArray[a];
						currFace.setTwinFace(prevFace);
					}
				}
				
				prevFacesArray = [];
				Array.prototype.push.apply(prevFacesArray, facesArray);
				
			}
		}
	}
	
	// Caps (bottom and top).***
	if (this.convexFacesIndicesData === undefined)
	{ return resultMesh; }
	
	var resultSurface;
	
	// Top profile.***********************************************************************
	// in this case, there are a surface with multiple convex faces.***
	if (bIncludeTopCap === undefined || bIncludeTopCap === true)
	{
		topVtxProfile = this.getVtxProfile(vtxProfilesCount-1);
		resultSurface = resultMesh.newSurface();
		resultSurface = VtxProfilesList.getTransversalSurface(topVtxProfile, this.convexFacesIndicesData, resultSurface);
	}

	// Bottom profile.***********************************************************************
	if (bIncludeBottomCap === undefined || bIncludeBottomCap === true)
	{
		bottomVtxProfile = this.getVtxProfile(0);
		resultSurface = resultMesh.newSurface();
		resultSurface = VtxProfilesList.getTransversalSurface(bottomVtxProfile, this.convexFacesIndicesData, resultSurface);
		
		// in bottomSurface inverse sense of faces.***
		resultSurface.reverseSense();
	}
	
	return resultMesh;
};

VtxProfilesList.getTransversalSurface = function(vtxProfile, convexFacesIndicesData, resultSurface)
{
	if (resultSurface === undefined)
	{ resultSurface = new Surface(); }
	 
	var currRing;
	var currVtxRing;
	var faceIndicesData;
	var indexData;
	var ringIdx, vertexIdx;
	var indicesCount;
	var face;
	var vertex;
	var convexFacesCount = convexFacesIndicesData.length;
	for (var i=0; i<convexFacesCount; i++)
	{
		face = resultSurface.newFace();
		face.vertexArray = [];
			
		faceIndicesData = convexFacesIndicesData[i];
		indicesCount = faceIndicesData.length;
		for (var j=0; j<indicesCount; j++)
		{
			indexData = faceIndicesData[j];
			ringIdx = indexData.ownerIdx;
			vertexIdx = indexData.idxInList;
			
			if (ringIdx === -1)
			{
				// is the outerRing.***
				currVtxRing = vtxProfile.outerVtxRing;
			}
			else 
			{
				currVtxRing = vtxProfile.innerVtxRingsList.getVtxRing(ringIdx);
			}
			
			vertex = currVtxRing.vertexList.getVertex(vertexIdx);
			face.vertexArray.push(vertex);
		}
	}
	
	return resultSurface;
};
























































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VtxRing
 */
var VtxRing = function() 
{
	if (!(this instanceof VtxRing)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertexList;
	this.elemsIndexRangesArray; // [] array.***
};

VtxRing.prototype.newElementIndexRange = function()
{
	if (this.elemsIndexRangesArray === undefined)
	{ this.elemsIndexRangesArray = []; }
	
	var indexRange = new IndexRange();
	this.elemsIndexRangesArray.push(indexRange);
	return indexRange;
};

VtxRing.prototype.getElementIndexRange = function(idx)
{
	if (this.elemsIndexRangesArray === undefined)
	{ return undefined; }
	
	return this.elemsIndexRangesArray[idx];
};

VtxRing.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.vertexList === undefined || this.vertexList.vertexArray === undefined)
	{ return resultVerticesArray; }
	
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	resultVerticesArray.push.apply(resultVerticesArray, this.vertexList.vertexArray);
	
	return resultVerticesArray;
};

VtxRing.prototype.copyFrom = function(vtxRing)
{
	if (vtxRing.vertexList !== undefined)
	{
		if (this.vertexList === undefined)
		{ this.vertexList = new VertexList(); }
		
		this.vertexList.copyFrom(vtxRing.vertexList);
	}
	
	if (vtxRing.elemsIndexRangesArray !== undefined)
	{
		if (this.elemsIndexRangesArray === undefined)
		{ this.elemsIndexRangesArray = []; }
		
		var indexRange, myIndexRange;
		var indexRangesCount = vtxRing.elemsIndexRangesArray.length;
		for (var i=0; i<indexRangesCount; i++)
		{
			indexRange = vtxRing.elemsIndexRangesArray[i];
			myIndexRange = this.newElementIndexRange();
			myIndexRange.copyFrom(indexRange);
		}
	}
};

VtxRing.prototype.translate = function(x, y, z)
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.translateVertices(x, y, z);
	}
};

VtxRing.prototype.transformPointsByMatrix4 = function(tMat4)
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.transformPointsByMatrix4(tMat4);
	}
};

VtxRing.prototype.makeByPoint2DList = function(point2dList, z)
{
	if (point2dList === undefined)
	{ return; }
	
	if (z === undefined)
	{ z = 0; }
	
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }
	
	this.vertexList.copyFromPoint2DList(point2dList, z);
	this.calculateElementsIndicesRange();
};

VtxRing.prototype.calculateElementsIndicesRange = function()
{
	if (this.vertexList === undefined)
	{ return false; }
	
	var vertex;
	var idxRange = undefined;
	var vertexType;
	var vertexCount = this.vertexList.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = this.vertexList.getVertex(i);
		vertexType = vertex.vertexType;
		
		//if(vertexType === undefined && i===0)
		//{
		//	var prevIdx = this.vertexList.getPrevIdx(i);
		//	var prevVertex = this.vertexList.getVertex(prevIdx);
		//	vertexType = prevVertex.vertexType;
		//}
		
		if (vertexType && vertexType === 1)
		{
			if (idxRange !== undefined)
			{
				idxRange.endIdx = i;
			}
			if (i !== vertexCount)
			{
				idxRange = this.newElementIndexRange();
				idxRange.strIdx = i;
			}
		}
	}
	
	if (idxRange !== undefined)
	{ idxRange.endIdx = 0; }
};
















































'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class VtxRingsList
*/
var VtxRingsList = function() 
{
	if (!(this instanceof VtxRingsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vtxRingsArray;
};

VtxRingsList.prototype.getVtxRingsCount = function()
{
	if (this.vtxRingsArray === undefined)
	{ return 0; }
	
	return this.vtxRingsArray.length;
};

VtxRingsList.prototype.getVtxRing = function(idx)
{
	if (this.vtxRingsArray === undefined)
	{ return undefined; }
	
	return this.vtxRingsArray[idx];
};

VtxRingsList.prototype.newVtxRing = function()
{
	if (this.vtxRingsArray === undefined)
	{ this.vtxRingsArray = []; }
	
	var vtxRing = new VtxRing();
	this.vtxRingsArray.push(vtxRing);
	return vtxRing;
};

VtxRingsList.prototype.copyFrom = function(vtxRingsList)
{
	if (vtxRingsList === undefined)
	{ return; }
	
	if (this.vtxRingsArray === undefined)
	{ this.vtxRingsArray = []; }
	
	var vtxRing;
	var vtxRingsCount = vtxRingsList.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		vtxRing = this.newVtxRing();
		vtxRing.copyFrom(vtxRingsList.getVtxRing(i));
	}
};

VtxRingsList.prototype.translate = function(x, y, z)
{
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].translate(x, y, z);
	}
};

VtxRingsList.prototype.transformPointsByMatrix4 = function(tMat4)
{
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].transformPointsByMatrix4(tMat4);
	}
};

VtxRingsList.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.vtxRingsArray === undefined)
	{ return resultVerticesArray; }
	
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].getAllVertices(resultVerticesArray);
	}
	
	return resultVerticesArray;
};

VtxRingsList.prototype.setVerticesIdxInList = function()
{
	if (this.vtxRingsArray === undefined)
	{ return; }
	
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].setVerticesIdxInList();
	}
};



















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VtxSegment
 */
var VtxSegment = function(startVertex, endVertex) 
{
	if (!(this instanceof VtxSegment)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.startVertex;
	this.endVertex;
	
	if (startVertex)
	{ this.startVertex = startVertex; }
	
	if (endVertex)
	{ this.endVertex = endVertex; }
};

VtxSegment.prototype.setVertices = function(startVertex, endVertex)
{
	this.startVertex = startVertex;
	this.endVertex = endVertex;
};

VtxSegment.prototype.getDirection = function(resultDirection)
{
	// the direction is an unitary vector.***
	var resultDirection = this.getVector();
	
	if (resultDirection === undefined)
	{ return undefined; }
	
	resultDirection.unitary();
	return resultDirection;
};

VtxSegment.prototype.getVector = function(resultVector)
{
	if (this.startVertex === undefined || this.endVertex === undefined)
	{ return undefined; }
	
	var startPoint = this.startVertex.point3d;
	var endPoint = this.endVertex.point3d;
	
	if (startPoint === undefined || endPoint === undefined)
	{ return undefined; }
	
	resultVector = startPoint.getVectorToPoint(endPoint, resultVector);
	return resultVector;
};

VtxSegment.prototype.getLine = function(resultLine)
{
	if (resultLine === undefined)
	{ resultLine = new Line(); }
	
	var dir = this.getDirection(); // unitary direction.***
	var strPoint = this.startVertex.point3d;
	resultLine.setPointAndDir(strPoint.x, strPoint.y, strPoint.z, dir.x, dir.y, dir.z);
	return resultLine;
};

VtxSegment.prototype.getSquaredLength = function()
{
	return this.startVertex.point3d.squareDistToPoint(this.endVertex.point3d);
};

VtxSegment.prototype.getLength = function()
{
	return Math.sqrt(this.getSquaredLength());
};

VtxSegment.prototype.intersectionWithPoint = function(point, error)
{
	// check if the point intersects the vtxSegment's line.***
	var line = this.getLine();
	
	if (error === undefined)
	{ error = 10E-8; }
	
	if (!line.isCoincidentPoint(point, error))
	{ return Constant.INTERSECTION_OUTSIDE; } // no intersection.***
	
	//Constant.INTERSECTION_OUTSIDE = 0;
	//Constant.INTERSECTION_INTERSECT= 1;
	//Constant.INTERSECTION_INSIDE = 2;
	//Constant.INTERSECTION_POINT_A = 3;
	//Constant.INTERSECTION_POINT_B = 4;
	
	// now, check if is inside of the segment or if is coincident with any vertex of segment.***
	var distA = this.startVertex.point3d.distToPoint(point);
	var distB = this.endVertex.point3d.distToPoint(point);
	var distTotal = this.getLength();
	
	if (distA < error)
	{ return Constant.INTERSECTION_POINT_A; }
	
	if (distB < error)
	{ return Constant.INTERSECTION_POINT_B; }
	
	if (distA> distTotal || distB> distTotal)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	if (Math.abs(distA + distB - distTotal) < error)
	{ return Constant.INTERSECTION_INSIDE; }
	
};
















































'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class UniformMatrix4fvDataPair
 * @param gl 변수
 */
var UniformMatrix4fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformMatrix4fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.matrix4fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformMatrix4fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniformMatrix4fv(this.uniformLocation, false, this.matrix4fv);
};

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec2fvDataPair
 * @param gl 변수
 */
var UniformVec2fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec2fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec2fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec2fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform2fv(this.uniformLocation, this.vec2fv);
};

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec3fvDataPair
 * @param gl 변수
 */
var UniformVec3fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec3fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec3fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec3fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform3fv(this.uniformLocation, this.vec3fv);
};

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec4fvDataPair
 * @param gl 변수
 */
var UniformVec4fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec4fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec4fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec4fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform4fv(this.uniformLocation, this.vec4fv);
};

/**
 * 어떤 일을 하고 있습니까?
 * @class Uniform1fDataPair
 * @param gl 변수
 */
var Uniform1fDataPair = function(gl, uniformName) 
{
	if (!(this instanceof Uniform1fDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.floatValue; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Uniform1fDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform1f(this.uniformLocation, this.floatValue);
};


/**
 * 어떤 일을 하고 있습니까?
 * @class Uniform1iDataPair
 * @param gl 변수
 */
var Uniform1iDataPair = function(gl, uniformName) 
{
	if (!(this instanceof Uniform1iDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.intValue; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Uniform1iDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform1i(this.uniformLocation, this.intValue);
};



/**
 * 어떤 일을 하고 있습니까?
 * @class PostFxShader
 * @param gl 변수
 */
var PostFxShader = function(gl) 
{
	if (!(this instanceof PostFxShader)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name;
	this.attribLocationCacheObj = {};
	this.uniformsArrayGeneral = []; // this array has the same uniforms that "uniformsCacheObj".***
	this.uniformsMapGeneral = {}; // this object has the same uniforms that "uniformsArray".***
	
	this.uniformsArrayLocal = []; // this array has the same uniforms that "uniformsCacheObj".***
	this.uniformsMapLocal = {}; // this object has the same uniforms that "uniformsArray".***
	
	// shader program.***
	this.program;
	this.shader_vertex;
	this.shader_fragment;
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.bindUniformGenerals = function()
{
	if (this.uniformsArrayGeneral === undefined)
	{ return; }
	
	var uniformsDataPairsCount = this.uniformsArrayGeneral.length;
	for (var i=0; i<uniformsDataPairsCount; i++)
	{
		this.uniformsArrayGeneral[i].bindUniform();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.newUniformDataPair = function(uniformType, uniformName)
{
	var uniformDataPair;//
	if (uniformType === "Matrix4fv")
	{
		uniformDataPair = new UniformMatrix4fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec4fv")
	{
		uniformDataPair = new UniformVec4fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec3fv")
	{
		uniformDataPair = new UniformVec3fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec2fv")
	{
		uniformDataPair = new UniformVec2fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1f")
	{
		uniformDataPair = new Uniform1fDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1i")
	{
		uniformDataPair = new Uniform1iDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	
	return uniformDataPair;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.newUniformDataPairLocal = function(uniformType, uniformName)
{
	var uniformDataPair;//
	if (uniformType === "Matrix4fv")
	{
		uniformDataPair = new UniformMatrix4fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec4fv")
	{
		uniformDataPair = new UniformVec4fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec3fv")
	{
		uniformDataPair = new UniformVec3fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec2fv")
	{
		uniformDataPair = new UniformVec2fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1f")
	{
		uniformDataPair = new Uniform1fDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1i")
	{
		uniformDataPair = new Uniform1iDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	
	return uniformDataPair;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 */
PostFxShader.prototype.createUniformGenerals = function(gl, shader, sceneState)
{
	// Here create all generals uniforms, if exist, of the shader.***
	var uniformDataPair;
	var uniformLocation;

	// 1. ModelViewProjectionMatrixRelToEye.***
	uniformLocation = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvpMat4RelToEye");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewProjRelToEyeMatrix._floatArrays;
	}
	
	// 1. ModelViewProjectionMatrix.***
	uniformLocation = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvpMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewProjMatrix._floatArrays;
	}
	
	// 2. modelViewMatrixRelToEye.***
	uniformLocation = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvMat4RelToEye");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewRelToEyeMatrix._floatArrays;
	}
	
	// 3. modelViewMatrix.***
	uniformLocation = gl.getUniformLocation(shader.program, "modelViewMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "modelViewMatrix");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewRelToEyeMatrix._floatArrays;
	}
	
	// 4. projectionMatrix.***
	uniformLocation = gl.getUniformLocation(shader.program, "projectionMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "pMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.projectionMatrix._floatArrays;
	}
	
	// 5. normalMatrix4.***
	uniformLocation = gl.getUniformLocation(shader.program, "normalMatrix4");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "normalMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.normalMatrix4._floatArrays;
	}
	
	// 6. encodedCameraPositionMCHigh.***
	uniformLocation = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "encodedCamPosHigh");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.encodedCamPosHigh;
	}
	
	// 7. encodedCameraPositionMCLow.***
	uniformLocation = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "encodedCamPosLow");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.encodedCamPosLow;
	}
	
	// 8. frustumNear.***
	uniformLocation = gl.getUniformLocation(shader.program, "near");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "frustumNear");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.near;
	}
	
	// 9. frustumFar.***
	uniformLocation = gl.getUniformLocation(shader.program, "far");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "frustumFar");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.far;
	}
	
	// 10. fovy.***
	uniformLocation = gl.getUniformLocation(shader.program, "fov");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "fovyRad");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.fovyRad;
	}
	
	// 11. aspectRatio.***
	uniformLocation = gl.getUniformLocation(shader.program, "aspectRatio");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "aspectRatio");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.aspectRatio;
	}
	
	// 12. drawBuffWidht.***
	uniformLocation = gl.getUniformLocation(shader.program, "screenWidth");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "drawBuffWidht");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.drawingBufferWidth;
	}
	
	// 13. drawBuffHeight.***
	uniformLocation = gl.getUniformLocation(shader.program, "screenHeight");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "drawBuffHeight");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.drawingBufferHeight;
	}
	
	// 14. depthTex.***
	uniformLocation = gl.getUniformLocation(shader.program, "depthTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "depthTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 0;
	}
	
	// 15. noiseTex.***
	uniformLocation = gl.getUniformLocation(shader.program, "noiseTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "noiseTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 1;
	}
	
	// 16. diffuseTex.***
	uniformLocation = gl.getUniformLocation(shader.program, "diffuseTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "diffuseTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 2;
	}
	
	// 17. specularColor.***
	uniformLocation = gl.getUniformLocation(shader.program, "specularColor");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "specularColor");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.specularColor;
	}
	
	// 18. ssaoRadius.***
	uniformLocation = gl.getUniformLocation(shader.program, "radius");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "radius");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.ssaoRadius;
	}
	
	// 19. ambientReflectionCoef.***
	uniformLocation = gl.getUniformLocation(shader.program, "ambientReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "ambientReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.ambientReflectionCoef;
	}
	
	// 20. diffuseReflectionCoef.***
	uniformLocation = gl.getUniformLocation(shader.program, "diffuseReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "diffuseReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.diffuseReflectionCoef;
	}
	
	// 21. specularReflectionCoef.***
	uniformLocation = gl.getUniformLocation(shader.program, "specularReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "specularReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.specularReflectionCoef;
	}
	
	// 22. shininessValue.***
	uniformLocation = gl.getUniformLocation(shader.program, "shininessValue");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "shininessValue");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.shininessValue;
	}
	
	// 23. ssaoNoiseScale2.***
	uniformLocation = gl.getUniformLocation(shader.program, "noiseScale");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec2fv", "ssaoNoiseScale2");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec2fv = sceneState.ssaoNoiseScale2;
	}
	
	// 24. ssaoKernel16.***
	uniformLocation = gl.getUniformLocation(shader.program, "kernel");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "ssaoKernel16");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.ssaoKernel16;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 */
PostFxShader.prototype.createUniformLocals = function(gl, shader, sceneState)
{
	// Here create all local uniforms, if exist, of the shader.***
	var uniformDataPair;
	var uniformLocation;
	
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");
	
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");
	
	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	
	// Attributtes.****
	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.color4_loc = gl.getAttribLocation(shader.program, "color4");
	
	shader.bUse1Color_loc = gl.getUniformLocation(shader.program, "bUse1Color");
	shader.oneColor4_loc = gl.getUniformLocation(shader.program, "oneColor4");
	
	// compression data, for shaders with data compressed.***
	// compressionMaxPoint & compressionMinPoint: for refObjects, this is the octree's size.***
	shader.posDataByteSize_loc = gl.getUniformLocation(shader.program, "posDataByteSize");
	shader.texCoordByteSize_loc = gl.getUniformLocation(shader.program, "texCoordByteSize");
	shader.compressionMaxPoint_loc = gl.getUniformLocation(shader.program, "compressionMaxPoint");
	shader.compressionMinPoint_loc = gl.getUniformLocation(shader.program, "compressionMinPoint");
	
	shader.bApplySpecularLighting_loc = gl.getUniformLocation(shader.program, "bApplySpecularLighting");
};

//*********************************************************************************************************************

/**
 * 어떤 일을 하고 있습니까?
 * @class PostFxShadersManager
 */
var PostFxShadersManager = function() 
{
	if (!(this instanceof PostFxShadersManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl;
	this.pFx_shaders_array = []; // old.***
	this.shadersMap = {};
	
	// preCreated shaders.***
	this.modelRefShader;
	this.modelRefSilhouetteShader;
	this.lodBuildingShader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShadersManager.prototype.newShader = function(shaderName)
{
	var shader = new PostFxShader(this.gl);
	shader.name = shaderName;
	this.shadersMap[shaderName] = shader;
	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param source 변수
 * @param type 변수
 * @param typeString 변수
 * @returns shader
 */
PostFxShadersManager.prototype.getShader = function(shaderName) 
{
	return this.shadersMap[shaderName];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param source 변수
 * @param type 변수
 * @param typeString 변수
 * @returns shader
 */
PostFxShadersManager.prototype.createShader = function(gl, source, type, typeString) 
{
	// Source from internet.***
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
	{
		alert("ERROR IN "+typeString+ " SHADER : " + gl.getShaderInfoLog(shader));
		return false;
	}
	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createDefaultShaders = function(gl, sceneState) 
{
	this.createRenderDepthShader(gl); // 0.***
	this.createSsaoShader(gl); // 1.***
	this.createBlurShader(gl); // 2.***

	// Now, create shaders for modelReference geometries.****
	this.createRenderDepthShaderModelRef(gl); // 3.***
	this.modelRefShader = this.createSsaoShaderModelRef(gl); // 4.***
	//this.createBlurShader_ModelRef(gl); // 5.***

	this.createColorSelectionShaderModelRef(gl);// 5.***
	this.createSimpleDepthShaderModelRef(gl);// 6.***

	this.createRenderDepthShaderLODBuilding(gl);// 7.***
	this.lodBuildingShader = this.createSsaoShaderLODBuilding(gl);// 8.***

	this.createRenderDepthShaderLego(gl);// 9.***
	this.createSsaoShaderLego(gl);// 10.***

	this.triPolyhedronDepthShader = this.createDepthShaderBox(gl); // 11.***
	this.triPolyhedronShader = this.createSsaoShaderBox(gl); // 12.***

	this.createPngImageShader(gl); // 13.***
	this.modelRefSilhouetteShader = this.createSilhouetteShaderModelRef(gl); // 14.***
	
	this.invertedBoxShader = this.createInvertedBoxShader(gl); // TEST.***
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getModelRefShader = function() 
{
	return this.modelRefShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getModelRefSilhouetteShader = function() 
{
	return this.modelRefSilhouetteShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getTriPolyhedronDepthShader = function() 
{
	return this.triPolyhedronDepthShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getTriPolyhedronShader = function() 
{
	return this.triPolyhedronShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getInvertedBoxShader = function() 
{
	return this.invertedBoxShader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createBlurShader = function(gl) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var blur_vs_source = ShaderSource.BlurVS;
	var blur_fs_source = ShaderSource.BlurFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, blur_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, blur_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.texCoord = gl.getAttribLocation(shader.program, "texCoord");

	shader.texelSize_loc = gl.getUniformLocation(shader.program, "texelSize");
	shader.colorTex_loc = gl.getUniformLocation(shader.program, "colorTex");
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSsaoShader = function(gl) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.SsaoVS;
	var ssao_fs_source = ShaderSource.SsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4");
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	shader.attribLocationCacheObj.texCoord = gl.getAttribLocation(shader.program, "texCoord");
	// ssao uniforms.**********************************************************************
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.***
	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov");
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio");

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth");
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight");

	// uniform samplers.***
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex");
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createRenderDepthShader = function(gl) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var showDepth_vs_source = ShaderSource.ShowDepthVS;
	var showDepth_fs_source = ShaderSource.ShowDepthFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, showDepth_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, showDepth_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");

	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
};

// Ref Model.***********************************************************************************************************************
// Ref Model.***********************************************************************************************************************
// Ref Model.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSsaoShaderModelRef = function(gl) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(undefined); // old.***

	var ssao_vs_source = ShaderSource.ModelRefSsaoVS;
	var ssao_fs_source = ShaderSource.ModelRefSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh"); // sceneState.***
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow"); // sceneState.***
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye"); // sceneState.***
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye"); // sceneState.***
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4"); // sceneState.***
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix"); // sceneState.***
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.texCoord = gl.getAttribLocation(shader.program, "texCoord");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	//*********************************************************************************
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.**********************************************************************
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.***
	shader.near_loc = gl.getUniformLocation(shader.program, "near"); // sceneState.***
	shader.far_loc = gl.getUniformLocation(shader.program, "far"); // sceneState.***
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov"); // sceneState.***
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio"); // sceneState.***

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth"); // sceneState.***
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight"); // sceneState.***
	
	shader.shininessValue_loc = gl.getUniformLocation(shader.program, "shininessValue");

	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");

	// uniform samplers.***
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex"); // no used.***
	
	// lighting.
	shader.specularColor_loc = gl.getUniformLocation(shader.program, "specularColor");
	shader.ssaoRadius_loc = gl.getUniformLocation(shader.program, "radius");  

	shader.ambientReflectionCoef_loc = gl.getUniformLocation(shader.program, "ambientReflectionCoef");
	shader.diffuseReflectionCoef_loc = gl.getUniformLocation(shader.program, "diffuseReflectionCoef");
	shader.specularReflectionCoef_loc = gl.getUniformLocation(shader.program, "specularReflectionCoef");
	
	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createRenderDepthShaderModelRef = function(gl, sceneState) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var showDepth_vs_source = ShaderSource.RenderShowDepthVS;
	var showDepth_fs_source = ShaderSource.RenderShowDepthFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, showDepth_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, showDepth_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
};

// Selection shader.***********************************************************************************************************************
// Selection shader.***********************************************************************************************************************
// Selection shader.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createColorSelectionShaderModelRef = function(gl) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.ColorSelectionSsaoVS;
	var ssao_fs_source = ShaderSource.ColorSelectionSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");

	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
};

// SimpleDepth shader.***********************************************************************************************************************
// SimpleDepth shader.***********************************************************************************************************************
// SimpleDepth shader.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSimpleDepthShaderModelRef = function(gl) 
{
	// no used.!!!!!!!!!!!!!!!
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.SimpleDepthSsaoVS;
	var ssao_fs_source = ShaderSource.SimpleDepthSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");

	//shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
};

// LOD 2 Building Shader.***********************************************************************************************************************
// LOD 2 Building Shader.***********************************************************************************************************************
// LOD 2 Building Shader.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSsaoShaderLODBuilding = function(gl) 
{
	// 8.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.LodBuildingSsaoVS;
	var ssao_fs_source = ShaderSource.LodBuildingSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4");
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.bUse1Color_loc = gl.getUniformLocation(shader.program, "bUse1Color");
	shader.oneColor4_loc = gl.getUniformLocation(shader.program, "oneColor4");
	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.color4_loc = gl.getAttribLocation(shader.program, "color4");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	shader.attribLocationCacheObj.color4 = gl.getAttribLocation(shader.program, "color4");

	//*********************************************************************************
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.**********************************************************************
	shader.shininessValue_loc = gl.getUniformLocation(shader.program, "shininessValue");
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.***
	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov");
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio");

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth");
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight");

	//shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.specularColor_loc = gl.getUniformLocation(shader.program, "specularColor");

	// uniform samplers.***
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex");

	// ModelReference.****
	shader.useRefTransfMatrix_loc = gl.getUniformLocation(shader.program, "useRefTransfMatrix");
	shader.useTexture_loc = gl.getUniformLocation(shader.program, "useTexture");
	shader.invertNormals_loc  = gl.getUniformLocation(shader.program, "invertNormals");
	shader.ssaoRadius_loc = gl.getUniformLocation(shader.program, "radius"); 
	
	shader.ambientReflectionCoef_loc = gl.getUniformLocation(shader.program, "ambientReflectionCoef");
	shader.diffuseReflectionCoef_loc = gl.getUniformLocation(shader.program, "diffuseReflectionCoef");
	shader.specularReflectionCoef_loc = gl.getUniformLocation(shader.program, "specularReflectionCoef");
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createRenderDepthShaderLODBuilding = function(gl) 
{
	// 7.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var showDepth_vs_source = ShaderSource.LodBuildingDepthVS;
	var showDepth_fs_source = ShaderSource.LodBuildingDepthFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, showDepth_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, showDepth_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
};

// Lego Shader.***********************************************************************************************************************
// Lego Shader.***********************************************************************************************************************
// Lego Shader.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSsaoShaderLego = function(gl) 
{
	// 10.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.LegoSsaoVS;
	var ssao_fs_source = ShaderSource.LegoSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4");
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	//shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.color4_loc = gl.getAttribLocation(shader.program, "color4");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	shader.attribLocationCacheObj.color4 = gl.getAttribLocation(shader.program, "color4");

	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.**********************************************************************
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.***
	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov");
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio");

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth");
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight");

	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");

	// uniform samplers.***
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex");

	// ModelReference.****
	shader.useRefTransfMatrix_loc = gl.getUniformLocation(shader.program, "useRefTransfMatrix");
	shader.useTexture_loc = gl.getUniformLocation(shader.program, "useTexture");
	shader.invertNormals_loc  = gl.getUniformLocation(shader.program, "invertNormals");
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createRenderDepthShaderLego = function(gl) 
{
	// 9.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var showDepth_vs_source = ShaderSource.LegoDepthVS;
	var showDepth_fs_source = ShaderSource.LegoDepthFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, showDepth_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, showDepth_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
};





/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createRenderDepthShaderLODBuilding = function(gl) 
{
	// 7.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var showDepth_vs_source = ShaderSource.LodBuildingDepthVS;
	var showDepth_fs_source = ShaderSource.LodBuildingDepthFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, showDepth_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, showDepth_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
};

// box depth Shader.***********************************************************************************************************************
// box depth Shader.***********************************************************************************************************************
// box depth Shader.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createDepthShaderBox = function(gl) 
{
	// 7.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var showDepth_vs_source = ShaderSource.BoxDepthVS;
	var showDepth_fs_source = ShaderSource.BoxDepthFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, showDepth_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, showDepth_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
	
	return shader;
};

// box Shader.***********************************************************************************************************************
// box Shader.***********************************************************************************************************************
// box Shader.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSsaoShaderBox = function(gl) 
{
	// 8.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.BoxSsaoVS;
	var ssao_fs_source = ShaderSource.BoxSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4");
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	//shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.bUse1Color_loc = gl.getUniformLocation(shader.program, "bUse1Color");
	shader.bApplySsao_loc = gl.getUniformLocation(shader.program, "bApplySsao");
	shader.oneColor4_loc = gl.getUniformLocation(shader.program, "oneColor4");
	shader.bUseNormal_loc = gl.getUniformLocation(shader.program, "bUseNormal");
	shader.bScale_loc = gl.getUniformLocation(shader.program, "bScale");
	shader.scale_loc = gl.getUniformLocation(shader.program, "scale");


	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	//shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.color4_loc = gl.getAttribLocation(shader.program, "color4");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	shader.attribLocationCacheObj.color4 = gl.getAttribLocation(shader.program, "color4");

	//*********************************************************************************
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.**********************************************************************
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.***
	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov");
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio");

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth");
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight");

	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");

	// uniform samplers.***
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex");

	// ModelReference.****
	shader.useRefTransfMatrix_loc = gl.getUniformLocation(shader.program, "useRefTransfMatrix");
	shader.useTexture_loc = gl.getUniformLocation(shader.program, "useTexture");
	shader.invertNormals_loc  = gl.getUniformLocation(shader.program, "invertNormals");
	
	return shader;
};

// PNG images shader.**************************************************************************************************
// PNG images shader.**************************************************************************************************
// PNG images shader.**************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createPngImageShader = function(gl) 
{
	// 13.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.PngImageVS;
	var ssao_fs_source = ShaderSource.PngImageFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.texture_loc = gl.getUniformLocation(shader.program, "u_texture"); 
	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	
	shader.position3_loc = gl.getAttribLocation(shader.program, "a_position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "a_texcoord");
	
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");
	
};

// 14) Silhouette shader.***********************************************************************************************************************
// 14) Silhouette shader.***********************************************************************************************************************
// 14) Silhouette shader.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSilhouetteShaderModelRef = function(gl) 
{
	// 14.***
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(undefined);

	var ssao_vs_source = ShaderSource.SilhouetteVS;
	var ssao_fs_source = ShaderSource.SilhouetteFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");

	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.camSpacePixelTranslation_loc = gl.getUniformLocation(shader.program, "camSpacePixelTranslation");
	shader.screenSize_loc = gl.getUniformLocation(shader.program, "screenSize");
	shader.ProjectionMatrix_loc = gl.getUniformLocation(shader.program, "ProjectionMatrix");
	shader.ModelViewMatrixRelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewMatrixRelToEye");
	
	return shader;
};

// InvertedBox.***********************************************************************************************************************
// InvertedBox.***********************************************************************************************************************
// InvertedBox.***********************************************************************************************************************
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createInvertedBoxShader = function(gl) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(undefined); // old.***

	var ssao_vs_source = ShaderSource.InvertedBoxVS;
	var ssao_fs_source = ShaderSource.InvertedBoxFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh"); // sceneState.***
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow"); // sceneState.***
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye"); // sceneState.***
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye"); // sceneState.***
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4"); // sceneState.***
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix"); // sceneState.***
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.texCoord = gl.getAttribLocation(shader.program, "texCoord");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	//*********************************************************************************
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.**********************************************************************
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.***
	shader.near_loc = gl.getUniformLocation(shader.program, "near"); // sceneState.***
	shader.far_loc = gl.getUniformLocation(shader.program, "far"); // sceneState.***
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov"); // sceneState.***
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio"); // sceneState.***

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth"); // sceneState.***
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight"); // sceneState.***
	
	shader.shininessValue_loc = gl.getUniformLocation(shader.program, "shininessValue");

	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");

	// uniform samplers.***
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex"); 
	
	// lighting.
	shader.specularColor_loc = gl.getUniformLocation(shader.program, "specularColor");
	shader.ssaoRadius_loc = gl.getUniformLocation(shader.program, "radius");  

	shader.ambientReflectionCoef_loc = gl.getUniformLocation(shader.program, "ambientReflectionCoef");
	shader.diffuseReflectionCoef_loc = gl.getUniformLocation(shader.program, "diffuseReflectionCoef");
	shader.specularReflectionCoef_loc = gl.getUniformLocation(shader.program, "specularReflectionCoef");
	
	return shader;
};















'use strict';

// An basic example.***********************************************************
/*
	var shader_vertex_source="\n\
		attribute vec3 position;\n\
		uniform mat4 Pmatrix;\n\
		uniform mat4 Vmatrix;\n\
		uniform mat4 Mmatrix;\n\
		attribute vec3 color; //the color of the point\n\
		varying vec3 vColor;\n\
		void main(void) { //pre-built function\n\
		gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);\n\
		vColor=color;\n\
		}";

	var shader_fragment_source="\n\
		precision mediump float;\n\
		varying vec3 vColor;\n\
		void main(void) {\n\
		gl_FragColor = vec4(vColor, 1.);\n\
		}";
		*/
// End example.-----------------------------------------------------------------

// http://learningwebgl.com/blog/?p=507
/*
		http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/ // GPU RTE HighValue-LowValue
		uniform vec3 uViewerHigh;
		uniform vec3 uViewerLow;

		void main(void)
		{
			vec3 highDifference = vec3(gl_Vertex.xyz - uViewerHigh);
			vec3 lowDifference = vec3(gl_Normal.xyz - uViewerLow);
			gl_Position = gl_ModelViewProjectionMatrix *
				 vec4(highDifference + lowDifference, 1.0);
		}
		//-----------------------------------------------
		void CDoubleToTwoFloats::Convert(double doubleValue,
		float&amp; floatHigh, float&amp; floatLow)
		{
			if (doubleValue &gt;= 0.0)
			{
				double doubleHigh = floor(doubleValue / 65536.0) * 65536.0;
				floatHigh = (float)doubleHigh;
				floatLow = (float)(doubleValue - doubleHigh);
			}
			else
			{
				double doubleHigh = floor(-doubleValue / 65536.0) * 65536.0;
				floatHigh = (float)-doubleHigh;
				floatLow = (float)(doubleValue + doubleHigh);
			}
		}
		//-----------------------------------------------
		*/
/*
		vec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n\
		{\n\
			vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n\
			vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\
		\n\
			return vec4(highDifference + lowDifference, 1.0);\n\
		}\n\
		*/

/**
 * 조명 입력 및 재질 구성을 기반으로 렌더링 된 각 픽셀의 색상을 계산하기위한 수학적 계산 및 알고리즘을 포함하는 작은 스크립트
 * @class Shader
 */
var Shader = function() 
{
	if (!(this instanceof Shader)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.shader_name;
	this.shader_vertex_source;
	this.shader_fragment_source;
	this.SHADER_PROGRAM;

	this.shader_vertex;
	this.shader_fragment;

	this._ModelViewProjectionMatrixRelToEye;
	this._RefTransfMatrix;
	this._NormalMatrix;

	this._encodedCamPosHIGH;
	this._encodedCamPosLOW;
	this._BuildingPosHIGH;
	this._BuildingPosLOW;
	this._lightDirection;

	this._color;
	this._position;
	this._texcoord;
	this._normal;

	// test.***
	this.samplerUniform;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class ShadersManager
 */
var ShadersManager = function() 
{
	if (!(this instanceof ShadersManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.shaders_array = [];

	// Create shaders to render F4D_Format.**********************
	// 1) Standard shader, that can render light mapping.***
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx = 변수
 * returns shader
 */
ShadersManager.prototype.getMagoShader = function(idx) 
{
	var shader;

	if (idx >= 0 && idx < this.shaders_array.length) 
	{
		shader = this.shaders_array[idx];
	}

	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.getShader = function(gl, source, type, typeString) 
{
	// Source from internet.***
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
	{
		alert("ERROR IN "+typeString+ " SHADER : " + gl.getShaderInfoLog(shader));
		return false;
	}
	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createDefaultShader = function(gl) 
{
	this.createStandardShader(gl);                // 0.***
	this.createTextureSimpleObjectShader(gl);     // 1.***
	this.createColorSelectionShader(gl);          // 2.***
	this.createTextureSimpleObjectA1Shader(gl);   // 3.***
	this.createCloudShader(gl);                   // 4.***
	this.createBlendingCubeShader(gl);            // 5.***
	this.createPCloudShader(gl);                  // 6.***
	this.createSimpleObjectTexNormalShader(gl); // 7.***
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createColorSelectionShader = function(gl) 
{
	var shader = new Shader();
	this.shaders_array.push(shader);

	shader.shader_vertex_source = ShaderSource.ColorVS;
	//http://www.lighthouse3d.com/tutorials/opengl-selection-tutorial/

	shader.shader_fragment_source = ShaderSource.ColorFS;

	// https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf
	shader.SHADER_PROGRAM = gl.createProgram();
	shader.shader_vertex = this.getShader(gl, shader.shader_vertex_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.getShader(gl, shader.shader_fragment_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.SHADER_PROGRAM, shader.shader_vertex);
	gl.attachShader(shader.SHADER_PROGRAM, shader.shader_fragment);
	gl.linkProgram(shader.SHADER_PROGRAM);

	shader._ModelViewProjectionMatrixRelToEye = gl.getUniformLocation(shader.SHADER_PROGRAM, "ModelViewProjectionMatrixRelToEye");
	shader._encodedCamPosHIGH = gl.getUniformLocation(shader.SHADER_PROGRAM, "encodedCameraPositionMCHigh");
	shader._encodedCamPosLOW = gl.getUniformLocation(shader.SHADER_PROGRAM, "encodedCameraPositionMCLow");
	shader._BuildingPosHIGH = gl.getUniformLocation(shader.SHADER_PROGRAM, "buildingPosHIGH");
	shader._BuildingPosLOW = gl.getUniformLocation(shader.SHADER_PROGRAM, "buildingPosLOW");
	shader._RefTransfMatrix = gl.getUniformLocation(shader.SHADER_PROGRAM, "RefTransfMatrix");

	shader._position = gl.getAttribLocation(shader.SHADER_PROGRAM, "position");
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createTextureSimpleObjectShader = function(gl) 
{
	var shader = new Shader();
	this.shaders_array.push(shader);

	shader.shader_vertex_source = ShaderSource.TextureVS;
	shader.shader_fragment_source = ShaderSource.TextureFS;

	//http://learningwebgl.com/blog/?p=507
	//https://gist.github.com/elnaqah/5070979
	shader.SHADER_PROGRAM = gl.createProgram();
	shader.shader_vertex = this.getShader(gl, shader.shader_vertex_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.getShader(gl, shader.shader_fragment_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.SHADER_PROGRAM, shader.shader_vertex);
	gl.attachShader(shader.SHADER_PROGRAM, shader.shader_fragment);
	gl.linkProgram(shader.SHADER_PROGRAM);

	shader._encodedCamPosHIGH = gl.getUniformLocation(shader.SHADER_PROGRAM, "encodedCameraPositionMCHigh");
	shader._encodedCamPosLOW = gl.getUniformLocation(shader.SHADER_PROGRAM, "encodedCameraPositionMCLow");
	shader._BuildingPosHIGH = gl.getUniformLocation(shader.SHADER_PROGRAM, "buildingPosHIGH");
	shader._BuildingPosLOW = gl.getUniformLocation(shader.SHADER_PROGRAM, "buildingPosLOW");
	shader._Mmatrix = gl.getUniformLocation(shader.SHADER_PROGRAM, "Mmatrix");
	shader._ModelViewProjectionMatrixRelToEye = gl.getUniformLocation(shader.SHADER_PROGRAM, "ModelViewProjectionMatrixRelToEye");
	shader.SHADER_PROGRAM.samplerUniform = gl.getUniformLocation(shader.SHADER_PROGRAM, "uSampler");

	shader._position = gl.getAttribLocation(shader.SHADER_PROGRAM, "position");
	shader._texcoord = gl.getAttribLocation(shader.SHADER_PROGRAM, "aTextureCoord");
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createTextureSimpleObjectA1Shader = function(gl) 
{
	var shader = new Shader();
	this.shaders_array.push(shader);

	shader.shader_vertex_source = ShaderSource.TextureA1VS;
	shader.shader_fragment_source = ShaderSource.TextureA1FS;

	//http://learningwebgl.com/blog/?p=507
	//https://gist.github.com/elnaqah/5070979
	shader.SHADER_PROGRAM = gl.createProgram();
	shader.shader_vertex = this.getShader(gl, shader.shader_vertex_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.getShader(gl, shader.shader_fragment_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.SHADER_PROGRAM, shader.shader_vertex);
	gl.attachShader(shader.SHADER_PROGRAM, shader.shader_fragment);
	gl.linkProgram(shader.SHADER_PROGRAM);

	shader._encodedCamPosHIGH = gl.getUniformLocation(shader.SHADER_PROGRAM, "encodedCameraPositionMCHigh");
	shader._encodedCamPosLOW = gl.getUniformLocation(shader.SHADER_PROGRAM, "encodedCameraPositionMCLow");
	shader._BuildingPosHIGH = gl.getUniformLocation(shader.SHADER_PROGRAM, "buildingPosHIGH");
	shader._BuildingPosLOW = gl.getUniformLocation(shader.SHADER_PROGRAM, "buildingPosLOW");
	shader._ModelViewProjectionMatrixRelToEye = gl.getUniformLocation(shader.SHADER_PROGRAM, "ModelViewProjectionMatrixRelToEye");
	shader.SHADER_PROGRAM.samplerUniform = gl.getUniformLocation(shader.SHADER_PROGRAM, "uSampler");

	shader._position = gl.getAttribLocation(shader.SHADER_PROGRAM, "position");
	shader._texcoord = gl.getAttribLocation(shader.SHADER_PROGRAM, "aTextureCoord");
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createStandardShader = function(gl) 
{
	// This shader renders the normal f4d geometry.***
	var standard_shader = new Shader();
	this.shaders_array.push(standard_shader);

	standard_shader.shader_vertex_source = ShaderSource.StandardVS;
	standard_shader.shader_fragment_source = ShaderSource.StandardFS;

	// Default ShaderProgram.********************************************************************
	standard_shader.SHADER_PROGRAM = gl.createProgram();
	standard_shader.shader_vertex = this.getShader(gl, standard_shader.shader_vertex_source, gl.VERTEX_SHADER, "VERTEX");
	standard_shader.shader_fragment = this.getShader(gl, standard_shader.shader_fragment_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(standard_shader.SHADER_PROGRAM, standard_shader.shader_vertex);
	gl.attachShader(standard_shader.SHADER_PROGRAM, standard_shader.shader_fragment);
	gl.linkProgram(standard_shader.SHADER_PROGRAM);

	standard_shader._ModelViewProjectionMatrixRelToEye = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "ModelViewProjectionMatrixRelToEye");
	standard_shader._RefTransfMatrix = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "RefTransfMatrix");
	standard_shader._encodedCamPosHIGH = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "encodedCameraPositionMCHigh");
	standard_shader._encodedCamPosLOW = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "encodedCameraPositionMCLow");
	standard_shader._BuildingPosHIGH = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "buildingPosHIGH");
	standard_shader._BuildingPosLOW = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "buildingPosLOW");

	standard_shader._color = gl.getAttribLocation(standard_shader.SHADER_PROGRAM, "color");
	standard_shader._position = gl.getAttribLocation(standard_shader.SHADER_PROGRAM, "position");
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createCloudShader = function(gl) 
{
	// This shader renders the f4d clouds.***
	var standard_shader = new Shader();
	this.shaders_array.push(standard_shader);

	standard_shader.shader_vertex_source = ShaderSource.CloudVS;
	standard_shader.shader_fragment_source = ShaderSource.CloudFS;

	// Default ShaderProgram.********************************************************************
	standard_shader.SHADER_PROGRAM = gl.createProgram();
	standard_shader.shader_vertex = this.getShader(gl, standard_shader.shader_vertex_source, gl.VERTEX_SHADER, "VERTEX");
	standard_shader.shader_fragment = this.getShader(gl, standard_shader.shader_fragment_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(standard_shader.SHADER_PROGRAM, standard_shader.shader_vertex);
	gl.attachShader(standard_shader.SHADER_PROGRAM, standard_shader.shader_fragment);
	gl.linkProgram(standard_shader.SHADER_PROGRAM);

	standard_shader._ModelViewProjectionMatrixRelToEye = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "ModelViewProjectionMatrixRelToEye");
	standard_shader._encodedCamPosHIGH = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "encodedCameraPositionMCHigh");
	standard_shader._encodedCamPosLOW = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "encodedCameraPositionMCLow");
	standard_shader._cloudPosHIGH = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "cloudPosHIGH");
	standard_shader._cloudPosLOW = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "cloudPosLOW");

	standard_shader._color = gl.getAttribLocation(standard_shader.SHADER_PROGRAM, "color");
	standard_shader._position = gl.getAttribLocation(standard_shader.SHADER_PROGRAM, "position");
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createBlendingCubeShader = function(gl) 
{
	// This shader renders the f4d clouds.***
	var standard_shader = new Shader();
	this.shaders_array.push(standard_shader);

	standard_shader.shader_vertex_source = ShaderSource.BlendingCubeVS;
	standard_shader.shader_fragment_source = ShaderSource.BlendingCubeFS;

	// Default ShaderProgram.********************************************************************
	standard_shader.SHADER_PROGRAM = gl.createProgram();
	standard_shader.shader_vertex = this.getShader(gl, standard_shader.shader_vertex_source, gl.VERTEX_SHADER, "VERTEX");
	standard_shader.shader_fragment = this.getShader(gl, standard_shader.shader_fragment_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(standard_shader.SHADER_PROGRAM, standard_shader.shader_vertex);
	gl.attachShader(standard_shader.SHADER_PROGRAM, standard_shader.shader_fragment);
	gl.linkProgram(standard_shader.SHADER_PROGRAM);

	standard_shader._ModelViewProjectionMatrixRelToEye = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "ModelViewProjectionMatrixRelToEye");
	standard_shader._encodedCamPosHIGH = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "encodedCameraPositionMCHigh");
	standard_shader._encodedCamPosLOW = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "encodedCameraPositionMCLow");

	standard_shader._color = gl.getAttribLocation(standard_shader.SHADER_PROGRAM, "color");
	standard_shader._position = gl.getAttribLocation(standard_shader.SHADER_PROGRAM, "position");
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createPCloudShader = function(gl) 
{
	// This shader renders the f4d clouds.***
	var standard_shader = new Shader();
	this.shaders_array.push(standard_shader);

	standard_shader.shader_vertex_source = ShaderSource.PointCloudVS;
	standard_shader.shader_fragment_source = ShaderSource.PointCloudFS;

	// Default ShaderProgram.********************************************************************
	standard_shader.SHADER_PROGRAM = gl.createProgram();
	standard_shader.shader_vertex = this.getShader(gl, standard_shader.shader_vertex_source, gl.VERTEX_SHADER, "VERTEX");
	standard_shader.shader_fragment = this.getShader(gl, standard_shader.shader_fragment_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(standard_shader.SHADER_PROGRAM, standard_shader.shader_vertex);
	gl.attachShader(standard_shader.SHADER_PROGRAM, standard_shader.shader_fragment);
	gl.linkProgram(standard_shader.SHADER_PROGRAM);

	standard_shader._ModelViewProjectionMatrixRelToEye = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "ModelViewProjectionMatrixRelToEye");
	standard_shader._encodedCamPosHIGH = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "encodedCameraPositionMCHigh");
	standard_shader._encodedCamPosLOW = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "encodedCameraPositionMCLow");
	standard_shader._BuildingPosHIGH = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "buildingPosHIGH");
	standard_shader._BuildingPosLOW = gl.getUniformLocation(standard_shader.SHADER_PROGRAM, "buildingPosLOW");

	standard_shader._color = gl.getAttribLocation(standard_shader.SHADER_PROGRAM, "color");
	standard_shader._position = gl.getAttribLocation(standard_shader.SHADER_PROGRAM, "position");
};

/**
 * 어떤 일을 하고 있습니까?
 */
ShadersManager.prototype.createSimpleObjectTexNormalShader = function(gl) 
{
	var shader = new Shader();
	this.shaders_array.push(shader);
	shader.shader_vertex_source = ShaderSource.TextureNormalVS;
	shader.shader_fragment_source = ShaderSource.TextureNormalFS;

	//http://learningwebgl.com/blog/?p=507
	//https://gist.github.com/elnaqah/5070979
	//https://dannywoodz.wordpress.com/2014/12/14/webgl-from-scratch-directional-lighting-part-1/
	//http://learningwebgl.com/blog/?p=684 // good.***
	shader.SHADER_PROGRAM = gl.createProgram();
	shader.shader_vertex = this.getShader(gl, shader.shader_vertex_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.getShader(gl, shader.shader_fragment_source, gl.FRAGMENT_SHADER, "FRAGMENT");
	gl.attachShader(shader.SHADER_PROGRAM, shader.shader_vertex);
	gl.attachShader(shader.SHADER_PROGRAM, shader.shader_fragment);
	gl.linkProgram(shader.SHADER_PROGRAM);

	shader._encodedCamPosHIGH = gl.getUniformLocation(shader.SHADER_PROGRAM, "encodedCameraPositionMCHigh");
	shader._encodedCamPosLOW = gl.getUniformLocation(shader.SHADER_PROGRAM, "encodedCameraPositionMCLow");
	shader._BuildingPosHIGH = gl.getUniformLocation(shader.SHADER_PROGRAM, "buildingPosHIGH");
	shader._BuildingPosLOW = gl.getUniformLocation(shader.SHADER_PROGRAM, "buildingPosLOW");

	shader._ModelViewProjectionMatrixRelToEye = gl.getUniformLocation(shader.SHADER_PROGRAM, "ModelViewProjectionMatrixRelToEye");
	shader._NormalMatrix = gl.getUniformLocation(shader.SHADER_PROGRAM, "uNMatrix");

	//shader.SHADER_PROGRAM.samplerUniform = gl.getUniformLocation(shader.SHADER_PROGRAM, "uSampler");
	shader.samplerUniform = gl.getUniformLocation(shader.SHADER_PROGRAM, "uSampler");
	shader._lightDirection = gl.getUniformLocation(shader.SHADER_PROGRAM, "uLightingDirection");

	shader._position = gl.getAttribLocation(shader.SHADER_PROGRAM, "position");
	shader._texcoord = gl.getAttribLocation(shader.SHADER_PROGRAM, "aTextureCoord");
	shader._normal = gl.getAttribLocation(shader.SHADER_PROGRAM, "aVertexNormal");
};

//# sourceURL=Shader.js

'use strict';
var ShaderSource = {};
ShaderSource.BlendingCubeFS = "	precision lowp float;\n\
	varying vec4 vColor;\n\
\n\
	void main()\n\
    {\n\
		gl_FragColor = vColor;\n\
	}";
ShaderSource.BlendingCubeVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
attribute vec4 color;\n\
varying vec4 vColor;\n\
\n\
void main()\n\
{\n\
    vec3 highDifference = -encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = position.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(position.xyz, 1.0);\n\
\n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.BlurFS = "#ifdef GL_ES\n\
    precision highp float;\n\
    #endif\n\
uniform sampler2D colorTex;\n\
uniform vec2 texelSize;\n\
varying vec2 vTexCoord; 	 	\n\
\n\
void main()\n\
{\n\
    vec3 result = vec3(0.0);\n\
    for (int i = 0; i < 4; ++i) {\n\
        for (int j = 0; j < 4; ++j) {\n\
            vec2 offset = vec2(texelSize.x * float(j), texelSize.y * float(i));\n\
            result += texture2D(colorTex, vTexCoord + offset).rgb;\n\
        }\n\
    }\n\
            \n\
    gl_FragColor.rgb = vec3(result * 0.0625); \n\
    gl_FragColor.a = 1.0;\n\
}\n\
";
ShaderSource.BlurVS = "attribute vec4 position;\n\
attribute vec2 texCoord;\n\
\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 modelViewMatrix;  \n\
\n\
varying vec2 vTexCoord;\n\
\n\
void main()\n\
{	\n\
    vTexCoord = texCoord;\n\
    \n\
    gl_Position = projectionMatrix * modelViewMatrix * position;\n\
}\n\
";
ShaderSource.BoxDepthFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying float depth;  \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}\n\
\n\
void main()\n\
{     \n\
    gl_FragData[0] = packDepth(-depth);\n\
}\n\
";
ShaderSource.BoxDepthVS = "attribute vec3 position;\n\
\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform vec3 aditionalPosition;\n\
\n\
varying float depth;  \n\
void main()\n\
{	\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    //linear depth in camera space (0..far)\n\
    depth = (modelViewMatrixRelToEye * pos4).z/far;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.BoxSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
uniform bool bUseNormal;\n\
uniform bool bApplySsao;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
const int kernelSize = 16;  \n\
const float radius = 0.5;      \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{                          \n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{ \n\
	vec4 textureColor;\n\
	textureColor = vcolor4;  \n\
	if(bUseNormal)\n\
    {\n\
		if(bApplySsao)\n\
		{\n\
			vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
			float linearDepth = getDepth(screenPos);          \n\
			vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
			vec3 normal2 = vNormal;   \n\
					\n\
			vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
			vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
			vec3 bitangent = cross(normal2, tangent);\n\
			mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
			\n\
			float occlusion = 0.0;\n\
			for(int i = 0; i < kernelSize; ++i)\n\
			{    	 \n\
				vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
				vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
				offset.xy /= offset.w;\n\
				offset.xy = offset.xy * 0.5 + 0.5;        \n\
				float sampleDepth = -sample.z/far;\n\
				float depthBufferValue = getDepth(offset.xy);				              \n\
				float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
				if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
				{\n\
					occlusion +=  1.0;\n\
				}\n\
				\n\
			}   \n\
				\n\
			occlusion = 1.0 - occlusion / float(kernelSize);\n\
										\n\
			vec3 lightPos = vec3(10.0, 10.0, 10.0);\n\
			vec3 L = normalize(lightPos);\n\
			float DiffuseFactor = dot(normal2, L);\n\
			float NdotL = abs(DiffuseFactor);\n\
			vec3 diffuse = vec3(NdotL);\n\
			vec3 ambient = vec3(1.0);\n\
			gl_FragColor.rgb = vec3((textureColor.xyz)*vLightWeighting * occlusion); \n\
			gl_FragColor.a = 1.0; \n\
		}\n\
		else{\n\
			gl_FragColor.rgb = vec3((textureColor.xyz)*vLightWeighting); \n\
			gl_FragColor.a = 1.0; \n\
		}\n\
	}\n\
	else\n\
	{\n\
		gl_FragColor.rgb = vec3(textureColor.xyz); \n\
		gl_FragColor.a = 1.0; \n\
	}	\n\
}\n\
";
ShaderSource.BoxSsaoVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool bUseNormal;\n\
uniform vec3 scale;\n\
uniform bool bScale;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;  \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
void main()\n\
{	\n\
    vec4 position2 = vec4(position.xyz, 1.0);\n\
    if(bScale)\n\
    {\n\
        position2.x *= scale.x;\n\
        position2.y *= scale.y;\n\
        position2.z *= scale.z;\n\
    }\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position2.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    if(bUseNormal)\n\
    {\n\
		vec4 rotatedNormal = buildingRotMatrix * vec4(normal.xyz, 1.0);\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8, 0.8, 0.8);\n\
		vec3 uLightingDirection = vec3(0.5, 0.5, 0.5);\n\
		vec3 directionalLightColor = vec3(0.6, 0.6, 0.6);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
	}\n\
    if(bUse1Color)\n\
    {\n\
        vcolor4 = oneColor4;\n\
    }\n\
    else\n\
    {\n\
        vcolor4 = color4;\n\
    }\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.CloudFS = "precision lowp float;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = vec4(vColor, 1.);\n\
}";
ShaderSource.CloudVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 cloudPosHIGH;\n\
uniform vec3 cloudPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
attribute vec3 color;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = cloudPosHIGH;\n\
    vec3 objPosLow = cloudPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.ColorFS = "precision mediump float;\n\
uniform int byteColor_r;\n\
uniform int byteColor_g;\n\
uniform int byteColor_b;\n\
\n\
void main()\n\
{\n\
    float byteMaxValue = 255.0;\n\
\n\
    gl_FragColor = vec4(float(byteColor_r)/byteMaxValue, float(byteColor_g)/byteMaxValue, float(byteColor_b)/byteMaxValue, 1);\n\
}\n\
";
ShaderSource.ColorSelectionSsaoFS = "precision highp float;\n\
uniform vec4 vColor4Aux;\n\
\n\
void main()\n\
{          \n\
    gl_FragColor = vColor4Aux;\n\
}\n\
";
ShaderSource.ColorSelectionSsaoVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 RefTransfMatrix;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos;\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    gl_PointSize = 10.0;\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.ColorVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform mat4 RefTransfMatrix;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}\n\
";
ShaderSource.InvertedBoxFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
    vec3 normal2 = vNormal;\n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
		if(sampleDepth > 0.49)\n\
			continue;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
\n\
    vec3 lightPos = vec3(20.0, 60.0, 20.0);\n\
    vec3 L = normalize(lightPos - vertexPos);\n\
    float lambertian = max(dot(normal2, L), 0.0);\n\
    float specular = 0.0;\n\
    if(lambertian > 0.0)\n\
    {\n\
        vec3 R = reflect(-L, normal2);      // Reflected light vector\n\
        vec3 V = normalize(-vertexPos); // Vector to viewer\n\
        \n\
        // Compute the specular term\n\
        float specAngle = max(dot(R, V), 0.0);\n\
        specular = pow(specAngle, shininessValue);\n\
    }\n\
	\n\
	if(lambertian < 0.5)\n\
    {\n\
		lambertian = 0.5;\n\
	}\n\
\n\
    vec4 textureColor;\n\
    if(hasTexture)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else{\n\
        textureColor = vColor4Aux;\n\
    }\n\
	\n\
	vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
\n\
    gl_FragColor = vec4((ambientReflectionCoef * ambientColor + diffuseReflectionCoef * lambertian * textureColor.xyz + specularReflectionCoef * specular * specularColor)*vLightWeighting * occlusion, 1.0); \n\
}\n\
";
ShaderSource.InvertedBoxVS = "	attribute vec3 position;\n\
	attribute vec3 normal;\n\
	attribute vec2 texCoord;\n\
	\n\
	uniform mat4 buildingRotMatrix; \n\
	uniform mat4 projectionMatrix;  \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 modelViewMatrixRelToEye; \n\
	uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
	uniform mat4 RefTransfMatrix;\n\
	uniform mat4 normalMatrix4;\n\
	uniform vec3 buildingPosHIGH;\n\
	uniform vec3 buildingPosLOW;\n\
	uniform vec3 encodedCameraPositionMCHigh;\n\
	uniform vec3 encodedCameraPositionMCLow;\n\
	uniform vec3 aditionalPosition;\n\
	uniform vec3 refTranslationVec;\n\
	uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
	varying vec3 vNormal;\n\
	varying vec2 vTexCoord;  \n\
	varying vec3 uAmbientColor;\n\
	varying vec3 vLightWeighting;\n\
	varying vec3 vertexPos;\n\
	\n\
	void main()\n\
    {	\n\
		vec4 rotatedPos;\n\
		mat3 currentTMat;\n\
		if(refMatrixType == 0)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 1)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 2)\n\
		{\n\
			rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(RefTransfMatrix);\n\
		}\n\
\n\
		vec3 objPosHigh = buildingPosHIGH;\n\
		vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
		vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
		vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
		vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
		vertexPos = vec3(modelViewMatrixRelToEye * pos4);\n\
		vec3 rotatedNormal = currentTMat * normal;\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8);\n\
		vec3 uLightingDirection = vec3(0.6, 0.6, 0.6);\n\
		vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		vTexCoord = texCoord;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
\n\
        gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	}\n\
";
ShaderSource.LegoDepthFS = "#ifdef GL_ES\n\
precision highp float;\n\
#endif\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying float depth;  \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}\n\
\n\
void main()\n\
{     \n\
    gl_FragData[0] = packDepth(-depth);\n\
}\n\
";
ShaderSource.LegoDepthVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec2 texCoord;\n\
\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 RefTransfMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform vec3 aditionalPosition;\n\
\n\
varying float depth;  \n\
void main()\n\
{	\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    depth = (modelViewMatrixRelToEye * pos4).z/far;\n\
    \n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.LegoSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
const int kernelSize = 16;  \n\
const float radius = 0.5;      \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{                          \n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
    vec3 normal2 = vNormal;   \n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
        \n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
                                \n\
    vec3 lightPos = vec3(10.0, 10.0, 10.0);\n\
    vec3 L = normalize(lightPos);\n\
    float DiffuseFactor = dot(normal2, L);\n\
    float NdotL = abs(DiffuseFactor);\n\
    vec3 diffuse = vec3(NdotL);\n\
    vec3 ambient = vec3(1.0);\n\
    vec4 textureColor;\n\
    textureColor = vcolor4;\n\
\n\
    gl_FragColor.rgb = vec3((textureColor.xyz)*vLightWeighting * occlusion); \n\
    gl_FragColor.a = 1.0;   \n\
}\n\
";
ShaderSource.LegoSsaoVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
attribute vec2 texCoord;\n\
\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 RefTransfMatrix;\n\
uniform mat4 normalMatrix4;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;  \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
void main()\n\
{	\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    vec3 rotatedNormal = mat3(RefTransfMatrix) * normal;\n\
    vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
    uAmbientColor = vec3(0.8, 0.8, 0.8);\n\
    vec3 uLightingDirection = vec3(0.5, 0.5, 0.5);\n\
    vec3 directionalLightColor = vec3(0.6, 0.6, 0.6);\n\
    vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
\n\
    float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
    vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
    vcolor4 = color4;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.LodBuildingDepthFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
varying float depth;  \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}\n\
\n\
void main()\n\
{     \n\
    gl_FragData[0] = packDepth(-depth);\n\
}\n\
";
ShaderSource.LodBuildingDepthVS = "attribute vec3 position;\n\
\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform vec3 aditionalPosition;\n\
\n\
varying float depth;  \n\
void main()\n\
{	\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
        \n\
    depth = (modelViewMatrixRelToEye * pos4).z/far;\n\
    \n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.LodBuildingSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;   \n\
uniform float shininessValue; \n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
uniform bool bApplyScpecularLighting;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
varying float applySpecLighting;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;    \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef;  \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{                          \n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
    vec3 normal2 = vNormal;   \n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
		if(sampleDepth > 0.49)\n\
			continue;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
        \n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
\n\
	float lambertian;\n\
	float specular;\n\
    if(applySpecLighting > 0.0)\n\
	{\n\
		vec3 lightPos = vec3(20.0, 60.0, 20.0);\n\
		vec3 L = normalize(lightPos - vertexPos);\n\
		lambertian = max(dot(normal2, L), 0.0);\n\
		specular = 0.0;\n\
		if(lambertian > 0.0)\n\
		{\n\
			vec3 R = reflect(-L, normal2);      // Reflected light vector\n\
			vec3 V = normalize(-vertexPos); // Vector to viewer\n\
			\n\
			// Compute the specular term\n\
			float specAngle = max(dot(R, V), 0.0);\n\
			specular = pow(specAngle, shininessValue);\n\
		}\n\
		\n\
		if(lambertian < 0.5)\n\
		{\n\
			lambertian = 0.5;\n\
		}\n\
	}\n\
\n\
    vec4 textureColor;\n\
    if(hasTexture)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else{\n\
        textureColor = vcolor4;\n\
    }\n\
	\n\
	vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
	vec4 finalColor;\n\
	if(applySpecLighting > 0.0)\n\
	{\n\
		finalColor = vec4((ambientReflectionCoef * ambientColor + diffuseReflectionCoef * lambertian * textureColor.xyz + specularReflectionCoef * specular * specularColor)*vLightWeighting * occlusion, 1.0); \n\
	}\n\
	else{\n\
		finalColor = vec4((textureColor.xyz) * occlusion, 1.0);\n\
	}\n\
    gl_FragColor = finalColor; \n\
}\n\
";
ShaderSource.LodBuildingSsaoSimpleCompressFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;   \n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec4 vcolor4;\n\
uniform vec3 specularColor;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;     \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{                          \n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
    vec3 normal2 = vNormal;   \n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
		if(sampleDepth > 0.49)\n\
			continue;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
\n\
    vec4 textureColor;\n\
    if(hasTexture)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else{\n\
        textureColor = vcolor4;\n\
    }\n\
\n\
    gl_FragColor = vec4((textureColor.xyz) * occlusion, 1.0); \n\
}\n\
";
ShaderSource.LodBuildingSsaoSimpleCompressVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
attribute vec2 texCoord;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool hasTexture;\n\
\n\
uniform int posDataByteSize;\n\
uniform int texCoordByteSize;\n\
uniform vec3 compressionMaxPoint;\n\
uniform vec3 compressionMinPoint;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
void main()\n\
{	\n\
    vec3 finalPos;\n\
	vec2 finalTexCoord;\n\
	if(posDataByteSize == 2)\n\
	{\n\
		// Decompress the position.*** \n\
		float rangeX = compressionMaxPoint.x - compressionMinPoint.x;\n\
		float rangeY = compressionMaxPoint.y - compressionMinPoint.y;\n\
		float rangeZ = compressionMaxPoint.z - compressionMinPoint.z;\n\
		float shortMax = 65535.0;\n\
		finalPos.x = (float(position.x) * rangeX / shortMax) + compressionMinPoint.x;\n\
		finalPos.y = (float(position.y) * rangeY / shortMax) + compressionMinPoint.y;\n\
		finalPos.z = (float(position.z) * rangeZ / shortMax) + compressionMinPoint.z;\n\
	}\n\
	else{\n\
		finalPos = position;\n\
	}\n\
	vec4 rotatedPos = buildingRotMatrix * vec4(finalPos.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    vec4 rotatedNormal = buildingRotMatrix * vec4(normal.xyz, 1.0);\n\
    vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
\n\
    if(bUse1Color)\n\
    {\n\
        vcolor4 = oneColor4;\n\
    }\n\
    else\n\
    {\n\
        vcolor4 = color4;\n\
    }\n\
	\n\
    if(texCoordByteSize == 2)\n\
	{\n\
		// Decompress the texCoord.***\n\
		float shortMax = 65535.0;\n\
		finalTexCoord.x = float(texCoord.x) / shortMax;\n\
		finalTexCoord.y = float(texCoord.y) / shortMax;\n\
	}\n\
	else\n\
	{\n\
		finalTexCoord = texCoord;\n\
	}\n\
    vTexCoord = finalTexCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.LodBuildingSsaoSimpleFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;   \n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec4 vcolor4;\n\
uniform vec3 specularColor;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;     \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{                          \n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
    vec3 normal2 = vNormal;   \n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
		if(sampleDepth > 0.49)\n\
			continue;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
\n\
    vec4 textureColor;\n\
    if(hasTexture)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else{\n\
        textureColor = vcolor4;\n\
    }\n\
\n\
    gl_FragColor = vec4((textureColor.xyz) * occlusion, 1.0); \n\
}\n\
";
ShaderSource.LodBuildingSsaoSimpleVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
attribute vec2 texCoord;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool hasTexture;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec4 vcolor4;\n\
\n\
void main()\n\
{	\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    if(bUse1Color)\n\
    {\n\
        vcolor4 = oneColor4;\n\
    }\n\
    else\n\
    {\n\
        vcolor4 = color4;\n\
    }\n\
    vTexCoord = texCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}";
ShaderSource.LodBuildingSsaoVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
attribute vec2 texCoord;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool hasTexture;\n\
uniform bool bApplySpecularLighting;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;   \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
varying vec3 vertexPos;\n\
varying float applySpecLighting;\n\
\n\
void main()\n\
{	\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
	vertexPos = vec3(modelViewMatrixRelToEye * pos4);\n\
    vec4 rotatedNormal = buildingRotMatrix * vec4(normal.xyz, 1.0);\n\
    vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
    uAmbientColor = vec3(0.8, 0.8, 0.8);\n\
    vec3 uLightingDirection = vec3(0.6, 0.6, 0.6);\n\
    vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
    vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
    float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
    vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
	\n\
	if(bApplySpecularLighting)\n\
			applySpecLighting = 1.0;\n\
		else\n\
			applySpecLighting = -1.0;\n\
\n\
    if(bUse1Color)\n\
    {\n\
        vcolor4 = oneColor4;\n\
    }\n\
    else\n\
    {\n\
        vcolor4 = color4;\n\
    }\n\
    vTexCoord = texCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.ModelRefSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 oneColor4;\n\
uniform bool bApplyScpecularLighting;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
varying float applySpecLighting;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
    vec3 normal2 = vNormal;\n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
		if(sampleDepth > 0.49)\n\
			continue;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
\n\
    // Do specular lighting.***\n\
	float lambertian;\n\
	float specular;\n\
		\n\
	if(applySpecLighting> 0.0)\n\
	{\n\
		vec3 lightPos = vec3(20.0, 60.0, 20.0);\n\
		vec3 L = normalize(lightPos - vertexPos);\n\
		lambertian = max(dot(normal2, L), 0.0);\n\
		specular = 0.0;\n\
		if(lambertian > 0.0)\n\
		{\n\
			vec3 R = reflect(-L, normal2);      // Reflected light vector\n\
			vec3 V = normalize(-vertexPos); // Vector to viewer\n\
			\n\
			// Compute the specular term\n\
			float specAngle = max(dot(R, V), 0.0);\n\
			specular = pow(specAngle, shininessValue);\n\
		}\n\
		\n\
		if(lambertian < 0.5)\n\
		{\n\
			lambertian = 0.5;\n\
		}\n\
	}\n\
\n\
    vec4 textureColor;\n\
    if(hasTexture)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else{\n\
        textureColor = oneColor4;\n\
    }\n\
	\n\
	vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
	float alfa = textureColor.w;\n\
\n\
    vec4 finalColor;\n\
	if(applySpecLighting> 0.0)\n\
	{\n\
		finalColor = vec4((ambientReflectionCoef * ambientColor + diffuseReflectionCoef * lambertian * textureColor.xyz + specularReflectionCoef * specular * specularColor)*vLightWeighting * occlusion, alfa); \n\
	}\n\
	else{\n\
		finalColor = vec4((textureColor.xyz) * occlusion, alfa);\n\
	}\n\
    gl_FragColor = finalColor; \n\
}\n\
";
ShaderSource.ModelRefSsaoSimpleFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 oneColor4;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
    vec3 normal2 = vNormal;\n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
		if(sampleDepth > 0.49)\n\
			continue;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
\n\
    vec4 textureColor;\n\
    if(hasTexture)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else{\n\
        textureColor = oneColor4;\n\
    }\n\
	\n\
	gl_FragColor = vec4((textureColor.xyz) * occlusion, 1.0); \n\
}\n\
";
ShaderSource.ModelRefSsaoSimpleVS = "	attribute vec3 position;\n\
	attribute vec3 normal;\n\
	attribute vec2 texCoord;\n\
	\n\
	uniform mat4 buildingRotMatrix; \n\
	uniform mat4 projectionMatrix;  \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 modelViewMatrixRelToEye; \n\
	uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
	uniform mat4 RefTransfMatrix;\n\
	uniform mat4 normalMatrix4;\n\
	uniform vec3 buildingPosHIGH;\n\
	uniform vec3 buildingPosLOW;\n\
	uniform vec3 encodedCameraPositionMCHigh;\n\
	uniform vec3 encodedCameraPositionMCLow;\n\
	uniform vec3 aditionalPosition;\n\
	uniform vec3 refTranslationVec;\n\
	uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
	varying vec3 vNormal;\n\
	varying vec2 vTexCoord;  \n\
	varying vec3 uAmbientColor;\n\
	varying vec3 vLightWeighting;\n\
	varying vec3 vertexPos;\n\
	\n\
	void main()\n\
    {	\n\
		vec4 rotatedPos;\n\
		mat3 currentTMat;\n\
		if(refMatrixType == 0)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 1)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 2)\n\
		{\n\
			rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(RefTransfMatrix);\n\
		}\n\
\n\
		vec3 objPosHigh = buildingPosHIGH;\n\
		vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
		vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
		vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
		vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
		vertexPos = vec3(modelViewMatrixRelToEye * pos4);\n\
		vec3 rotatedNormal = currentTMat * normal;\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8);\n\
		vec3 uLightingDirection = vec3(0.6, 0.6, 0.6);\n\
		vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		vTexCoord = texCoord;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
\n\
        gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	}\n\
";
ShaderSource.ModelRefSsaoVS = "	attribute vec3 position;\n\
	attribute vec3 normal;\n\
	attribute vec2 texCoord;\n\
	\n\
	uniform mat4 buildingRotMatrix; \n\
	uniform mat4 projectionMatrix;  \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 modelViewMatrixRelToEye; \n\
	uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
	uniform mat4 RefTransfMatrix;\n\
	uniform mat4 normalMatrix4;\n\
	uniform vec3 buildingPosHIGH;\n\
	uniform vec3 buildingPosLOW;\n\
	uniform vec3 encodedCameraPositionMCHigh;\n\
	uniform vec3 encodedCameraPositionMCLow;\n\
	uniform vec3 aditionalPosition;\n\
	uniform vec3 refTranslationVec;\n\
	uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
	uniform bool bApplySpecularLighting;\n\
\n\
	varying vec3 vNormal;\n\
	varying vec2 vTexCoord;  \n\
	varying vec3 uAmbientColor;\n\
	varying vec3 vLightWeighting;\n\
	varying vec3 vertexPos;\n\
	varying float applySpecLighting;\n\
	\n\
	void main()\n\
    {	\n\
		vec4 rotatedPos;\n\
		mat3 currentTMat;\n\
		if(refMatrixType == 0)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 1)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 2)\n\
		{\n\
			rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(RefTransfMatrix);\n\
		}\n\
\n\
		vec3 objPosHigh = buildingPosHIGH;\n\
		vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
		vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
		vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
		vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
		vertexPos = vec3(modelViewMatrixRelToEye * pos4);\n\
		vec3 rotatedNormal = currentTMat * normal;\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8);\n\
		vec3 uLightingDirection = vec3(0.6, 0.6, 0.6);\n\
		vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		vTexCoord = texCoord;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
		\n\
		if(bApplySpecularLighting)\n\
			applySpecLighting = 1.0;\n\
		else\n\
			applySpecLighting = -1.0;\n\
\n\
        gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	}\n\
";
ShaderSource.PngImageFS = "precision mediump float;\n\
varying vec2 v_texcoord;\n\
uniform bool textureFlipYAxis;\n\
uniform sampler2D u_texture;\n\
\n\
void main()\n\
{\n\
    vec4 textureColor;\n\
    if(textureFlipYAxis)\n\
    {\n\
        textureColor = texture2D(u_texture, vec2(v_texcoord.s, 1.0 - v_texcoord.t));\n\
    }\n\
    else\n\
    {\n\
        textureColor = texture2D(u_texture, v_texcoord);\n\
    }\n\
    if(textureColor.w < 0.1)\n\
    {\n\
        discard;\n\
    }\n\
\n\
    gl_FragColor = textureColor;\n\
}";
ShaderSource.PngImageVS = "attribute vec3 a_position;\n\
attribute vec2 a_texcoord;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec2 v_texcoord;\n\
\n\
void main()\n\
{\n\
    vec4 position2 = vec4(a_position.xyz, 1.0);\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position2.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    v_texcoord = a_texcoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.PointCloudFS = "	precision lowp float;\n\
	varying vec4 vColor;\n\
\n\
	void main()\n\
    {\n\
		gl_FragColor = vColor;\n\
	}";
ShaderSource.PointCloudVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform mat4 buildingRotMatrix;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform bool bPositionCompressed;\n\
uniform vec3 minPosition;\n\
uniform vec3 bboxSize;\n\
attribute vec4 color4;\n\
varying vec4 vColor;\n\
\n\
void main()\n\
{\n\
	vec3 realPos;\n\
	vec4 rotatedPos;\n\
	if(bPositionCompressed)\n\
	{\n\
		float maxShort = 65535.0;\n\
		realPos = vec3(float(position.x)/maxShort*bboxSize.x + minPosition.x, float(position.y)/maxShort*bboxSize.y + minPosition.y, float(position.z)/maxShort*bboxSize.z + minPosition.z);\n\
	}\n\
	else\n\
	{\n\
		realPos = position;\n\
	}\n\
	rotatedPos = buildingRotMatrix * vec4(realPos.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vColor=color4;\n\
	\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
	gl_PointSize = 1.0 + 50.0/gl_Position.z;\n\
	if(gl_PointSize > 10.0)\n\
		gl_PointSize = 10.0;\n\
}";
ShaderSource.RenderShowDepthFS = "#ifdef GL_ES\n\
precision highp float;\n\
#endif\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying float depth;  \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}\n\
\n\
void main()\n\
{     \n\
    gl_FragData[0] = packDepth(-depth);\n\
}\n\
";
ShaderSource.RenderShowDepthVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix; \n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 RefTransfMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
varying float depth;\n\
  \n\
void main()\n\
{	\n\
	vec4 rotatedPos;\n\
\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    //linear depth in camera space (0..far)\n\
    depth = (modelViewMatrixRelToEye * pos4).z/far;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	gl_PointSize = 2.0;\n\
}\n\
";
ShaderSource.ShowDepthFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying float depth;  \n\
varying vec3 vN; \n\
varying vec4 vVSPos;\n\
\n\
// from http://spidergl.org/example.php?id=6\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
\n\
    return res;  \n\
}\n\
\n\
void main()\n\
{\n\
    gl_FragData[0] = packDepth(-depth);\n\
    gl_FragData[0].r = -depth/far;\n\
}\n\
";
ShaderSource.ShowDepthVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix3;\n\
uniform mat4 normalMatrix4;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying vec3 vN;\n\
varying float depth;  \n\
varying vec4 vVSPos;\n\
\n\
void main()\n\
{	\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vN = normalize((normalMatrix4 * vec4(normal, 1.0)).xyz);\n\
    \n\
    //linear depth in camera space (0..far)\n\
    depth = (modelViewMatrixRelToEye * pos4).z/far;\n\
    vVSPos = modelViewMatrixRelToEye * pos4;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.SilhouetteFS = "precision highp float;\n\
uniform vec4 vColor4Aux;\n\
\n\
void main()\n\
{          \n\
    gl_FragColor = vColor4Aux;\n\
}";
ShaderSource.SilhouetteVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 ModelViewMatrixRelToEye;\n\
uniform mat4 ProjectionMatrix;\n\
uniform mat4 RefTransfMatrix;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
uniform vec2 camSpacePixelTranslation;\n\
uniform vec2 screenSize;    \n\
varying vec2 camSpaceTranslation;\n\
\n\
void main()\n\
{    \n\
    vec4 rotatedPos;\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    vec4 camSpacePos = ModelViewMatrixRelToEye * pos4;\n\
    vec4 translationVec = ProjectionMatrix * vec4(camSpacePixelTranslation.x*(-camSpacePos.z), camSpacePixelTranslation.y*(-camSpacePos.z), 0.0, 1.0);\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
    gl_Position += translationVec;  \n\
}";
ShaderSource.SimpleDepthSsaoFS = "precision highp float;\n\
const vec4 bitEnc = vec4(1.0,255.0,65025.0,16581375.0);\n\
const vec4 bitDec = 1.0/bitEnc;\n\
varying float zDepth;\n\
\n\
vec4 EncodeFloatRGBA (float v)\n\
{\n\
    vec4 enc = bitEnc * v;\n\
    enc = fract(enc);\n\
    enc -= enc.yzww * vec2(1.0/255.0, 0.0).xxxy;\n\
    return enc;\n\
}\n\
\n\
void main()\n\
{          \n\
    vec4 encodedZ = EncodeFloatRGBA(zDepth);\n\
    gl_FragData[0] = encodedZ;\n\
}\n\
";
ShaderSource.SimpleDepthSsaoVS = "attribute vec3 position;\n\
\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 RefTransfMatrix;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying float zDepth;\n\
uniform float far;\n\
\n\
void main()\n\
{	\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    zDepth = (modelViewMatrixRelToEye * pos4).z/far;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.SsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
\n\
varying vec2 vTexCoord;   \n\
\n\
const int kernelSize = 16;  \n\
const float radius = 1.0;      \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{                          \n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
 \n\
    vec3 normal2 = vNormal;   \n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
\n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
        \n\
    }   \n\
        \n\
    occlusion = 1.0 - (occlusion) / float(kernelSize);\n\
                                \n\
    vec3 lightPos = vec3(10.0, 10.0, 10.0);\n\
    vec3 L = normalize(lightPos);\n\
    float NdotL = abs(dot(normal2, L));\n\
    vec3 diffuse = vec3(NdotL);\n\
    vec3 ambient = vec3(1.0);\n\
    vec4 textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
\n\
    gl_FragColor.rgb = vec3((textureColor.xyz*0.2 + textureColor.xyz*0.8) * occlusion); // with texture.***\n\
    gl_FragColor.a = 1.0;   \n\
}\n\
";
ShaderSource.SsaoVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec2 texCoord;\n\
\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;  \n\
\n\
void main()\n\
{	\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vNormal = (normalMatrix4 * vec4(-normal.x, -normal.y, -normal.z, 1.0)).xyz;\n\
    vTexCoord = texCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}";
ShaderSource.StandardFS = "precision lowp float;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = vec4(vColor, 1.);\n\
}";
ShaderSource.StandardVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform mat4 RefTransfMatrix;\n\
attribute vec3 color;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
 \n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.TextureA1FS = "precision mediump float;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
uniform sampler2D uSampler;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
}\n\
";
ShaderSource.TextureA1VS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
 \n\
    vColor=aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.TextureFS = "precision mediump float;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
uniform sampler2D uSampler;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
}";
ShaderSource.TextureNormalFS = "	precision mediump float;\n\
	varying vec4 vColor;\n\
	varying vec2 vTextureCoord;\n\
	uniform sampler2D uSampler;\n\
	varying vec3 vLightWeighting;\n\
\n\
	void main()\n\
    {\n\
		vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
        \n\
		gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);\n\
	}\n\
";
ShaderSource.TextureNormalVS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
attribute vec3 aVertexNormal;\n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
uniform mat3 uNMatrix;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    vColor = aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
    \n\
    vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
    uAmbientColor = vec3(0.7, 0.7, 0.7);\n\
    vec3 uLightingDirection = vec3(0.8, 0.2, -0.9);\n\
    vec3 directionalLightColor = vec3(0.4, 0.4, 0.4);\n\
    vec3 transformedNormal = uNMatrix * aVertexNormal;\n\
    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);\n\
    vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}\n\
";
ShaderSource.TextureVS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 Mmatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = Mmatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vColor=aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
    \n\
}";
ShaderSource.TinTerrainFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
uniform bool bIsMakingDepth;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
varying float depthValue;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
} \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}               \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{           \n\
	if(bIsMakingDepth)\n\
	{\n\
		gl_FragColor = packDepth(-depthValue);\n\
	}\n\
	else{\n\
		vec4 textureColor;\n\
		if(hasTexture)\n\
		{\n\
			if(textureFlipYAxis)\n\
			{\n\
				textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
			}\n\
			else{\n\
				textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
			}\n\
			\n\
			if(textureColor.w == 0.0)\n\
			{\n\
				discard;\n\
			}\n\
		}\n\
		else{\n\
			textureColor = vColor4Aux;\n\
		}\n\
		//vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
		gl_FragColor = vec4(textureColor.xyz, 1.0); \n\
	}\n\
}";
ShaderSource.TinTerrainVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
attribute vec2 texCoord;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 ModelViewProjectionMatrix;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool hasTexture;\n\
uniform bool bIsMakingDepth;\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;   \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
varying vec3 vertexPos;\n\
varying float depthValue;\n\
\n\
void main()\n\
{	\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
	if(bIsMakingDepth)\n\
	{\n\
		depthValue = (modelViewMatrixRelToEye * pos4).z/far;\n\
	}\n\
	else\n\
	{\n\
		vTexCoord = texCoord;\n\
	}\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	\n\
}";

'use strict';

var MAGO3DJS_MESSAGE = new Object();


'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Renderer
 */
var Renderer = function() 
{
	if (!(this instanceof Renderer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.renderNormals = true;
	this.renderTexture = true;
	

	this.vbo_vi_cacheKey_aux;
	this.byteColorAux = new ByteColor();

	// SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.***

	this.currentTimeSC;
	this.dateSC;
	this.startTimeSC;
	this.simpObj_scratch;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Renderer.prototype.renderRenderables = function(gl, renderables, magoManager, shader, renderTexture, ssao_idx, maxSizeToRender, refMatrixIdxKey) 
{
	var node;
	var neoBuilding;
	var lod;
	var renderablesCount = renderables.length;
	for (var i=0; i<renderablesCount; i++)
	{
		node = renderables[i];
		neoBuilding = node.data.neoBuilding;
		lod = neoBuilding.currentLod;
		
		if (lod === 0)
		{
			
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Renderer.prototype.renderVboContainer = function(gl, vboContainer, magoManager, shader, renderWireframe) 
{
	if (vboContainer === undefined)
	{ return; }
	
	var cacheKeys_count = vboContainer.vboCacheKeysArray.length;
	// Must applicate the transformMatrix of the reference object.***
	
	var indicesCount;

	for (var n=0; n<cacheKeys_count; n++) // Original.***
	{
		//var mesh_array = block.viArraysContainer._meshArrays[n];
		this.vbo_vi_cacheKey_aux = vboContainer.vboCacheKeysArray[n];
		if (!this.vbo_vi_cacheKey_aux.isReadyPositions(gl, magoManager.vboMemoryManager))
		{ continue; }
	
		if (!this.vbo_vi_cacheKey_aux.isReadyNormals(gl, magoManager.vboMemoryManager))
		{ 
			// disable normals.***
			
		}
		
		if (!this.vbo_vi_cacheKey_aux.isReadyFaces(gl, magoManager.vboMemoryManager))
		{ 
			// disable indices.***
			
		}
		
		// Positions.***
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshVertexCacheKey);
		gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);
		//gl.vertexAttribPointer(shader.attribLocationCacheObj["position"], 3, gl.FLOAT, false,0,0);

		// Normals.***
		if (shader.normal3_loc !== -1 && this.renderNormals) 
		{
			gl.enableVertexAttribArray(shader.normal3_loc); 
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshNormalCacheKey);
			gl.vertexAttribPointer(shader.normal3_loc, 3, gl.BYTE, true, 0, 0);
		}
		else 
		{
			gl.disableVertexAttribArray(shader.normal3_loc); 
		}

		if (shader.texCoord2_loc !== -1 && this.renderTexture) 
		{
			if (!this.vbo_vi_cacheKey_aux.isReadyTexCoords(gl, magoManager.vboMemoryManager))
			{ continue; }

			gl.enableVertexAttribArray(shader.texCoord2_loc);
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshTexcoordsCacheKey);
			gl.vertexAttribPointer(shader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
		}
		else 
		{
			if (shader.texCoord2_loc !== -1) { gl.disableVertexAttribArray(shader.texCoord2_loc); }
		}

		// Indices.***
		if (magoManager.isCameraMoving)
		{
			indicesCount = this.vbo_vi_cacheKey_aux.indicesCount;
		}
		else
		{
			indicesCount = this.vbo_vi_cacheKey_aux.indicesCount;
		}

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshFacesCacheKey);
		
		if (renderWireframe)
		{
			gl.drawElements(gl.LINES, this.vbo_vi_cacheKey_aux.indicesCount, gl.UNSIGNED_SHORT, 0); // Wireframe.***

		}
		else 
		{
			gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Renderer.prototype.renderNodes = function(gl, visibleNodesArray, magoManager, shader, renderTexture, ssao_idx, maxSizeToRender, refMatrixIdxKey) 
{
	var node;
	var rootNode;
	var geoLocDataManager;
	var neoBuilding;
	var minSize = 0.0;
	var lowestOctreesCount;
	var lowestOctree;
	var isInterior = false; // no used.***
	
	// set webgl options.
	gl.enable(gl.DEPTH_TEST);
	if (MagoConfig.getPolicy().geo_cull_face_enable === "true") 
	{
		gl.enable(gl.CULL_FACE);
	}
	else 
	{
		gl.disable(gl.CULL_FACE);
	}

	gl.enable(gl.CULL_FACE);
	gl.frontFace(gl.CCW);
	
	var flipYTexCoord = false;
	
	// do render.
	var nodesCount = visibleNodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = visibleNodesArray[i];
		rootNode = node.getRoot();
		
		geoLocDataManager = rootNode.data.geoLocDataManager;
		neoBuilding = node.data.neoBuilding;

		// check attributes of the project.************************************************
		var project = magoManager.hierarchyManager.getNodesMap(node.data.projectId);
		if (project.attributes !== undefined && project.attributes.specularLighting !== undefined && shader.bApplySpecularLighting_loc !== undefined)
		{
			var applySpecLighting = project.attributes.specularLighting;
			if (applySpecLighting)
			{ gl.uniform1i(shader.bApplySpecularLighting_loc, true); }
			else
			{ gl.uniform1i(shader.bApplySpecularLighting_loc, false); }
		}
		// end check attributes of the project.----------------------------------------
		
		if (neoBuilding.currentVisibleOctreesControler === undefined)
		{ continue; }
	
		if (node.data.attributes.flipYTexCoords !== undefined)
		{
			flipYTexCoord = node.data.attributes.flipYTexCoords;
		}
		else 
		{
			flipYTexCoord = false;
		}
		gl.uniform1i(shader.textureFlipYAxis_loc, flipYTexCoord);
		
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(shader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(shader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
			
		if (ssao_idx === 0)
		{
			renderTexture = false;
		}
		else if (ssao_idx === 1)
		{
			if (neoBuilding.texturesLoaded && neoBuilding.texturesLoaded.length>0)
			{
				renderTexture = true;
			}
			else { renderTexture = false; }
			
			if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === neoBuilding)
			{
				// active stencil buffer to draw silhouette.***
				this.enableStencilBuffer(gl);
			}
			
		}
		
		// LOD0.***
		minSize = 0.0;
		lowestOctreesCount = neoBuilding.currentVisibleOctreesControler.currentVisibles0.length;
		for (var j=0; j<lowestOctreesCount; j++) 
		{
			lowestOctree = neoBuilding.currentVisibleOctreesControler.currentVisibles0[j];
			if (lowestOctree.neoReferencesMotherAndIndices === undefined) 
			{ continue; }

			this.renderNeoRefListsAsimetricVersion(gl, lowestOctree.neoReferencesMotherAndIndices, neoBuilding, magoManager, isInterior, shader, renderTexture, ssao_idx, minSize, 0, refMatrixIdxKey);
		}
		
		// LOD1.***
		minSize = 0.45;
		lowestOctreesCount = neoBuilding.currentVisibleOctreesControler.currentVisibles1.length;
		for (var j=0; j<lowestOctreesCount; j++) 
		{
			lowestOctree = neoBuilding.currentVisibleOctreesControler.currentVisibles1[j];
			if (lowestOctree.neoReferencesMotherAndIndices === undefined) 
			{ continue; }

			this.renderNeoRefListsAsimetricVersion(gl, lowestOctree.neoReferencesMotherAndIndices, neoBuilding, magoManager, isInterior, shader, renderTexture, ssao_idx, minSize, 1, refMatrixIdxKey);
		}
		
		if (ssao_idx === 1)
		{
			if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === neoBuilding)
			{
				// deactive stencil buffer to draw silhouette.***
				this.disableStencilBuffer(gl);
			}
			
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Renderer.prototype.renderNeoBuildingsLOD2AsimetricVersion = function(gl, visibleNodesArray, magoManager, shader, renderTexture, ssao_idx) 
{
	var node;
	var rootNode;
	var geoLocDataManager;
	var neoBuilding;
	//var minSize = 0.0;
	var lowestOctreesCount;
	var lowestOctree;
	//var isInterior = false; // no used.***
	var lastExtureId;
	
	var nodesCount = visibleNodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = visibleNodesArray[i];
		rootNode = node.getRoot();
		geoLocDataManager = rootNode.data.geoLocDataManager;
		neoBuilding = node.data.neoBuilding;
		
		if (neoBuilding.currentVisibleOctreesControler === undefined)
		{ continue; }
	
		lowestOctreesCount = neoBuilding.currentVisibleOctreesControler.currentVisibles2.length;
		if (lowestOctreesCount === 0)
		{ continue; }
	
		//if(neoBuilding.simpleBuilding3x3Texture === undefined || neoBuilding.simpleBuilding3x3Texture.texId === undefined)
		//	continue;
		
		if (ssao_idx === 1 && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === neoBuilding)
		{
			// active stencil buffer to draw silhouette.***
			this.enableStencilBuffer(gl);
		}
		
		// check attributes of the project.************************************************
		var project = magoManager.hierarchyManager.getNodesMap(node.data.projectId);
		if (project.attributes !== undefined && project.attributes.specularLighting !== undefined && shader.bApplySpecularLighting_loc !== undefined)
		{
			var applySpecLighting = project.attributes.specularLighting;
			if (applySpecLighting)
			{ gl.uniform1i(shader.bApplySpecularLighting_loc, true); }
			else
			{ gl.uniform1i(shader.bApplySpecularLighting_loc, false); }
		}
		// end check attributes of the project.----------------------------------------
		
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(shader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(shader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);

		for (var j=0; j<lowestOctreesCount; j++) 
		{
			lowestOctree = neoBuilding.currentVisibleOctreesControler.currentVisibles2[j];

			if (lowestOctree.lego === undefined) 
			{
				lowestOctree.lego = new Lego();
				lowestOctree.lego.fileLoadState = CODE.fileLoadState.READY;
				lowestOctree.lego.legoKey = lowestOctree.octreeKey + "_lego";
				continue;
			}
			
			if (lowestOctree.lego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
			{ continue; }

			// if the building is highlighted, the use highlight oneColor4.*********************
			if (ssao_idx === 1)
			{
				if (neoBuilding.isHighLighted)
				{
					gl.uniform1i(shader.bUse1Color_loc, true);
					gl.uniform4fv(shader.oneColor4_loc, this.highLightColor4); //.***
				}
				else if (neoBuilding.isColorChanged)
				{
					gl.uniform1i(shader.bUse1Color_loc, true);
					gl.uniform4fv(shader.oneColor4_loc, [neoBuilding.aditionalColor.r, neoBuilding.aditionalColor.g, neoBuilding.aditionalColor.b, neoBuilding.aditionalColor.a]); //.***
				}
				else
				{
					gl.uniform1i(shader.bUse1Color_loc, false);
				}
				//----------------------------------------------------------------------------------
				renderTexture = true;
				if (neoBuilding.simpleBuilding3x3Texture !== undefined && neoBuilding.simpleBuilding3x3Texture.texId)
				{
					gl.enableVertexAttribArray(shader.texCoord2_loc);
					//gl.activeTexture(gl.TEXTURE2); 
					gl.uniform1i(shader.hasTexture_loc, true);
					if (lastExtureId !== neoBuilding.simpleBuilding3x3Texture.texId)
					{
						gl.bindTexture(gl.TEXTURE_2D, neoBuilding.simpleBuilding3x3Texture.texId);
						lastExtureId = neoBuilding.simpleBuilding3x3Texture.texId;
					}
				}
				else 
				{
					//continue;
					gl.uniform1i(shader.hasTexture_loc, false);
					gl.disableVertexAttribArray(shader.texCoord2_loc);
					renderTexture = false;
				}
			}
			
			// If data is compressed, then set uniforms.***
			//gl.uniform1i(shader.posDataByteSize_loc, 2);
			//gl.uniform1i(shader.texCoordByteSize_loc, 2);
			//var bbox = lowestOctree.lego.bbox;
			//gl.uniform3fv(shader.compressionMaxPoint_loc, [bbox.maxX, bbox.maxY, bbox.maxZ]); //.***
			//gl.uniform3fv(shader.compressionMinPoint_loc, [bbox.minX, bbox.minY, bbox.minZ]); //.***

			this.renderLodBuilding(gl, lowestOctree.lego, magoManager, shader, ssao_idx, renderTexture);
		}
		
		if (ssao_idx === 1 && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === neoBuilding)
		{
			// active stencil buffer to draw silhouette.***
			this.disableStencilBuffer(gl);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param neoRefList_array 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 * @param isInterior 변수
 * @param standardShader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 */
Renderer.prototype.renderPCloud = function(gl, pCloud, magoManager, shader, ssao_idx, renderTexture, distToCam, lod, posCompressed) 
{
	if (pCloud.vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{
		return;
	}
	gl.frontFace(gl.CCW);
	// ssao_idx = -1 -> pickingMode.***
	// ssao_idx = 0 -> depth.***
	// ssao_idx = 1 -> ssao.***

	if (ssao_idx === 0) // depth.***
	{
		// 1) Position.*********************************************
		var vbo_vicky = pCloud.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.***
		if (!vbo_vicky.isReadyPositions(gl, magoManager.vboMemoryManager))
		{ return; }

		var vertices_count = vbo_vicky.vertexCount;
		if (vertices_count === 0) 
		{
			return;
		}
		
		gl.disableVertexAttribArray(shader.color4_loc);

		gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshVertexCacheKey);
		gl.vertexAttribPointer(shader.position3_loc, 3, gl.UNSIGNED_SHORT, false, 0, 0);
		gl.drawArrays(gl.POINTS, 0, vertices_count);
	}
	else if (ssao_idx === 1) // ssao.***
	{
		var vbo_vicky = pCloud.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.***
		var vertices_count = vbo_vicky.vertexCount;

		if (vertices_count === 0) 
		{
			return;
		}
		
		if (!vbo_vicky.isReadyPositions(gl, magoManager.vboMemoryManager))
		{ return; }
		
		//if (!vbo_vicky.isReadyNormals(gl, magoManager.vboMemoryManager))
		//{ return; }
		
		if (!vbo_vicky.isReadyColors(gl, magoManager.vboMemoryManager))
		{ return; }
		
		// 4) Texcoord.*********************************************
		/*
		if (renderTexture)
		{
			if (!vbo_vicky.isReadyTexCoords(gl, magoManager.vboMemoryManager))
			{ return; }
		}
		else 
		{
			gl.uniform1i(shader.bUse1Color_loc, false);
			gl.disableVertexAttribArray(shader.texCoord2_loc);
		}
		*/
		
		gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshVertexCacheKey);
		if (posCompressed)
		{
			gl.vertexAttribPointer(shader.position3_loc, 3, gl.UNSIGNED_SHORT, false, 0, 0);
		}
		else 
		{
			gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);
		}

		//gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshNormalCacheKey);
		//gl.vertexAttribPointer(shader.normal3_loc, 3, gl.BYTE, true, 0, 0);

		if (vbo_vicky.meshColorCacheKey !== undefined )
		{
			gl.enableVertexAttribArray(shader.color4_loc);
			gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshColorCacheKey);
			gl.vertexAttribPointer(shader.color4_loc, 4, gl.UNSIGNED_BYTE, true, 0, 0);
		}
		
		//if (renderTexture && vbo_vicky.meshTexcoordsCacheKey)
		//{
		//	gl.disableVertexAttribArray(shader.color4_loc);
		//	gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshTexcoordsCacheKey);
		//	gl.vertexAttribPointer(shader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
		//}
		if (magoManager.isCameraMoving)// && !isInterior && magoManager.isCameraInsideBuilding)
		{
			vertices_count = Math.floor(vertices_count/5);
			if (vertices_count === 0)
			{ return; }
		}
		
		if (distToCam < 100)
		{
			// do nothing.***
		}
		else if (distToCam < 200)
		{
			vertices_count = Math.floor(vertices_count/2);
			if (vertices_count === 0)
			{ return; }
		}
		else if (distToCam < 400)
		{
			vertices_count = Math.floor(vertices_count/4);
			if (vertices_count === 0)
			{ return; }
		}
		else if (distToCam < 800)
		{
			vertices_count = Math.floor(vertices_count/8);
			if (vertices_count === 0)
			{ return; }
		}
		else if (distToCam < 1600)
		{
			vertices_count = Math.floor(vertices_count/16);
			if (vertices_count === 0)
			{ return; }
		}
		else
		{
			vertices_count = Math.floor(vertices_count/32);
			if (vertices_count === 0)
			{ return; }
		}

		gl.drawArrays(gl.POINTS, 0, vertices_count);
		gl.disableVertexAttribArray(shader.color4_loc);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Renderer.prototype.renderNeoBuildingsPCloud = function(gl, visibleNodesArray, magoManager, shader, renderTexture, ssao_idx) 
{
	var node;
	var rootNode;
	var geoLocDataManager;
	var neoBuilding;
	var lowestOctreesCount;
	var lowestOctree;
	var lastExtureId;
	
	var nodesCount = visibleNodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = visibleNodesArray[i];
		rootNode = node.getRoot();
		geoLocDataManager = rootNode.data.geoLocDataManager;
		neoBuilding = node.data.neoBuilding;
		
		if (neoBuilding.currentVisibleOctreesControler === undefined)
		{ continue; }
	
		lowestOctreesCount = neoBuilding.currentVisibleOctreesControler.currentVisibles2.length;
		if (lowestOctreesCount === 0)
		{ continue; }
		
		if (ssao_idx === 1 && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === neoBuilding)
		{
			// active stencil buffer to draw silhouette.***
			this.enableStencilBuffer(gl);
		}
		
		// check attributes of the project.************************************************
		var project = magoManager.hierarchyManager.getNodesMap(node.data.projectId);
		if (project.attributes !== undefined && project.attributes.specularLighting !== undefined && shader.bApplySpecularLighting_loc !== undefined)
		{
			//var applySpecLighting = project.attributes.specularLighting;
			//if (applySpecLighting)
			//{ gl.uniform1i(shader.bApplySpecularLighting_loc, true); }
			//else
			//{ gl.uniform1i(shader.bApplySpecularLighting_loc, false); }
		}
		// end check attributes of the project.----------------------------------------
		
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(shader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(shader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
		
		

		for (var j=0; j<lowestOctreesCount; j++) 
		{
			lowestOctree = neoBuilding.currentVisibleOctreesControler.currentVisibles2[j];

			if (lowestOctree.lego === undefined) 
			{
				lowestOctree.lego = new Lego();
				lowestOctree.lego.fileLoadState = CODE.fileLoadState.READY;
				lowestOctree.lego.legoKey = lowestOctree.octreeKey + "_lego";
				continue;
			}
			
			if (lowestOctree.lego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
			{ continue; }
		
			// data compression.***
			var posCompressed = false;
			if (lowestOctree.lego.bPositionsCompressed !== undefined)
			{
				posCompressed = lowestOctree.lego.bPositionsCompressed;
			}
			gl.uniform1i(shader.bPositionCompressed_loc, posCompressed);
			
			// If data is compressed, then set uniforms.***
			//gl.uniform1i(shader.posDataByteSize_loc, 2);
			//gl.uniform1i(shader.texCoordByteSize_loc, 2);
			var bbox = lowestOctree.lego.bbox;
			gl.uniform3fv(shader.bboxSize_loc, [bbox.getXLength(), bbox.getYLength(), bbox.getZLength()]); //.***
			gl.uniform3fv(shader.minPosition_loc, [bbox.minX, bbox.minY, bbox.minZ]); //.***
			var lod = 2;
			var distToCam = lowestOctree.distToCamera;
			this.renderPCloud(gl, lowestOctree.lego, magoManager, shader, ssao_idx, renderTexture, distToCam, lod, posCompressed);
		}
		
		if (ssao_idx === 1 && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === neoBuilding)
		{
			// active stencil buffer to draw silhouette.***
			this.disableStencilBuffer(gl);
		}
	}
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Renderer.prototype.renderNeoBuildingsLowLOD = function(gl, visibleNodesArray, magoManager, shader, renderTexture, ssao_idx) 
{
	var node;
	var rootNode;
	var geoLocDataManager;
	var neoBuilding;
	var lastExtureId;
	var skinLego;
	
	var nodesCount = visibleNodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = visibleNodesArray[i];
		rootNode = node.getRoot();
		geoLocDataManager = rootNode.data.geoLocDataManager;
		neoBuilding = node.data.neoBuilding;
		if (neoBuilding === undefined)
		{ continue; }
		
		skinLego = neoBuilding.getCurrentSkin();
		
		if (skinLego === undefined)
		{ continue; }
	
		if (skinLego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
		{ continue; }
	
		if (ssao_idx === 1 && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === neoBuilding)
		{
			// active stencil buffer to draw silhouette.***
			this.enableStencilBuffer(gl);
		}
		
		// check attributes of the project.************************************************
		var project = magoManager.hierarchyManager.getNodesMap(node.data.projectId);
		if (project.attributes !== undefined && project.attributes.specularLighting !== undefined && shader.bApplySpecularLighting_loc !== undefined)
		{
			var applySpecLighting = project.attributes.specularLighting;
			if (applySpecLighting)
			{ gl.uniform1i(shader.bApplySpecularLighting_loc, true); }
			else
			{ gl.uniform1i(shader.bApplySpecularLighting_loc, false); }
		}
		// end check attributes of the project.----------------------------------------
			
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(shader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(shader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);

		//if (skinLego.dataArrayBuffer === undefined) 
		//{ continue; }

		// if the building is highlighted, the use highlight oneColor4.*********************
		if (ssao_idx === 1)
		{
			if (neoBuilding.isHighLighted)
			{
				gl.uniform1i(shader.bUse1Color_loc, true);
				gl.uniform4fv(shader.oneColor4_loc, this.highLightColor4); //.***
			}
			else if (neoBuilding.isColorChanged)
			{
				gl.uniform1i(shader.bUse1Color_loc, true);
				gl.uniform4fv(shader.oneColor4_loc, [neoBuilding.aditionalColor.r, neoBuilding.aditionalColor.g, neoBuilding.aditionalColor.b, neoBuilding.aditionalColor.a]); //.***
			}
			else
			{
				gl.uniform1i(shader.bUse1Color_loc, false);
			}
			//----------------------------------------------------------------------------------
			renderTexture = true;
			if (skinLego.texture !== undefined && skinLego.texture.texId)
			{
				gl.enableVertexAttribArray(shader.texCoord2_loc);
				//gl.activeTexture(gl.TEXTURE2); 
				gl.uniform1i(shader.hasTexture_loc, true);
				if (lastExtureId !== skinLego.texture.texId)
				{
					gl.bindTexture(gl.TEXTURE_2D, skinLego.texture.texId);
					lastExtureId = skinLego.texture.texId;
				}
			}
			else 
			{
				if (magoManager.textureAux_1x1 !== undefined)
				{
					gl.enableVertexAttribArray(shader.texCoord2_loc);
					//gl.activeTexture(gl.TEXTURE2); 
					gl.uniform1i(shader.hasTexture_loc, true);
					gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
					//gl.uniform1i(shader.hasTexture_loc, false);
					//gl.disableVertexAttribArray(shader.texCoord2_loc);
					//renderTexture = false;
				}
			}
		}
		
		// If data is compressed, then set uniforms.***
		//gl.uniform1i(shader.posDataByteSize_loc, 2);
		//gl.uniform1i(shader.texCoordByteSize_loc, 2);
		//var bbox = skinLego.bbox;
		//gl.uniform3fv(shader.compressionMaxPoint_loc, [bbox.maxX, bbox.maxY, bbox.maxZ]); //.***
		//gl.uniform3fv(shader.compressionMinPoint_loc, [bbox.minX, bbox.minY, bbox.minZ]); //.***

		this.renderLodBuilding(gl, skinLego, magoManager, shader, ssao_idx, renderTexture);
		skinLego = undefined;
		
		if (ssao_idx === 1 && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected === neoBuilding)
		{
			// active stencil buffer to draw silhouette.***
			this.disableStencilBuffer(gl);
		}
	}
};

Renderer.prototype.enableStencilBuffer = function(gl)
{
	// Active stencil if the object is selected.
	gl.enable(gl.STENCIL_TEST);
	
	gl.stencilFunc(gl.ALWAYS, 1, 1);
	// (stencil-fail: replace), (stencil-pass & depth-fail: replace), (stencil-pass & depth-pass: replace).***
	//gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
	gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
	gl.enable(gl.POLYGON_OFFSET_FILL);
	//gl.disable(gl.CULL_FACE);
};

Renderer.prototype.disableStencilBuffer = function(gl)
{
	gl.disable(gl.STENCIL_TEST);
	gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	gl.disable(gl.POLYGON_OFFSET_FILL);
	//gl.enable(gl.CULL_FACE);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReferencesMotherAndIndices instance of NeoReferencesMotherAndIndices.
  * @returns {boolean} returns if the neoReferencesMotherAndIndices is ready to render.
 */
Renderer.prototype.isReadyNeoRefList = function(neoReferencesMotherAndIndices) 
{
	if (neoReferencesMotherAndIndices === undefined)
	{ return false; }
	
	var neoRefsCount = neoReferencesMotherAndIndices.neoRefsIndices.length;
	if (neoRefsCount === 0) 
	{ return false; }

	var myBlocksList = neoReferencesMotherAndIndices.blocksList;
	if (myBlocksList === undefined)
	{ return false; }

	if (myBlocksList.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED) 
	{ return false; }

	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference instance of NeoReference.
  * @returns {boolean} returns if the neoReference is ready to render.
 */
Renderer.prototype.isReadyNeoReference = function(neoReference, magoManager) 
{
	if (neoReference === undefined)
	{ return false; }
	
	if (neoReference.renderingFase === magoManager.renderingFase)
	{ return false; }

	if (neoReference.tMatrixAuxArray === undefined)
	{
		//neoReference.multiplyKeyTransformMatrix(refMatrixIdxKey, neoBuilding.geoLocationDataAux.rotMatrix);
		// we must collect all the neoReferences that has no tMatrixAuxArray and make it.***
		return false;
	}
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference instance of NeoReference.
  * @returns {boolean} returns if the neoReference is ready to render.
 */
Renderer.prototype.isReadyBlock = function(block, neoReference, magoManager, maxSizeToRender) 
{
	if (block === undefined)
	{ return false; }

	if (maxSizeToRender && (block.radius < maxSizeToRender))
	{ return false; }
	
	if (magoManager.isCameraMoving && block.radius < magoManager.smallObjectSize && magoManager.objectSelected !== neoReference)
	{ return false; }

	return true;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param neoRefList_array 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 * @param isInterior 변수
 * @param standardShader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 */
Renderer.prototype.renderNeoRefListsAsimetricVersion = function(gl, neoReferencesMotherAndIndices, neoBuilding, magoManager,
	isInterior, standardShader, renderTexture, ssao_idx, maxSizeToRender, lod, refMatrixIdxKey) 
{
	// 1rst check if the "neoReferencesMotherAndIndices" is ready to be rendered.***
	if (!this.isReadyNeoRefList(neoReferencesMotherAndIndices))
	{ return; }
	
	if (ssao_idx === 0) // do depth render.***
	{
		this.depthRenderNeoRefListsAsimetricVersion(gl, neoReferencesMotherAndIndices, neoBuilding, magoManager,
			isInterior, standardShader, renderTexture, ssao_idx, maxSizeToRender, lod, refMatrixIdxKey);
		return;
	}

	var cacheKeys_count;
	var block_idx;
	var block;
	var current_tex_id;
	var texFileLoadState;

	gl.activeTexture(gl.TEXTURE2); // ...***
	if (renderTexture) 
	{
		if (ssao_idx === 1) { gl.uniform1i(standardShader.hasTexture_loc, true); } //.***
	}

	gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
	
	var renderType = 1;

	// New version. Use occlussion indices.***
	//var visibleIndices_count = neoReferencesMotherAndIndices.neoRefsIndices.length; // no occludeCulling mode.***
	var visibleIndices_count = neoReferencesMotherAndIndices.currentVisibleIndices.length;

	for (var k=0; k<visibleIndices_count; k++) 
	{
		//var neoReference = neoReferencesMotherAndIndices.motherNeoRefsList[neoReferencesMotherAndIndices.neoRefsIndices[k]]; // no occludeCulling mode.***
		var neoReference = neoReferencesMotherAndIndices.motherNeoRefsList[neoReferencesMotherAndIndices.currentVisibleIndices[k]];
		
		if (!this.isReadyNeoReference(neoReference, magoManager))
		{ continue; }

		block_idx = neoReference._block_idx;
		block = neoBuilding.motherBlocksArray[block_idx];
		
		if (!this.isReadyBlock(block, neoReference, magoManager, maxSizeToRender))
		{ continue; }
		
		// Check if the texture is loaded.
		//if(renderTexture)
		{
			//if (neoReference.texture !== undefined || neoReference.materialId != -1)
			if (neoReference.hasTexture)// && neoReference.texture !== undefined)
			{
				// note: in the future use only "neoReference.materialId".
				texFileLoadState = neoBuilding.manageNeoReferenceTexture(neoReference, magoManager);
				if (texFileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
				{ continue; }
			
				if (neoReference.texture === undefined)
				{ continue; }
			
				if (neoReference.texture.texId === undefined)
				{ continue; }
			}
		}
		
		// Check the color or texture of reference object.
		if (neoBuilding.isHighLighted)
		{
			gl.uniform1i(standardShader.hasTexture_loc, false); //.***
			gl.uniform4fv(standardShader.oneColor4_loc, magoManager.highLightColor4);
		}
		else if (neoBuilding.isColorChanged)
		{
			gl.uniform1i(standardShader.hasTexture_loc, false); //.***
			if (magoManager.objectSelected === neoReference) 
			{
				gl.uniform4fv(standardShader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
			}
			else
			{
				gl.uniform4fv(standardShader.oneColor4_loc, [neoBuilding.aditionalColor.r, neoBuilding.aditionalColor.g, neoBuilding.aditionalColor.b, neoBuilding.aditionalColor.a] );
			}
		}
		else if (neoReference.aditionalColor)
		{
			gl.uniform1i(standardShader.hasTexture_loc, false); //.***
			if (magoManager.objectSelected === neoReference) 
			{
				gl.uniform4fv(standardShader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
			}
			else
			{
				gl.uniform4fv(standardShader.oneColor4_loc, [neoReference.aditionalColor.r, neoReference.aditionalColor.g, neoReference.aditionalColor.b, neoReference.aditionalColor.a] );
			}
		}
		else
		{
			// Normal rendering.
			if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && magoManager.objectSelected === neoReference) 
			{
				gl.uniform1i(standardShader.hasTexture_loc, false); //.***
				gl.uniform4fv(standardShader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
				
				// Active stencil if the object is selected.
				this.enableStencilBuffer(gl);
			}
			else if (magoManager.magoPolicy.colorChangedObjectId === neoReference.objectId)
			{
				gl.uniform1i(standardShader.hasTexture_loc, false); //.***
				gl.uniform4fv(standardShader.oneColor4_loc, [magoManager.magoPolicy.color[0], magoManager.magoPolicy.color[1], magoManager.magoPolicy.color[2], 1.0]);
			}
			else
			{
				
				if (renderTexture && neoReference.hasTexture) 
				{
					if (neoReference.texture !== undefined && neoReference.texture.texId !== undefined) 
					{
						//textureBinded = true;
						gl.uniform1i(standardShader.hasTexture_loc, true); //.***
						if (current_tex_id !== neoReference.texture.texId) 
						{
							gl.bindTexture(gl.TEXTURE_2D, neoReference.texture.texId);
							current_tex_id = neoReference.texture.texId;
						}
					}
					else 
					{
						gl.uniform1i(standardShader.hasTexture_loc, false); //.***
						gl.uniform4fv(standardShader.oneColor4_loc, [0.8, 0.8, 0.8, 1.0]);
					}
				}
				else 
				{
					// if no render texture, then use a color.***
					gl.uniform1i(standardShader.bUse1Color_loc, true); //.***
					if (neoReference.color4) 
					{
						gl.uniform1i(standardShader.hasTexture_loc, false); //.***
						gl.uniform4fv(standardShader.oneColor4_loc, [neoReference.color4.r/255.0, neoReference.color4.g/255.0, neoReference.color4.b/255.0, neoReference.color4.a/255.0]);
					}
					else
					{
						gl.uniform1i(standardShader.hasTexture_loc, false); //.***
						gl.uniform4fv(standardShader.oneColor4_loc, [0.8, 0.8, 0.8, 1.0]);
					}
				}
			}
		}
		
		cacheKeys_count = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray.length;
		// Must applicate the transformMatrix of the reference object.***
	
		gl.uniform1i(standardShader.refMatrixType_loc, neoReference.refMatrixType);

		if (neoReference.refMatrixType === 1)
		{ gl.uniform3fv(standardShader.refTranslationVec_loc, neoReference.refTranslationVec); }
		else if (neoReference.refMatrixType === 2)
		{ gl.uniformMatrix4fv(standardShader.refMatrix_loc, false, neoReference.tMatrixAuxArray[refMatrixIdxKey]._floatArrays); }
		

		if (neoReference.moveVector !== undefined) 
		{
			gl.uniform1i(standardShader.hasAditionalMov_loc, true);
			gl.uniform3fv(standardShader.aditionalMov_loc, [neoReference.moveVector.x, neoReference.moveVector.y, neoReference.moveVector.z]); //.***
		}
		else 
		{
			gl.uniform1i(standardShader.hasAditionalMov_loc, false);
			gl.uniform3fv(standardShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		}

		for (var n=0; n<cacheKeys_count; n++) // Original.***
		{
			//var mesh_array = block.viArraysContainer._meshArrays[n];
			this.vbo_vi_cacheKey_aux = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];
			if (!this.vbo_vi_cacheKey_aux.isReadyPositions(gl, magoManager.vboMemoryManager) || !this.vbo_vi_cacheKey_aux.isReadyNormals(gl, magoManager.vboMemoryManager) || !this.vbo_vi_cacheKey_aux.isReadyFaces(gl, magoManager.vboMemoryManager))
			{ continue; }
			
			// Positions.***
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshVertexCacheKey);
			gl.vertexAttribPointer(standardShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
			//gl.vertexAttribPointer(standardShader.attribLocationCacheObj["position"], 3, gl.FLOAT, false,0,0);

			// Normals.***
			if (standardShader.normal3_loc !== -1) 
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshNormalCacheKey);
				gl.vertexAttribPointer(standardShader.normal3_loc, 3, gl.BYTE, true, 0, 0);
			}

			if (renderTexture && neoReference.hasTexture) 
			{
				if (block.vertexCount <= neoReference.vertexCount) 
				{
					var refVboData = neoReference.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];
					if (!refVboData.isReadyTexCoords(gl, magoManager.vboMemoryManager))
					{ continue; }

					gl.enableVertexAttribArray(standardShader.texCoord2_loc);
					gl.bindBuffer(gl.ARRAY_BUFFER, refVboData.meshTexcoordsCacheKey);
					gl.vertexAttribPointer(standardShader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
				}
				else 
				{
					if (standardShader.texCoord2_loc !== -1) { gl.disableVertexAttribArray(standardShader.texCoord2_loc); }
				}
			}
			else 
			{
				if (standardShader.texCoord2_loc !== -1) { gl.disableVertexAttribArray(standardShader.texCoord2_loc); }
			}

			// Indices.***
			var indicesCount;
			if (magoManager.isCameraMoving)// && !isInterior && magoManager.isCameraInsideBuilding)
			{
				if (magoManager.objectSelected === neoReference)
				{ indicesCount = this.vbo_vi_cacheKey_aux.indicesCount; }
				else
				{
					indicesCount = this.vbo_vi_cacheKey_aux.bigTrianglesIndicesCount;
					if (indicesCount > this.vbo_vi_cacheKey_aux.indicesCount)
					{ indicesCount = this.vbo_vi_cacheKey_aux.indicesCount; }
				}
			}
			else
			{
				if (magoManager.thereAreUrgentOctrees)
				{
					indicesCount = this.vbo_vi_cacheKey_aux.bigTrianglesIndicesCount;
					if (indicesCount > this.vbo_vi_cacheKey_aux.indicesCount)
					{ indicesCount = this.vbo_vi_cacheKey_aux.indicesCount; }
				}
				else 
				{
					indicesCount = this.vbo_vi_cacheKey_aux.indicesCount;
				}
			}

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshFacesCacheKey);
			gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
			//gl.drawElements(gl.LINES, this.vbo_vi_cacheKey_aux.indicesCount, gl.UNSIGNED_SHORT, 0); // Wireframe.***
		}

		neoReference.swapRenderingFase();
		if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && magoManager.objectSelected === neoReference)
		{
			this.disableStencilBuffer(gl);
			gl.disable(gl.POLYGON_OFFSET_FILL);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param neoRefList_array 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 * @param isInterior 변수
 * @param standardShader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 */
Renderer.prototype.depthRenderNeoRefListsAsimetricVersion = function(gl, neoReferencesMotherAndIndices, neoBuilding, magoManager,
	isInterior, standardShader, renderTexture, ssao_idx, maxSizeToRender, lod, refMatrixIdxKey) 
{
	if (!this.isReadyNeoRefList(neoReferencesMotherAndIndices))
	{ return; }

	var cacheKeys_count;
	//var reference;
	var block_idx;
	var block;
		
	// New version. Use occlussion indices.***
	//var visibleIndices_count = neoReferencesMotherAndIndices.neoRefsIndices.length; // no occludeCulling mode.***
	var visibleIndices_count = neoReferencesMotherAndIndices.currentVisibleIndices.length;

	for (var k=0; k<visibleIndices_count; k++) 
	{
		//var neoReference = neoReferencesMotherAndIndices.motherNeoRefsList[neoReferencesMotherAndIndices.neoRefsIndices[k]]; // no occludeCulling mode.***
		var neoReference = neoReferencesMotherAndIndices.motherNeoRefsList[neoReferencesMotherAndIndices.currentVisibleIndices[k]];
		if (!this.isReadyNeoReference(neoReference, magoManager))
		{ continue; }

		block_idx = neoReference._block_idx;
		block = neoBuilding.motherBlocksArray[block_idx];

		if (!this.isReadyBlock(block, neoReference, magoManager, maxSizeToRender))
		{ continue; }
		
		gl.uniform1i(standardShader.hasTexture_loc, false); //.***
		gl.uniform4fv(standardShader.color4Aux_loc, [0.0/255.0, 0.0/255.0, 0.0/255.0, 1.0]);


		cacheKeys_count = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray.length;
		// Must applicate the transformMatrix of the reference object.***
		// Must applicate the transformMatrix of the reference object.***
		gl.uniform1i(standardShader.refMatrixType_loc, neoReference.refMatrixType);

		if (neoReference.refMatrixType === 1)
		{ gl.uniform3fv(standardShader.refTranslationVec_loc, neoReference.refTranslationVec); }
		else if (neoReference.refMatrixType === 2)
		{ gl.uniformMatrix4fv(standardShader.refMatrix_loc, false, neoReference.tMatrixAuxArray[refMatrixIdxKey]._floatArrays); }

		if (neoReference.moveVector !== undefined) 
		{
			gl.uniform1i(standardShader.hasAditionalMov_loc, true);
			gl.uniform3fv(standardShader.aditionalMov_loc, [neoReference.moveVector.x, neoReference.moveVector.y, neoReference.moveVector.z]); //.***
		}
		else 
		{
			gl.uniform1i(standardShader.hasAditionalMov_loc, false);
			gl.uniform3fv(standardShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		}

		for (var n=0; n<cacheKeys_count; n++) // Original.***
		{
			//var mesh_array = block.viArraysContainer._meshArrays[n];
			this.vbo_vi_cacheKey_aux = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];
			if (!this.vbo_vi_cacheKey_aux.isReadyPositions(gl, magoManager.vboMemoryManager))
			{ continue; }

			if (!this.vbo_vi_cacheKey_aux.isReadyFaces(gl, magoManager.vboMemoryManager))
			{ continue; }
			
			// Positions.***
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshVertexCacheKey);
			gl.vertexAttribPointer(standardShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
			
			// Indices.***
			var indicesCount;
			if (magoManager.isCameraMoving)// && !isInterior && magoManager.isCameraInsideBuilding)
			{
				if (magoManager.objectSelected === neoReference)
				{ indicesCount = this.vbo_vi_cacheKey_aux.indicesCount; }
				else 
				{
					indicesCount = this.vbo_vi_cacheKey_aux.bigTrianglesIndicesCount;
					if (indicesCount > this.vbo_vi_cacheKey_aux.indicesCount)
					{ indicesCount = this.vbo_vi_cacheKey_aux.indicesCount; }
					
					//if(indicesCount === 0)
					//	indicesCount = this.vbo_vi_cacheKey_aux.indicesCount;
				}
			}
			else
			{
				indicesCount = this.vbo_vi_cacheKey_aux.indicesCount;
			}

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshFacesCacheKey);
			gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
			//gl.drawElements(gl.LINES, this.vbo_vi_cacheKey_aux.indicesCount, gl.UNSIGNED_SHORT, 0); // Wireframe.***
		}

		neoReference.swapRenderingFase();
	}
	
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param neoRefList_array 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 * @param isInterior 변수
 * @param standardShader 변수
 */
Renderer.prototype.renderNeoRefListsAsimetricVersionColorSelection = function(gl, lowestOctree, node, magoManager, isInterior, standardShader, maxSizeToRender, refMatrixIdxKey, glPrimitive) 
{
	var neoBuilding = node.data.neoBuilding;
	// render_neoRef
	var neoReferencesMotherAndIndices = lowestOctree.neoReferencesMotherAndIndices;

	if (!this.isReadyNeoRefList(neoReferencesMotherAndIndices))
	{ return; }

	// New version. Use occlussion indices.***
	var visibleIndices_count = neoReferencesMotherAndIndices.currentVisibleIndices.length;
	var selCandidates = magoManager.selectionCandidates;
	var idxKey;

	for (var k=0; k<visibleIndices_count; k++) 
	{
		var neoReference = neoReferencesMotherAndIndices.motherNeoRefsList[neoReferencesMotherAndIndices.currentVisibleIndices[k]];
		if (!this.isReadyNeoReference(neoReference, magoManager))
		{ continue; }
	
		neoReference.selColor4 = magoManager.selectionColor.getAvailableColor(neoReference.selColor4); // new.
		idxKey = magoManager.selectionColor.decodeColor3(neoReference.selColor4.r, neoReference.selColor4.g, neoReference.selColor4.b);
		selCandidates.setCandidates(idxKey, neoReference, lowestOctree, neoBuilding, node);
		
		if (neoReference.selColor4) 
		{
			//if(neoReference.color4.a < 255) // if transparent object, then skip. provisional.***
			//gl.uniform1i(standardShader.hasTexture_loc, false); //.***
			gl.uniform4fv(standardShader.color4Aux_loc, [neoReference.selColor4.r/255.0, neoReference.selColor4.g/255.0, neoReference.selColor4.b/255.0, 1.0]);
		}

		this.renderNeoReferenceAsimetricVersionColorSelection(gl, neoReference, neoReferencesMotherAndIndices, neoBuilding, magoManager, standardShader, maxSizeToRender, refMatrixIdxKey, glPrimitive);
		
		neoReference.swapRenderingFase();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param neoRefList_array 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 * @param isInterior 변수
 * @param standardShader 변수
 */
Renderer.prototype.renderNeoReferenceAsimetricVersionColorSelection = function(gl, neoReference, neoReferencesMotherAndIndices, neoBuilding, magoManager, standardShader, maxSizeToRender, refMatrixIdxKey, glPrimitive) 
{
	var cacheKeys_count;
	var block_idx;
	var block;

	block_idx = neoReference._block_idx;
	block = neoBuilding.motherBlocksArray[block_idx];

	if (!this.isReadyBlock(block, neoReference, magoManager, maxSizeToRender))
	{ return; }
	
	cacheKeys_count = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray.length;
	// Must applicate the transformMatrix of the reference object.***

	gl.uniform1i(standardShader.refMatrixType_loc, neoReference.refMatrixType);
	
	if (neoReference.refMatrixType === 1)
	{ gl.uniform3fv(standardShader.refTranslationVec_loc, neoReference.refTranslationVec); }
	else if (neoReference.refMatrixType === 2)
	{ gl.uniformMatrix4fv(standardShader.refMatrix_loc, false, neoReference.tMatrixAuxArray[refMatrixIdxKey]._floatArrays); }

	if (neoReference.moveVector !== undefined) 
	{
		gl.uniform1i(standardShader.hasAditionalMov_loc, true);
		gl.uniform3fv(standardShader.aditionalMov_loc, [neoReference.moveVector.x, neoReference.moveVector.y, neoReference.moveVector.z]); //.***
	}
	else 
	{
		gl.uniform1i(standardShader.hasAditionalMov_loc, false);
		gl.uniform3fv(standardShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
	}

	for (var n=0; n<cacheKeys_count; n++) // Original.***
	{
		//var mesh_array = block.viArraysContainer._meshArrays[n];
		this.vbo_vi_cacheKey_aux = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];

		if (!this.vbo_vi_cacheKey_aux.isReadyPositions(gl, magoManager.vboMemoryManager))
		{ continue; }
		
		if (!this.vbo_vi_cacheKey_aux.isReadyFaces(gl, magoManager.vboMemoryManager))
		{ continue; }

		// Positions.***
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshVertexCacheKey);
		gl.vertexAttribPointer(standardShader.position3_loc, 3, gl.FLOAT, false, 0, 0);

		// Indices.***
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vbo_vi_cacheKey_aux.meshFacesCacheKey);
		gl.drawElements(glPrimitive, this.vbo_vi_cacheKey_aux.indicesCount, gl.UNSIGNED_SHORT, 0); 
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param neoRefList_array 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 * @param isInterior 변수
 * @param standardShader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 */
Renderer.prototype.renderLodBuilding = function(gl, lodBuilding, magoManager, shader, ssao_idx, renderTexture) 
{
	if (lodBuilding.vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{
		return;
	}
	gl.frontFace(gl.CCW);
	// ssao_idx = -1 -> pickingMode.***
	// ssao_idx = 0 -> depth.***
	// ssao_idx = 1 -> ssao.***

	if (ssao_idx === 0) // depth.***
	{
		// 1) Position.*********************************************
		var vbo_vicky = lodBuilding.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.***
		if (!vbo_vicky.isReadyPositions(gl, magoManager.vboMemoryManager))
		{ return; }

		var vertices_count = vbo_vicky.vertexCount;
		if (vertices_count === 0) 
		{
			return;
		}

		gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshVertexCacheKey);
		gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);
		gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
	}
	else if (ssao_idx === 1) // ssao.***
	{
		var vbo_vicky = lodBuilding.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.***
		var vertices_count = vbo_vicky.vertexCount;

		if (vertices_count === 0) 
		{
			return;
		}
		
		if (!vbo_vicky.isReadyPositions(gl, magoManager.vboMemoryManager))
		{ return; }
		
		if (!vbo_vicky.isReadyNormals(gl, magoManager.vboMemoryManager))
		{ return; }
		
		if (!renderTexture && !vbo_vicky.isReadyColors(gl, magoManager.vboMemoryManager))
		{ return; }
		
		// 4) Texcoord.*********************************************
		if (renderTexture)
		{
			if (!vbo_vicky.isReadyTexCoords(gl, magoManager.vboMemoryManager))
			{ return; }
		}
		else 
		{
			gl.uniform1i(shader.bUse1Color_loc, false);
			gl.disableVertexAttribArray(shader.texCoord2_loc);
		}

		

		gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshVertexCacheKey);
		gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);

		gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshNormalCacheKey);
		gl.vertexAttribPointer(shader.normal3_loc, 3, gl.BYTE, true, 0, 0);

		if (vbo_vicky.meshColorCacheKey !== undefined )
		{
			gl.enableVertexAttribArray(shader.color4_loc);
			gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshColorCacheKey);
			gl.vertexAttribPointer(shader.color4_loc, 4, gl.UNSIGNED_BYTE, true, 0, 0);
		}
		
		if (renderTexture && vbo_vicky.meshTexcoordsCacheKey)
		{
			gl.disableVertexAttribArray(shader.color4_loc);
			gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshTexcoordsCacheKey);
			gl.vertexAttribPointer(shader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
		}

		gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
		/*
		gl.uniform1i(shader.bUse1Color_loc, true);
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 1.0, 1.0]); //.***
		gl.disableVertexAttribArray(shader.texCoord2_loc);
		gl.uniform1i(shader.hasTexture_loc, false);
		gl.drawArrays(gl.LINES, 0, vertices_count);
		gl.enableVertexAttribArray(shader.texCoord2_loc);
		*/
		
		gl.disableVertexAttribArray(shader.color4_loc);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param neoRefList_array 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 * @param isInterior 변수
 * @param standardShader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 */
Renderer.prototype.renderLodBuildingColorSelection = function(gl, lodBuilding, magoManager, shader)
{
	if (lodBuilding.vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{
		return;
	}
	gl.frontFace(gl.CCW);

	// 1) Position.*********************************************
	var vbo_vicky = lodBuilding.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.***
	if (!vbo_vicky.isReadyPositions(gl, magoManager.vboMemoryManager))
	{ return; }

	var vertices_count = vbo_vicky.vertexCount;
	if (vertices_count === 0) 
	{
		return;
	}

	gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshVertexCacheKey);
	gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param neoRefList_array 변수
 * @param magoManager 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 */
Renderer.prototype.renderObject = function(gl, renderable, magoManager, shader, ssao_idx, bRenderLines, primitiveType)
{
	var vbo_vicks_container = renderable.getVboKeysContainer();
	
	if (vbo_vicks_container === undefined)
	{ return; }
	
	if (vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{ return; }
	
	// ssao_idx = -1 -> pickingMode.***
	// ssao_idx = 0 -> depth.***
	// ssao_idx = 1 -> ssao.***
	if (bRenderLines === undefined)
	{ bRenderLines = false; }
	
	var vbosCount = vbo_vicks_container.getVbosCount();
	for (var i=0; i<vbosCount; i++)
	{
		// 1) Position.*********************************************
		var vbo_vicky = vbo_vicks_container.vboCacheKeysArray[i]; // there are only one.***
		if (!vbo_vicky.isReadyPositions(gl, magoManager.vboMemoryManager))
		{ return; }

		var vertices_count = vbo_vicky.vertexCount;
		if (vertices_count === 0) 
		{ return; }

		gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshVertexCacheKey);
		gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);

		if (ssao_idx === 1) // ssao.***
		{
			if (!vbo_vicky.isReadyNormals(gl, magoManager.vboMemoryManager)) // do this optional. TODO.***
			{ 
				//return;
				gl.disableVertexAttribArray(shader.normal3_loc);
				gl.uniform1i(shader.bUseNormal_loc, false);
			}
			else 
			{
				gl.enableVertexAttribArray(shader.normal3_loc);
				gl.uniform1i(shader.bUseNormal_loc, true);
				gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshNormalCacheKey);
				gl.vertexAttribPointer(shader.normal3_loc, 3, gl.BYTE, true, 0, 0);
			}
			
			if (!vbo_vicky.isReadyColors(gl, magoManager.vboMemoryManager)) // do this optional. TODO.***
			{ 
				gl.disableVertexAttribArray(shader.color4_loc);
			}
			else 
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshColorCacheKey);
				gl.vertexAttribPointer(shader.color4_loc, 4, gl.UNSIGNED_BYTE, true, 0, 0);
			}
		}
		
		if (bRenderLines === false)
		{
			if (vbo_vicky.indicesCount > 0)
			{
				if (!vbo_vicky.isReadyFaces(gl, magoManager.vboMemoryManager)) 
				{ return; }
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vbo_vicky.meshFacesCacheKey);
				gl.drawElements(gl.TRIANGLES, vbo_vicky.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
			}
			else 
			{
				gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
			}
		}
		else 
		{
			/*
			if (!vbo_vicky.isReadyFaces(gl, magoManager.vboMemoryManager)) 
				{ return; }
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vbo_vicky.meshFacesCacheKey);
				gl.drawElements(gl.LINE_STRIP, vbo_vicky.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.***
				*/
			gl.drawArrays(gl.LINE_STRIP, 0, vertices_count);
		}
	}
};
























'use strict';

/**
 * ??
 * @class SceneState
 */
var SceneState = function() 
{
	if (!(this instanceof SceneState)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.gl;

	// this contains the model matrices and camera position.***
	this.modelViewProjRelToEyeMatrix = new Matrix4(); // created as identity matrix.***
	this.modelViewRelToEyeMatrix = new Matrix4(); // created as identity matrix.***
	this.modelViewRelToEyeMatrixInv = new Matrix4(); // created as identity matrix.***
	this.modelViewMatrix = new Matrix4(); // created as identity matrix.***
	this.modelViewMatrixInv = new Matrix4(); // created as identity matrix.***
	this.projectionMatrix = new Matrix4(); // created as identity matrix.***
	this.modelViewProjMatrix = new Matrix4(); // created as identity matrix.***
	this.normalMatrix4 = new Matrix4(); // created as identity matrix.***
	this.identityMatrix4 = new Matrix4(); // created as identity matrix.***

	this.encodedCamPosHigh = new Float32Array([0.0, 0.0, 0.0]);
	this.encodedCamPosLow = new Float32Array([0.0, 0.0, 0.0]);
	
	this.camera = new Camera();
	this.drawingBufferWidth = new Int32Array([1000]);
	this.drawingBufferHeight = new Int32Array([1000]);
	this.mouseAction = new MouseAction();
	
	// lighting & ssao.***
	this.ambientReflectionCoef = 0.45; // 0.2.
	this.diffuseReflectionCoef = 0.75; // 1.0
	this.specularReflectionCoef = 0.6; // 0.7
	this.specularColor = new Float32Array([0.7, 0.7, 0.7]);
	this.ssaoRadius = 0.15;
	this.shininessValue = 40.0;
	this.ssaoNoiseScale2 = new Float32Array([1.0, 1.0]); // [this.depthFboNeo.width[0]/this.noiseTexture.width, this.depthFboNeo.height[0]/this.noiseTexture.height]
	this.ssaoKernel16 = [ 0.33, 0.0, 0.85,
		0.25, 0.3, 0.5,
		0.1, 0.3, 0.85,
		-0.15, 0.2, 0.85,
		-0.33, 0.05, 0.6,
		-0.1, -0.15, 0.85,
		-0.05, -0.32, 0.25,
		0.2, -0.15, 0.85,
		0.6, 0.0, 0.55,
		0.5, 0.6, 0.45,
		-0.01, 0.7, 0.35,
		-0.33, 0.5, 0.45,
		-0.45, 0.0, 0.55,
		-0.65, -0.5, 0.7,
		0.0, -0.5, 0.55,
		0.33, 0.3, 0.35];
		
	this.ssaoSphereKernel32 = [ 0.33, 0.0, 0.85,
		0.25, 0.3, 0.5,
		0.1, 0.3, 0.85,
		-0.15, 0.2, 0.85,
		-0.33, 0.05, 0.6,
		-0.1, -0.15, 0.85,
		-0.05, -0.32, 0.25,
		0.2, -0.15, 0.85,
		0.6, 0.0, 0.55,
		0.5, 0.6, 0.45,
		-0.01, 0.7, 0.35,
		-0.33, 0.5, 0.45,
		-0.45, 0.0, 0.55,
		-0.65, -0.5, 0.7,
		0.0, -0.5, 0.55,
		0.33, 0.3, 0.35,
		
		 0.33, 0.0, -0.85,
		0.25, 0.3, -0.5,
		0.1, 0.3, -0.85,
		-0.15, 0.2, -0.85,
		-0.33, 0.05, -0.6,
		-0.1, -0.15, -0.85,
		-0.05, -0.32, -0.25,
		0.2, -0.15, -0.85,
		0.6, 0.0, -0.55,
		0.5, 0.6, -0.45,
		-0.01, 0.7, -0.35,
		-0.33, 0.5, -0.45,
		-0.45, 0.0, -0.55,
		-0.65, -0.5, -0.7,
		0.0, -0.5, -0.55,
		0.33, 0.3, -0.35];
		
	this.bMust = false;
	
	// webWorldWind vars.***
	this.dc;
	
	// insertIssue states.***
	this.insertIssueState = 0; // 0 = no started. 1 = started.***
	
	// provisionally.***
	this.textureFlipYAxis = false;
	
	// mouse.***
	this.mouseButton = -1;
	
};

































'use strict';

// NO USED.

/**
 * 어떤 일을 하고 있습니까?
 * @class Selection
 */
var Selection = function() 
{
	if (!(this instanceof Selection)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.drawing_height;
	this.drawing_width;
	this.GAIA_selectFrameBuffer;
	this.GAIA_selectRenderBuffer;
	this.GAIA_selectRttTexture;
	
	this.currentByteColorPicked = new Uint8Array(4);
	this.currentSelectedObj_idx = -1;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param drawingBufferWidth 변수
 * @param drawingBufferHeight 변수
 */
Selection.prototype.init = function(gl, drawingBufferWidth, drawingBufferHeight) 
{
	// http://www.webglacademy.com/courses.php?courses=0|1|20|2|3|4|23|5|6|7|10#10
	this.drawing_height = drawingBufferHeight;
	this.drawing_width = drawingBufferWidth;
	//this.lastCapturedColourMap = new Uint8Array(this.drawing_width * this.drawing_height * 4);
	this.GAIA_selectFrameBuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, this.GAIA_selectFrameBuffer);
	
	this.GAIA_selectRenderBuffer = gl.createRenderbuffer();
	gl.bindRenderbuffer(gl.RENDERBUFFER, this.GAIA_selectRenderBuffer);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.drawing_width, this.drawing_height);

	this.GAIA_selectRttTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, this.GAIA_selectRttTexture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.drawing_width, this.drawing_height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.GAIA_selectRttTexture, 0);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.GAIA_selectRenderBuffer);
	
	// Finally...
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};
'use strict';

/**
 * SelectionCandidates
 * 
 * @alias SelectionCandidates
 * @class SelectionCandidates
 */
var SelectionCandidates = function() 
{
	if (!(this instanceof SelectionCandidates)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.referencesMap = {};
	this.octreesMap = {};
	this.buildingsMap = {};
	this.nodesMap = {};
	
	this.currentReferenceSelected;
	this.currentOctreeSelected;
	this.currentBuildingSelected;
	this.currentNodeSelected;
};

/**
 * SelectionCandidates
 * 
 * @alias SelectionCandidates
 * @class SelectionCandidates
 */
SelectionCandidates.prototype.setCandidates = function(idxKey, reference, octree, building, node)
{
	if (reference)
	{
		this.referencesMap[idxKey] = reference;
	}
	
	if (octree)
	{
		this.octreesMap[idxKey] = octree;
	}
	
	if (building)
	{
		this.buildingsMap[idxKey] = building;
	}
	
	if (node)
	{
		this.nodesMap[idxKey] = node;
	}
};

/**
 * SelectionCandidates
 * 
 * @alias SelectionCandidates
 * @class SelectionCandidates
 */
SelectionCandidates.prototype.clearCandidates = function()
{
	this.referencesMap = {};
	this.octreesMap = {};
	this.buildingsMap = {};
	this.nodesMap = {};
};

/**
 * SelectionCandidates
 * 
 * @alias SelectionCandidates
 * @class SelectionCandidates
 */
SelectionCandidates.prototype.selectObjects = function(idxKey)
{
	this.currentReferenceSelected = this.referencesMap[idxKey];
	this.currentOctreeSelected = this.octreesMap[idxKey];
	this.currentBuildingSelected = this.buildingsMap[idxKey];
	this.currentNodeSelected = this.nodesMap[idxKey];
};

/**
 * SelectionCandidates
 * 
 * @alias SelectionCandidates
 * @class SelectionCandidates
 */
SelectionCandidates.prototype.clearCurrents = function(idxKey)
{
	this.currentReferenceSelected = undefined;
	this.currentOctreeSelected = undefined;
	this.currentBuildingSelected = undefined;
	this.currentNodeSelected = undefined;
};
'use strict';

/**
 * Returns the first parameter if not undefined, otherwise the second parameter.
 * Useful for setting a default value for a parameter.
 *
 * @exports defaultValue
 *
 * @param {*} a
 * @param {*} b
 * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter.
 *
 * @example
 * param = defaultValue(param, 'default');
 * 
 * @copyright https://github.com/AnalyticalGraphicsInc/cesium
 */
function defaultValue(a, b) 
{
	if (a !== undefined) 
	{
		return a;
	}
	return b;
}
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ByteColor
 */
var ByteColor = function() 
{
	if (!(this instanceof ByteColor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.ByteR = 0;
	this.ByteG = 0;
	this.ByteB = 0;
	this.ByteAlfa = 255;
};

/**
 * 어떤 일을 하고 있습니까?
 */
ByteColor.prototype.destroy = function() 
{
	this.ByteR = null;
	this.ByteG = null;
	this.ByteB = null;
	this.ByteAlfa = null;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param byteRed 변수
 * @param byteGreen 변수
 * @param byteBlue 변수
 */
ByteColor.prototype.set = function(byteRed, byteGreen, byteBlue) 
{
	this.ByteR = byteRed;
	this.ByteG = byteGreen;
	this.ByteB = byteBlue;
};



/**
 * 어떤 일을 하고 있습니까?
 * @class Point3DAux
 */
var Point3DAux = function() 
{
	if (!(this instanceof Point3DAux)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.x = 0.0;
	this.y = 0.0;
	this.z = 0.0;
	//this.IdxInIist;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class TTriangle
 */
var TTriangle = function() 
{
	if (!(this instanceof TTriangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.mVertex1;
	this.mVertex2;
	this.mVertex3;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param vtx1 변수
 * @param vtx2 변수
 * @param vtx3 변수
 */
TTriangle.prototype.setVertices = function(vtx1, vtx2, vtx3) 
{
	this.mVertex1 = vtx1;
	this.mVertex2 = vtx2;
	this.mVertex3 = vtx3;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TTriangle.prototype.invert = function() 
{
	var vertexAux = this.mVertex2;
	this.mVertex2 = this.mVertex3;
	this.mVertex3 = vertexAux;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class TTrianglesList
 */
var TTrianglesList = function() 
{
	if (!(this instanceof TTrianglesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.tTrianglesArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns tTri
 */
TTrianglesList.prototype.newTTriangle = function() 
{
	var tTri = new TTriangle();
	this.tTrianglesArray.push(tTri);
	return tTri;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TTrianglesList.prototype.invertTrianglesSense= function() 
{
	for (var i = 0, triCount = this.tTrianglesArray.length; i < triCount; i++) 
	{
		this.tTrianglesArray[i].invert();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param idx 변수
 * @returns tTrianglesArray[idx]
 */
TTrianglesList.prototype.getTTriangle = function(idx) 
{
	if (idx >= 0 && idx < this.tTrianglesArray.length) 
	{
		return this.tTrianglesArray[idx];
	}
	else
	{
		return undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class TTrianglesMatrix
 */
var TTrianglesMatrix = function() 
{
	if (!(this instanceof TTrianglesMatrix)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.tTrianglesListsArray = [];
	// SCRATX.*********************
	this.totalTTrianglesArraySC = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns tTrianglesList
 */
TTrianglesMatrix.prototype.newTTrianglesList = function() 
{
	var tTrianglesList = new TTrianglesList();
	this.tTrianglesListsArray.push(tTrianglesList);
	return tTrianglesList;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TTrianglesMatrix.prototype.invertTrianglesSense = function() 
{
	for (var i = 0, tTriListsCount = this.tTrianglesListsArray.length; i < tTriListsCount; i++) 
	{
		this.tTrianglesListsArray[i].invertTrianglesSense();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param resultTotalTTrianglesArray 변수
 * @returns resultTotalTTrianglesArray
 */
TTrianglesMatrix.prototype.getTotalTTrianglesArray = function(resultTotalTTrianglesArray) 
{
	for (var i = 0, tTriListsCount = this.tTrianglesListsArray.length; i < tTriListsCount; i++) 
	{
		for (var j = 0, tTrianglesCount = this.tTrianglesListsArray[i].tTrianglesArray.length; j < tTrianglesCount; j++) 
		{
			var tTriangle = this.tTrianglesListsArray[i].getTTriangle(j);
			resultTotalTTrianglesArray.push(tTriangle);
		}
	}

	return resultTotalTTrianglesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns shortArray
 */
TTrianglesMatrix.prototype.getVBOIndicesShortArray = function() 
{
	this.totalTTrianglesArraySC.length = 0;
	this.totalTTrianglesArraySC = this.getTotalTTrianglesArray(this.totalTTrianglesArraySC);

	var tTriangle;
	var tTrianglesCount = this.totalTTrianglesArraySC.length;
	var shortArray = new Uint16Array(tTrianglesCount * 3);
	for (var i = 0; i < tTrianglesCount; i++) 
	{
		tTriangle = this.totalTTrianglesArraySC[i];
		shortArray[i*3] = tTriangle.mVertex1.mIdxInList;
		shortArray[i*3+1] = tTriangle.mVertex2.mIdxInList;
		shortArray[i*3+2] = tTriangle.mVertex3.mIdxInList;
	}

	return shortArray;
};



'use strict';

var ManagerUtils = function() 
{
	// sqrtTable.
	this.sqrtTable = [];
	// make 100 values.
	var increValue = 0.01;
	for (var i=0; i<101; i++)
	{
		this.sqrtTable[i] = Math.sqrt(1+(increValue*i)*(increValue*i));
	}
	
};

ManagerUtils.pointToGeographicCoord = function(point, resultGeographicCoord, magoManager) 
{
	if (resultGeographicCoord === undefined)
	{ resultGeographicCoord = new GeographicCoord(); }
	
	if (magoManager.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		var globe = magoManager.wwd.globe;
		var origin = new WorldWind.Position();
		origin = globe.computePositionFromPoint(point.x, point.y, point.z, origin);
		resultGeographicCoord.setLonLatAlt(origin.longitude, origin.latitude, origin.altitude);
	}
	else if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
	{
		var cartographic = Cesium.Cartographic.fromCartesian(new Cesium.Cartesian3(point.x, point.y, point.z));
		resultGeographicCoord.setLonLatAlt(cartographic.longitude * (180.0/Math.PI), cartographic.latitude * (180.0/Math.PI), cartographic.height);
	}
	else if (magoManager.configInformation.geo_view_library === Constant.MAGOWORLD)
	{
		var cartographic = Globe.CartesianToGeographicWgs84(point.x, point.y, point.z, cartographic);
		resultGeographicCoord.setLonLatAlt(cartographic.longitude, cartographic.latitude, cartographic.height);
	}
	
	return resultGeographicCoord;
};

ManagerUtils.geographicCoordToWorldPoint = function(longitude, latitude, altitude, resultWorldPoint, magoManager) 
{
	if (resultWorldPoint === undefined)
	{ resultWorldPoint = new Point3D(); }

	var cartesian = Globe.geographicToCartesianWgs84(longitude, latitude, altitude, undefined);
	
	if (magoManager.configInformation !== undefined && magoManager.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		resultWorldPoint.set(cartesian[1], cartesian[2], cartesian[0]);
		return resultWorldPoint;
	}
	
	resultWorldPoint.set(cartesian[0], cartesian[1], cartesian[2]);
	
	return resultWorldPoint;
};

ManagerUtils.getTransformationMatrixInPoint = function(point, resultTMatrix, resultMatrixInv, magoManager) 
{
	if (magoManager.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		;//
	}
	else if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
	{
		if (resultTMatrix === undefined)
		{ resultTMatrix = new Matrix4(); }
		
		Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(point.x, point.y, point.z), undefined, resultTMatrix._floatArrays);
		
		if (resultMatrixInv)
		{
			Cesium.Matrix4.inverseTransformation(resultTMatrix._floatArrays, resultMatrixInv._floatArrays);
		}
	}
	
	return resultTMatrix;
};

ManagerUtils.translatePivotPointGeoLocationData = function(geoLocationData, newPivotPoint) 
{
	// this function NO modifies the geographic coords.***
	// "newPivotPoint" is in buildingCoords.***
	// "newPivotPoint" is the desired position of the new origen of coords, for example:
	// in a building you can desire the center of the bbox as the origin of the coords.***
	if (geoLocationData === undefined)
	{ return; }

	var rawTranslation = new Point3D();
	rawTranslation.set(-newPivotPoint.x, -newPivotPoint.y, -newPivotPoint.z);

	geoLocationData.pivotPointTraslation = rawTranslation;
	geoLocationData.doEffectivePivotPointTranslation();
};

ManagerUtils.calculateGeoLocationMatrixAtWorldPosition = function(worldPosition, resultGeoLocMatrix, magoManager) 
{
	// this function calculates the transformation matrix for (x, y, z) coordinate, that has NO heading, pitch or roll rotations.
	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }

	if (magoManager.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		// * if this in webWorldWind:
		var xAxis = new WorldWind.Vec3(0, 0, 0),
			yAxis = new WorldWind.Vec3(0, 0, 0),
			zAxis = new WorldWind.Vec3(0, 0, 0);
		var tMatrix = WorldWind.Matrix.fromIdentity();
		
		WorldWind.WWMath.localCoordinateAxesAtPoint([worldPosition.x, worldPosition.y, worldPosition.z], magoManager.wwd.globe, xAxis, yAxis, zAxis);
				
		tMatrix.set(
			xAxis[0], yAxis[0], zAxis[0], worldPosition.x,
			xAxis[1], yAxis[1], zAxis[1], worldPosition.y,
			xAxis[2], yAxis[2], zAxis[2], worldPosition.z,
			0, 0, 0, 1);
		
		var tMatrixColMajorArray = WorldWind.Matrix.fromIdentity();
		tMatrixColMajorArray = tMatrix.columnMajorComponents(tMatrixColMajorArray);
		resultGeoLocMatrix.setByFloat32Array(tMatrixColMajorArray);
		return resultGeoLocMatrix;
	}

	if (magoManager.globe === undefined)
	{ magoManager.globe = new Globe(); }
	magoManager.globe.transformMatrixAtCartesianPointWgs84(worldPosition.x, worldPosition.y, worldPosition.z, resultGeoLocMatrix._floatArrays);
	
	return resultGeoLocMatrix;
};

ManagerUtils.calculateGeoLocationMatrixAtLonLatAlt = function(longitude, latitude, altitude, resultGeoLocMatrix, magoManager) 
{
	// this function calculates the transformation matrix for (longitude, latitude, altitude) coordinate, that has NO heading, pitch or roll rotations.
	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }
	
	var worldPosition;
	worldPosition = this.geographicCoordToWorldPoint(longitude, latitude, altitude, worldPosition, magoManager);
	resultGeoLocMatrix = ManagerUtils.calculateGeoLocationMatrixAtWorldPosition(worldPosition, resultGeoLocMatrix, magoManager);
	
	return resultGeoLocMatrix;
};

ManagerUtils.calculateTransformMatrixAtWorldPosition = function(worldPosition, heading, pitch, roll, resultGeoLocMatrix, resultTransformMatrix, magoManager) 
{
	// This function calculates the "resultGeoLocMatrix" & "resultTransformMatrix".
	// note: "resultGeoLocMatrix" is the transformMatrix without the heading, pitch, roll rotations.
	// note: "resultTransformMatrix" is the transformMatrix including the heading, pitch, roll rotations.
	var xRotMatrix = new Matrix4();  // created as identity matrix.
	var yRotMatrix = new Matrix4();  // created as identity matrix.
	var zRotMatrix = new Matrix4();  // created as identity matrix.
	
	if (heading !== undefined && heading !== 0)
	{ zRotMatrix.rotationAxisAngDeg(heading, 0.0, 0.0, 1.0); }

	if (pitch !== undefined && pitch !== 0)
	{ xRotMatrix.rotationAxisAngDeg(pitch, 1.0, 0.0, 0.0); }

	if (roll !== undefined && roll !== 0)
	{ yRotMatrix.rotationAxisAngDeg(roll, 0.0, 1.0, 0.0); }

	/*
	if (heading !== undefined && heading !== 0)
	{ zRotMatrix.rotationAxisAngDeg(heading, 0.0, 0.0, -1.0); }

	if (pitch !== undefined && pitch !== 0)
	{ xRotMatrix.rotationAxisAngDeg(pitch, -1.0, 0.0, 0.0); }

	if (roll !== undefined && roll !== 0)
	{ yRotMatrix.rotationAxisAngDeg(roll, 0.0, -1.0, 0.0); }
	*/

	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }  // created as identity matrix.
	
	if (resultTransformMatrix === undefined)
	{ resultTransformMatrix = new Matrix4(); }  // created as identity matrix.

	// 1rst, calculate the transformation matrix for the location.
	resultGeoLocMatrix = ManagerUtils.calculateGeoLocationMatrixAtWorldPosition(worldPosition, resultGeoLocMatrix, magoManager);
	
	resultTransformMatrix.copyFromMatrix4(resultGeoLocMatrix);
	var zRotatedTMatrix;
	var zxRotatedTMatrix;
	var zxyRotatedTMatrix;

	zRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(resultTransformMatrix, zRotatedTMatrix);
	zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
	zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
	
	resultTransformMatrix = zxyRotatedTMatrix;
	return resultTransformMatrix;
};

ManagerUtils.calculateGeoLocationData = function(longitude, latitude, altitude, heading, pitch, roll, resultGeoLocationData, magoManager) 
{
	// This function calculates all data and matrices for the location(longitude, latitude, altitude) and rotation(heading, pitch, roll).
	if (resultGeoLocationData === undefined)
	{ resultGeoLocationData = new GeoLocationData(); }

	// 0) Position.********************************************************************************************
	if (resultGeoLocationData.geographicCoord === undefined)
	{ resultGeoLocationData.geographicCoord = new GeographicCoord(); }

	if (longitude !== undefined)
	{ resultGeoLocationData.geographicCoord.longitude = longitude; }
	else 
	{ longitude = resultGeoLocationData.geographicCoord.longitude; }

	if (latitude !== undefined)
	{ resultGeoLocationData.geographicCoord.latitude = latitude; }
	else 
	{ latitude = resultGeoLocationData.geographicCoord.latitude; }

	if (altitude !== undefined)
	{ resultGeoLocationData.geographicCoord.altitude = altitude; }
	else 
	{ altitude = resultGeoLocationData.geographicCoord.altitude; }

	if (heading !== undefined)
	{ resultGeoLocationData.heading = heading; }

	if (pitch !== undefined)
	{ resultGeoLocationData.pitch = pitch; }

	if (roll !== undefined)
	{ resultGeoLocationData.roll = roll; }

	if (resultGeoLocationData.geographicCoord.longitude === undefined || resultGeoLocationData.geographicCoord.latitude === undefined)
	{ return; }
	
	if (magoManager.configInformation === undefined)
	{ return; }

	resultGeoLocationData.position = this.geographicCoordToWorldPoint(longitude, latitude, altitude, resultGeoLocationData.position, magoManager);
	
	// High and Low values of the position.********************************************************************
	if (resultGeoLocationData.positionHIGH === undefined)
	{ resultGeoLocationData.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); }
	if (resultGeoLocationData.positionLOW === undefined)
	{ resultGeoLocationData.positionLOW = new Float32Array([0.0, 0.0, 0.0]); }
	this.calculateSplited3fv([resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z], resultGeoLocationData.positionHIGH, resultGeoLocationData.positionLOW);

	// Determine the elevation of the position.***********************************************************
	//var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	//var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------
	if (resultGeoLocationData.tMatrix === undefined)
	{ resultGeoLocationData.tMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrix === undefined)
	{ resultGeoLocationData.geoLocMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrixInv === undefined)
	{ resultGeoLocationData.geoLocMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrixInv.Identity(); }

	//---------------------------------------------------------

	if (resultGeoLocationData.tMatrixInv === undefined)
	{ resultGeoLocationData.tMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrixInv.Identity(); }

	if (resultGeoLocationData.rotMatrix === undefined)
	{ resultGeoLocationData.rotMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrix.Identity(); }

	if (resultGeoLocationData.rotMatrixInv === undefined)
	{ resultGeoLocationData.rotMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrixInv.Identity(); }

	// 1rst, calculate the transformation matrix for the location.
	resultGeoLocationData.tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(resultGeoLocationData.position, resultGeoLocationData.heading, resultGeoLocationData.pitch, resultGeoLocationData.roll, 
		resultGeoLocationData.geoLocMatrix, resultGeoLocationData.tMatrix, magoManager);
	resultGeoLocationData.rotMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);
	resultGeoLocationData.rotMatrix._floatArrays[12] = 0;
	resultGeoLocationData.rotMatrix._floatArrays[13] = 0;
	resultGeoLocationData.rotMatrix._floatArrays[14] = 0;
		
	// now calculate the inverse matrices.
	if (magoManager.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		// * if this in webWorldWind:
		var tMatrixInv = WorldWind.Matrix.fromIdentity();
		tMatrixInv.invertMatrix(resultGeoLocationData.tMatrix._floatArrays);
		resultGeoLocationData.tMatrixInv.setByFloat32Array(tMatrixInv);
		
		var rotMatrixInv = WorldWind.Matrix.fromIdentity();
		rotMatrixInv.invertMatrix(resultGeoLocationData.rotMatrix._floatArrays);
		resultGeoLocationData.rotMatrixInv.setByFloat32Array(rotMatrixInv);
		
		var geoLocMatrixInv = WorldWind.Matrix.fromIdentity();
		geoLocMatrixInv.invertMatrix(resultGeoLocationData.geoLocMatrix._floatArrays);
		resultGeoLocationData.geoLocMatrixInv.setByFloat32Array(geoLocMatrixInv);
	}
	else if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
	{
		// *if this in Cesium:
		Cesium.Matrix4.inverseTransformation(resultGeoLocationData.tMatrix._floatArrays, resultGeoLocationData.tMatrixInv._floatArrays);
		Cesium.Matrix4.inverseTransformation(resultGeoLocationData.rotMatrix._floatArrays, resultGeoLocationData.rotMatrixInv._floatArrays);
		Cesium.Matrix4.inverseTransformation(resultGeoLocationData.geoLocMatrix._floatArrays, resultGeoLocationData.geoLocMatrixInv._floatArrays);
	}

	// finally assing the pivotPoint.***
	if (resultGeoLocationData.pivotPoint === undefined)
	{ resultGeoLocationData.pivotPoint = new Point3D(); }

	resultGeoLocationData.pivotPoint.set(resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z);
	resultGeoLocationData.doEffectivePivotPointTranslation();
	
	return resultGeoLocationData;
};

ManagerUtils.calculateGeoLocationDataByAbsolutePoint = function(absoluteX, absoluteY, absoluteZ, resultGeoLocationData, magoManager) 
{

	if (resultGeoLocationData === undefined)
	{ resultGeoLocationData = new GeoLocationData(); }

	// 0) Position.********************************************************************************************
	if (resultGeoLocationData.geographicCoord === undefined)
	{ resultGeoLocationData.geographicCoord = new GeographicCoord(); }
	
	if (magoManager.configInformation === undefined)
	{ return; }
	
	if (resultGeoLocationData.position === undefined)
	{ resultGeoLocationData.position = new Point3D(); }
		
	resultGeoLocationData.position.x = absoluteX;
	resultGeoLocationData.position.y = absoluteY;
	resultGeoLocationData.position.z = absoluteZ;
		
	if (magoManager.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		var globe = magoManager.wwd.globe;
		var resultCartographic = new WorldWind.Vec3(0, 0, 0);
		resultCartographic = globe.computePositionFromPoint(absoluteX, absoluteY, absoluteZ, resultCartographic);
		resultGeoLocationData.geographicCoord.longitude = resultCartographic.longitude;
		resultGeoLocationData.geographicCoord.latitude = resultCartographic.latitude;
		resultGeoLocationData.geographicCoord.altitude = resultCartographic.altitude;
	}
	else if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
	{
		// *if this in Cesium:
		//resultGeoLocationData.position = Cesium.Cartesian3.fromDegrees(resultGeoLocationData.geographicCoord.longitude, resultGeoLocationData.geographicCoord.latitude, resultGeoLocationData.geographicCoord.altitude);
		// must find cartographic data.***
		var cartographic = new Cesium.Cartographic();
		var cartesian = new Cesium.Cartesian3();
		cartesian.x = absoluteX;
		cartesian.y = absoluteY;
		cartesian.z = absoluteZ;
		cartographic = Cesium.Cartographic.fromCartesian(cartesian, magoManager.scene._globe._ellipsoid, cartographic);
		resultGeoLocationData.geographicCoord.longitude = cartographic.longitude * 180.0/Math.PI;
		resultGeoLocationData.geographicCoord.latitude = cartographic.latitude * 180.0/Math.PI;
		resultGeoLocationData.geographicCoord.altitude = cartographic.height;
	}

	// High and Low values of the position.********************************************************************
	if (resultGeoLocationData.positionHIGH === undefined)
	{ resultGeoLocationData.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); }
	if (resultGeoLocationData.positionLOW === undefined)
	{ resultGeoLocationData.positionLOW = new Float32Array([0.0, 0.0, 0.0]); }
	this.calculateSplited3fv([resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z], resultGeoLocationData.positionHIGH, resultGeoLocationData.positionLOW);

	// Determine the elevation of the position.***********************************************************
	//var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	//var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------
	if (resultGeoLocationData.tMatrix === undefined)
	{ resultGeoLocationData.tMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrix === undefined)
	{ resultGeoLocationData.geoLocMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrixInv === undefined)
	{ resultGeoLocationData.geoLocMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrixInv.Identity(); }

	//---------------------------------------------------------

	if (resultGeoLocationData.tMatrixInv === undefined)
	{ resultGeoLocationData.tMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrixInv.Identity(); }

	if (resultGeoLocationData.rotMatrix === undefined)
	{ resultGeoLocationData.rotMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrix.Identity(); }

	if (resultGeoLocationData.rotMatrixInv === undefined)
	{ resultGeoLocationData.rotMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrixInv.Identity(); }

	var xRotMatrix = new Matrix4();  // created as identity matrix.***
	var yRotMatrix = new Matrix4();  // created as identity matrix.***
	var zRotMatrix = new Matrix4();  // created as identity matrix.***

	if (resultGeoLocationData.heading !== undefined && resultGeoLocationData.heading !== 0)
	{
		zRotMatrix.rotationAxisAngDeg(resultGeoLocationData.heading, 0.0, 0.0, -1.0);
	}

	if (resultGeoLocationData.pitch !== undefined && resultGeoLocationData.pitch !== 0)
	{
		xRotMatrix.rotationAxisAngDeg(resultGeoLocationData.pitch, -1.0, 0.0, 0.0);
	}

	if (resultGeoLocationData.roll !== undefined && resultGeoLocationData.roll !== 0)
	{
		yRotMatrix.rotationAxisAngDeg(resultGeoLocationData.roll, 0.0, -1.0, 0.0);
	}
	
	if (magoManager.configInformation.geo_view_library === Constant.WORLDWIND)
	{
		// * if this in webWorldWind:
		var xAxis = new WorldWind.Vec3(0, 0, 0),
			yAxis = new WorldWind.Vec3(0, 0, 0),
			zAxis = new WorldWind.Vec3(0, 0, 0);
		var rotMatrix = WorldWind.Matrix.fromIdentity();
		var tMatrix = WorldWind.Matrix.fromIdentity();
		
		WorldWind.WWMath.localCoordinateAxesAtPoint([resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z], magoManager.wwd.globe, xAxis, yAxis, zAxis);

		rotMatrix.set(
			xAxis[0], yAxis[0], zAxis[0], 0,
			xAxis[1], yAxis[1], zAxis[1], 0,
			xAxis[2], yAxis[2], zAxis[2], 0,
			0, 0, 0, 1); 
				
		tMatrix.set(
			xAxis[0], yAxis[0], zAxis[0], resultGeoLocationData.position.x,
			xAxis[1], yAxis[1], zAxis[1], resultGeoLocationData.position.y,
			xAxis[2], yAxis[2], zAxis[2], resultGeoLocationData.position.z,
			0, 0, 0, 1);
				
		var columnMajorArray = WorldWind.Matrix.fromIdentity(); 
		columnMajorArray = rotMatrix.columnMajorComponents(columnMajorArray); // no used.***
			
		var matrixInv = WorldWind.Matrix.fromIdentity();
		matrixInv.invertMatrix(rotMatrix);
		var columnMajorArrayAux_inv = WorldWind.Matrix.fromIdentity();
		var columnMajorArray_inv = matrixInv.columnMajorComponents(columnMajorArrayAux_inv); 
		
		var tMatrixColMajorArray = WorldWind.Matrix.fromIdentity();
		tMatrixColMajorArray = tMatrix.columnMajorComponents(tMatrixColMajorArray);
		resultGeoLocationData.tMatrix.setByFloat32Array(tMatrixColMajorArray);
		
		resultGeoLocationData.geoLocMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix); // "geoLocMatrix" is the pure transformation matrix, without heading or pitch or roll.***

		var zRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(resultGeoLocationData.tMatrix, zRotatedTMatrix);
		var zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
		var zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
		resultGeoLocationData.tMatrix = zxyRotatedTMatrix;

		resultGeoLocationData.rotMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);
		resultGeoLocationData.rotMatrix._floatArrays[12] = 0;
		resultGeoLocationData.rotMatrix._floatArrays[13] = 0;
		resultGeoLocationData.rotMatrix._floatArrays[14] = 0;
		
		// now calculate the inverses of the matrices.***
		var tMatrixInv = WorldWind.Matrix.fromIdentity();
		tMatrixInv.invertMatrix(resultGeoLocationData.tMatrix._floatArrays);
		resultGeoLocationData.tMatrixInv.setByFloat32Array(tMatrixInv);
		
		var rotMatrixInv = WorldWind.Matrix.fromIdentity();
		rotMatrixInv.invertMatrix(resultGeoLocationData.rotMatrix._floatArrays);
		resultGeoLocationData.rotMatrixInv.setByFloat32Array(rotMatrixInv);
		
		var geoLocMatrixInv = WorldWind.Matrix.fromIdentity();
		geoLocMatrixInv.invertMatrix(resultGeoLocationData.geoLocMatrix._floatArrays);
		resultGeoLocationData.geoLocMatrixInv.setByFloat32Array(geoLocMatrixInv);
	}
	else if (magoManager.configInformation.geo_view_library === Constant.CESIUM)
	{
		// *if this in Cesium:
		Cesium.Transforms.eastNorthUpToFixedFrame(resultGeoLocationData.position, undefined, resultGeoLocationData.tMatrix._floatArrays);
		resultGeoLocationData.geoLocMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);// "geoLocMatrix" is the pure transformation matrix, without heading or pitch or roll.***

		var zRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(resultGeoLocationData.tMatrix, zRotatedTMatrix);
		var zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
		var zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
		resultGeoLocationData.tMatrix = zxyRotatedTMatrix;
		
		// test.***
		//var yRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(resultGeoLocationData.tMatrix, yRotatedTMatrix);
		//var yxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(yRotatedTMatrix, yxRotatedTMatrix);
		//var yxzRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(yxRotatedTMatrix, yxzRotatedTMatrix);
		//resultGeoLocationData.tMatrix = yxzRotatedTMatrix;
		// end test.---

		resultGeoLocationData.rotMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);
		resultGeoLocationData.rotMatrix._floatArrays[12] = 0;
		resultGeoLocationData.rotMatrix._floatArrays[13] = 0;
		resultGeoLocationData.rotMatrix._floatArrays[14] = 0;

		// now, calculates the inverses.***
		Cesium.Matrix4.inverse(resultGeoLocationData.tMatrix._floatArrays, resultGeoLocationData.tMatrixInv._floatArrays);
		Cesium.Matrix4.inverse(resultGeoLocationData.rotMatrix._floatArrays, resultGeoLocationData.rotMatrixInv._floatArrays);
		Cesium.Matrix4.inverse(resultGeoLocationData.geoLocMatrix._floatArrays, resultGeoLocationData.geoLocMatrixInv._floatArrays);
	}

	// finally assing the pivotPoint.***
	if (resultGeoLocationData.pivotPoint === undefined)
	{ resultGeoLocationData.pivotPoint = new Point3D(); }

	resultGeoLocationData.pivotPoint.set(resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z);

	return resultGeoLocationData;
};

ManagerUtils.calculateSplitedValues = function(value, resultSplitValue)
{
	if (resultSplitValue === undefined)
	{ resultSplitValue = new SplitValue(); }

	var doubleHigh;
	if (value >= 0.0) 
	{
		doubleHigh = Math.floor(value / 65536.0) * 65536.0;
		resultSplitValue.high = doubleHigh;
		resultSplitValue.low = value - doubleHigh;
	}
	else 
	{
		doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
		resultSplitValue.high = -doubleHigh;
		resultSplitValue.low = value + doubleHigh;
	}

	return resultSplitValue;
};

ManagerUtils.calculateSplited3fv = function(point3fv, resultSplitPoint3fvHigh, resultSplitPoint3fvLow)
{
	if (point3fv === undefined)
	{ return undefined; }

	if (resultSplitPoint3fvHigh === undefined) // delete unnecesary.
	{ resultSplitPoint3fvHigh = new Float32Array(3); }// delete unnecesary.

	if (resultSplitPoint3fvLow === undefined)// delete unnecesary.
	{ resultSplitPoint3fvLow = new Float32Array(3); }// delete unnecesary.

	var posSplitX = new SplitValue();
	posSplitX = this.calculateSplitedValues(point3fv[0], posSplitX);
	var posSplitY = new SplitValue();
	posSplitY = this.calculateSplitedValues(point3fv[1], posSplitY);
	var posSplitZ = new SplitValue();
	posSplitZ = this.calculateSplitedValues(point3fv[2], posSplitZ);

	resultSplitPoint3fvHigh[0] = posSplitX.high;
	resultSplitPoint3fvHigh[1] = posSplitY.high;
	resultSplitPoint3fvHigh[2] = posSplitZ.high;

	resultSplitPoint3fvLow[0] = posSplitX.low;
	resultSplitPoint3fvLow[1] = posSplitY.low;
	resultSplitPoint3fvLow[2] = posSplitZ.low;
};

ManagerUtils.calculateAproxDist2D = function(pointA, pointB, sqrtTable)
{
	// test function.
	var difX = Math.abs(pointA.x - pointB.x);
	var difY = Math.abs(pointA.y - pointB.y);
	
	// find the big value.
	var maxValue, value1;
	
	if (difX > difY)
	{
		maxValue = difX;
		value1 = difY/maxValue;
	}
	else 
	{
		maxValue = difY;
		value1 = difX/maxValue;
	}
	
	var value1Idx = Math.floor(value1*100);
	var aproxDist = maxValue * sqrtTable[value1Idx];
	return aproxDist;
};

var sqrtTable = new Float32Array(11);
// make 10 values.
var increValue = 0.1;
for (var i=0; i<11; i++)
{
	sqrtTable[i] = Math.sqrt(1+(increValue*i)*(increValue*i));
}
	
ManagerUtils.calculateAproxDist3D = function(pointA, pointB)
{
	var difX = Math.abs(pointA.x - pointB.x);
	var difY = Math.abs(pointA.y - pointB.y);
	var difZ = Math.abs(pointA.z - pointB.z);
	
	// find the big value.
	var maxValue, value1, value2;
	var value1Idx, value2Idx;
	var aproxDist;
	
	if (difX > difY)
	{
		if (difX > difZ)
		{
			maxValue = difX;
			value1 = difY/maxValue;
			value1Idx = Math.floor(value1*100);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			value2Idx = Math.floor(value2*100);
			return (middleDist * sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*100);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difY/middleDist;
			value2Idx = Math.floor(value2*100);
			return (middleDist * sqrtTable[value2Idx]);
		}
	}
	else 
	{
		if (difY > difZ)
		{
			maxValue = difY;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*100);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			value2Idx = Math.floor(value2*100);
			return (middleDist * sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*100);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difY/middleDist;
			value2Idx = Math.floor(value2*100);
			return (middleDist * sqrtTable[value2Idx]);
		}
	}
	
};
/*
ManagerUtils.getBuildingCurrentPosition = function(renderingMode, neoBuilding) 
{
	// renderingMode = 0 => assembled.***
	// renderingMode = 1 => dispersed.***

	if (neoBuilding === undefined) { return undefined; }

	var realBuildingPos;

	// 0 = assembled mode. 1 = dispersed mode.***
	if (renderingMode === 1) 
	{
		if (neoBuilding.geoLocationDataAux === undefined) 
		{
			var realTimeLocBlocksList = MagoConfig.getData().alldata;
			var newLocation = realTimeLocBlocksList[neoBuilding.buildingId];
			// must calculate the realBuildingPosition (bbox_center_position).***

			if (newLocation) 
			{
				neoBuilding.geoLocationDataAux = ManagerUtils.calculateGeoLocationData(newLocation.LONGITUDE, newLocation.LATITUDE, newLocation.ELEVATION, neoBuilding.geoLocationDataAux);

				//this.pointSC = neoBuilding.bbox.getCenterPoint(this.pointSC);
				neoBuilding.point3dScratch.set(0.0, 0.0, 50.0);
				realBuildingPos = neoBuilding.geoLocationDataAux.tMatrix.transformPoint3D(neoBuilding.point3dScratch, realBuildingPos );
			}
			else 
			{
				// use the normal data.***
				neoBuilding.point3dScratch = neoBuilding.bbox.getCenterPoint(neoBuilding.point3dScratch);
				realBuildingPos = neoBuilding.transfMat.transformPoint3D(neoBuilding.point3dScratch, realBuildingPos );
			}
		}
		else 
		{
			//this.pointSC = neoBuilding.bbox.getCenterPoint(this.pointSC);
			neoBuilding.point3dScratch.set(0.0, 0.0, 50.0);
			realBuildingPos = neoBuilding.geoLocationDataAux.tMatrix.transformPoint3D(neoBuilding.point3dScratch, realBuildingPos );
		}
	}
	else 
	{
		neoBuilding.point3dScratch = neoBuilding.bbox.getCenterPoint(neoBuilding.point3dScratch);
		realBuildingPos = neoBuilding.transfMat.transformPoint3D(neoBuilding.point3dScratch, realBuildingPos );
	}

	return realBuildingPos;
};
*/
'use strict';

/**
 * 사용하지 않음
 */
!(function() 
{

	var URL = window.URL || window.webkitURL;
	if (!URL) 
	{
		throw new Error('This browser does not support Blob URLs');
	}

	if (!window.Worker) 
	{
		throw new Error('This browser does not support Web Workers');
	}

	function Multithread(threads) 
	{
		this.threads = Math.max(2, threads | 0);
		this._queue = [];
		this._queueSize = 0;
		this._activeThreads = 0;
		this._debug = {
			start : 0,
			end   : 0,
			time  : 0
		};
	}

	Multithread.prototype._worker = {
		JSON: function() 
		{
			var /**/name/**/ = (/**/func/**/);
			self.addEventListener('message', function(e) 
			{
				var data = e.data;
				var view = new DataView(data);
				var len = data.byteLength;
				var str = Array(len);
				for (var i=0;i<len;i++) 
				{
					str[i] = String.fromCharCode(view.getUint8(i));
				}
				var args = JSON.parse(str.join(''));
				var value = (/**/name/**/).apply(/**/name/**/, args);
				try 
				{
					data = JSON.stringify(value);
				}
				catch (ex) 
				{
					throw new Error('Parallel function must return JSON serializable response');
				}
				len = typeof(data)==='undefined'?0:data.length;
				var buffer = new ArrayBuffer(len);
				view = new DataView(buffer);
				for (i=0;i<len;i++) 
				{
					view.setUint8(i, data.charCodeAt(i) & 255);
				}
				self.postMessage(buffer, [buffer]);
				self.close();
			});
		},
		Int32: function() 
		{
			var /**/name/**/ = (/**/func/**/);
			self.addEventListener('message', function(e) 
			{
				var data = e.data;
				var view = new DataView(data);
				var len = data.byteLength / 4;
				var arr = Array(len);
				for (var i=0;i<len;i++) 
				{
					arr[i] = view.getInt32(i*4);
				}
				var value = (/**/name/**/).apply(/**/name/**/, arr);
				if (!(value instanceof Array)) { value = [value]; }
				len = value.length;
				var buffer = new ArrayBuffer(len * 4);
				view = new DataView(buffer);
				for (i=0;i<len;i++) 
				{
					view.setInt32(i*4, value[i]);
				}
				self.postMessage(buffer, [buffer]);
				self.close();
			});
		},
		Float64: function() 
		{
			var /**/name/**/ = (/**/func/**/);
			self.addEventListener('message', function(e) 
			{
				var data = e.data;
				var view = new DataView(data);
				var len = data.byteLength / 8;
				var arr = Array(len);
				for (var i=0;i<len;i++) 
				{
					arr[i] = view.getFloat64(i*8);
				}
				var value = (/**/name/**/).apply(/**/name/**/, arr);
				if (!(value instanceof Array)) { value = [value]; }
				len = value.length;
				var buffer = new ArrayBuffer(len * 8);
				view = new DataView(buffer);
				for (i=0;i<len;i++) 
				{
					view.setFloat64(i*8, value[i]);
				}
				self.postMessage(buffer, [buffer]);
				self.close();
			});
		}
	};

	Multithread.prototype._encode = {
		JSON: function(args) 
		{
			try 
			{
				var data = JSON.stringify(args);
			}
			catch (e) 
			{
				throw new Error('Arguments provided to parallel function must be JSON serializable');
			}
			len = data.length;
			var buffer = new ArrayBuffer(len);
			var view = new DataView(buffer);
			for (var i=0;i<len;i++) 
			{
				view.setUint8(i, data.charCodeAt(i) & 255);
			}
			return buffer;
		},
		Int32: function(args) 
		{
			len = args.length;
			var buffer = new ArrayBuffer(len*4);
			var view = new DataView(buffer);
			for (var i=0;i<len;i++) 
			{
				view.setInt32(i*4, args[i]);
			}
			return buffer;
		},
		Float64: function(args) 
		{
			len = args.length;
			var buffer = new ArrayBuffer(len*8);
			var view = new DataView(buffer);
			for (var i=0;i<len;i++) 
			{
				view.setFloat64(i*8, args[i]);
			}
			return buffer;
		}
	};

	Multithread.prototype._decode = {
		JSON: function(data) 
		{
			var view = new DataView(data);
			var len = data.byteLength;
			var str = Array(len);
			for (var i=0;i<len;i++) 
			{
				str[i] = String.fromCharCode(view.getUint8(i));
			}
			if (!str.length) 
			{
				return;
			}
			else 
			{
				return JSON.parse(str.join(''));
			}
		},
		Int32: function(data) 
		{
			var view = new DataView(data);
			var len = data.byteLength / 4;
			var arr = Array(len);
			for (var i=0;i<len;i++) 
			{
				arr[i] = view.getInt32(i*4);
			}
			return arr;
		},
		Float64: function(data) 
		{
			var view = new DataView(data);
			var len = data.byteLength / 8;
			var arr = Array(len);
			for (var i=0;i<len;i++) 
			{
				arr[i] = view.getFloat64(i*8);
			}
			return arr;
		},
	};

	Multithread.prototype._execute = function(resource, args, type, callback) 
	{
		if (!this._activeThreads) 
		{
			this._debug.start = (new Date()).valueOf();
		}
		if (this._activeThreads < this.threads) 
		{
			this._activeThreads++;
			var t = (new Date()).valueOf();
			var worker = new Worker(resource);
			var buffer = this._encode[type](args);
			var decode = this._decode[type];
			var self = this;
			if (type==='JSON') 
			{
				var listener = function(e) 
				{
					callback.call(self, decode(e.data));
					self.ready();
				};
			}
			else 
			{
				var listener = function(e) 
				{
					callback.apply(self, decode(e.data));
					self.ready();
				};
			}
			worker.addEventListener('message', listener);
			worker.postMessage(buffer, [buffer]);
		}
		else 
		{
			this._queueSize++;
			this._queue.push([resource, args, type, callback]);
		}
	};

	Multithread.prototype.ready = function() 
	{
		this._activeThreads--;
		if (this._queueSize) 
		{
			this._execute.apply(this, this._queue.shift());
			this._queueSize--;
		}
		else if (!this._activeThreads) 
		{
			this._debug.end = (new Date()).valueOf();
			this._debug.time = this._debug.end - this._debug.start;
		}
	};

	Multithread.prototype._prepare = function(fn, type) 
	{

		fn = fn;

		var name = fn.name;
		var fnStr = fn.toString();
		if (!name) 
		{
			name = '$' + ((Math.random()*10)|0);
			while (fnStr.indexOf(name) !== -1) 
			{
				name += ((Math.random()*10)|0);
			}
		}

		var script = this._worker[type]
			.toString()
			.replace(/^.*?[\n\r]+/gi, '')
			.replace(/\}[\s]*$/, '')
			.replace(/\/\*\*\/name\/\*\*\//gi, name)
			.replace(/\/\*\*\/func\/\*\*\//gi, fnStr);

		var resource = URL.createObjectURL(new Blob([script], {type: 'text/javascript'}));

		return resource;

	};

	Multithread.prototype.process = function(fn, callback) 
	{

		var resource = this._prepare(fn, 'JSON');
		var self = this;

		return function() 
		{
			self._execute(resource, [].slice.call(arguments), 'JSON', callback);
		};

	};

	Multithread.prototype.processInt32 = function(fn, callback) 
	{

		var resource = this._prepare(fn, 'Int32');
		var self = this;

		return function() 
		{
			self._execute(resource, [].slice.call(arguments), 'Int32', callback);
		};

	};

	Multithread.prototype.processFloat64 = function(fn, callback) 
	{

		var resource = this._prepare(fn, 'Float64');
		var self = this;

		return function() 
		{
			self._execute(resource, [].slice.call(arguments), 'Float64', callback);
		};

	};

	window.Multithread = Multithread;

})();